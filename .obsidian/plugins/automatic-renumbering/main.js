/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AutoRenumbering
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// node_modules/async-mutex/index.mjs
var E_TIMEOUT = new Error("timeout while waiting for mutex to become available");
var E_ALREADY_LOCKED = new Error("mutex already locked");
var E_CANCELED = new Error("request for lock canceled");
var __awaiter$2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Semaphore = class {
  constructor(_value, _cancelError = E_CANCELED) {
    this._value = _value;
    this._cancelError = _cancelError;
    this._queue = [];
    this._weightedWaiters = [];
  }
  acquire(weight = 1, priority = 0) {
    if (weight <= 0)
      throw new Error(`invalid weight ${weight}: must be positive`);
    return new Promise((resolve, reject) => {
      const task = { resolve, reject, weight, priority };
      const i = findIndexFromEnd(this._queue, (other) => priority <= other.priority);
      if (i === -1 && weight <= this._value) {
        this._dispatchItem(task);
      } else {
        this._queue.splice(i + 1, 0, task);
      }
    });
  }
  runExclusive(callback_1) {
    return __awaiter$2(this, arguments, void 0, function* (callback, weight = 1, priority = 0) {
      const [value, release] = yield this.acquire(weight, priority);
      try {
        return yield callback(value);
      } finally {
        release();
      }
    });
  }
  waitForUnlock(weight = 1, priority = 0) {
    if (weight <= 0)
      throw new Error(`invalid weight ${weight}: must be positive`);
    if (this._couldLockImmediately(weight, priority)) {
      return Promise.resolve();
    } else {
      return new Promise((resolve) => {
        if (!this._weightedWaiters[weight - 1])
          this._weightedWaiters[weight - 1] = [];
        insertSorted(this._weightedWaiters[weight - 1], { resolve, priority });
      });
    }
  }
  isLocked() {
    return this._value <= 0;
  }
  getValue() {
    return this._value;
  }
  setValue(value) {
    this._value = value;
    this._dispatchQueue();
  }
  release(weight = 1) {
    if (weight <= 0)
      throw new Error(`invalid weight ${weight}: must be positive`);
    this._value += weight;
    this._dispatchQueue();
  }
  cancel() {
    this._queue.forEach((entry) => entry.reject(this._cancelError));
    this._queue = [];
  }
  _dispatchQueue() {
    this._drainUnlockWaiters();
    while (this._queue.length > 0 && this._queue[0].weight <= this._value) {
      this._dispatchItem(this._queue.shift());
      this._drainUnlockWaiters();
    }
  }
  _dispatchItem(item) {
    const previousValue = this._value;
    this._value -= item.weight;
    item.resolve([previousValue, this._newReleaser(item.weight)]);
  }
  _newReleaser(weight) {
    let called = false;
    return () => {
      if (called)
        return;
      called = true;
      this.release(weight);
    };
  }
  _drainUnlockWaiters() {
    if (this._queue.length === 0) {
      for (let weight = this._value; weight > 0; weight--) {
        const waiters = this._weightedWaiters[weight - 1];
        if (!waiters)
          continue;
        waiters.forEach((waiter) => waiter.resolve());
        this._weightedWaiters[weight - 1] = [];
      }
    } else {
      const queuedPriority = this._queue[0].priority;
      for (let weight = this._value; weight > 0; weight--) {
        const waiters = this._weightedWaiters[weight - 1];
        if (!waiters)
          continue;
        const i = waiters.findIndex((waiter) => waiter.priority <= queuedPriority);
        (i === -1 ? waiters : waiters.splice(0, i)).forEach((waiter) => waiter.resolve());
      }
    }
  }
  _couldLockImmediately(weight, priority) {
    return (this._queue.length === 0 || this._queue[0].priority < priority) && weight <= this._value;
  }
};
function insertSorted(a, v) {
  const i = findIndexFromEnd(a, (other) => v.priority <= other.priority);
  a.splice(i + 1, 0, v);
}
function findIndexFromEnd(a, predicate) {
  for (let i = a.length - 1; i >= 0; i--) {
    if (predicate(a[i])) {
      return i;
    }
  }
  return -1;
}
var __awaiter$1 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Mutex = class {
  constructor(cancelError) {
    this._semaphore = new Semaphore(1, cancelError);
  }
  acquire() {
    return __awaiter$1(this, arguments, void 0, function* (priority = 0) {
      const [, releaser] = yield this._semaphore.acquire(1, priority);
      return releaser;
    });
  }
  runExclusive(callback, priority = 0) {
    return this._semaphore.runExclusive(() => callback(), 1, priority);
  }
  isLocked() {
    return this._semaphore.isLocked();
  }
  waitForUnlock(priority = 0) {
    return this._semaphore.waitForUnlock(1, priority);
  }
  release() {
    if (this._semaphore.isLocked())
      this._semaphore.release();
  }
  cancel() {
    return this._semaphore.cancel();
  }
};

// src/settings-tab.ts
var import_obsidian = require("obsidian");

// src/SettingsManager.ts
var DEFAULT_SETTINGS = {
  liveNumberingUpdate: true,
  smartPasting: true,
  startsFromOne: true,
  indentSize: 4,
  liveCheckboxUpdate: true,
  sortCheckboxesToBottom: true
};
var SettingsManager = class {
  constructor() {
    this.settings = DEFAULT_SETTINGS;
  }
  static getInstance() {
    if (!SettingsManager.instance) {
      SettingsManager.instance = new SettingsManager();
    }
    return SettingsManager.instance;
  }
  getSettings() {
    return this.settings;
  }
  setSettings(settings) {
    this.settings = settings;
  }
  getLiveUpdate() {
    return this.settings.liveNumberingUpdate;
  }
  setLiveUpdate(value) {
    this.settings.liveNumberingUpdate = value;
  }
  getIndentSize() {
    return this.settings.indentSize;
  }
  setIndentSize(value) {
    this.settings.indentSize = value;
  }
  getSortCheckboxesBottom() {
    return this.settings.sortCheckboxesToBottom;
  }
  setSortCheckboxesBottom(value) {
    this.settings.sortCheckboxesToBottom = value;
  }
};

// src/settings-tab.ts
var AutoRenumberingSettings = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.settingsManager = SettingsManager.getInstance();
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Sort automatically").setDesc("Automatically sorts checkboxes").addToggle(
      (toggle) => toggle.setValue(this.settingsManager.getLiveUpdate()).onChange(async (value) => {
        this.settingsManager.setLiveUpdate(value);
        await this.plugin.saveSettings();
      })
    );
  }
};

// src/utils.ts
function getLineInfo(line) {
  const length = line.length;
  let index = 0;
  let numOfSpaceIndents = 0;
  const indentSize = SettingsManager.getInstance().getIndentSize();
  while (index < length && (line[index] === " " || line[index] === "	")) {
    numOfSpaceIndents += line[index] === " " ? 1 : indentSize;
    index++;
  }
  const spaceCharsNum = index;
  while (index < length && "0".charCodeAt(0) <= line.charCodeAt(index) && line.charCodeAt(index) <= "9".charCodeAt(0)) {
    index++;
  }
  const isNumberDetected = spaceCharsNum !== index && line[index] === "." && line[index + 1] === " ";
  if (!isNumberDetected) {
    const isChecked2 = getCheckboxInfo(line, index, isNumberDetected);
    return {
      spaceCharsNum,
      spaceIndent: numOfSpaceIndents,
      number: void 0,
      textIndex: index,
      isChecked: isChecked2
    };
  }
  const number = parseInt(line.slice(spaceCharsNum, index));
  index += 2;
  const isChecked = getCheckboxInfo(line, index, isNumberDetected);
  if (isNaN(number)) {
    return {
      spaceCharsNum,
      spaceIndent: numOfSpaceIndents,
      number: void 0,
      textIndex: 0,
      isChecked
    };
  }
  return {
    spaceCharsNum,
    spaceIndent: numOfSpaceIndents,
    number,
    textIndex: index,
    isChecked
  };
}
function getCheckboxInfo(line, index, isNumberDetected) {
  const EMPTY_CHECKBOX_NUMBERED = /^\s*\[ \] /;
  const FULL_CHECKBOX_NUMBERED = /^\s*\[.\] /;
  const EMPTY_CHECKBOX = /^\s*- \[ \] /;
  const FULL_CHECKBOX = /^\s*- \[.\] /;
  if (isNumberDetected) {
    const s = line.slice(index);
    if (EMPTY_CHECKBOX_NUMBERED.test(s)) {
      return false;
    }
    if (FULL_CHECKBOX_NUMBERED.test(s)) {
      return true;
    }
  } else {
    if (EMPTY_CHECKBOX.test(line)) {
      return false;
    }
    if (FULL_CHECKBOX.test(line)) {
      return true;
    }
  }
  return void 0;
}

// src/checkbox.ts
function reorderCheckboxes(editor, index) {
  const info = getLineInfo(editor.getLine(index));
  if (info.isChecked === void 0) {
    return;
  }
  let toLine = info.isChecked === true ? getNewCheckedLoc(editor, index) : getNewUncheckedLoc(editor, index);
  if (toLine === void 0 || index === toLine) {
    return;
  }
  moveLine(editor, index, toLine);
}
function getNewUncheckedLoc(editor, startIndex) {
  if (startIndex < 0 || editor.lastLine() < startIndex) {
    return void 0;
  }
  const startInfo = getLineInfo(editor.getLine(startIndex));
  if (startInfo.isChecked !== false) {
    return void 0;
  }
  const startContainsNumber = startInfo.number !== void 0;
  function shouldBreak(currentInfo) {
    const currentContainsNumber = currentInfo.number !== void 0;
    const hasSameNumberStatus = currentContainsNumber === startContainsNumber;
    const hasSameIndentation = currentInfo.spaceIndent === startInfo.spaceIndent;
    if (!hasSameNumberStatus || !hasSameIndentation) {
      return true;
    }
    return currentInfo.isChecked === false || currentInfo.isChecked === void 0;
  }
  let index = startIndex - 1;
  while (0 <= index) {
    const currentInfo = getLineInfo(editor.getLine(index));
    if (shouldBreak(currentInfo)) {
      break;
    }
    index--;
  }
  return index + 1;
}
function getNewCheckedLoc(editor, startIndex) {
  if (startIndex < 0 || editor.lastLine() < startIndex) {
    return void 0;
  }
  const startInfo = getLineInfo(editor.getLine(startIndex));
  if (startInfo.isChecked !== true) {
    return void 0;
  }
  function shouldBreak(currentInfo) {
    const currentContainsNumber = currentInfo.number !== void 0;
    const hasSameNumberStatus = currentContainsNumber === startContainsNumber;
    const hasSameIndentation = currentInfo.spaceIndent === startInfo.spaceIndent;
    if (!hasSameNumberStatus || !hasSameIndentation) {
      return true;
    }
    return currentInfo.isChecked === true || currentInfo.isChecked === void 0;
  }
  const startContainsNumber = startInfo.number !== void 0;
  let index = startIndex + 1;
  while (index <= editor.lastLine()) {
    const currentInfo = getLineInfo(editor.getLine(index));
    if (shouldBreak(currentInfo)) {
      break;
    }
    index++;
  }
  return index - 1;
}
function moveLine(editor, fromLine, toLine) {
  if (fromLine === toLine) {
    return;
  }
  const changes = [];
  const content = editor.getLine(fromLine);
  const lastLine = editor.lastLine();
  let removeLine;
  let insertLine;
  if (fromLine === lastLine) {
    removeLine = {
      from: { line: fromLine - 1, ch: editor.getLine(fromLine - 1).length },
      to: { line: fromLine + 1, ch: content.length },
      text: ""
    };
    insertLine = {
      from: { line: toLine, ch: 0 },
      to: { line: toLine, ch: 0 },
      text: content + "\n"
    };
  } else if (toLine === lastLine) {
    removeLine = {
      from: { line: fromLine, ch: 0 },
      to: { line: fromLine + 1, ch: 0 },
      text: ""
    };
    insertLine = {
      from: { line: toLine + 1, ch: 0 },
      to: { line: toLine + 1, ch: 0 },
      text: "\n" + content
    };
  } else {
    removeLine = {
      from: { line: fromLine, ch: 0 },
      to: { line: fromLine + 1, ch: 0 },
      text: ""
    };
    const adjustedLine = toLine > fromLine ? toLine + 1 : toLine;
    insertLine = {
      from: { line: adjustedLine, ch: 0 },
      to: { line: adjustedLine, ch: 0 },
      text: content + "\n"
    };
  }
  changes.push(insertLine, removeLine);
  editor.transaction({ changes });
}

// main.ts
var mutex = new Mutex();
var AutoRenumbering = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.blockChanges = false;
    this.checkboxClickedAt = void 0;
  }
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new AutoRenumberingSettings(this.app, this));
    this.settingsManager = SettingsManager.getInstance();
    this.registerEvent(
      this.app.workspace.on("editor-change", (editor) => {
        if (this.settingsManager.getLiveUpdate() === false) {
          return;
        }
        setTimeout(() => {
          mutex.runExclusive(() => {
            const originalPos = editor.getCursor();
            if (this.blockChanges) {
              return;
            }
            this.blockChanges = true;
            let currIndex;
            if (this.checkboxClickedAt !== void 0) {
              currIndex = this.checkboxClickedAt;
            } else {
              const { anchor, head } = editor.listSelections()[0];
              currIndex = Math.min(anchor.line, head.line);
            }
            reorderCheckboxes(editor, currIndex);
            if (!editor.somethingSelected()) {
              const newLineInOriginalPos = editor.getLine(originalPos.line);
              const newPos = {
                line: originalPos.line,
                ch: Math.min(originalPos.ch, newLineInOriginalPos.length)
              };
              editor.setCursor(newPos);
            }
          });
        }, 0);
      })
    );
    this.handleKeystrokeBound = this.handleKeystroke.bind(this);
    window.addEventListener("keydown", this.handleKeystrokeBound);
    this.handleMouseBound = this.handleMouseClick.bind(this);
    window.addEventListener("click", this.handleMouseBound);
  }
  handleKeystroke(event) {
    mutex.runExclusive(() => {
      this.blockChanges = event.ctrlKey || event.metaKey || event.altKey;
    });
  }
  handleMouseClick(event) {
    mutex.runExclusive(() => {
      this.checkboxClickedAt = void 0;
      const target = event.target;
      if (target.classList.contains("task-list-item-checkbox")) {
        const listLine = target.closest(".HyperMD-list-line");
        if (listLine) {
          const editor = listLine.closest(".cm-editor");
          if (editor) {
            const allListLines = Array.from(editor.getElementsByClassName("HyperMD-list-line"));
            this.checkboxClickedAt = allListLines.indexOf(listLine);
          }
        }
      }
      this.blockChanges = false;
    });
  }
  async onunload() {
    window.removeEventListener("keydown", this.handleKeystrokeBound);
    window.removeEventListener("mouse", this.handleMouseBound);
  }
  async loadSettings() {
    const settingsManager = SettingsManager.getInstance();
    settingsManager.setSettings(Object.assign({}, DEFAULT_SETTINGS, await this.loadData()));
  }
  async saveSettings() {
    const settingsManager = SettingsManager.getInstance();
    await this.saveData(settingsManager.getSettings());
  }
};


/* nosourcemap */