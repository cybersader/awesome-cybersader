/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TagBuddy
});
module.exports = __toCommonJS(main_exports);
var import_obsidian10 = require("obsidian");

// settings.ts
var import_obsidian = require("obsidian");
var TBSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    let { containerEl } = this;
    containerEl.empty();
    function isValidTag(tag) {
      const tagPattern = /^#[\w]+$/;
      return tagPattern.test(tag);
    }
    function filterAndJoinTags(tagsString) {
      const tagsArray = tagsString.split(", ");
      const validTags = tagsArray.filter(isValidTag);
      return validTags.join(", ");
    }
    containerEl.createEl("h3", { text: "General" });
    new import_obsidian.Setting(containerEl).setName("Recent tags").setDesc("The most recent tags added via Tag Buddy are stored here. These will show up first in the list when adding.").addText((text) => {
      text.setPlaceholder(this.plugin.settings.recentlyAddedTags).setValue(this.plugin.settings.recentlyAddedTags).onChange(async (value) => {
        this.plugin.settings.recentlyAddedTags = filterAndJoinTags(value);
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Lock recent tags").setDesc("Toggle ON to lock the recent tags list. Recent tags will not be updated. Instead, the tags above will act like a favorites list.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.lockRecentTags).onChange(async (value) => {
        this.plugin.settings.lockRecentTags = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Desktop" });
    new import_obsidian.Setting(containerEl).setName("Action when clicking a tag:").setDesc("What should happen when you click a tag?").addDropdown(
      (opt) => opt.addOption("remove", "Remove tag").addOption("hash", "Remove hash").addOption("edit", "Edit tag").addOption("native", "Search tag").setValue(this.plugin.settings.desktopClickTag).onChange(
        async (value) => {
          this.plugin.settings.desktopClickTag = value;
          await this.plugin.saveSettings();
        }
      )
    );
    new import_obsidian.Setting(containerEl).setName("Action when clicking a tag with CMD/CTRL modifier key:").setDesc("What should happen when you click a tag while holding the CMD or CTRL key?").addDropdown(
      (opt) => opt.addOption("remove", "Remove tag").addOption("hash", "Remove hash").addOption("edit", "Edit tag").addOption("native", "Search tag").setValue(this.plugin.settings.desktopCMDClickTag).onChange(
        async (value) => {
          this.plugin.settings.desktopCMDClickTag = value;
          await this.plugin.saveSettings();
        }
      )
    );
    new import_obsidian.Setting(containerEl).setName("Action when clicking a tag with OPT/ALT modifier key:").setDesc("What should happen when you click a tag while holding the OPT or ALT key?").addDropdown(
      (opt) => opt.addOption("remove", "Remove tag").addOption("hash", "Remove hash").addOption("edit", "Edit tag").addOption("native", "Search tag").setValue(this.plugin.settings.desktopOPTClickTag).onChange(
        async (value) => {
          this.plugin.settings.desktopOPTClickTag = value;
          await this.plugin.saveSettings();
        }
      )
    );
    containerEl.createEl("h3", { text: "Mobile" });
    new import_obsidian.Setting(containerEl).setName("Show mobile notices").setDesc("Toggle OFF to hide notices.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.mobileNotices).onChange(
        async (value) => {
          this.plugin.settings.mobileNotices = value;
          await this.plugin.saveSettings();
        }
      )
    );
    new import_obsidian.Setting(containerEl).setName("Action when DOUBLE-TAPPING a tag:").setDesc("What should happen when you DOUBLE-TAP a tag?").addDropdown(
      (opt) => opt.addOption("remove", "Remove tag").addOption("hash", "Remove hash").addOption("edit", "Edit tag").addOption("native", "Search tag").setValue(this.plugin.settings.mobileDoubleTapTag).onChange(
        async (value) => {
          this.plugin.settings.mobileDoubleTapTag = value;
          await this.plugin.saveSettings();
        }
      )
    );
    new import_obsidian.Setting(containerEl).setName("Action when LONG-PRESSING a tag:").setDesc("What should happen when you LONG-PRESS a tag?").addDropdown(
      (opt) => opt.addOption("remove", "Remove tag").addOption("hash", "Remove hash").addOption("edit", "Edit tag").setValue(this.plugin.settings.mobileLongPressTag).onChange(
        async (value) => {
          this.plugin.settings.mobileLongPressTag = value;
          await this.plugin.saveSettings();
        }
      )
    );
    new import_obsidian.Setting(containerEl).setName("TRIPLE-TAP non-tag, non-link text to add a tag:").setDesc("Toggle OFF to disable triple-tap.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.mobileTripleTapText).onChange(
        async (value) => {
          this.plugin.settings.mobileTripleTapText = value;
          await this.plugin.saveSettings();
        }
      )
    );
    containerEl.createEl("h3", { text: "Tag Summaries" });
    new import_obsidian.Setting(containerEl).setName("Show tag summary buttons").setDesc("Toggle OFF to hide these buttons.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showSummaryButtons).onChange(
        async (value) => {
          this.plugin.settings.showSummaryButtons = value;
          await this.plugin.saveSettings();
        }
      )
    );
    containerEl.createEl("h5", { text: "Tag Summaries Items" });
    new import_obsidian.Setting(containerEl).setName("Remove tag button:").addDropdown(
      (opt) => opt.addOption("always", "Desktop and mobile").addOption("desktop", "Only desktop").addOption("mobile", "Only mobile").addOption("hide", "Hide").setValue(this.plugin.settings.removeTagBtn).onChange(
        async (value) => {
          this.plugin.settings.removeTagBtn = value;
          await this.plugin.saveSettings();
        }
      )
    );
    new import_obsidian.Setting(containerEl).setName("Copy to clipboard button:").addDropdown(
      (opt) => opt.addOption("always", "Desktop and mobile").addOption("desktop", "Only desktop").addOption("mobile", "Only mobile").addOption("hide", "Hide").setValue(this.plugin.settings.copyToCBBtn).onChange(
        async (value) => {
          this.plugin.settings.copyToCBBtn = value;
          await this.plugin.saveSettings();
        }
      )
    );
    new import_obsidian.Setting(containerEl).setName("Move to section button:").addDropdown(
      (opt) => opt.addOption("always", "Desktop and mobile").addOption("desktop", "Only desktop").addOption("mobile", "Only mobile").addOption("hide", "Hide").setValue(this.plugin.settings.moveToSectionBtn).onChange(
        async (value) => {
          this.plugin.settings.moveToSectionBtn = value;
          await this.plugin.saveSettings();
        }
      )
    );
    new import_obsidian.Setting(containerEl).setName("Copy to section button:").addDropdown(
      (opt) => opt.addOption("always", "Desktop and mobile").addOption("desktop", "Only desktop").addOption("mobile", "Only mobile").addOption("hide", "Hide").setValue(this.plugin.settings.copyToSectionBtn).onChange(
        async (value) => {
          this.plugin.settings.copyToSectionBtn = value;
          await this.plugin.saveSettings();
        }
      )
    );
    new import_obsidian.Setting(containerEl).setName("Copy link to section button:").addDropdown(
      (opt) => opt.addOption("always", "Desktop and mobile").addOption("desktop", "Only desktop").addOption("mobile", "Only mobile").addOption("hide", "Hide").setValue(this.plugin.settings.copyLinkToSectionBtn).onChange(
        async (value) => {
          this.plugin.settings.copyLinkToSectionBtn = value;
          await this.plugin.saveSettings();
        }
      )
    );
    new import_obsidian.Setting(containerEl).setName("Copy to note button:").addDropdown(
      (opt) => opt.addOption("always", "Desktop and mobile").addOption("desktop", "Only desktop").addOption("mobile", "Only mobile").addOption("hide", "Hide").setValue(this.plugin.settings.copyToNoteBtn).onChange(
        async (value) => {
          this.plugin.settings.copyToNoteBtn = value;
          await this.plugin.saveSettings();
        }
      )
    );
    containerEl.createEl("hr");
    containerEl.createEl("h1", { text: "Support a buddy" });
    const donateLink = containerEl.createEl("a");
    donateLink.setAttribute("href", "https://www.buymeacoffee.com/moremeyou");
    const donateButton = createEl("img");
    donateButton.setAttribute("src", "https://cdn.buymeacoffee.com/buttons/v2/default-yellow.png");
    donateButton.setAttribute("alt", "Buy Me A Coffee");
    donateButton.style = "height: 40px !important;width: 150px !important;";
    donateLink.appendChild(donateButton);
    containerEl.createEl("br");
    containerEl.createEl("br");
    containerEl.createEl("br");
    new import_obsidian.Setting(containerEl).setName("Debug mode").setDesc("Output to console.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.debugMode).onChange(async (value) => {
        this.plugin.settings.debugMode = value;
        await this.plugin.saveSettings();
      })
    );
  }
};

// gui.ts
var import_obsidian6 = require("obsidian");

// utils.ts
var import_obsidian2 = require("obsidian");
function getTagElement(paragraphEl2, tagText) {
  const els = paragraphEl2.querySelectorAll(".tag");
  let tagElText = "";
  let tagElHasSub;
  for (let el of els) {
    tagElText = el.innerText.trim();
    if (tagElText === tagText) {
      return el;
    }
  }
  return null;
}
function platformSettingCheck(app2, value) {
  return value == "always" || value == "desktop" && !app2.isMobile || value == "mobile" && app2.isMobile;
}
function platformSettingCheckMultiple(app2, values) {
  for (let value of values) {
    if (platformSettingCheck(app2, value)) {
      return true;
    }
  }
  return false;
}
function isWordNearEnd(str, word, charDistance = 0) {
  const lastIndex = str.lastIndexOf(word);
  if (lastIndex === -1)
    return false;
  const wordEndIndex = lastIndex + word.length;
  const distanceToEnd = str.length - wordEndIndex;
  return distanceToEnd === 0 || distanceToEnd <= charDistance;
}
function getWordObjFromString(sourceText, offset) {
  let wordRegex = /[^\s]+(?=[.,:!?]?(\s|$))/g;
  let match;
  let index;
  let word = null;
  while ((match = wordRegex.exec(sourceText)) !== null) {
    if (match.index <= offset && offset <= match.index + match[0].length) {
      word = match[0];
      index = match.index;
      break;
    }
  }
  return {
    text: word,
    index
  };
}
function getClickedTextObjFromDoc(x, y, minNodeLength = 10) {
  let range, nodeText, offset;
  if (document.caretRangeFromPoint) {
    range = document.caretRangeFromPoint(x, y);
    if (range.startContainer.nodeType === Node.TEXT_NODE) {
      nodeText = range.startContainer.nodeValue.trim();
    } else {
      return null;
    }
    offset = range.startOffset;
  }
  if (nodeText.length < minNodeLength) {
    return null;
  }
  return {
    text: nodeText,
    index: offset,
    el: range.startContainer.parentNode
  };
}
function getMarkdownHeadings(bodyLines, headingFilter = "") {
  const headers = [];
  let accumulatedIndex = 0;
  bodyLines.forEach((line, index) => {
    const match = line.match(/^(#+)[\s]?(.*)$/);
    if (match && (headingFilter == "" || match[2] == headingFilter)) {
      headers.push({
        fullText: match[0],
        level: match[1].length,
        text: match[2],
        line: index,
        startIndex: accumulatedIndex,
        endIndex: accumulatedIndex + match[0].length - 1
      });
    }
    accumulatedIndex += line.length + 1;
  });
  return headers;
}
function findClosestHeaderWithLink(paragraph) {
  const lines = paragraph.split("\n");
  let closestHeader = "";
  for (let i = lines.length - 1; i >= 0; i--) {
    const line = lines[i].trim();
    if (/^#{1,6}\s/.test(line)) {
      closestHeader = line;
      break;
    }
  }
  if (closestHeader) {
    const text = closestHeader.replace(/^#{1,6}\s*/, "").trim();
    const link = `#${text}`;
    return { text, link };
  }
  return { text: "", link: "" };
}
function fileContainsHeading(fileContent, heading) {
  const fileContentLines = getLinesInString(fileContent);
  const mdHeadings = getMarkdownHeadings(fileContentLines, heading);
  return mdHeadings.length > 0;
}
function findFirstLineAfterFrontMatter(markdown) {
  const lines = getLinesInString(markdown);
  let inFrontMatter = false;
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    if (line === "---") {
      inFrontMatter = !inFrontMatter;
      if (!inFrontMatter) {
        return i;
      }
    }
  }
  return 0;
}
function getLinesInString(input) {
  const lines = input.split("\n");
  if (lines.length > 0 && lines[lines.length - 1] === "") {
    lines.pop();
  }
  return lines;
}
function insertTextAfterLine(text, body, line, filePath) {
  const splitContent = body.split("\n");
  const pre = splitContent.slice(0, line + 1).join("\n");
  const post = splitContent.slice(line + 1).join("\n");
  return `${pre}
${text}
${post}`;
}
function getListTypeFromLineNumber(fullText, lineNumber) {
  const lines = fullText.split("\n");
  if (lineNumber >= 0 && lineNumber < lines.length) {
    const line = lines[lineNumber];
    const leadingWhitespace = line.match(/^\s*/)[0];
    if (/^\s*-\s\[\s\]\s/.test(line)) {
      return leadingWhitespace + "- [ ] ";
    } else if (/^\s*-\s\[x\]\s/.test(line)) {
      return leadingWhitespace + "- [ ] ";
    } else if (/^\s*-\s/.test(line)) {
      return leadingWhitespace + "- ";
    } else if (/^\s*\d+\.\s/.test(line)) {
      const num = parseInt(line.match(/^\s*(\d+)\./)[1], 10);
      return leadingWhitespace + `${num}. `;
    } else if (/^\s*>\s/.test(line)) {
      return leadingWhitespace + "> ";
    }
  } else {
  }
  return "";
}
function removeTagFromString(inputText, hashtagToRemove, all = true) {
  const regex = new RegExp(
    "\\s?" + hashtagToRemove.replace(/#/g, "\\#") + "(?!\\w|\\/)",
    all ? "gi" : "i"
  );
  return inputText.replace(regex, "").trim();
}
function insertTextInString(newText, sourceText, charPos) {
  return sourceText.substring(0, charPos) + newText + " " + sourceText.substring(charPos);
}
function removeTextFromString(removeText, sourceText, all = false) {
  const regex = new RegExp(escapeRegExp(removeText), all ? "gi" : "i");
  return sourceText.replace(regex, "").trim();
}
function replaceTextInString(replaceText, sourceText, newText, all = false) {
  const escapedReplaceText = escapeRegExp(replaceText.trim()).replace(/\n/g, "\\s*\\n\\s*");
  const regex = new RegExp(escapedReplaceText, all ? "gsi" : "si");
  return sourceText.trim().replace(regex, newText.trim()).trim();
}
function truncateStringAtWord(str, maxChars = 16) {
  if (str.length <= maxChars)
    return str;
  let truncated = str.substr(0, maxChars);
  const lastSpace = truncated.lastIndexOf(" ");
  if (lastSpace > 0)
    truncated = truncated.substr(0, lastSpace);
  return truncated;
}
function contentChangedTooMuch(original, modified, tag, buffer = 5) {
  const expectedChange = tag.length;
  const threshold = expectedChange + buffer;
  const actualChange = Math.abs(original.length - modified.length);
  return actualChange > threshold;
}
function fileObjFromTags(tags) {
  let tagsArray = tags.map((tag) => tag.replace(/#/g, "").toLowerCase());
  tagsArray = tagsArray.filter((tag, index, self) => self.indexOf(tag) === index);
  const tagsPart = tagsArray.join("+");
  const currentDate = /* @__PURE__ */ new Date();
  const datePart = currentDate.getDate().toString().padStart(2, "0") + //'-' +
  (currentDate.getMonth() + 1).toString().padStart(2, "0") + //'-' +
  currentDate.getFullYear().toString().slice(-2);
  const timePart = (
    //currentDate.getHours().toString().padStart(2, '0') + '-' +
    //currentDate.getMinutes().toString().padStart(2, '0') + '-' +
    currentDate.getSeconds().toString().padStart(2, "0")
  );
  const fileName = `Tag Summary (${datePart} ${timePart}).md`;
  const titleTagsPart = tagsArray.map((tag) => tag.charAt(0).toUpperCase() + tag.slice(1)).join(" + ");
  const title = `${titleTagsPart} Tag Summary`;
  return {
    fileName,
    title
  };
}
function getActiveFileFolder(activeFile) {
  if (!activeFile)
    return null;
  let folderPath;
  if (activeFile.path.includes("\\") || activeFile.path.includes("/")) {
    const pathSeparator = activeFile.path.includes("\\") ? "\\" : "/";
    const pathParts = activeFile.path.split(pathSeparator);
    pathParts.pop();
    folderPath = pathParts.join(pathSeparator);
    if (!folderPath.endsWith(pathSeparator)) {
      folderPath += pathSeparator;
    }
  } else {
    folderPath = "";
  }
  return folderPath;
}
function getTagsFromApp(app2, recentTags) {
  const tagsObject = app2.metadataCache.getTags();
  const tagsArray = Object.entries(tagsObject);
  tagsArray.sort((a, b) => b[1] - a[1]);
  if (recentTags.length > 0) {
    const recentTagsAsTuples = recentTags.map((tag) => [tag, 0]);
    const recentAndAllTags = recentTagsAsTuples.concat(tagsArray);
    return recentAndAllTags.map(([tag, _]) => tag.replace(/^#/, ""));
  } else {
    return tagsArray.map(([tag, _]) => tag.replace(/^#/, ""));
  }
}
async function validateFilePath(filePath) {
  const matchingFiles = await app.vault.getFiles().filter((file) => file.name === filePath);
  if (matchingFiles.length === 1) {
    const filePath2 = matchingFiles[0].path;
    const file = await this.app.vault.getAbstractFileByPath(filePath2);
    return file;
  } else if (matchingFiles.length > 1) {
    new Notice("Tag Buddy: Multiple files found with the same name. Can't safely edit tag.");
    return null;
  } else {
    new Notice("Tag Buddy: No file found. Try again, or this tag might be in an unsupported embed type.");
    return null;
  }
}
function ctrlCmdKey(event) {
  const isMac = import_obsidian2.Platform.isMacOS;
  if (isMac)
    return event.metaKey;
  else
    return event.ctrlKey;
}
function tagsInString(string, tag) {
  let regex;
  if (tag) {
    regex = new RegExp(tag.replace(/\//g, "\\/") + "(?![\\w\\/\\#])", "g");
  } else {
    regex = /#(\w+)(?![\w\/#])/g;
  }
  const matches = string.match(regex);
  return matches || [];
}
function countOccurrences(summaryTags, contentTags) {
  let count = 0;
  for (let tag of summaryTags) {
    count += contentTags.filter((item) => item === tag).length;
  }
  return count;
}
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
async function getEmbedFile(el) {
  let filePath = el.getAttribute("src");
  const linkArray = filePath.split("#");
  filePath = linkArray[0].trim() + ".md";
  const file = await validateFilePath(filePath);
  return file;
}
function isTagValid(tag, fullTag = false) {
  let tagPattern;
  if (fullTag)
    tagPattern = /^#[a-zA-Z0-9_\-\/]*[a-zA-Z_\-\/][a-zA-Z0-9_\-\/]*$/;
  else
    tagPattern = /^[a-zA-Z0-9_\-\/]*[a-zA-Z_\-\/][a-zA-Z0-9_\-\/]*$/;
  return tagPattern.test(tag);
}
function extractValidTags(tagsString) {
  const potentialTags = tagsString.split(",");
  const validTags = potentialTags.map((tag) => tag.trim()).filter((tag) => isTagValid(tag, true));
  return validTags;
}

// Modal.ts
var import_obsidian3 = require("obsidian");
var TagSelector = class extends import_obsidian3.FuzzySuggestModal {
  constructor(app2, plugin, event, onChooseItemCallback) {
    super(app2);
    this.height = 215;
    this.noSelection = false;
    this.app = app2;
    this.plugin = plugin;
    this.tag = "";
    this.onChooseItemCallback = onChooseItemCallback;
    this.inputListener = this.listenInput.bind(this);
    this.tagCache = [];
    if (event != null)
      this.location = { x: event.pageX, y: event.pageY };
  }
  onOpen() {
    this.setPlaceholder("");
    this.inputEl.addEventListener("keyup", this.inputListener);
    if (!this.app.isMobile) {
      this.resultContainerEl.parentNode.style.width = "200px";
      this.resultContainerEl.style.height = "215px";
      this.resultContainerEl.parentNode.style.left = `${this.location.x}px`;
      this.resultContainerEl.parentNode.style.top = `${this.location.y}px`;
    } else {
      setTimeout(() => {
        this.inputEl.focus();
      }, 500);
    }
    super.onOpen();
  }
  onClose() {
    this.inputEl.removeEventListener("keyup", this.inputListener);
    super.onClose();
  }
  listenInput(event) {
    this.noSelection = false;
    if (!this.app.isMobile) {
      const itemsHeight = this.getSuggestions(this.inputEl.value).length * 42;
      const height = Math.min(this.height, Math.max(65, itemsHeight));
      this.resultContainerEl.style.height = `${height}px`;
    }
    if (event.key == "Enter" && !this.noSelection) {
      const text = this.inputEl.value.trim();
      const pattern = /(?=[^\d\s]+)[a-zA-Z0-9_\-\/]+/g;
      if (pattern.test(text)) {
        this.close();
        this.onChooseItem(this.inputEl.value);
      } else {
        new import_obsidian3.Notice("Invalid tag.");
      }
    }
  }
  /*getSuggestions(query: string) : string[]{
          const filteredTags = Utils.getTagsFromApp(
              this.app, 
              this.plugin.getRecentTags()).filter(tag => 
              //tag.toLowerCase().includes(query.toLowerCase())
              query == '' ? true : tag.toLowerCase() == query.toLowerCase()
          );
          return filteredTags;
      }
  
      renderSuggestion(header: string, el: HTMLElement) {
          el.createEl("div", { text: header });
      }*/
  onNoSuggestion() {
    super.onNoSuggestion();
    this.noSelection = true;
  }
  getItems() {
    const filteredTags = getTagsFromApp(
      this.app,
      this.plugin.getRecentTags()
    );
    return filteredTags;
  }
  getItemText(tag) {
    return tag;
  }
  async onChooseItem(result) {
    if (!this.app.isMobile) {
      this.onChooseItemCallback(result);
    } else {
      setTimeout(() => {
        this.onChooseItemCallback(result);
      }, 250);
    }
  }
};

// TagEditorModal.ts
var import_obsidian4 = require("obsidian");
var TBTagEditorModal = class extends import_obsidian4.Modal {
  //constructor(app: App, tag: String, onSubmit: (result: string) => void) {
  constructor(app2, plugin, tag, index, filePath = null, tagEl2 = null) {
    super(app2);
    this.settings = {
      originalTag: "",
      originalIndex: null,
      tagEl: null,
      filePath: null,
      batchAction: "instance",
      newName: "",
      summaryPos: "top",
      action: "rename"
    };
    this.plugin = plugin;
    this.settings.tagEl = tagEl2;
    this.settings.filePath = filePath;
    this.settings.originalTag = tag;
    this.settings.originalIndex = index;
  }
  onOpen() {
    let { contentEl, titleEl, modalEl, containerEl } = this;
    titleEl.setText("Tag Actions");
    this.editDiv = createEl("div");
    this.editDiv.classList.add("tag-editor-edit-div");
    this.optionsDiv = createEl("div");
    this.optionsDiv.classList.add("tag-editor-options");
    this.input = new import_obsidian4.TextComponent(this.editDiv);
    this.input.inputEl.classList.add("tag-editor-input");
    this.tagActionDropdown = new import_obsidian4.DropdownComponent(this.editDiv).addOption("rename", "Rename").addOption("lower", "Convert to lower case").addOption("totext", "Remove hash (#)").addOption("summary", "Create summary");
    this.tagActionDropdown.selectEl.classList.add("tag-editor-dropdown");
    contentEl.appendChild(this.editDiv);
    contentEl.appendChild(this.optionsDiv);
    this.showEditTagOptions("rename");
    const hr = createEl("hr");
    hr.classList.add("tag-editor-hr");
    contentEl.appendChild(hr);
    this.tagActionDropdown.onChange((value) => {
      this.settings.action = value;
      if (value == "summary") {
        this.showSummaryOptions();
      } else {
        this.showEditTagOptions(value);
      }
    });
    const submitBtn = new import_obsidian4.ButtonComponent(contentEl).setClass("tag-editor-submit").setButtonText("Submit").onClick(
      (evt) => {
        this.submitTagEdit();
      }
    );
  }
  submitTagEdit() {
    const isValidTag = isTagValid(this.settings.newName.trim(), true);
    const action = this.settings.action;
    let newName = this.settings.originalTag;
    if (action == "summary") {
      const summaryTags = extractValidTags(this.input.getValue());
      if (summaryTags.length < 1) {
        new import_obsidian4.Notice("Invalid tag format.");
      } else {
        this.plugin.tagSummary.createCodeBlock(summaryTags, this.settings.summaryPos);
        this.close();
      }
    } else if (action == "rename" && !isValidTag) {
      new import_obsidian4.Notice("Invalid tag format.");
    } else {
      if (action == "rename")
        newName = this.settings.newName;
      else if (action == "lower")
        newName = this.settings.originalTag.toLowerCase();
      else if (action == "totext")
        newName = this.settings.originalTag.substring(1);
      this.plugin.tagEditor.renameTag(
        this.settings.originalTag,
        newName,
        this.settings.batchAction == "instance" ? parseInt(this.settings.originalIndex) : this.settings.batchAction,
        this.settings.filePath,
        this.settings.tagEl
        //parseInt(this.settings.originalIndex),
        //((this.settings.batchAction == 'instance') ? parseInt(this.settings.originalIndex) : this.settings.batchAction)
      );
      this.close();
      setTimeout(async () => {
        this.plugin.tagSummary.update(tagEl.closest());
        paragraphEl.remove();
      }, 500);
    }
  }
  showSummaryOptions() {
    this.optionsDiv.empty();
    this.input.setDisabled(false);
    new import_obsidian4.Setting(this.optionsDiv).setName("Where do you want to add the tag summary?").setDesc("Add multiple tags above separated by a comma.").addDropdown(
      (opt) => opt.addOption("top", "Top of this note").addOption("end", "Bottom of this note").addOption("note", "In a new note").onChange(
        (value) => {
          this.settings.summaryPos = value;
        }
      )
    );
  }
  showEditTagOptions(editType) {
    this.optionsDiv.empty();
    this.input.setValue(this.settings.originalTag);
    this.input.setDisabled(true);
    if (editType == "rename") {
      const newName = new import_obsidian4.Setting(this.optionsDiv).setName("New name").setDesc("Tags can include letters, numbers, underscores (_), hyphens (-), and forward slashes (/) for nested tags.").addText(
        (opt) => opt.setValue("").onChange(
          (value) => {
            this.settings.newName = value;
          }
        )
      );
    }
    const whereEditOpt = new import_obsidian4.Setting(this.optionsDiv).setName("Where to make this change?").addDropdown(
      (opt) => opt.addOption("instance", "Just this instance").addOption("note", "All in this note").addOption("vault", "Across entire vault").onChange((value) => {
        if (value == "vault") {
          whereEditOpt.setDesc("WARNING: There is NO UNDO for vault changes. Consider making a backup of your vault first.");
          this.settings.batchAction = "vault";
        } else if (value == "note") {
          whereEditOpt.setDesc("Only tags in this note will be updated. Choose 'Across entire vault' to update this tag everywhere.");
          this.settings.batchAction = "note";
        } else if (value == "instance") {
          whereEditOpt.setDesc("");
          this.settings.batchAction = "instance";
        }
      })
    );
  }
  onClose() {
    let { contentEl } = this;
    contentEl.empty();
  }
};

// FindFileModal.ts
var import_obsidian5 = require("obsidian");
var SelectFileModal2 = class extends import_obsidian5.SuggestModal {
  constructor(app2, onSubmit) {
    super(app2);
    this.onSubmit = onSubmit;
    this.fileList = this.app.vault.getMarkdownFiles();
  }
  // Returns all available suggestions.
  getSuggestions(query) {
    return this.fileList.filter(
      (file) => file.path.includes(query)
    );
  }
  // Renders each suggestion item.
  renderSuggestion(file, el) {
    el.createEl("div", { text: file.name });
    el.createEl("small", { text: file.path });
  }
  // Perform action on the selected suggestion.
  onChooseSuggestion(file, evt) {
    this.onSubmit(file);
  }
  //onNoSuggestion(file: TFile, evt: MouseEvent | KeyboardEvent) {
  //new Notice(`No selection`);
  //this.onSubmit(file)
  //}
};

// gui.ts
var GUI = class {
  constructor(app2, plugin) {
    this.app = app2;
    this.plugin = plugin;
  }
  showTagEditor(tagEl2) {
    const view = this.app.workspace.getActiveViewOfType(import_obsidian6.MarkdownView);
    const mode = view == null ? void 0 : view.getMode();
    if (this.app.isMobile) {
    } else {
    }
    const index = parseInt(tagEl2.getAttribute("md-index"));
    const tag = tagEl2.innerText;
    const filePath = tagEl2.getAttribute("file-source");
    const tagContainerType = tagEl2.getAttribute("type");
    if (mode == "preview") {
      const tagEditorModal = new TBTagEditorModal(
        this.app,
        this.plugin,
        tag,
        index,
        filePath,
        tagContainerType == "plugin-summary" ? tagEl2 : null
        //tag,
        //index
        //(tag)=>{
        //	console.log(tag) 
        //}
      ).open();
    }
  }
  /*isTagValid (tag:string):boolean { // including the #
  	const tagPattern = /^#[\w]+$/;
  	return tagPattern.test(tag);
  }*/
  makeButton(lable, clickFn, classId = "tagsummary-button") {
    const button = createEl("button");
    (0, import_obsidian6.setIcon)(button, lable);
    button.className = classId;
    this.plugin.registerDomEvent(
      button,
      "click",
      clickFn
    );
    return button;
  }
  makeBlockSelector(index) {
    const checkboxEl = createEl("div");
    checkboxEl.setAttribute("index", index);
    let checkedBtn;
    let uncheckedBtn;
    const checkBox = function(bool) {
      this.plugin.tagSummary.updateSelection(parseInt(checkboxEl.getAttribute("index")), bool);
      if (bool) {
        uncheckedBtn.remove();
        checkboxEl.appendChild(checkedBtn);
      } else {
        checkedBtn.remove();
        checkboxEl.appendChild(uncheckedBtn);
      }
    }.bind(this);
    checkedBtn = this.makeButton("check-square", (e) => {
      e.stopPropagation();
      checkBox(false);
    }, "tagsummary-button tagsummary-checkbox checked");
    checkedBtn.title = "Unselect this paragraph.";
    uncheckedBtn = this.makeButton("square", (e) => {
      e.stopPropagation();
      checkBox(true);
    }, "tagsummary-button tagsummary-checkbox");
    uncheckedBtn.title = "Select this paragraph.";
    checkBox(false);
    return checkboxEl;
  }
  makeRemoveTagButton(clickFn, paragraphEl2, tag) {
    const button = this.makeButton("list-x", (e) => {
      e.stopPropagation();
      clickFn(e, paragraphEl2, tag);
    });
    button.title = "Removed " + tag + " from paragraph.";
    return button;
  }
  makeSummaryRefreshButton(summaryEl2) {
    const button = this.makeButton(
      "refresh-ccw",
      (e) => {
        e.stopPropagation();
        this.plugin.tagSummary.update(summaryEl2);
        new import_obsidian6.Notice("Tag Summary updated");
        setTimeout(async () => {
        }, 10);
      }
    );
    button.title = "Refresh tag summary";
    return button;
  }
  makeCopyToSection(clickFn, content, sections, tags, filePath, paragraphEl2, summaryEl2) {
    const copyToEl = createEl("span");
    const selectEl = createEl("selectEl");
    let dropdown = new import_obsidian6.DropdownComponent(selectEl);
    sections.forEach((sec) => {
      dropdown.addOption(sec, truncateStringAtWord(sec, 16));
    });
    dropdown.addOption("top", "Note top");
    dropdown.addOption("end", "Note end");
    selectEl.querySelector("select").className = "tagsummary-dropdown";
    if (platformSettingCheck(this.app, this.plugin.settings.copyToNoteBtn)) {
      copyToEl.appendChild(
        this.makeCopyToButton(
          clickFn,
          "note",
          dropdown,
          paragraphEl2,
          summaryEl2,
          content,
          tags,
          filePath
        )
      );
    }
    if (platformSettingCheck(this.app, this.plugin.settings.copyLinkToSectionBtn)) {
      copyToEl.appendChild(
        this.makeCopyToButton(
          clickFn,
          "link",
          dropdown,
          paragraphEl2,
          summaryEl2,
          content,
          tags,
          filePath
        )
      );
    }
    if (platformSettingCheck(this.app, this.plugin.settings.copyToSectionBtn)) {
      copyToEl.appendChild(
        this.makeCopyToButton(
          clickFn,
          "copy",
          dropdown,
          paragraphEl2,
          summaryEl2,
          content,
          tags,
          filePath
        )
      );
    }
    if (platformSettingCheck(this.app, this.plugin.settings.moveToSectionBtn)) {
      copyToEl.appendChild(
        this.makeCopyToButton(
          clickFn,
          "move",
          dropdown,
          paragraphEl2,
          summaryEl2,
          content,
          tags,
          filePath
        )
      );
    }
    if (platformSettingCheckMultiple(this.app, [
      this.plugin.settings.moveToSectionBtn,
      this.plugin.settings.copyToSectionBtn,
      this.plugin.settings.copyLinkToSectionBtn,
      this.plugin.settings.copyToNoteBtn
    ])) {
      copyToEl.appendChild(selectEl);
    }
    return copyToEl;
  }
  makeCopyToButton(clickFn, mode, dropdown, paragraphEl2, summaryEl2, content, tags, filePath) {
    let buttonLabel;
    if (mode == "link")
      buttonLabel = "link";
    else if (mode == "copy")
      buttonLabel = "copy-plus";
    else if (mode == "move")
      buttonLabel = "replace";
    else if (mode == "note")
      buttonLabel = "file-plus-2";
    const button = this.makeButton(buttonLabel, async (e) => {
      e.stopPropagation();
      if (mode == "note") {
        new SelectFileModal2(this.app, (file) => {
          clickFn(e, mode, dropdown, paragraphEl2, summaryEl2, content, tags, filePath, file);
        }).open();
      } else {
        clickFn(e, mode, dropdown, paragraphEl2, summaryEl2, content, tags, filePath);
      }
    });
    let buttonHoverText;
    if (mode == "link")
      buttonHoverText = "Copy paragraph link.";
    else if (mode == "copy")
      buttonHoverText = "Copy paragraph.";
    else if (mode == "move")
      buttonHoverText = "Move paragraph.";
    else if (mode == "note")
      buttonHoverText = "Copy paragraph to section in note.";
    button.title = buttonHoverText;
    return button;
  }
  makeBakeButton(clickFn, summaryMd, summaryEl2, filePath) {
    const button = this.makeButton(
      "stamp",
      async (e) => {
        e.stopPropagation();
        clickFn(summaryMd, summaryEl2, filePath);
      }
    );
    button.title = "Flatten summary (replaces code block).";
    return button;
  }
  makeCopyButton(clickFn, content) {
    const button = this.makeButton("clipboard-list", (e) => {
      e.stopPropagation();
      clickFn(e, content);
    });
    button.title = "Copy paragraph to clipboard.";
    return button;
  }
  makeCopySummaryButton(summaryMd) {
    const button = this.makeButton(
      "clipboard-list",
      (e) => {
        e.stopPropagation();
        navigator.clipboard.writeText(summaryMd);
        new import_obsidian6.Notice("Summary copied to clipboard.");
      }
    );
    button.title = "Copy summary";
    return button;
  }
  makeSummaryNoteButton(clickFn, summaryMd, tags) {
    const button = this.makeButton(
      "file-plus-2",
      async (e) => {
        e.stopPropagation();
        clickFn(summaryMd, tags);
      }
    );
    button.title = "Create note from summary";
    return button;
  }
  showTagSelector(event) {
    const view = this.app.workspace.getActiveViewOfType(import_obsidian6.MarkdownView);
    const mode = view == null ? void 0 : view.getMode();
    let pageX, pageY;
    let nodeType;
    let deepestNode;
    let range;
    if (this.app.isMobile) {
      const touch = event.touches[0] || event.changedTouches[0];
      pageX = Math.round(touch.pageX);
      pageY = Math.round(touch.pageY);
      range = document.caretRangeFromPoint(pageX, pageY);
      nodeType = range.startContainer.nodeType;
    } else {
      pageX = event.pageX;
      pageY = event.pageY;
      range = document.caretRangeFromPoint(pageX, pageY);
      nodeType = range.startContainer.nodeType;
    }
    if (mode == "preview") {
      if (nodeType === Node.TEXT_NODE) {
        const tagSelector = new TagSelector(
          this.app,
          this.plugin,
          event,
          (tag) => {
            this.plugin.tagEditor.add(
              "#" + tag,
              pageX,
              pageY
              //,
              //{range: range, el: deepestNode}
            );
          }
        ).open();
      }
    }
  }
  removeElementWithAnimation(el, callback) {
    const height = el.offsetHeight;
    el.style.height = `${height}px`;
    setTimeout(() => {
      el.style.height = "0px";
      el.style.opacity = "0";
      el.style.margin = "0";
      el.style.padding = "0";
    }, 0);
    el.addEventListener(
      "transitionend",
      function onEnd() {
        el.removeEventListener("transitionend", onEnd);
        callback();
      }
    );
  }
};

// TagSummary.ts
var import_obsidian7 = require("obsidian");
var TagSummary = class {
  constructor(app2, plugin) {
    this.app = app2;
    this.plugin = plugin;
  }
  async bakeSummaryBtnHandler(summaryMd, summaryEl2, filePath) {
    const mdSource = summaryEl2.getAttribute(
      "codeblock-code"
    );
    if (mdSource) {
      const file = await this.app.vault.getAbstractFileByPath(filePath);
      const fileContent = await this.app.vault.read(file);
      const newFileContent = replaceTextInString(
        mdSource,
        fileContent,
        summaryMd
      );
      this.app.vault.modify(file, newFileContent);
      const notice = new import_obsidian7.Notice("Tag summary flattened to active note.");
    } else {
      new import_obsidian7.Notice("\u26A0\uFE0F Tag Buddy: Can	 find code block source. This is a BUG. \u{1FAB2}");
    }
  }
  /*public static addSummary(file: TFile, summary: HTMLElement): void {
          if (!this.fileSummaries.has(file)) {
              this.fileSummaries.set(file, new Set([summary]));
          } else {
              const summaries = this.fileSummaries.get(file);
              summaries?.add(summary);
          }
      }
  
      // Method to retrieve an array of unique summary elements for a given file
      public static getSummariesByFile(file: TFile): HTMLElement[] {
          const summaries = this.fileSummaries.get(file);
          return summaries ? Array.from(summaries) : [];
      }*/
  copyBtnHandler(e, content) {
    const selection = window.getSelection().toString();
    let notice;
    if (selection != "") {
      navigator.clipboard.writeText(selection);
      notice = new import_obsidian7.Notice("Selection copied to clipboard.");
    } else {
      navigator.clipboard.writeText(content);
      notice = new import_obsidian7.Notice("Tagged paragraph copied to clipboard.");
    }
  }
  removeTagBtnHandler(e, paragraphEl2, tag) {
    const tagEl2 = getTagElement(paragraphEl2, tag);
    this.plugin.tagEditor.edit(tagEl2);
    setTimeout(async () => {
      this.update(summaryEl);
    }, 800);
  }
  async copyToBtnHandler(e, mode, dropdown, paragraphEl2, summaryEl2, content, tags, filePath, selectedFile) {
    let newContent;
    const selection = window.getSelection().toString();
    if (selection == "")
      newContent = content;
    else
      newContent = selection;
    let notice;
    if (mode == "link") {
      const fileName = filePath.split("/").pop().replace(/\.md$/, "");
      newContent = "[[" + filePath + "|" + fileName + "]]";
    }
    if (mode != "link" && !selection) {
      tags.forEach((tag, i) => {
        newContent = removeTagFromString(newContent, tag).trim();
      });
    }
    const copySuccess = await this.copyTextToSection(
      //this.plugin.settings.taggedParagraphCopyPrefix + 
      newContent,
      dropdown.getValue(),
      filePath,
      mode != "link",
      selectedFile
    );
    if (copySuccess) {
      if (mode == "note") {
        notice = new import_obsidian7.Notice(
          "Copied to section: " + dropdown.getValue() + " in " + selectedFile.name + " \u{1F517}",
          5e3
        );
        this.plugin.registerDomEvent(notice.noticeEl, "click", (e2) => {
          this.app.workspace.openLinkText(selectedFile.path + "#" + dropdown.getValue(), "");
        });
      } else if (mode == "move" && !selection) {
        const file = await this.app.vault.getAbstractFileByPath(filePath.split("#")[0]);
        let fileContent = await this.app.vault.read(file);
        fileContent = fileContent.trim();
        const newFileContent = replaceTextInString(
          content.trim(),
          fileContent,
          newContent
        ).trim();
        if (fileContent != newFileContent) {
          this.app.vault.modify(file, newFileContent);
          const copiedToWhere = dropdown.getValue() == "top" ? "top of note" : dropdown.getValue() == "end" ? "end of note" : dropdown.getValue();
          notice = new import_obsidian7.Notice(
            //'Moved to section: ' + dropdown.getValue() +
            //'.\n🔗 Open source note.', 
            "Copied to section: " + dropdown.getValue() + ". " + (dropdown.getValue() == "top" || dropdown.getValue() == "end" ? "" : "\u{1F517}"),
            5e3
          );
          setTimeout(async () => {
          }, 100);
          setTimeout(async () => {
            this.update(summaryEl2);
          }, 300);
          if (dropdown.getValue() != "top" || dropdown.getValue() != "end") {
            this.plugin.registerDomEvent(notice.noticeEl, "click", (e2) => {
              this.app.workspace.openLinkText(this.app.workspace.getActiveFile().path + "#" + dropdown.getValue(), "");
            });
          }
        } else {
          new import_obsidian7.Notice("Copied to section: " + dropdown.getValue() + ".\nCan't update source file.");
        }
      } else if (mode == "copy" || mode == "link") {
        notice = new import_obsidian7.Notice("Copied to section: " + dropdown.getValue() + ". " + (dropdown.getValue() == "top" || dropdown.getValue() == "end" ? "" : "\u{1F517}"));
        this.plugin.registerDomEvent(notice.noticeEl, "click", (e2) => {
          this.app.workspace.openLinkText(this.app.workspace.getActiveFile().path + "#" + dropdown.getValue(), "");
        });
      }
    }
  }
  async makeSummaryBtnHandler(summaryMd, tags, code = false, incrementFile = false) {
    const newNoteObj = fileObjFromTags(tags);
    let fileContent = code ? summaryMd : "## " + newNoteObj.title + "\n\n" + summaryMd;
    const view = await this.app.workspace.getActiveViewOfType(import_obsidian7.MarkdownView);
    const filePath = getActiveFileFolder(this.app.workspace.getActiveFile());
    const fileName = filePath + newNoteObj.fileName;
    const file = this.app.vault.getAbstractFileByPath(fileName);
    let notice;
    if (!code) {
      tags.forEach((tag) => {
        fileContent = replaceTextInString(tag, fileContent, tag.substring(1), true);
      });
    }
    if (file instanceof import_obsidian7.TFile && !incrementFile) {
      notice = new import_obsidian7.Notice("\u26A0\uFE0F Note already exists.\nClick here to overwrite.", 8e3);
      this.plugin.registerDomEvent(notice.noticeEl, "click", (e) => {
        this.app.vault.modify(file, fileContent);
        notice = new import_obsidian7.Notice("Note updated.\n\u{1F517} Open note.", 5e3);
        this.plugin.registerDomEvent(notice.noticeEl, "click", (e2) => {
          this.app.workspace.openLinkText(fileName, "");
        });
      });
    } else if (!file) {
      this.app.vault.create(fileName, fileContent);
      const notice2 = new import_obsidian7.Notice("Summary note created. \u{1F4DC}\n\u{1F517} Open note.");
      this.plugin.registerDomEvent(notice2.noticeEl, "click", (e) => {
        this.app.workspace.openLinkText(newNoteObj.fileName, "");
      });
    }
  }
  createCodeBlock(tagsArray, pos) {
    const codeBlockString = "```tag-summary\ntags: " + tagsArray.join(" ") + "\n```";
    if (pos == "note") {
      this.makeSummaryBtnHandler(codeBlockString, tagsArray, true);
    } else {
      this.copyTextToSection(
        codeBlockString,
        pos,
        "",
        false
      );
    }
  }
  async codeBlockProcessor(source, el, ctx) {
    let tags = Array();
    let include = Array();
    let exclude = Array();
    let sections = Array();
    let max = 50;
    const maxPattern = /^\s*max:\s*(\d+)\s*$/;
    let match;
    const rows = source.split("\n").filter((row) => row.length > 0);
    rows.forEach((line) => {
      if (line.match(/^\s*tags:[\p{L}0-9_\-/# ]+$/gu)) {
        const content = line.replace(/^\s*tags:/, "").trim();
        let list = content.split(/\s+/).map((tag) => tag.trim());
        list = list.filter((tag) => {
          if (tag.match(/^#[\p{L}]+[^#]*$/u)) {
            return true;
          } else {
            return false;
          }
        });
        tags = list;
      }
      if (line.match(/^\s*include:[\p{L}0-9_\-/# ]+$/gu)) {
        const content = line.replace(/^\s*include:/, "").trim();
        let list = content.split(/\s+/).map((tag) => tag.trim());
        list = list.filter((tag) => {
          if (tag.match(/^#[\p{L}]+[^#]*$/u)) {
            return true;
          } else {
            return false;
          }
        });
        include = list;
      }
      if (line.match(/^\s*exclude:[\p{L}0-9_\-/# ]+$/gu)) {
        const content = line.replace(/^\s*exclude:/, "").trim();
        let list = content.split(/\s+/).map((tag) => tag.trim());
        list = list.filter((tag) => {
          if (tag.match(/^#[\p{L}]+[^#]*$/u)) {
            return true;
          } else {
            return false;
          }
        });
        exclude = list;
      }
      if (line.match(/^\s*sections:[\p{L}0-9_\-/#, ]+$/gu)) {
        const content = line.replace(/^\s*sections:/, "").trim();
        let list = content.split(",").map((sec) => sec.trim());
        sections = list;
      }
      match = line.match(maxPattern);
      if (match) {
        max = Math.min(50, Number(match[1]));
      }
    });
    const codeBlock = "```tag-summary\n" + source.trim() + "\n```";
    if (tags.length > 0 || include.length > 0) {
      await this.create(
        el,
        tags,
        include,
        exclude,
        sections,
        max,
        ctx.sourcePath,
        codeBlock
      );
    } else {
      this.createEmpty(
        el,
        tags ? tags : [],
        include ? include : [],
        exclude ? exclude : [],
        sections ? sections : [],
        max ? max : [],
        ctx.sourcePath ? ctx.sourcePath : "",
        codeBlock
      );
    }
  }
  createEmpty(element, tags, include, exclude, sections, max, fileCtx, mdSource) {
    const container = createEl("div");
    const textDiv = createEl("blockquote");
    textDiv.innerHTML = "There are no notes with tagged paragraphs that match the tags:<br>" + (tags.length > 0 ? tags.join(", ") : "No tags specified.") + "<br>";
    container.appendChild(textDiv);
    container.setAttribute(
      "codeblock-tags",
      tags.length > 0 ? tags.join(",") : ""
    );
    container.setAttribute(
      "codeblock-tags-include",
      include ? include.join(",") : ""
    );
    container.setAttribute(
      "codeblock-tags-exclude",
      exclude ? exclude.join(",") : ""
    );
    container.setAttribute(
      "codeblock-sections",
      sections ? sections.join(",") : ""
    );
    container.setAttribute(
      "codeblock-max",
      max
    );
    container.setAttribute(
      "codeblock-code",
      mdSource
    );
    container.appendChild(this.plugin.gui.makeSummaryRefreshButton(container));
    ;
    element.replaceWith(container);
  }
  async create(element, tags, include, exclude, sections, max, fileCtx, mdSource) {
    const activeFile = await this.app.workspace.getActiveFile();
    const validTags = tags.concat(include);
    const tempComponent = new TempComponent();
    const summaryContainer = createEl("div");
    this.selectedBlocks = [];
    this.blocks = [];
    summaryContainer.setAttribute(
      "class",
      "tag-summary-block"
    );
    let listFiles = this.app.vault.getMarkdownFiles();
    listFiles = listFiles.filter((file) => {
      const cache = this.app.metadataCache.getFileCache(file);
      const tagsInFile = (0, import_obsidian7.getAllTags)(cache);
      if (file.path.includes("_exclude"))
        return false;
      if (activeFile) {
        if (activeFile.path == file.path)
          return false;
      }
      if (validTags.some((value) => tagsInFile == null ? void 0 : tagsInFile.includes(value))) {
        return true;
      }
      return false;
    });
    listFiles = listFiles.sort((file1, file2) => {
      return file2.stat.ctime - file1.stat.ctime;
    });
    let listContents = await this.readFiles(listFiles);
    let count = 0;
    let summary = "";
    listContents.forEach((item) => {
      const fileName = item[0].name.replace(/.md$/g, "");
      const filePath = item[0].path;
      let listParagraphs = Array();
      const blocks = item[1].split(/(?:\n\s*\n|(?<=^|\n)[*-]\s|(?<=^|\n)\d+\.\s)/).filter((row) => row.trim().length > 0);
      blocks.forEach((paragraph) => {
        let valid = false;
        let listTags = paragraph.match(/(?<=^|\s)(#[^\s#.,;!?:]+)/g);
        if (listTags != null && listTags.length > 0) {
          if (!paragraph.contains("```") && !paragraph.contains("---")) {
            valid = this.isValidText(listTags, tags, include, exclude);
          }
        }
        if (valid)
          listParagraphs.push(paragraph);
      });
      listParagraphs.forEach(async (paragraph) => {
        if (count++ >= max)
          return;
        paragraph += "\n";
        var regex = new RegExp();
        var tagText = new String();
        var tagSection = null;
        tags.forEach((tag) => {
          tagText = tag.replace("#", "\\#");
          regex = new RegExp(`${tagText}(\\W|$)`, "g");
          if (paragraph.match(regex) != null) {
            tagSection = tag;
          }
        });
        const buttonContainer = createEl("div");
        buttonContainer.setAttribute("class", "tagsummary-buttons");
        const paragraphEl2 = createEl("blockquote");
        paragraphEl2.setAttribute("file-source", filePath);
        paragraphEl2.setAttribute("index", count - 1);
        paragraphEl2.setAttribute("class", "tag-summary-paragraph");
        const blockLink = paragraph.match(/\^[\p{L}0-9_\-/^]+/gu);
        const header = findClosestHeaderWithLink(paragraph);
        let headerLink = removeTextFromString("#", header.link, true);
        headerLink = removeTextFromString("[", headerLink, true);
        headerLink = removeTextFromString("]", headerLink, true);
        let link;
        if (blockLink)
          link = "[[" + filePath + "#" + blockLink + "|" + fileName + "]]";
        else if (header.text != "")
          link = "[[" + filePath + "#" + headerLink + "]]";
        else
          link = "[[" + filePath + "|" + fileName + "]]";
        buttonContainer.appendChild(
          this.plugin.gui.makeCopyToSection(
            this.copyToBtnHandler.bind(this),
            paragraph,
            sections,
            tags,
            blockLink ? filePath + "#" + blockLink[0] : filePath,
            paragraphEl2,
            summaryContainer
          )
        );
        if (platformSettingCheck(this.app, this.plugin.settings.copyToCBBtn)) {
          buttonContainer.appendChild(
            this.plugin.gui.makeCopyButton(
              this.copyBtnHandler.bind(this),
              paragraph.trim()
            )
          );
        }
        if (platformSettingCheck(this.app, this.plugin.settings.removeTagBtn)) {
          buttonContainer.appendChild(
            this.plugin.gui.makeRemoveTagButton(
              this.removeTagBtnHandler.bind(this),
              paragraphEl2,
              tagSection
              //, 
              //(blockLink ? (filePath + '#' + blockLink[0]) : filePath)
            )
          );
        }
        const mdParagraph = paragraph;
        paragraph = "**" + link + "**\n" + paragraph;
        summary += paragraph + "\n";
        paragraphEl2.setAttribute("md-source", mdParagraph);
        blocks.push(mdParagraph);
        await import_obsidian7.MarkdownRenderer.render(this.app, paragraph, paragraphEl2, "", tempComponent);
        const titleEl = createEl("span");
        titleEl.setAttribute("class", "tagsummary-item-title");
        titleEl.appendChild(paragraphEl2.querySelector("strong").cloneNode(true));
        paragraphEl2.appendChild(buttonContainer);
        paragraphEl2.querySelector("strong").replaceWith(titleEl);
        summaryContainer.appendChild(paragraphEl2);
      });
    });
    if (summary != "") {
      setTimeout(async () => {
        if (this.plugin.settings.showSummaryButtons) {
          summaryContainer.appendChild(
            this.plugin.gui.makeSummaryRefreshButton(
              summaryContainer
            )
          );
          summaryContainer.appendChild(
            this.plugin.gui.makeCopySummaryButton(
              summary
            )
          );
          summaryContainer.appendChild(
            this.plugin.gui.makeSummaryNoteButton(
              this.makeSummaryBtnHandler.bind(this),
              summary,
              tags
            )
          );
          summaryContainer.appendChild(
            this.plugin.gui.makeBakeButton(
              this.bakeSummaryBtnHandler.bind(this),
              summary,
              summaryContainer,
              activeFile.path
            )
          );
          summaryContainer.appendChild(createEl("br"));
        }
      }, 0);
      summaryContainer.setAttribute(
        "codeblock-tags",
        tags.join(",")
      );
      summaryContainer.setAttribute(
        "codeblock-tags-include",
        include.length > 0 ? include.join(",") : ""
      );
      summaryContainer.setAttribute(
        "codeblock-tags-exclude",
        exclude.length > 0 ? exclude.join(",") : ""
      );
      summaryContainer.setAttribute(
        "codeblock-sections",
        sections.length > 0 ? sections.join(",") : ""
      );
      summaryContainer.setAttribute(
        "codeblock-max",
        max
      );
      summaryContainer.setAttribute(
        "codeblock-code",
        mdSource
      );
      element.replaceWith(summaryContainer);
    } else {
      this.createEmpty(
        element,
        tags ? tags : [],
        include ? include : [],
        exclude ? exclude : [],
        sections ? sections : [],
        max ? max : [],
        "",
        mdSource
      );
    }
  }
  update(summaryEl2) {
    const tagsStr = summaryEl2.getAttribute(
      "codeblock-tags"
    );
    const tags = tagsStr ? tagsStr.split(",") : [];
    const tagsIncludeStr = summaryEl2.getAttribute(
      "codeblock-tags-include"
    );
    const tagsInclude = tagsIncludeStr ? tagsIncludeStr.split(",") : [];
    const tagsExcludeStr = summaryEl2.getAttribute(
      "codeblock-tags-exclude"
    );
    const tagsExclude = tagsExcludeStr ? tagsExcludeStr.split(",") : [];
    const sectionsStr = summaryEl2.getAttribute(
      "codeblock-sections"
    );
    const sections = sectionsStr ? sectionsStr.split(",") : [];
    const max = Number(summaryEl2.getAttribute(
      "codeblock-max"
    ));
    const mdSource = summaryEl2.getAttribute(
      "codeblock-code"
    );
    this.create(
      summaryEl2,
      tags,
      tagsInclude,
      tagsExclude,
      sections,
      max,
      "",
      mdSource
    );
  }
  // Not factored yet
  async copyTextToSection(text, section, filePath, addLink = true, selectedFile, detectPrefix = true) {
    const file = selectedFile ? selectedFile : await this.app.workspace.getActiveFile();
    let fileContent = await this.app.vault.read(file);
    const fileContentLines = getLinesInString(fileContent);
    const mdHeadings = getMarkdownHeadings(fileContentLines);
    let targetLine;
    if (mdHeadings.length <= 0 || section == "end" || section == "top") {
      if (section == "top") {
        targetLine = findFirstLineAfterFrontMatter(fileContent);
        if (targetLine == 0)
          fileContent = "\n" + fileContent;
      } else if (section == "end") {
        targetLine = fileContentLines.length - 1;
      }
    } else if (mdHeadings.length > 0) {
      const headingObj = mdHeadings.find((heading) => heading.text.trim() === section);
      if (headingObj) {
        targetLine = headingObj.line;
      } else {
        new import_obsidian7.Notice(`${section} not found.`);
        return false;
      }
    }
    const linePrefix = detectPrefix ? getListTypeFromLineNumber(fileContent, targetLine + 1) : "";
    let finalText;
    if (addLink)
      finalText = linePrefix + text + ` [[${filePath}|\u{1F517}]]`;
    else
      finalText = linePrefix + text;
    let newContent = insertTextAfterLine(finalText, fileContent, targetLine);
    await this.app.vault.modify(file, newContent);
    return true;
  }
  async readFiles(listFiles) {
    let list = [];
    for (let t = 0; t < listFiles.length; t += 1) {
      const file = listFiles[t];
      let content = await this.app.vault.cachedRead(file);
      list.push([file, content]);
    }
    return list;
  }
  isValidText(listTags, tags, include, exclude) {
    let valid = true;
    if (tags.length > 0) {
      valid = valid && tags.some((value) => listTags.includes(value));
    }
    if (include.length > 0) {
      valid = valid && include.every((value) => listTags.includes(value));
    }
    if (valid && exclude.length > 0) {
      valid = !exclude.some((value) => listTags.includes(value));
    }
    return valid;
  }
  static getTagsToCheckFromEl(tagSummaryEl) {
    const tagsStr = tagSummaryEl.getAttribute("codeblock-tags");
    const tags = tagsStr ? tagsStr.split(",") : [];
    const tagsIncludeStr = tagSummaryEl.getAttribute("codeblock-tags-include");
    const tagsInclude = tagsIncludeStr ? tagsIncludeStr.split(",") : [];
    return tags.concat(tagsInclude);
  }
  async getFile(el) {
    const filePath = el.getAttribute("file-source");
    const file = await this.app.vault.getAbstractFileByPath(filePath);
    return file;
  }
  updateSelection(index, bool) {
    if (bool) {
      if (!this.selectedBlocks.includes(index)) {
        this.selectedBlocks.push(index);
      }
    } else {
      this.selectedBlocks = this.selectedBlocks.filter((itemIndex) => itemIndex !== index);
    }
  }
  getSelectedMarkdownBlocks() {
  }
};
TagSummary.fileSummaries = /* @__PURE__ */ new Map();
var TempComponent = class extends import_obsidian7.Component {
  constructor() {
    super(...arguments);
    this.doNotPostProcess = true;
  }
  onload() {
  }
  onunload() {
  }
};

// TagProcessor.ts
var import_obsidian8 = require("obsidian");
var TagProcessor = class {
  constructor(app2, plugin) {
    this.outOfSync = false;
    this.app = app2;
    this.plugin = plugin;
    this.debouncedProcessActiveFileTagEls = (0, import_obsidian8.debounce)(this.processActiveFileTags.bind(this), 500);
    this.debouncedProcessActiveFileTagEls();
  }
  reset() {
    this.outOfSync = false;
  }
  filterActiveFileTagEls(tags) {
    const filteredTagElements = Array.from(tags).filter((tag) => {
      if (tag.closest(".frontmatter-section-data"))
        return false;
      if (tag.parentElement.closest(".markdown-embed"))
        return false;
      if (tag.closest(".markdown-embed"))
        return false;
      if (tag.parentElement.closest(".tag-summary-block"))
        return false;
      return true;
    });
    return filteredTagElements;
  }
  async renderPostProcessor(el, ctx) {
    const processingFile = this.app.vault.getAbstractFileByPath(ctx.sourcePath);
    const activeFile = this.app.workspace.getActiveFile();
    const activeFilePath = activeFile == null ? void 0 : activeFile.path;
    const nativeEmbedEl = el.querySelector(".internal-embed");
    const tags = el.querySelectorAll(".tag");
    if (nativeEmbedEl && ctx.sourcePath == activeFilePath || ctx.sourcePath == activeFilePath && tags.length > 0 || el.classList.contains("tag-summary-paragraph")) {
    } else {
      return;
    }
    if (nativeEmbedEl) {
      let nativeEmbedObserver;
      nativeEmbedObserver = new MutationObserver((mutationsList) => {
        const target = mutationsList[0].target;
        if (target.querySelectorAll(".tag").length > 0) {
          nativeEmbedObserver.disconnect();
          this.processNativeEmbed(target);
        }
      });
      nativeEmbedObserver.observe(nativeEmbedEl, { childList: true, subtree: true });
    }
    if (el.classList.contains("tag-summary-paragraph")) {
      this.processTagSummaryParagraph(el);
      return;
    }
    this.debouncedProcessActiveFileTagEls();
  }
  async processActiveFileTags() {
    if (this.plugin.settings.debugMode)
      console.log("Tag Buddy: processing active file tags");
    const view = await this.app.workspace.getActiveViewOfType(import_obsidian8.MarkdownView);
    const mode = view == null ? void 0 : view.getMode();
    if (mode == "preview") {
      const activeFile = await this.app.workspace.getActiveFile();
      const fileContent = await this.app.vault.read(activeFile);
      const sections = view.currentMode.renderer.sections;
      const activeFileTagEls = [];
      const activeFileTags = await this.getMarkdownTags(
        activeFile,
        fileContent
      );
      sections.forEach((section) => {
        Array.from(section.el.querySelectorAll(".tag")).forEach((tag) => {
          activeFileTagEls.push(tag);
        });
      });
      const filteredTagElements = this.filterActiveFileTagEls(activeFileTagEls);
      if (filteredTagElements.length > 0) {
        this.assignMarkdownTags(
          activeFileTags,
          filteredTagElements,
          0,
          //startIndex,
          "active"
        );
      }
    }
  }
  async processTagSummaryParagraph(paragraphEl2) {
    const filePath = paragraphEl2.getAttribute("file-source");
    const markdownBlock = paragraphEl2.getAttribute("md-source").trim();
    const file = await this.app.vault.getAbstractFileByPath(filePath);
    const fileContent = await this.app.vault.read(file);
    const startIndex = fileContent.indexOf(markdownBlock);
    const mdTags = this.getMarkdownTags(
      file,
      fileContent
    );
    this.assignMarkdownTags(
      mdTags,
      paragraphEl2.querySelectorAll(".tag"),
      startIndex,
      "plugin-summary"
    );
  }
  /*
  	// adapt this method to use the cache tag info (line, offset, etc)
  	getMarkdownTags (
  		file: TFile,  
  		fileContent: string 
  	): Array {
  
  		const tagPositions = [];
  		let match;
  		// Obsidian tag spec: https://help.obsidian.md/Editing+and+formatting/Tags#Tag+format
  		//const regex = /(?:^|\s)#[^\s#]+|```/g; // BUG: wrong match.index. matches the space before the tag.
  		//const regex = /(?<=^|\s)#[^\s#]+|```/g // FIX. But still matching punctuation after
  		//const regex = /(?<=^|\s)(#[^\s#.,;!?:]+)(?=[.,;!?:\s]|$)|```/g  // matches punctuation after, but not included in the match
  		//const regex = /(?<=^|\s)(#[^\s#.,;!?:]+)(?=[.,;!?:\s]|$)|(?<!`)```(?!`)/g; // Fix for matching ```` 
  		//const regex = /(?<=^|\s)(#[^\s#.',;!?:]+)(?=[.,;!?:'\s]|$)|(?<!`)```(?!`)/g; // Fix for matching but excluding ''s' in '#tag's'
  		const regex = /(?<=^|\s)(#(?=[^\s#.'’,;!?:]*[^\d\s#.'’,;!?:])[^\s#.'’,;!?:]+)(?=[.,;!?:'’\s]|$)|(?<!`)```(?!`)/g; // fix for number-only and typographic apostrophy's
  
  
  
  		let insideCodeBlock = false;
  
  		while ((match = regex.exec(fileContent)) !== null) {
  		    if (match[0].trim() === "```") {
  		        insideCodeBlock = !insideCodeBlock; 
  		        continue; // Reject if tag in a code block
  		    }	    
  		    if (insideCodeBlock) continue;
  		    const tag = match[0].trim();
  		    tagPositions.push({tag:tag, index:match.index, source:file.name}); 
  //console.log(tag)
  		}
  		return tagPositions;
  	}
  */
  getMarkdownTags(file, fileContent) {
    const tagPositions = [];
    const processedPositions = /* @__PURE__ */ new Set();
    let match;
    const regex = /(?<=^|\s)(#(?=[^\s#.'’,;!?:]*[^\d\s#.'’,;!?:])[^\s#.'’,;!?:]+)(?=[.,;!?:'’\s]|$)|(?<!`)```(?!`)/g;
    let currentContext = "normal";
    let insideCodeBlock = false;
    let invalidBlockquote = false;
    while ((match = regex.exec(fileContent)) !== null) {
      const matchedString = match[0].trim();
      const matchIndex = match.index;
      if (processedPositions.has(matchIndex)) {
        if (this.plugin.settings.debugMode)
          console.log(`Skipping duplicate tag at position ${matchIndex}: ${matchedString}`);
        continue;
      }
      if (matchedString === "```") {
        insideCodeBlock = !insideCodeBlock;
        if (this.plugin.settings.debugMode)
          console.log(`Toggled insideCodeBlock to ${insideCodeBlock}`);
        continue;
      }
      if (insideCodeBlock) {
        if (this.plugin.settings.debugMode)
          console.log(`Skipping tag ${matchedString} inside code block.`);
        continue;
      }
      const lineStart = fileContent.lastIndexOf("\n", matchIndex) + 1;
      const lineEnd = fileContent.indexOf("\n", matchIndex);
      const line = fileContent.slice(lineStart, lineEnd !== -1 ? lineEnd : void 0);
      if (line.trim().startsWith(">")) {
        currentContext = "blockquote";
        if (line.startsWith("> 	") || line.startsWith(">	") || line.includes("(not a tag)")) {
          invalidBlockquote = true;
          if (this.plugin.settings.debugMode)
            console.log(`Invalid blockquote triggered at line: ${fileContent.substring(0, matchIndex).split("\n").length}`);
        }
      } else if (line.trim().startsWith("-") || line.trim().match(/^\d+\./)) {
        currentContext = "list";
        invalidBlockquote = false;
      } else if (line.startsWith("	")) {
        currentContext = "indented";
        invalidBlockquote = false;
      } else {
        currentContext = "normal";
        invalidBlockquote = false;
      }
      if (this.plugin.settings.debugMode)
        console.log(`Line ${fileContent.substring(0, matchIndex).split("\n").length}: ${currentContext} - ${line.trim()}`);
      if (invalidBlockquote) {
        if (this.plugin.settings.debugMode)
          console.log(`Skipping tag ${matchedString} due to invalid blockquote context.`);
        continue;
      }
      const isValid = currentContext !== "indented" && // Exclude lines starting with tabs
      !(currentContext === "list" && line.includes("(not a tag)")) && // Exclude invalid list tags
      !(currentContext === "blockquote" && invalidBlockquote);
      if (isValid) {
        tagPositions.push({
          tag: matchedString,
          index: matchIndex,
          source: file.name,
          context: currentContext,
          line: fileContent.substring(0, matchIndex).split("\n").length
          // Calculate line number
        });
        if (this.plugin.settings.debugMode)
          console.log(`Found tag: ${matchedString} in context: ${currentContext}`);
        processedPositions.add(matchIndex);
      } else {
        if (this.plugin.settings.debugMode)
          console.log(`Excluded tag: ${matchedString} in invalid context: ${currentContext}`);
      }
    }
    return tagPositions;
  }
  async assignMarkdownTags(tagPositions, tagElements, startIndex, type) {
    if (type == "active") {
      if (this.plugin.settings.debugMode) {
        const activeFilePath = this.app.workspace.getActiveFile().path;
        console.log(tagPositions.length, tagElements.length);
        const temp1 = [];
        tagPositions.forEach((nodeObj) => {
          temp1.push(nodeObj.tag);
        });
        const temp2 = [];
        tagElements.forEach((nodeObj) => {
          temp2.push(nodeObj.innerText);
        });
        console.log(temp1, temp2);
      }
      if (tagPositions.length != tagElements.length) {
        this.outOfSync = true;
        new import_obsidian8.Notice("Tag Buddy: Markdown source and preview tags out of sync. Try refreshing this summary. Then check for tag syntax errors or conflicts in metadata. Please report if this error persists.", 1e4);
        if (this.plugin.settings.debugMode)
          this.logDifferences(tagPositions, tagElements);
        return;
      }
    }
    let tagEl2;
    const tagElArray = Array.from(tagElements);
    let tagElIndex = 0;
    let tagPos;
    for (let i = 0; i < tagPositions.length; i++) {
      tagPos = tagPositions[i];
      if (tagPos.index >= startIndex) {
        tagEl2 = tagElArray[tagElIndex];
        if (tagEl2) {
          if (tagEl2.innerText.trim() == tagPos.tag.trim()) {
            tagEl2.setAttribute("md-index", tagPos.index);
            tagEl2.setAttribute("file-source", tagPos.source);
            tagEl2.setAttribute("type", type);
            tagEl2.setAttribute("pos", i);
            tagElIndex++;
          } else {
            this.outOfSync = true;
            new import_obsidian8.Notice("Tag Buddy: Markdown source and preview tags out of sync. Try refreshing this summary. Then check for tag syntax errors or conflicts in metadata. Please report if this error persists.");
            this.logDifferences(tagPositions, tagElements);
            return;
          }
        }
      }
    }
    ;
    return tagElArray;
  }
  async processNativeEmbed(embed, checkDuplicates = false) {
    if (this.plugin.settings.debugMode)
      console.log("Tag Buddy: processNativeEmbed");
    embed = embed.closest(".markdown-embed");
    if (embed == null ? void 0 : embed.getAttribute("src")) {
      const linkElement = embed.getAttribute("src");
      let filePath = embed.getAttribute("src");
      const linkArray = filePath.split("#");
      const hasAnchorLink = linkArray.length > 1;
      let anchorLinkType = "";
      let anchorLink;
      if (hasAnchorLink) {
        anchorLink = linkArray[1];
        anchorLinkType = anchorLink.startsWith("^") ? "block" : "header";
      }
      filePath = linkArray[0].trim() + ".md";
      const file = await validateFilePath(filePath);
      if (file) {
        const fileContent = await this.app.vault.read(file);
        const embededTagFile = await this.getMarkdownTags(file, fileContent);
        if (hasAnchorLink && anchorLinkType != "") {
          if (anchorLinkType == "header" && !fileContainsHeading(fileContent, anchorLink)) {
            embed.setAttribute("embed-success", "false");
            return;
          } else {
            embed.setAttribute("embed-success", "true");
          }
        }
        const tempComponent = new TempComponent2();
        const tempContainerHTML = createEl("div");
        await import_obsidian8.MarkdownRenderer.renderMarkdown(
          fileContent,
          tempContainerHTML,
          "noFile",
          //file.path, 
          tempComponent
        );
        const innerText = await embed.querySelector(".markdown-embed-content").innerText;
        const startIndex = tempContainerHTML.innerText.indexOf(innerText);
        this.assignMarkdownTags(
          embededTagFile,
          embed.querySelectorAll(".tag"),
          startIndex,
          "native-embed"
        );
      }
    }
  }
  logDifferences(tagPositions, tagElements) {
    const tags = tagPositions.map((item) => item.tag);
    const innerTexts1 = tagElements.map((item) => item.innerText);
    let uniqueToTagPositions = [];
    let uniqueToTagElements = [];
    const findUnique = (arr1, arr2) => {
      return arr1.filter((item) => !arr2.includes(item));
    };
    uniqueToTagPositions = findUnique(tags, innerTexts1);
    uniqueToTagElements = findUnique(innerTexts1, tags);
    console.log("differences:", uniqueToTagPositions.length, uniqueToTagElements.length);
    if (uniqueToTagPositions.length) {
      console.log("Unique to tagPositions based on tag:", uniqueToTagPositions);
    }
    if (uniqueToTagElements.length) {
      console.log("Unique to tagElements based on innerText:", uniqueToTagElements);
    }
  }
};
var TempComponent2 = class extends import_obsidian8.Component {
  onload() {
  }
  onunload() {
  }
};

// ReadingModeTagEditor.ts
var import_obsidian9 = require("obsidian");
var ReadingModeTagEditor = class {
  constructor(app2, plugin) {
    this.app = app2;
    this.plugin = plugin;
  }
  //async renameTag (tag, newName, batchAction: string | number, specificFile:TFile = null) {
  async renameTag(tag, newName, batchAction, filePath = null, tagEl2) {
    const activeFile = await this.app.workspace.getActiveFile();
    const file = filePath == null ? activeFile : await validateFilePath(filePath);
    if (!file)
      return;
    const fileContent = await this.app.vault.read(file);
    if (typeof batchAction === "number") {
      const newFileContent = this.renameTagInStringByIndex(
        tag,
        newName,
        parseInt(batchAction),
        fileContent
      );
      this.app.vault.modify(file, newFileContent);
    } else if (batchAction == "note") {
      this.renameTagsInFileByIndex(
        tag,
        newName,
        file
      );
    } else if (batchAction == "vault") {
      this.renameTagsInVaultByIndex(
        tag,
        newName
      );
    }
    if (activeFile != file && tagEl2) {
      new import_obsidian9.Notice("Refresh this summary to see changes.", 5e3);
    }
  }
  async renameTagsInVaultByIndex(tag, newName) {
    const validTags = [tag];
    let listFiles = this.app.vault.getMarkdownFiles();
    listFiles = listFiles.filter((file) => {
      const cache = this.app.metadataCache.getFileCache(file);
      const tagsInFile = (0, import_obsidian9.getAllTags)(cache);
      if (validTags.some((value) => tagsInFile == null ? void 0 : tagsInFile.includes(value))) {
        return true;
      }
      return false;
    });
    let listContents = await this.plugin.tagSummary.readFiles(listFiles);
    listContents.forEach(async (note) => {
      this.renameTagsInFileByIndex(
        tag,
        newName,
        note[0]
      );
    });
  }
  async renameTagsInFileByIndex(tag, newName, file) {
    const fileContent = await this.app.vault.read(file);
    let newFileContent = fileContent;
    const tagPositions = this.plugin.tagProcessor.getMarkdownTags(file, fileContent);
    let filteredTagObjs = tagPositions.filter((tagObj) => tagObj.tag === tag);
    if (filteredTagObjs.length > 0) {
      filteredTagObjs.sort((a, b) => a.index - b.index);
      let offset = 0;
      filteredTagObjs.forEach((tagObj) => {
        const newIndex = tagObj.index + offset;
        newFileContent = newFileContent.substring(0, newIndex) + newName + newFileContent.substring(newIndex + tagObj.tag.length);
        offset += newName.length - tagObj.tag.length;
      });
      this.app.vault.modify(file, newFileContent);
    } else {
    }
  }
  renameTagInStringByIndex(tag, newName, index, fileContent) {
    const newContent = fileContent.substring(0, parseInt(index)) + newName + fileContent.substring(parseInt(index) + parseInt(tag.length));
    return newContent;
  }
  async add(tag, x, y) {
    if (this.plugin.settings.debugMode) {
      console.log("Tag Buddy add " + tag + " at (" + x + ", " + y + ")");
    }
    let fileContent;
    let file;
    const clickedTextObj = getClickedTextObjFromDoc(x, y);
    const clickedText = clickedTextObj == null ? void 0 : clickedTextObj.text;
    const clickedTextIndex = clickedTextObj == null ? void 0 : clickedTextObj.index;
    const clickedTextEl = clickedTextObj == null ? void 0 : clickedTextObj.el;
    let contentSourceType = null;
    let summaryEl2 = void 0;
    let embedEl = void 0;
    if (clickedTextObj) {
      try {
        summaryEl2 = clickedTextEl == null ? void 0 : clickedTextEl.closest(".tag-summary-paragraph");
        embedEl = clickedTextEl == null ? void 0 : clickedTextEl.closest(".markdown-embed");
      } catch (e) {
      }
      if (summaryEl2) {
        file = await this.plugin.tagSummary.getFile(summaryEl2);
        fileContent = await this.app.vault.read(file);
        contentSourceType = "plugin-summary";
      } else if (embedEl) {
        file = await getEmbedFile(embedEl);
        fileContent = await this.app.vault.read(file);
        contentSourceType = "native-embed";
      } else {
        file = await this.app.workspace.getActiveFile();
        fileContent = await this.app.vault.read(file);
        contentSourceType = "active";
      }
    } else {
      new import_obsidian9.Notice("\u26A0\uFE0F Can't find text position or area too busy.\nTry a another text area.");
      return;
    }
    if (clickedText) {
    } else {
      new import_obsidian9.Notice("\u26A0\uFE0F Can't add tag.\nTry a different text area.");
      return;
    }
    const escapedClickedText = escapeRegExp(clickedText);
    const regex = new RegExp(escapedClickedText, "g");
    const matches = fileContent.match(regex);
    if (matches && matches.length > 1) {
      new import_obsidian9.Notice("\u26A0\uFE0F Can't add tag: Clicked text repeated in note. Try a another text block.");
      return;
    } else if (matches && matches.length === 0 || !matches) {
      new import_obsidian9.Notice("\u26A0\uFE0F Can't find text position or area too busy.\nTry a another text area.");
      return;
    }
    if (!this.plugin.settings.lockRecentTags)
      this.plugin.saveRecentTag(tag);
    const startIndex = regex.exec(fileContent).index;
    const endIndex = startIndex + clickedText.length;
    const clickedWordObj = getWordObjFromString(clickedText, clickedTextIndex);
    const clickedWord = clickedWordObj.text;
    const clickedWordIndex = clickedWordObj.index;
    let newContent;
    if (clickedWord) {
      if (isWordNearEnd(clickedText, clickedWord))
        newContent = insertTextInString(" " + tag, fileContent, endIndex);
      else
        newContent = insertTextInString(tag, fileContent, startIndex + clickedWordIndex);
    } else {
      new import_obsidian9.Notice("\u26A0\uFE0F Can't find clicked word.\nPlease try again.");
      return;
    }
    await this.app.vault.modify(file, newContent);
    if (contentSourceType == "plugin-summary") {
      const summaryContainer = summaryEl2.closest(".tag-summary-block");
      this.plugin.tagSummary.update(summaryContainer);
    } else if (contentSourceType == "native-embed") {
      setTimeout(async () => {
        this.plugin.tagProcessor.processNativeEmbed(embedEl, true);
      }, 200);
    }
  }
  async edit(tagEl2, event, pragraphEl, editType, newName) {
    let tagContainer;
    const tagContainerType = tagEl2.getAttribute(
      "type"
    );
    const index = tagEl2.getAttribute(
      "md-index"
    );
    const filePath = tagEl2.getAttribute(
      "file-source"
    );
    if (this.plugin.settings.debugMode) {
      console.log("Tag Buddy edit tag: " + tagEl2.innerText + "\nIn file: " + filePath);
    }
    if (tagContainerType == "native-embed")
      tagContainer = tagEl2.closest(".markdown-embed");
    else if (tagContainerType == "plugin-summary")
      tagContainer = tagEl2.closest(".tag-summary-paragraph");
    else
      tagContainer = this.app.workspace.activeLeaf.containerEl.querySelector(".markdown-reading-view");
    if (filePath) {
      const file = await validateFilePath(filePath);
      let fileContent;
      let fileContentBackup;
      const tag = tagEl2.innerText.trim();
      try {
        fileContent = await this.app.vault.read(file);
        fileContentBackup = fileContent;
      } catch (error) {
        new import_obsidian9.Notice("Tag Buddy file read error:\n" + error.message);
        return;
      }
      let safeToEmptyFile = false;
      const tagRegex = /^\s*#(\w+)\s*$/;
      if (tagRegex.test(fileContent.trim())) {
        safeToEmptyFile = true;
      }
      let beforeTag = fileContent.substring(0, index);
      let afterTag = fileContent.substring(
        Number(index) + Number(tag.length)
      );
      let afterTagChr = "";
      if (fileContent[index] === "\n")
        beforeTag += "\n";
      let newContent = "";
      if (editType == "rename") {
      } else if (!event) {
        newContent = beforeTag + afterTagChr + afterTag;
      } else if (editType == "hash") {
        const noHash = tag.substring(1);
        newContent = beforeTag + noHash + afterTagChr + afterTag;
        if (this.app.isMobile && this.plugin.settings.mobileNotices) {
          new import_obsidian9.Notice("Tag Buddy: " + tag + " converted to text.");
        }
      } else if (event.type == "touchend" || this.plugin.settings.mobileTagSearch || editType == "remove") {
        let parentTag = "";
        if (tag.includes("/")) {
          let parts = tag.split("/");
          const removedChild = parts.pop();
          parentTag = parts.join("/");
          newContent = beforeTag + parentTag + afterTagChr + afterTag;
          if (this.app.isMobile && this.plugin.settings.mobileNotices) {
            new import_obsidian9.Notice("Tag Buddy: '" + removedChild + "' removed from parent tag.");
          }
        } else {
          const startsWithPunctuation = /^[.,!:?;]/.test(afterTag.trimStart()[0]);
          if (beforeTag.endsWith(" ") && afterTag.startsWith(" ")) {
            newContent = beforeTag + afterTag.substring(1);
          } else if (startsWithPunctuation) {
            newContent = beforeTag.trimEnd() + afterTag.trimStart();
          } else {
            newContent = beforeTag + afterTag;
          }
          if (this.app.isMobile && this.plugin.settings.mobileNotices) {
            new import_obsidian9.Notice("Tag Buddy: " + tag + " removed.");
          }
        }
      }
      if (tagEl2.getAttribute("type") == "plugin-summary") {
        const summaryEl2 = tagEl2.closest(".tag-summary-paragraph");
        const mdSource = summaryEl2.getAttribute("md-source").trim();
        const escapedText = escapeRegExp(mdSource);
        const regex = new RegExp(escapedText, "g");
        const matches = fileContent.match(regex);
        if (matches && matches.length > 1) {
          new import_obsidian9.Notice("\u26A0\uFE0F Can't safely remove/edit tag:\nSurrounding text repeated in source note.");
          return;
        } else if (matches && matches.length === 0 || !matches) {
          new import_obsidian9.Notice("\u26A0\uFE0F Can't find tag in source note.\n");
          return;
        }
        if (newContent == "" && !safeToEmptyFile || contentChangedTooMuch(
          fileContentBackup,
          newContent,
          tag,
          2
        )) {
          new import_obsidian9.Notice("Tag Buddy: File change error.");
          newContent = fileContentBackup;
        } else if (newContent == "" && safeToEmptyFile) {
          new import_obsidian9.Notice("Tag Buddy: Tag removed. The note is empty.");
        }
        setTimeout(async () => {
          const tagParagraphEl = tagEl2.closest(".tag-summary-paragraph");
          const tagSummaryBlock = tagEl2.closest(".tag-summary-block");
          const tagsToCheck = TagSummary.getTagsToCheckFromEl(tagSummaryBlock);
          const tagsInContent = tagsInString(tagParagraphEl.innerText);
          if (tagsToCheck.includes(tag)) {
            const tagCount = countOccurrences(tagsToCheck, tagsInContent);
            if (tagCount >= 2) {
              this.plugin.tagSummary.update(tagSummaryBlock);
            } else {
              const notice = new import_obsidian9.Notice(tag + " removed from paragraph.\n\u{1F517} Open source note.", 5e3);
              this.plugin.gui.removeElementWithAnimation(
                tagParagraphEl,
                () => {
                  setTimeout(async () => {
                    this.plugin.tagSummary.update(tagSummaryBlock);
                    tagParagraphEl.remove();
                  }, 500);
                }
              );
              this.plugin.registerDomEvent(
                notice.noticeEl,
                "click",
                (e) => {
                  this.app.workspace.openLinkText(filePath, "");
                }
              );
            }
          } else {
            this.plugin.tagSummary.update(tagSummaryBlock);
          }
        }, 200);
      } else if (tagEl2.getAttribute("type") == "native-embed") {
        setTimeout(async () => {
          this.plugin.tagProcessor.processNativeEmbed(tagContainer, true);
        }, 200);
      }
      try {
        await this.app.vault.modify(file, newContent);
      } catch (error) {
        try {
          const backupFileName = String(file.name.substring(0, file.name.indexOf(".md")) + " BACKUP.md");
          this.app.vault.create(backupFileName, fileContentBackup);
          new import_obsidian9.Notice("\u26A0\uFE0F Tag/note editing error: " + error.message + "\n" + backupFileName + " saved to vault root.", 1e4);
        } catch (error2) {
          navigator.clipboard.writeText(fileContentBackup);
          new import_obsidian9.Notice("\u26A0\uFE0F Tag/note editing error: " + error2.message + "\nNote content copied to clipboard.", 1e4);
        }
      }
      this.plugin.tagProcessor.debouncedProcessActiveFileTagEls();
    } else {
      new import_obsidian9.Notice("\u26A0\uFE0F Can't identify tag location. Please try again.");
    }
  }
};

// Mobile.ts
var DoubleTapHandler = class {
  constructor(plugin, element, callback) {
    this.plugin = plugin;
    this.element = element;
    this.callback = callback;
    this.lastTap = 0;
    this.plugin.registerDomEvent(
      this.element,
      "touchend",
      this.handleTouchEnd.bind(this),
      true
    );
  }
  handleTouchEnd(event) {
    const currentTime = (/* @__PURE__ */ new Date()).getTime();
    const tapLength = currentTime - this.lastTap;
    clearTimeout(this.timeout);
    if (tapLength < 500 && tapLength > 0) {
      this.callback(event);
    } else {
      this.timeout = setTimeout(() => {
        clearTimeout(this.timeout);
      }, 500);
    }
    this.lastTap = currentTime;
  }
};
var TripleTapHandler = class {
  constructor(plugin, element, callback) {
    this.plugin = plugin;
    this.element = element;
    this.callback = callback;
    this.lastTap = 0;
    this.tapCount = 0;
    this.plugin.registerDomEvent(
      this.element,
      "touchend",
      this.handleTouchEnd.bind(this),
      true
    );
  }
  handleTouchEnd(event) {
    const currentTime = (/* @__PURE__ */ new Date()).getTime();
    const tapLength = currentTime - this.lastTap;
    clearTimeout(this.timeout);
    if (tapLength < 500 && tapLength > 0) {
      this.tapCount++;
      if (this.tapCount === 2) {
        this.callback(event);
        this.tapCount = 0;
      }
    } else {
      this.tapCount = 0;
    }
    this.timeout = setTimeout(() => {
      clearTimeout(this.timeout);
      this.tapCount = 0;
    }, 500);
    this.lastTap = currentTime;
  }
};
var PressAndHoldHandler = class {
  constructor(plugin, element, callback, duration = 600) {
    this.plugin = plugin;
    this.element = element;
    this.callback = callback;
    this.duration = duration;
    this.timeout = null;
    this.plugin.registerDomEvent(
      this.element,
      "touchstart",
      this.handleTouchStart.bind(this),
      true
    );
    this.plugin.registerDomEvent(
      this.element,
      "touchend",
      this.handleTouchEnd.bind(this),
      true
    );
  }
  handleTouchStart(event) {
    this.timeout = setTimeout(() => {
      this.callback(event);
      this.timeout = null;
    }, this.duration);
  }
  handleTouchEnd(event) {
    if (this.timeout) {
      clearTimeout(this.timeout);
      this.timeout = null;
    }
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  removeOnClick: true,
  removeChildTagsFirst: true,
  optToConvert: true,
  mobileTagSearch: false,
  tagSummaryBlockButtons: false,
  taggedParagraphCopyPrefix: "",
  // new
  desktopClickTag: "remove",
  desktopCMDClickTag: "edit",
  desktopOPTClickTag: "native",
  mobileDoubleTapTag: "remove",
  mobileLongPressTag: "edit",
  mobileTripleTapText: true,
  removeTagBtn: "always",
  copyToCBBtn: "hide",
  moveToSectionBtn: "always",
  copyToSectionBtn: "always",
  copyLinkToSectionBtn: "hide",
  copyToNoteBtn: "always",
  mobileNotices: true,
  recentlyAddedTags: "",
  lockRecentTags: false,
  showSummaryButtons: false,
  debugMode: false
};
var TagBuddy = class extends import_obsidian10.Plugin {
  onunload() {
  }
  // this is needed for hotreload. Actual cleanup is done throughout.
  async onload() {
    console.log("Tag Buddy Plugin loaded on " + (this.app.isMobile ? "mobile at " : "desktop at ") + (/* @__PURE__ */ new Date()).toUTCString().substring(17));
    this.addSettingTab(new TBSettingsTab(this.app, this));
    await this.loadSettings();
    this.app.workspace.onLayoutReady(async () => {
      this.gui = new GUI(this.app, this);
      this.tagSummary = new TagSummary(this.app, this);
      this.tagProcessor = new TagProcessor(this.app, this);
      this.tagEditor = new ReadingModeTagEditor(this.app, this);
      this.registerMarkdownPostProcessor(
        this.tagProcessor.renderPostProcessor.bind(this.tagProcessor)
      );
      try {
        this.registerMarkdownCodeBlockProcessor(
          "tag-summary",
          this.tagSummary.codeBlockProcessor.bind(this.tagSummary)
        );
      } catch (e) {
      }
      this.registerDomEvent(
        document,
        "contextmenu",
        async (event) => {
          const view = await this.app.workspace.getActiveViewOfType(import_obsidian10.MarkdownView);
          if (view && ctrlCmdKey(event) && view.getMode() == "preview" && view.containerEl.contains(event.target)) {
            event.preventDefault();
            this.gui.showTagSelector(event);
          }
        }
      );
      this.registerEvent(this.app.on(
        "layout-change",
        async (event) => {
          var _a;
          const mode = (_a = this.app.workspace.getActiveViewOfType(import_obsidian10.MarkdownView)) == null ? void 0 : _a.getMode();
          if (this.settings.debugMode)
            console.log("Tag Buddy: layout-change:", mode);
          if (mode == "preview") {
            this.tagProcessor.reset();
            this.tagProcessor.debouncedProcessActiveFileTagEls();
          } else if (mode == "source") {
          }
        }
      ));
      this.registerEvent(this.app.workspace.on(
        "file-open",
        //debounce(
        async (event) => {
          var _a, _b;
          const activeFile = await this.app.workspace.getActiveFile();
          if (this.settings.debugMode)
            console.log("Tag Buddy: last active file:", (_a = this.activeFile) == null ? void 0 : _a.name);
          if (this.settings.debugMode)
            console.log("Tag Buddy: file open:", activeFile == null ? void 0 : activeFile.name);
          if ((activeFile == null ? void 0 : activeFile.path) != ((_b = this.activeFile) == null ? void 0 : _b.path)) {
            this.tagProcessor.reset();
            this.activeFile = this.app.workspace.getActiveFile();
            if (this.tagProcessor) {
              this.tagProcessor.processActiveFileTags();
            }
          }
        }
        //, 3000, true)
      ));
      if (!this.app.isMobile) {
        this.registerDomEvent(
          document,
          "click",
          this.onClickEvent.bind(this),
          true
        );
      } else {
        this.registerDomEvent(
          document,
          "click",
          (e) => {
            const isTag = e.target.classList.contains("tag");
            const tag = e.target.closest(".tag");
            if (isTag && this.settings.mobileDoubleTapTag != "native") {
              e.stopPropagation();
            } else if (!isTag) {
            } else {
            }
          },
          true
        );
        new DoubleTapHandler(
          this,
          document,
          (event) => {
            if (event.target.classList.contains("tag")) {
              this.mobileTapHandler(event, this.settings.mobileDoubleTapTag);
            }
          },
          true
          //this.onClickEvent.bind(this)
        );
        new PressAndHoldHandler(
          this,
          document,
          (event) => {
            if (event.target.classList.contains("tag")) {
              this.mobileTapHandler(event, this.settings.mobileLongPressTag);
            }
          }
          /*async (event: MouseEvent) => {	
           			const view = await this.app.workspace.getActiveViewOfType(MarkdownView);
                 if (view && 
                 	(view.getMode() == 'preview') &&
                 	(view.containerEl.contains(event.target))
                	) {         
                 	event.preventDefault();
                 	this.gui.showTagEditor(event.target.closest('.tag').innerText)
                 }
           		}, true*/
          //(event) => {
          //	this.gui.showTagEditor(event.target.closest('.tag').innerText)
          //}
          //this.onClickEvent.bind(this)
        );
        new TripleTapHandler(
          this,
          document,
          async (event) => {
            const view = await this.app.workspace.getActiveViewOfType(import_obsidian10.MarkdownView);
            if (view && view.getMode() == "preview" && view.containerEl.contains(event.target)) {
              this.gui.showTagSelector(event);
            }
          },
          true
          //this.gui.showTagSelector.bind(this.gui)
        );
      }
    });
  }
  async mobileTapHandler(event, setting) {
    if (setting == "edit") {
      const view = await this.app.workspace.getActiveViewOfType(import_obsidian10.MarkdownView);
      if (view && view.getMode() == "preview" && view.containerEl.contains(event.target)) {
        this.gui.showTagEditor(event.target.closest(".tag"));
      }
    } else if (setting == "remove") {
      this.tagEditor.edit(event.target, event, null, "remove");
    } else if (setting == "hash") {
      this.tagEditor.edit(event.target, event, null, "hash");
    }
  }
  async onClickEvent(event) {
    const target = event.target;
    const view = await this.app.workspace.getActiveViewOfType(import_obsidian10.MarkdownView);
    const modKey = ctrlCmdKey(event) ? "CMD" : event.altKey ? "OPT" : "";
    if (!view && target.matches(".tag")) {
      new import_obsidian10.Notice("Tag Buddy: Can't edit tag. Unsupported view type. Try again within the source note.");
      return;
    }
    if (view) {
      if (view.getMode() != "preview" || !view.containerEl.contains(event.target))
        return;
    }
    if (!this.app.isMobile) {
      if (this.settings.desktopClickTag == "native" && modKey == "" || this.settings.desktopCMDClickTag == "native" && modKey == "CMD" || this.settings.desktopOPTClickTag == "native" && modKey == "OPT") {
        return;
      } else if (this.settings.desktopClickTag == "edit" && modKey == "" || this.settings.desktopCMDClickTag == "edit" && modKey == "CMD" || this.settings.desktopOPTClickTag == "edit" && modKey == "OPT") {
        if (!target.matches(".tag"))
          return;
        event.stopPropagation();
        event.preventDefault();
        this.gui.showTagEditor(event.target.closest(".tag"));
        return;
      }
    } else {
      setTimeout(() => {
        const selection = window.getSelection();
        if (selection)
          selection.removeAllRanges();
      }, 400);
      if (this.settings.mobileTagSearch && event.type == "touchend") {
        return;
      }
    }
    if (target && target.matches(".tag")) {
      if (this.tagProcessor.outOfSync) {
        new import_obsidian10.Notice("Markdown source and HTML tags are out of sync. Check for tag syntax errors.");
        return;
      }
      let editType;
      if (modKey == "")
        editType = this.settings.desktopClickTag;
      else if (modKey == "CMD")
        editType = this.settings.desktopCMDClickTag;
      else if (modKey == "OPT")
        editType = this.settings.desktopOPTClickTag;
      event.stopPropagation();
      event.preventDefault();
      const clickedTag = target.closest(".tag");
      const tag = clickedTag.innerText;
      let tagIndex = clickedTag.getAttribute("md-index");
      let tagFile = clickedTag.getAttribute("file-source");
      if (tagFile) {
        this.tagEditor.edit(
          target,
          event,
          null,
          editType
        );
      } else {
        setTimeout(async () => {
          tagIndex = clickedTag.getAttribute("md-index");
          tagFile = clickedTag.getAttribute("file-source");
          this.tagEditor.edit(
            target,
            event,
            null,
            editType
          );
        }, 300);
      }
    } else if (!view && target.matches(".tag")) {
      new import_obsidian10.Notice("Tag Buddy: Can't edit tag. Might be in an unsupported view type.");
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  getTagsFromApp() {
    const tagsObject = this.app.metadataCache.getTags();
    const tagsArray = Object.entries(tagsObject);
    tagsArray.sort((a, b) => b[1] - a[1]);
    const recentTags = this.getRecentTags();
    if (recentTags.length > 0) {
      const recentTagsAsTuples = recentTags.map((tag) => [tag, 0]);
      const recentAndAllTags = recentTagsAsTuples.concat(tagsArray);
      return recentAndAllTags.map(([tag, _]) => tag.replace(/^#/, ""));
    } else {
      return tagsArray.map(([tag, _]) => tag.replace(/^#/, ""));
    }
  }
  saveRecentTag(tag) {
    if (isTagValid(tag, true)) {
      const recentTagsString = this.settings.recentlyAddedTags;
      let recentTags;
      if (recentTagsString == "") {
        recentTags = [];
      } else if (recentTagsString.indexOf(", ")) {
        recentTags = this.settings.recentlyAddedTags.split(", ");
      } else {
        recentTags = [this.settings.recentlyAddedTags];
      }
      if (recentTags.includes(tag)) {
        recentTags.splice(recentTags.indexOf(tag), 1);
      }
      recentTags.unshift(tag.trim());
      recentTags = recentTags.slice(0, 3);
      this.settings.recentlyAddedTags = recentTags.join(", ");
      this.saveSettings();
    } else {
    }
  }
  getRecentTags() {
    const recentTags = this.settings.recentlyAddedTags == "" ? [] : this.settings.recentlyAddedTags.split(", ");
    return recentTags;
  }
};


/* nosourcemap */