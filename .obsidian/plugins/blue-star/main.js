/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => BlueStar
});
module.exports = __toCommonJS(main_exports);
var import_obsidian6 = require("obsidian");

// src/config.ts
var DEFAULT_SETTINGS = {
  updateExisting: false,
  allowSingleField: true,
  htmlLineBreak: false,
  directoryPath: "Anki",
  includeFileTag: "",
  excludeFileTag: "",
  ankiDeck: "Default",
  ankiModel: "Basic",
  ankiTag: "blue-star",
  matchMode: "section-subsection",
  currentHeadingLevel: 2,
  headingLevel: {
    "section-subsection": 2,
    "heading-paragraph": 2,
    "multi-subsection": 2,
    "multi-subparagraph": 2
  },
  regexPatterns: [
    {
      alias: "Single line separated by ::",
      pattern: "^(.*[^\n:]{1}):{2}([^\n:]{1}.*)",
      flags: "gm",
      enabled: false
    },
    {
      alias: "Multi-line Q&A starting with Q: and A:",
      pattern: "^Q: ((?:.+\n)*)\n*A: (.+(?:\n(?:^.{1,3}$|^.{4}(?<!<!--).*))*)",
      flags: "gm",
      enabled: false
    },
    {
      alias: "Multi-line text separated by '#flashcard'",
      pattern: "((?:[^\n][\n]?)+) #flashcard ?\n*((?:\n(?:^.{1,3}$|^.{4}(?<!<!--).*))+)",
      flags: "gm",
      enabled: false
    },
    {
      alias: "Multi-line text separated by ---",
      pattern: "((?:[^\n][\n]?)+\n)-{3,}((?:\n(?:^.{1,3}$|^.{4}(?<!<!--).*))*)",
      flags: "gm",
      enabled: false
    },
    {
      alias: "Cloze paragraph format",
      pattern: "((?:.+\n)*(?:.*{{c.*)(?:\n(?:^.{1,3}$|^.{4}(?<!<!--).*))*)",
      flags: "gm",
      enabled: false
    },
    {
      alias: "All headings and paragraph, starting from h1",
      pattern: "^#+(.+)\n*((?:\n(?:^[^\n#].{0,2}$|^[^\n#].{3}(?<!<!--).*))+)",
      flags: "gm",
      enabled: false
    },
    {
      alias: "All headings and paragraph, starting from h2",
      pattern: "^#{2,}(.+)\n*((?:\n(?:^[^\n#].{0,2}$|^[^\n#].{3}(?<!<!--).*))+)",
      flags: "gm",
      enabled: false
    },
    {
      alias: "All headings and paragraph, starting from h3",
      pattern: "^#{3,}(.+)\n*((?:\n(?:^[^\n#].{0,2}$|^[^\n#].{3}(?<!<!--).*))+)",
      flags: "gm",
      enabled: false
    }
  ],
  customDelimiters: {
    cardStart: "<!-- card start -->",
    fieldSeparator: "<!-- field separator -->",
    cardEnd: "<!-- card end -->"
  },
  signleDelimiter: {
    fieldSeparator: "<!-- field separator -->"
  },
  fieldSeparator: "<!-- field separator -->"
};

// src/settingsTab.ts
var import_obsidian = require("obsidian");
var BlueStarSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Directory path").setDesc("Specify the directory path to scan for files.").addText((text) => text.setPlaceholder("Anki").setValue(this.plugin.settings.directoryPath).onChange(async (value) => {
      this.plugin.settings.directoryPath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Include file tag").setDesc("Specify the tag for files that need to be included in the specified directory.").addText((text) => text.setPlaceholder("anki").setValue(this.plugin.settings.includeFileTag).onChange(async (value) => {
      this.plugin.settings.includeFileTag = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Exclude file tag").setDesc("Specify the tag for files that need to be excluded in the specified directory.").addText((text) => text.setPlaceholder("anki-ignore").setValue(this.plugin.settings.excludeFileTag).onChange(async (value) => {
      this.plugin.settings.excludeFileTag = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Update existing cards").setDesc("If enabled, existing cards in Anki will be updated. Otherwise, only new cards will be added.").addToggle((toggle) => toggle.setValue(this.plugin.settings.updateExisting).onChange(async (value) => {
      this.plugin.settings.updateExisting = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Allow single field cards").setDesc("If enabled, allows generating Anki cards with a single field.").addToggle((toggle) => toggle.setValue(this.plugin.settings.allowSingleField).onChange(async (value) => {
      this.plugin.settings.allowSingleField = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Add HTML break").setDesc("If enabled, add HTML line break <br>.").addToggle((toggle) => toggle.setValue(this.plugin.settings.htmlLineBreak).onChange(async (value) => {
      this.plugin.settings.htmlLineBreak = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Anki deck").setDesc("The default deck to add cards to.").addText((text) => text.setPlaceholder("Default").setValue(this.plugin.settings.ankiDeck).onChange(async (value) => {
      this.plugin.settings.ankiDeck = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Anki model (note type)").setDesc("The default model (note type) to use for cards.").addText((text) => text.setPlaceholder("Basic").setValue(this.plugin.settings.ankiModel).onChange(async (value) => {
      this.plugin.settings.ankiModel = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Anki tag").setDesc("The default tag to add to cards.").addText((text) => text.setPlaceholder("blue-star").setValue(this.plugin.settings.ankiTag).onChange(async (value) => {
      this.plugin.settings.ankiTag = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Match mode").setDesc("The mode to use for matching content.").addDropdown((dropdown) => dropdown.addOption("section-subsection", "Section :: Subsection").addOption("heading-paragraph", "Heading :: Paragraph").addOption("multi-subsection", "Multi-Subsection").addOption("multi-subparagraph", "Multi-Subparagraph").addOption("regex", "Regex").addOption("custom-delimiter", "Custom delimiter").addOption("single-delimiter", "Single delimiter").setValue(this.plugin.settings.matchMode).onChange(async (value) => {
      this.plugin.settings.matchMode = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.matchMode === "section-subsection") {
      new import_obsidian.Setting(containerEl).setName("Heading level").setDesc('Select the title level to match for "section-subsection" mode.').addDropdown((dropdown) => dropdown.addOption("1", "Heading 1").addOption("2", "Heading 2").addOption("3", "Heading 3").addOption("4", "Heading 4").addOption("5", "Heading 5").setValue(this.plugin.settings.headingLevel["section-subsection"].toString()).onChange(async (value) => {
        this.plugin.settings.headingLevel["section-subsection"] = parseInt(value);
        this.plugin.settings.currentHeadingLevel = parseInt(value);
        await this.plugin.saveSettings();
      }));
      this.plugin.settings.currentHeadingLevel = this.plugin.settings.headingLevel["section-subsection"];
      this.plugin.saveSettings();
    } else if (this.plugin.settings.matchMode === "heading-paragraph") {
      new import_obsidian.Setting(containerEl).setName("Heading level").setDesc('Select the heading level to match for "heading-paragraph" mode.').addDropdown((dropdown) => dropdown.addOption("1", "Heading 1").addOption("2", "Heading 2").addOption("3", "Heading 3").addOption("4", "Heading 4").addOption("5", "Heading 5").setValue(this.plugin.settings.headingLevel["heading-paragraph"].toString()).onChange(async (value) => {
        this.plugin.settings.headingLevel["heading-paragraph"] = parseInt(value);
        this.plugin.settings.currentHeadingLevel = parseInt(value);
        await this.plugin.saveSettings();
      }));
      this.plugin.settings.currentHeadingLevel = this.plugin.settings.headingLevel["heading-paragraph"];
      this.plugin.saveSettings();
    } else if (this.plugin.settings.matchMode === "multi-subsection") {
      new import_obsidian.Setting(containerEl).setName("Heading level").setDesc('Select the title heading to match for "multi-section" mode.').addDropdown((dropdown) => dropdown.addOption("1", "Heading 1").addOption("2", "Heading 2").addOption("3", "Heading 3").addOption("4", "Heading 4").addOption("5", "Heading 5").setValue(this.plugin.settings.headingLevel["multi-subsection"].toString()).onChange(async (value) => {
        this.plugin.settings.headingLevel["multi-subsection"] = parseInt(value);
        this.plugin.settings.currentHeadingLevel = parseInt(value);
        await this.plugin.saveSettings();
      }));
      this.plugin.settings.currentHeadingLevel = this.plugin.settings.headingLevel["multi-subsection"];
      this.plugin.saveSettings();
    } else if (this.plugin.settings.matchMode === "multi-subparagraph") {
      new import_obsidian.Setting(containerEl).setName("Heading level").setDesc('Select the title heading to match for "multi-paragraph" mode.').addDropdown((dropdown) => dropdown.addOption("1", "Heading 1").addOption("2", "Heading 2").addOption("3", "Heading 3").addOption("4", "Heading 4").addOption("5", "Heading 5").setValue(this.plugin.settings.headingLevel["multi-subparagraph"].toString()).onChange(async (value) => {
        this.plugin.settings.headingLevel["multi-subparagraph"] = parseInt(value);
        this.plugin.settings.currentHeadingLevel = parseInt(value);
        await this.plugin.saveSettings();
      }));
      this.plugin.settings.currentHeadingLevel = this.plugin.settings.headingLevel["multi-subparagraph"];
      this.plugin.saveSettings();
    } else if (this.plugin.settings.matchMode === "regex") {
      new import_obsidian.Setting(containerEl).setName("Regex patterns").setDesc("Add or edit regex patterns.").addButton((button) => {
        button.setButtonText("+").onClick(() => {
          this.plugin.settings.regexPatterns.push({ alias: "", pattern: "", flags: "", enabled: false });
          this.display();
        });
      });
      this.plugin.settings.regexPatterns.forEach((pattern, index) => {
        const patternSetting = new import_obsidian.Setting(containerEl).addText((text) => {
          text.setPlaceholder("Regex pattern").setValue(pattern.pattern).onChange(async (value) => {
            this.plugin.settings.regexPatterns[index].pattern = value;
            await this.plugin.saveSettings();
          });
        }).addText((text) => {
          text.setPlaceholder("Flags").setValue(pattern.flags).onChange(async (value) => {
            this.plugin.settings.regexPatterns[index].flags = value;
            await this.plugin.saveSettings();
          });
          text.inputEl.addClass("blue-star-regex-input-flags");
        }).addText((text) => {
          text.setPlaceholder("Desc").setValue(pattern.alias).onChange(async (value) => {
            this.plugin.settings.regexPatterns[index].alias = value;
            await this.plugin.saveSettings();
          });
          text.inputEl.addClass("blue-star-regex-input-alias");
        }).addToggle((toggle) => {
          toggle.setValue(pattern.enabled).onChange(async (value) => {
            if (value) {
              this.plugin.settings.regexPatterns.forEach((p, i) => {
                this.plugin.settings.regexPatterns[i].enabled = i === index;
              });
            } else {
              this.plugin.settings.regexPatterns[index].enabled = false;
            }
            await this.plugin.saveSettings();
            this.display();
          });
        }).addButton((button) => {
          button.setButtonText("Remove").onClick(() => {
            this.plugin.settings.regexPatterns.splice(index, 1);
            this.display();
          });
        });
      });
    } else if (this.plugin.settings.matchMode === "custom-delimiter") {
      new import_obsidian.Setting(containerEl).setName("Card start delimiter").setDesc("Specify the delimiter to mark the start of a card.").addText((text) => text.setPlaceholder("card start symbol").setValue(this.plugin.settings.customDelimiters.cardStart).onChange(async (value) => {
        this.plugin.settings.customDelimiters.cardStart = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian.Setting(containerEl).setName("Field separator").setDesc("Specify the delimiter to separate fields within a card.").addText((text) => text.setPlaceholder("field separator").setValue(this.plugin.settings.customDelimiters.fieldSeparator).onChange(async (value) => {
        this.plugin.settings.customDelimiters.fieldSeparator = value;
        this.plugin.settings.fieldSeparator = value;
        await this.plugin.saveSettings();
      }));
      this.plugin.settings.fieldSeparator = this.plugin.settings.customDelimiters.fieldSeparator;
      this.plugin.saveSettings();
      new import_obsidian.Setting(containerEl).setName("Card end delimiter").setDesc("Specify the delimiter to mark the end of a card.").addText((text) => text.setPlaceholder("card en symbol").setValue(this.plugin.settings.customDelimiters.cardEnd).onChange(async (value) => {
        this.plugin.settings.customDelimiters.cardEnd = value;
        await this.plugin.saveSettings();
      }));
    } else if (this.plugin.settings.matchMode === "single-delimiter") {
      new import_obsidian.Setting(containerEl).setName("Field separator").setDesc("Specify the delimiter to separate fields within a card.").addText((text) => text.setPlaceholder("field separator").setValue(this.plugin.settings.signleDelimiter.fieldSeparator).onChange(async (value) => {
        this.plugin.settings.signleDelimiter.fieldSeparator = value;
        this.plugin.settings.fieldSeparator = value;
        await this.plugin.saveSettings();
      }));
      this.plugin.settings.fieldSeparator = this.plugin.settings.signleDelimiter.fieldSeparator;
      this.plugin.saveSettings();
    }
    new import_obsidian.Setting(containerEl).setName("Usage Instructions").setDesc("1. You can specify Anki's multi-level decks using ::, for example: Deck::SubDeck");
    const usageHint = containerEl.createEl("p", { text: "2. For usage instructions, please refer to: " });
    usageHint.createEl("a", { href: "https://github.com/Lio5n/blue-star", text: "https://github.com/Lio5n/blue-star" });
    usageHint.addClass("blue-star-usage-instructions");
    const usageHint2 = containerEl.createEl("p", { text: "3. Obsidian_2_Anki is a powerful Obsidian plugin for generating Anki flashcards. Our Regex come from " });
    usageHint2.createEl("a", { href: "https://github.com/ObsidianToAnki/Obsidian_to_Anki/wiki/Regex", text: "Obsidian_2_Anki" });
    usageHint2.addClass("blue-star-usage-instructions");
  }
};

// src/fileReader.ts
var import_obsidian2 = require("obsidian");
async function readCurrentFileContent(app) {
  const activeFile = app.workspace.getActiveFile();
  if (!activeFile) {
    new import_obsidian2.Notice("No active file found");
    return null;
  }
  return await app.vault.read(activeFile);
}

// src/customDelimiterParserStrategy.ts
var CustomDelimiterParserStrategy = class {
  constructor(cardStart, fieldSeparator, cardEnd, allowSingleField, html) {
    this.allowSingleField = allowSingleField;
    this.cardStart = cardStart.trim();
    this.fieldSeparator = fieldSeparator.trim();
    this.cardEnd = cardEnd.trim();
    if (html)
      this.htmlBreak = "<br>";
    else
      this.htmlBreak = "";
  }
  parse(content, config) {
    const cards = [];
    const lines = content.split("\n");
    let currentCard = [];
    let currentFied = "";
    let inCodeBlock = 0;
    let isInCard = false;
    const minFieldsCount = this.allowSingleField ? 1 : 2;
    for (const line of lines) {
      const trimmedLine = line.trim();
      const lineType = lineTypeChecker(trimmedLine);
      if (trimmedLine.startsWith(this.cardStart)) {
        if (currentFied)
          currentCard.push(currentFied);
        if (currentCard.length >= minFieldsCount)
          cards.push(currentCard);
        currentCard = [];
        currentFied = "";
        isInCard = true;
        continue;
      }
      if (!isInCard)
        continue;
      if (trimmedLine.startsWith(this.fieldSeparator)) {
        currentCard.push(currentFied);
        currentFied = "";
        continue;
      }
      if (trimmedLine.startsWith(this.cardEnd)) {
        if (currentFied)
          currentCard.push(currentFied);
        if (currentCard.length >= minFieldsCount)
          cards.push(currentCard);
        currentCard = [];
        currentFied = "";
        isInCard = false;
        continue;
      }
      if (lineType.type == "code-symbol" && !inCodeBlock) {
        inCodeBlock = lineType.codeSymbolNumber ? lineType.codeSymbolNumber : 0;
        if (currentFied)
          currentFied += "\n" + this.htmlBreak + line;
        else
          currentFied = line;
        continue;
      }
      if (inCodeBlock) {
        if (lineType.type == "code-symbol" && lineType.codeSymbolType == "can-be-end" && inCodeBlock <= lineType.codeSymbolNumber)
          inCodeBlock = 0;
        currentFied += "\n" + line;
        continue;
      }
      if (currentFied)
        currentFied += "\n" + this.htmlBreak + line;
      else
        currentFied = line;
    }
    if (currentFied.replace(/\n+$/, ""))
      currentCard.push(currentFied);
    if (currentCard.length >= minFieldsCount)
      cards.push(currentCard);
    return cards;
  }
};

// src/customSingleDelimiterParserStrategy.ts
var CustomSingleDelimiterParserStrategy = class {
  constructor(fieldSeparator, allowSingleField, html) {
    this.allowSingleField = allowSingleField;
    this.fieldSeparator = fieldSeparator.trim();
    if (html)
      this.htmlBreak = "<br>";
    else
      this.htmlBreak = "";
  }
  parse(content, config) {
    const cards = [];
    const lines = content.split("\n");
    let currentCard = [];
    let currentFied = "";
    let inCodeBlock = 0;
    let isInCard = false;
    const minFieldsCount = this.allowSingleField ? 1 : 2;
    for (const line of lines) {
      const trimmedLine = line.trim();
      const lineType = lineTypeChecker(trimmedLine);
      if (lineType.type == "code-symbol" && !inCodeBlock) {
        inCodeBlock = lineType.codeSymbolNumber ? lineType.codeSymbolNumber : 0;
        if (currentFied)
          currentFied += "\n" + this.htmlBreak + line;
        else
          currentFied = line;
        continue;
      }
      if (inCodeBlock) {
        if (lineType.type == "code-symbol" && lineType.codeSymbolType == "can-be-end" && inCodeBlock <= lineType.codeSymbolNumber)
          inCodeBlock = 0;
        currentFied += "\n" + line;
        continue;
      }
      if (!trimmedLine) {
        if (currentFied)
          currentCard.push(currentFied);
        if (currentCard.length >= minFieldsCount && isInCard)
          cards.push(currentCard);
        currentCard = [];
        currentFied = "";
        isInCard = false;
        continue;
      }
      if (trimmedLine.startsWith(this.fieldSeparator)) {
        if (currentCard.length == 0 && currentFied)
          currentCard.push(currentFied);
        else
          currentCard.push(currentFied);
        currentFied = "";
        isInCard = true;
        continue;
      }
      if (currentFied)
        currentFied += "\n" + this.htmlBreak + line;
      else
        currentFied = line;
    }
    if (currentFied)
      currentCard.push(currentFied);
    if (currentCard.length >= minFieldsCount && isInCard)
      cards.push(currentCard);
    return cards;
  }
};

// src/headingParagraphParserStrategy.ts
var HeadingParagraphParserStrategy = class {
  constructor(headingLevel, allowSingleField, html) {
    this.headingLevel = headingLevel;
    this.allowSingleField = allowSingleField;
    if (html)
      this.htmlBreak = "<br>";
    else
      this.htmlBreak = "";
  }
  parse(content, config) {
    const cards = [];
    const lines = content.split("\n");
    let currentCard = [];
    let currentFied = "";
    let inCodeBlock = 0;
    let isInCard = false;
    const minFieldsCount = this.allowSingleField ? 1 : 2;
    for (const line of lines) {
      const trimmedLine = line.trimEnd();
      const lineType = lineTypeChecker(line.trim());
      if (lineType.type == "heading" && !inCodeBlock) {
        let headingLevel = lineType.headingLevel ? lineType.headingLevel : 0;
        if (headingLevel == this.headingLevel) {
          if (currentFied)
            currentCard.push(currentFied);
          if (currentCard.length >= minFieldsCount)
            cards.push(currentCard);
          currentCard = [];
          currentCard.push(line);
          currentFied = "";
          isInCard = true;
          continue;
        }
        if (!isInCard)
          continue;
        if (headingLevel < this.headingLevel) {
          if (currentFied)
            currentCard.push(currentFied);
          if (currentCard.length >= minFieldsCount)
            cards.push(currentCard);
          currentCard = [];
          currentFied = "";
          isInCard = false;
          continue;
        }
        currentFied += "\n" + this.htmlBreak + line;
        continue;
      }
      if (!isInCard)
        continue;
      if (lineType.type == "code-symbol" && !inCodeBlock) {
        inCodeBlock = lineType.codeSymbolNumber ? lineType.codeSymbolNumber : 0;
        if (currentFied)
          currentFied += "\n" + this.htmlBreak + line;
        else
          currentFied = line;
        continue;
      }
      if (inCodeBlock) {
        if (lineType.type == "code-symbol" && lineType.codeSymbolType == "can-be-end" && inCodeBlock <= lineType.codeSymbolNumber)
          inCodeBlock = 0;
        currentFied += "\n" + line;
        continue;
      }
      if (currentFied)
        currentFied += "\n" + this.htmlBreak + line;
      else
        currentFied = line;
    }
    if (currentFied.replace(/\n+$/, ""))
      currentCard.push(currentFied);
    if (currentCard.length >= minFieldsCount)
      cards.push(currentCard);
    return cards;
  }
};

// src/multiSubparagraphParserStrategy.ts
var MultiSubparagraphParserStrategy = class {
  constructor(headingLevel, allowSingleField, html) {
    this.headingLevel = headingLevel;
    this.allowSingleField = allowSingleField;
    if (html)
      this.htmlBreak = "<br>";
    else
      this.htmlBreak = "";
  }
  parse(content, config) {
    const cards = [];
    const lines = content.split("\n");
    let currentCard = [];
    let currentFied = "";
    let inCodeBlock = 0;
    let isInCard = false;
    let isInField = false;
    const minFieldsCount = this.allowSingleField ? 1 : 2;
    for (const line of lines) {
      const trimmedLine = line.trimEnd();
      const lineType = lineTypeChecker(line.trim());
      if (lineType.type == "heading" && !inCodeBlock) {
        let headingLevel = lineType.headingLevel ? lineType.headingLevel : 0;
        if (headingLevel <= this.headingLevel) {
          if (currentFied)
            currentCard.push(currentFied);
          if (currentCard.length >= minFieldsCount)
            cards.push(currentCard);
          currentCard = [];
          currentFied = "";
          isInCard = true;
          isInField = false;
          continue;
        }
        if (!isInCard)
          continue;
        if (headingLevel == this.headingLevel + 1) {
          if (isInField)
            currentCard.push(currentFied);
          currentFied = "";
          isInField = true;
          continue;
        }
        if (!isInField)
          continue;
        if (currentFied)
          currentFied += this.htmlBreak + "\n" + line;
        else
          currentFied = line;
        continue;
      }
      if (!isInCard || !isInField)
        continue;
      if (lineType.type == "code-symbol" && !inCodeBlock) {
        inCodeBlock = lineType.codeSymbolNumber ? lineType.codeSymbolNumber : 0;
        if (currentFied)
          currentFied += "\n" + this.htmlBreak + line;
        else
          currentFied = line;
        continue;
      }
      if (inCodeBlock) {
        if (lineType.type == "code-symbol" && lineType.codeSymbolType == "can-be-end" && inCodeBlock <= lineType.codeSymbolNumber)
          inCodeBlock = 0;
        currentFied += "\n" + line;
        continue;
      }
      if (currentFied)
        currentFied += "\n" + this.htmlBreak + line;
      else
        currentFied = line;
    }
    if (currentFied.replace(/\n+$/, ""))
      currentCard.push(currentFied);
    if (currentCard.length >= minFieldsCount)
      cards.push(currentCard);
    return cards;
  }
};

// src/multiSubsectionParserStrategy.ts
var MultiSubsectionParserStrategy = class {
  constructor(headingLevel, allowSingleField, html) {
    this.headingLevel = headingLevel;
    this.allowSingleField = allowSingleField;
    if (html)
      this.htmlBreak = "<br>";
    else
      this.htmlBreak = "";
  }
  parse(content, config) {
    const cards = [];
    const lines = content.split("\n");
    let currentCard = [];
    let currentFied = "";
    let inCodeBlock = 0;
    let isInCard = false;
    let isInField = false;
    const minFieldsCount = this.allowSingleField ? 1 : 2;
    for (const line of lines) {
      const trimmedLine = line.trimEnd();
      const lineType = lineTypeChecker(line.trim());
      if (lineType.type == "heading" && !inCodeBlock) {
        let headingLevel = lineType.headingLevel ? lineType.headingLevel : 0;
        if (headingLevel <= this.headingLevel) {
          if (currentFied)
            currentCard.push(currentFied);
          if (currentCard.length >= minFieldsCount)
            cards.push(currentCard);
          currentCard = [];
          currentFied = "";
          isInCard = true;
          isInField = false;
          continue;
        }
        if (!isInCard)
          continue;
        if (headingLevel == this.headingLevel + 1) {
          if (isInField)
            currentCard.push(currentFied);
          currentFied = line;
          isInField = true;
          continue;
        }
        if (!isInField)
          continue;
        currentFied += "\n" + this.htmlBreak + line;
        continue;
      }
      if (!isInCard || !isInField)
        continue;
      if (lineType.type == "code-symbol" && !inCodeBlock) {
        inCodeBlock = lineType.codeSymbolNumber ? lineType.codeSymbolNumber : 0;
        currentFied += "\n" + this.htmlBreak + line;
        continue;
      }
      if (inCodeBlock) {
        if (lineType.type == "code-symbol" && lineType.codeSymbolType == "can-be-end" && inCodeBlock <= lineType.codeSymbolNumber)
          inCodeBlock = 0;
        currentFied += "\n" + line;
        continue;
      }
      currentFied += "\n" + this.htmlBreak + line;
    }
    if (currentFied)
      currentCard.push(currentFied);
    if (currentCard.length >= minFieldsCount)
      cards.push(currentCard);
    return cards;
  }
};

// src/ui.ts
var import_obsidian3 = require("obsidian");
var import_obsidian4 = require("obsidian");
function showNotice(message) {
  new import_obsidian3.Notice(message);
}
var InputPromptModal = class extends import_obsidian4.Modal {
  constructor(app, message, onSubmit) {
    super(app);
    this.message = message;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: this.message });
    const button = contentEl.createEl("button", { text: "Confirm" });
    button.addEventListener("click", () => {
      this.onSubmit();
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/regexParserStrategy.ts
var RegexParserStrategy = class {
  constructor(pattern, flags, allowSingleField, html) {
    try {
      this.regex = new RegExp(pattern, flags || "g");
    } catch (error) {
      showNotice(error);
      throw new Error(error);
    }
    this.allowSingleField = allowSingleField;
    if (html)
      this.htmlBreak = "<br>";
    else
      this.htmlBreak = "";
  }
  parse(content, config) {
    const minFieldsCount = this.allowSingleField ? 1 : 2;
    const matches = [...content.matchAll(this.regex)];
    const cards = matches.map((match, index) => {
      const card = [];
      for (let i = 1; i < match.length; i++)
        if (this.htmlBreak) {
          const lines = match[i].split("\n");
          let inCodeBlock = 0;
          let currentFied = "";
          for (const line of lines) {
            const trimedLine = line.trim();
            const lineType = lineTypeChecker(trimedLine);
            if (lineType.type == "code-symbol" && !inCodeBlock) {
              inCodeBlock = lineType.codeSymbolNumber ? lineType.codeSymbolNumber : 0;
              if (currentFied)
                currentFied += "\n" + this.htmlBreak + line;
              else
                currentFied = line;
              continue;
            }
            if (inCodeBlock) {
              if (lineType.type == "code-symbol" && lineType.codeSymbolType == "can-be-end" && inCodeBlock <= lineType.codeSymbolNumber)
                inCodeBlock = 0;
              currentFied += "\n" + line;
              continue;
            }
            if (currentFied)
              currentFied += "\n" + this.htmlBreak + line;
            else
              currentFied = line;
          }
          card.push(currentFied);
        } else
          card.push(match[i]);
      if (card.length >= minFieldsCount)
        return card;
      else
        return [];
    });
    return cards;
  }
};

// src/sectionSubsectionParserStrategy.ts
var SectionSubSectionParserStrategy = class {
  constructor(headingLevel, allowSingleField, html) {
    this.headingLevel = headingLevel;
    this.allowSingleField = allowSingleField;
    if (html)
      this.htmlBreak = "<br>";
    else
      this.htmlBreak = "";
  }
  parse(content, config) {
    const cards = [];
    const lines = content.split("\n");
    let currentCard = [];
    let currentFied = "";
    let inCodeBlock = 0;
    let isInCard = false;
    let isFront = false;
    const minFieldsCount = this.allowSingleField ? 1 : 2;
    for (const line of lines) {
      const trimmedLine = line.trimEnd();
      const lineType = lineTypeChecker(line.trim());
      if (lineType.type == "heading" && !inCodeBlock) {
        let headingLevel = lineType.headingLevel ? lineType.headingLevel : 0;
        if (headingLevel == this.headingLevel) {
          if (currentFied)
            currentCard.push(currentFied);
          if (currentCard.length >= minFieldsCount)
            cards.push(currentCard);
          currentCard = [];
          currentFied = line;
          isFront = true;
          isInCard = true;
          continue;
        }
        if (!isInCard)
          continue;
        if (headingLevel < this.headingLevel) {
          if (currentFied)
            currentCard.push(currentFied);
          if (currentCard.length >= minFieldsCount)
            cards.push(currentCard);
          currentCard = [];
          currentFied = "";
          isFront = false;
          isInCard = false;
          continue;
        }
        if (isFront) {
          currentCard.push(currentFied);
          currentFied = line;
          isFront = false;
          continue;
        }
        currentFied += "\n" + this.htmlBreak + line;
        continue;
      }
      if (!isInCard)
        continue;
      if (lineType.type == "code-symbol" && !inCodeBlock) {
        inCodeBlock = lineType.codeSymbolNumber ? lineType.codeSymbolNumber : 0;
        currentFied += "\n" + this.htmlBreak + line;
        continue;
      }
      if (inCodeBlock) {
        if (lineType.type == "code-symbol" && lineType.codeSymbolType == "can-be-end" && inCodeBlock <= lineType.codeSymbolNumber)
          inCodeBlock = 0;
        currentFied += "\n" + line;
        continue;
      }
      currentFied += "\n" + this.htmlBreak + line;
    }
    if (currentFied)
      currentCard.push(currentFied);
    if (currentCard.length >= minFieldsCount)
      cards.push(currentCard);
    return cards;
  }
};

// src/parser.ts
var Parser = class {
  constructor(parserType, config) {
    if (parserType === "regex") {
      if (!config.regex) {
        showNotice('Regex pattern is required for "Regex" parser strategy');
        throw new Error("Regex pattern is required for RegexParserStrategy");
      }
      this.strategy = new RegexParserStrategy(config.regex, config.flags || "g", config.single, config.html);
    } else if (parserType === "section-subsection") {
      if (config.heading === void 0 || !config.heading || config.heading <= 0) {
        showNotice('Heading level is required for "Section::Subsectioin" parser strategy');
        throw new Error("Heading level is required for SectionSubsectioinParserStrategy");
      }
      this.strategy = new SectionSubSectionParserStrategy(config.heading, config.single, config.html);
    } else if (parserType === "heading-paragraph") {
      if (config.heading === void 0 || !config.heading || config.heading <= 0) {
        showNotice('Heading level is required for "Heading::Paragraph" parser strategy');
        throw new Error("Heading level is required for HeadingParagraphParserStrategy");
      }
      this.strategy = new HeadingParagraphParserStrategy(config.heading, config.single, config.html);
    } else if (parserType === "multi-subsection") {
      if (config.heading === void 0 || !config.heading || config.heading <= 0) {
        showNotice('Heading level is required for "Multi-Subsection" parser strategy');
        throw new Error("Heading level is required for MultiSubsectionParserStrategy");
      }
      this.strategy = new MultiSubsectionParserStrategy(config.heading, config.single, config.html);
    } else if (parserType === "multi-subparagraph") {
      if (config.heading === void 0 || !config.heading || config.heading <= 0) {
        showNotice('Heading level is required for "Multi-Subparagraph" parser strategy');
        throw new Error("Heading level is required for MultiSubparagraphParserStrategy");
      }
      this.strategy = new MultiSubparagraphParserStrategy(config.heading, config.single, config.html);
    } else if (parserType === "custom-delimiter") {
      if (!config.start.trim() || !config.separator.trim() || !config.end.trim()) {
        showNotice('Custom delimiter is required for "Custom delimiter" parser strategy');
        throw new Error("Custom delimiter is required for CustomDelimiterParserStrategy");
      }
      this.strategy = new CustomDelimiterParserStrategy(config.start, config.separator, config.end, config.single, config.html);
    } else if (parserType === "single-delimiter") {
      if (!config.separator.trim()) {
        showNotice('Custom delimiter is required for "Single delimiter" parser strategy');
        throw new Error("Custom delimiter is required for CustomSingleDelimiterParserStrategy");
      }
      this.strategy = new CustomSingleDelimiterParserStrategy(config.separator, config.single, config.html);
    } else {
      showNotice(`Unknown parser type: ${parserType}`);
      throw new Error(`Unknown parser type: ${parserType}`);
    }
  }
  parse(content, config) {
    return this.strategy.parse(content, config);
  }
  static extractConfig(content) {
    let configMatch = content.match(/```anki\s+([\s\S]*?)\s+```/);
    if (!configMatch)
      configMatch = content.match(/```\s*\nanki\s*([\s\S]*?)\s+```/);
    if (!configMatch)
      return null;
    const configLines = configMatch[1].split("\n").map((line) => line.trim());
    const config = {};
    for (const line of configLines) {
      const [key, ...valueParts] = line.split(/[:ï¼š]/);
      const value = valueParts.join(":").trim();
      if (key && value) {
        const lowerKey = key.toLowerCase();
        if (lowerKey === "deck")
          config.deck = value;
        if (lowerKey === "anki-deck")
          config.deck = value;
        if (lowerKey === "model")
          config.model = value;
        if (lowerKey === "anki-model")
          config.model = value;
        if (lowerKey === "note-type")
          config.model = value;
        if (lowerKey === "anki-note-type")
          config.model = value;
        if (lowerKey === "tag")
          config.tag = value;
        if (lowerKey === "anki-tag")
          config.tag = value;
        if (lowerKey === "card-tag")
          config.tag = value;
        if (lowerKey === "anki-card-tag")
          config.tag = value;
        if (lowerKey === "parser")
          config.parser = value;
        if (lowerKey === "parser-mode")
          config.parser = value;
        if (lowerKey === "match")
          config.parser = value;
        if (lowerKey === "match-mode")
          config.parser = value;
        if (lowerKey === "regex")
          config.regex = value;
        if (lowerKey === "flags")
          config.flags = value;
        if (lowerKey === "regex-flags")
          config.flags = value;
        if (lowerKey === "flag")
          config.flags = value;
        if (lowerKey === "regex-flag")
          config.flags = value;
        if (lowerKey === "heading")
          config.heading = parseInt(value, 10);
        if (lowerKey === "heading-level")
          config.heading = parseInt(value, 10);
        if (lowerKey === "update")
          config.update = this.parseBoolean(value);
        if (lowerKey === "upsert")
          config.update = this.parseBoolean(value);
        if (lowerKey === "single")
          config.single = this.parseBoolean(value);
        if (lowerKey === "single-field")
          config.single = this.parseBoolean(value);
        if (lowerKey === "html")
          config.html = this.parseBoolean(value);
        if (lowerKey === "html-break")
          config.html = this.parseBoolean(value);
        if (lowerKey === "html-line-break")
          config.html = this.parseBoolean(value);
        if (lowerKey === "card-start")
          config.start = value;
        if (lowerKey === "field")
          config.separator = value;
        if (lowerKey === "field-split")
          config.separator = value;
        if (lowerKey === "field-separator")
          config.separator = value;
        if (lowerKey === "card-end")
          config.end = value;
        if (lowerKey === "ignore")
          config.ignore = this.parseBoolean(value);
      }
    }
    return config;
  }
  static parseBoolean(value) {
    const normalizedValue = value.trim().toLowerCase();
    return ["true", "1", "yes", "y"].includes(normalizedValue);
  }
};
function lineTypeChecker(line) {
  if (line.startsWith("```")) {
    let n = 0;
    for (let i = 0; i < line.length; i++) {
      if (line[i] === "`") {
        n++;
      }
    }
    if (line.startsWith("    ") || !line.startsWith("`".repeat(n)))
      return { type: "content" };
    else if (line != "`".repeat(line.length)) {
      return { type: "code-symbol", codeSymbolType: "only-begin", codeSymbolNumber: n };
    } else
      return { type: "code-symbol", codeSymbolType: "can-be-end", codeSymbolNumber: n };
  } else if (line.startsWith("#")) {
    const headingSymbol = line.split(" ")[0];
    if (headingSymbol != "#".repeat(headingSymbol.length))
      return { type: "content" };
    else
      return { type: "heading", headingLevel: headingSymbol.length };
  } else
    return { type: "content" };
}

// src/utils.ts
async function request(action, params = {}) {
  const response = await fetch("http://localhost:8765", {
    method: "POST",
    body: JSON.stringify({
      action,
      version: 6,
      params
    }),
    headers: {
      "Content-Type": "application/json"
    }
  });
  const data = await response.json();
  if (data.error) {
    throw new Error(data.error);
  }
  return data.result;
}

// src/ankiConnector.ts
var import_obsidian5 = require("obsidian");
async function getImageBase64(app, imagePath) {
  var _a;
  try {
    const imageFile = app.vault.getAbstractFileByPath(imagePath);
    if (imageFile instanceof import_obsidian5.TFile) {
      const arrayBuffer = await app.vault.readBinary(imageFile);
      const base64 = arrayBufferToBase64(arrayBuffer);
      const extension = ((_a = imagePath.split(".").pop()) == null ? void 0 : _a.toLowerCase()) || "png";
      return `data:image/${extension};base64,${base64}`;
    }
  } catch (error) {
  }
  return "";
}
function arrayBufferToBase64(buffer) {
  let binary = "";
  const bytes = new Uint8Array(buffer);
  for (let i = 0; i < bytes.byteLength; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return window.btoa(binary);
}
function isImageFile(filename) {
  var _a;
  const imageExtensions = ["png", "jpg", "jpeg", "gif", "bmp", "webp", "svg"];
  const extension = (_a = filename.split(".").pop()) == null ? void 0 : _a.toLowerCase();
  return extension ? imageExtensions.includes(extension) : false;
}
function decodeImagePath(path) {
  try {
    return decodeURIComponent(path);
  } catch (error) {
    return path;
  }
}
function getAttachmentFolderPath(app, currentFileDir) {
  const attachmentFolderPath = app.vault.getConfig("attachmentFolderPath");
  if (attachmentFolderPath && !attachmentFolderPath.startsWith("./")) {
    return attachmentFolderPath;
  }
  if (attachmentFolderPath && attachmentFolderPath.startsWith("./")) {
    return `${currentFileDir}/${attachmentFolderPath.slice(2)}`;
  }
  return "";
}
function removeAnkiCodeBlocks(content) {
  const ankiCodeBlockRegex = /^```anki[\s\S]*?^```\s*$/gm;
  const multiLineAnkiCodeBlockRegex = /^```\s*\nanki[\s\S]*?^```\s*$/gm;
  return content.replace(ankiCodeBlockRegex, "").replace(multiLineAnkiCodeBlockRegex, "");
}
async function processContent(app, content, filePath, settings) {
  let processedContent = removeAnkiCodeBlocks(content);
  const currentFileDir = filePath.substring(0, filePath.lastIndexOf("/"));
  const attachmentFolder = getAttachmentFolderPath(app, currentFileDir);
  const imageRegex = /!\[(.*?)\]\((.*?)(?:\s+"(.*?)")?\)|!\[\[(.*?)(?:\s*\|\s*(\d+)(?:\s*x\s*(\d+))?)?\]\]/g;
  let match;
  while ((match = imageRegex.exec(content)) !== null) {
    const [fullMatch, mdAlt, mdPath, mdTitle, obsidianPath, obsidianWidth, obsidianHeight] = match;
    const imagePath = obsidianPath || mdPath;
    if (!imagePath)
      continue;
    const decodedPath = decodeImagePath(imagePath);
    if (!isImageFile(decodedPath)) {
      continue;
    }
    const cleanPath = decodedPath.replace(/^["'](.+)["']$/, "$1");
    const possiblePaths = [
      cleanPath,
      // Original path
      `${currentFileDir}/${cleanPath}`,
      // Relative to current file
      cleanPath.startsWith("/") ? cleanPath.slice(1) : cleanPath,
      // Remove leading slash if exists
      attachmentFolder ? `${attachmentFolder}/${cleanPath}` : cleanPath
      // Check in attachment folder
    ];
    let imageFile = null;
    let workingPath = null;
    for (const path of possiblePaths) {
      try {
        const file = app.vault.getAbstractFileByPath(path);
        if (file instanceof import_obsidian5.TFile && isImageFile(file.path)) {
          imageFile = file;
          workingPath = path;
          break;
        }
      } catch (error) {
      }
    }
    if (imageFile && workingPath) {
      try {
        const base64Data = await getImageBase64(app, workingPath);
        if (base64Data) {
          processedContent = processedContent.replace(
            fullMatch,
            `<img src="${base64Data}">`
          );
        }
      } catch (error) {
      }
    }
  }
  return processedContent;
}
async function createAnkiCards(parsedContent, settings, fileName, app) {
  const modelExists = await checkAnkiModelExists(settings.model);
  if (!modelExists) {
    showNotice(`Anki model "${settings.model}" does not exist.`);
    return;
  }
  await checkOrCreateDeck(settings.deck);
  const modelFields = await getModelFields(settings.model);
  const processedNotes = await Promise.all(parsedContent.map(async (content) => {
    const fields = {};
    for (let i = 0; i < modelFields.length; i++) {
      const fieldContent = content[i] || "";
      fields[modelFields[i]] = await processContent(app, fieldContent, fileName, settings);
    }
    return {
      deckName: settings.deck,
      modelName: settings.model,
      fields,
      tags: [settings.tag]
    };
  }));
  if (settings.update) {
    await upsertAnkiNotes(processedNotes, fileName);
  } else {
    await addAnkiNotes(processedNotes, fileName);
  }
}
async function addAnkiNotes(notes, fileName) {
  let addedCount = 0;
  let skippedCount = 0;
  for (const note of notes) {
    try {
      const response = await request("addNote", { note });
      if (response) {
        addedCount++;
      }
    } catch (error) {
      if (error.message.includes("duplicate")) {
        skippedCount++;
      } else {
        throw error;
      }
    }
  }
  showNotice(`Added ${addedCount} Anki cards and
Skipped ${skippedCount} Anki cards
from file "${fileName}".`);
}
async function upsertAnkiNotes(notes, fileName) {
  let addedCount = 0;
  let updatedCount = 0;
  let skipCount = 0;
  const failedNotes = [];
  for (const note of notes) {
    try {
      const response = await request("addNote", { note });
      if (response) {
        addedCount++;
      }
    } catch (error) {
      if (error.message.includes("duplicate")) {
        failedNotes.push(note);
      } else {
        throw error;
      }
    }
  }
  if (failedNotes.length > 0) {
    const firstFieldKey = Object.keys(failedNotes[0].fields)[0];
    const queries = failedNotes.map((note) => `"${firstFieldKey}:${note.fields[firstFieldKey]}"`);
    const noteIdsResponse = await request("findNotes", { query: queries.join(" OR ") });
    if (noteIdsResponse.length > 0) {
      const notesInfo = await request("notesInfo", { notes: noteIdsResponse });
      const notesToUpdate = [];
      notesInfo.forEach((noteInfo, index) => {
        if (index < failedNotes.length) {
          const failedNote = failedNotes[index];
          const fieldsDifferent = Object.keys(failedNote.fields).some(
            (key) => failedNote.fields[key] !== noteInfo.fields[key].value
          );
          if (fieldsDifferent) {
            notesToUpdate.push({
              id: noteInfo.noteId,
              fields: failedNote.fields,
              tags: failedNote.tags
            });
          } else {
            skipCount++;
          }
        }
      });
      if (notesToUpdate.length > 0) {
        for (const note of notesToUpdate) {
          try {
            await request("updateNoteFields", { note });
            updatedCount++;
          } catch (error) {
            skipCount++;
          }
        }
      }
    }
  }
  showNotice(`Added ${addedCount} Anki cards
Updated ${updatedCount} Anki cards
Skipped ${skipCount} Anki cards
from file "${fileName}".`);
}
async function checkAnkiModelExists(modelName) {
  const response = await request("modelNames");
  return response.includes(modelName);
}
async function checkOrCreateDeck(deckName) {
  const response = await request("deckNames");
  if (!response.includes(deckName)) {
    await request("createDeck", { deck: deckName });
  }
}
async function getModelFields(modelName) {
  const response = await request("modelFieldNames", { modelName });
  return response;
}

// src/main.ts
var BlueStar = class extends import_obsidian6.Plugin {
  constructor() {
    super(...arguments);
    this.isProcessingCurrentFile = false;
    this.isProcessingDirectory = false;
  }
  async onload() {
    console.log("Loading Blue Star plugin");
    await this.loadSettings();
    this.currentFileIconEl = this.addRibbonIcon("star", "Create Anki cards from current file", async () => {
      if (!this.isProcessingCurrentFile && !this.isProcessingDirectory) {
        await this.createAnkiCardsFromCurrentFile();
      } else {
        showNotice("Generating Anki flashcards...");
      }
    });
    this.directoryIconEl = this.addRibbonIcon("moon-star", "Create Anki cards from directory", async () => {
      if (!this.isProcessingCurrentFile && !this.isProcessingDirectory) {
        await this.createAnkiCardsFromDirectory();
      } else {
        showNotice("Generating Anki flashcards...");
      }
    });
    this.addCommand({
      id: "create-anki-cards-from-current-file",
      name: "Create Anki cards from current file",
      callback: async () => {
        if (!this.isProcessingCurrentFile && !this.isProcessingDirectory) {
          await this.createAnkiCardsFromCurrentFile();
        } else {
          showNotice("Generating Anki flashcards...");
        }
      }
    });
    this.addCommand({
      id: "create-anki-cards-from-directory",
      name: "Create Anki cards from directory",
      callback: async () => {
        if (!this.isProcessingCurrentFile && !this.isProcessingDirectory) {
          await this.createAnkiCardsFromDirectory();
        } else {
          showNotice("Generating Anki flashcards...");
        }
      }
    });
    this.addSettingTab(new BlueStarSettingTab(this.app, this));
  }
  onunload() {
    console.log("Unloading Blue Star plugin");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    const defaultPatterns = DEFAULT_SETTINGS.regexPatterns;
    defaultPatterns.forEach((defaultPattern) => {
      if (!this.settings.regexPatterns.some((p) => p.alias === defaultPattern.alias)) {
        this.settings.regexPatterns.push(defaultPattern);
      }
    });
    await this.saveSettings();
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async createAnkiCardsFromCurrentFile() {
    this.isProcessingCurrentFile = true;
    this.toggleRibbonIcon("current-file", "loading");
    try {
      showNotice("Generating flashcards...\n\nPlease do not click repeatedly or execute the command multiple times.");
      const fileContent = await readCurrentFileContent(this.app);
      const activeFile = this.app.workspace.getActiveFile();
      if (!fileContent || !activeFile)
        return;
      const fileConfig = Parser.extractConfig(fileContent) || {};
      const config = { ...this.getDefaultConfig(), ...fileConfig };
      let parser = new Parser(config.parser.toLowerCase(), config);
      const parsedContent = parser.parse(fileContent, config);
      if (parsedContent.length === 0) {
        showNotice(`No content matched the pattern in file "${activeFile.name}".`);
        return;
      }
      try {
        await createAnkiCards(
          parsedContent,
          { ...config, updateExisting: config.update },
          activeFile.path,
          this.app
        );
      } catch (error) {
        showNotice(`Error: ${error.message}

When creating Anki cards from file "${activeFile.name}".`);
      }
    } finally {
      this.toggleRibbonIcon("current-file", "done");
      this.isProcessingCurrentFile = false;
    }
  }
  async createAnkiCardsFromDirectory() {
    var _a;
    this.isProcessingDirectory = true;
    this.toggleRibbonIcon("directory", "loading");
    try {
      showNotice("Generating flashcards...\n\nPlease do not click repeatedly or execute the command multiple times.");
      const folderPath = this.settings.directoryPath;
      if (!folderPath || !folderPath.trim()) {
        showNotice("Directory path must be specified.");
        new InputPromptModal(this.app, "Directory path must be specified.", () => {
        }).open();
        return;
      }
      const folder = this.app.vault.getAbstractFileByPath(folderPath);
      if (!(folder instanceof import_obsidian6.TFolder)) {
        showNotice("Invalid directory path.");
        new InputPromptModal(this.app, "Invalid directory path.", () => {
        }).open();
        return;
      }
      const files = this.getFilesFromFolder(folder);
      const totalFiles = files.length;
      let processedFiles = 0;
      let skippedFiles = 0;
      let includeTag = this.settings.includeFileTag.trim();
      if (includeTag.startsWith("#")) {
        includeTag = includeTag.slice(1);
      }
      let excludedTag = this.settings.excludeFileTag.trim();
      if (excludedTag.startsWith("#")) {
        excludedTag = excludedTag.slice(1);
      }
      for (const file of files) {
        const fileContent = await this.app.vault.read(file);
        const frontMatter = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
        const tags = (frontMatter == null ? void 0 : frontMatter.tags) || [];
        if (includeTag && !tags.includes(includeTag)) {
          continue;
        }
        if (excludedTag && tags.includes(excludedTag)) {
          continue;
        }
        const fileConfig = Parser.extractConfig(fileContent) || {};
        const config = { ...this.getDefaultConfig(), ...fileConfig };
        if (config.ignore) {
          continue;
        }
        let parser = new Parser(config.parser.toLowerCase(), config);
        const parsedContent = parser.parse(fileContent, config);
        if (parsedContent.length > 0) {
          try {
            await createAnkiCards(
              parsedContent,
              { ...config, updateExisting: config.update },
              file.path,
              this.app
            );
            processedFiles++;
          } catch (error) {
            showNotice(`Error creating Anki cards from file "${file.name}": ${error.message}`);
          }
        } else {
          skippedFiles++;
        }
      }
      showNotice(`Processing completed. Total files: ${totalFiles}, Processed files: ${processedFiles}, Skipped files: ${skippedFiles}.`);
    } finally {
      this.toggleRibbonIcon("directory", "done");
      this.isProcessingDirectory = false;
    }
  }
  getFilesFromFolder(folder) {
    const files = [];
    for (const child of folder.children) {
      if (child instanceof import_obsidian6.TFile) {
        files.push(child);
      } else if (child instanceof import_obsidian6.TFolder) {
        files.push(...this.getFilesFromFolder(child));
      }
    }
    return files;
  }
  getDefaultConfig() {
    var _a, _b;
    return {
      deck: this.settings.ankiDeck,
      model: this.settings.ankiModel,
      tag: this.settings.ankiTag,
      parser: this.settings.matchMode,
      regex: ((_a = this.settings.regexPatterns.find((pattern) => pattern.enabled)) == null ? void 0 : _a.pattern) || "",
      flags: ((_b = this.settings.regexPatterns.find((pattern) => pattern.enabled)) == null ? void 0 : _b.flags) || "g",
      heading: this.settings.currentHeadingLevel || 2,
      update: this.settings.updateExisting,
      single: this.settings.allowSingleField,
      html: this.settings.htmlLineBreak,
      start: this.settings.customDelimiters.cardStart,
      separator: this.settings.fieldSeparator,
      end: this.settings.customDelimiters.cardEnd,
      ignore: false
    };
  }
  toggleRibbonIcon(type, state) {
    if (type === "current-file") {
      (0, import_obsidian6.setIcon)(this.currentFileIconEl, state === "loading" ? "star-half" : "star");
    } else {
      (0, import_obsidian6.setIcon)(this.directoryIconEl, state === "loading" ? "moon" : "moon-star");
    }
  }
};

/* nosourcemap */