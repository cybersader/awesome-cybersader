/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/obsidian-daily-notes-interface/dist/main.js
var require_main = __commonJS({
  "node_modules/obsidian-daily-notes-interface/dist/main.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var obsidian = require("obsidian");
    var DEFAULT_DAILY_NOTE_FORMAT = "YYYY-MM-DD";
    var DEFAULT_WEEKLY_NOTE_FORMAT = "gggg-[W]ww";
    var DEFAULT_MONTHLY_NOTE_FORMAT = "YYYY-MM";
    var DEFAULT_QUARTERLY_NOTE_FORMAT = "YYYY-[Q]Q";
    var DEFAULT_YEARLY_NOTE_FORMAT = "YYYY";
    function shouldUsePeriodicNotesSettings(periodicity) {
      var _a, _b;
      const periodicNotes = window.app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a[periodicity]) == null ? void 0 : _b.enabled);
    }
    function getDailyNoteSettings() {
      var _a, _b, _c, _d;
      try {
        const { internalPlugins, plugins } = window.app;
        if (shouldUsePeriodicNotesSettings("daily")) {
          const { format: format2, folder: folder2, template: template2 } = ((_b = (_a = plugins.getPlugin("periodic-notes")) == null ? void 0 : _a.settings) == null ? void 0 : _b.daily) || {};
          return {
            format: format2 || DEFAULT_DAILY_NOTE_FORMAT,
            folder: (folder2 == null ? void 0 : folder2.trim()) || "",
            template: (template2 == null ? void 0 : template2.trim()) || ""
          };
        }
        const { folder, format, template } = ((_d = (_c = internalPlugins.getPluginById("daily-notes")) == null ? void 0 : _c.instance) == null ? void 0 : _d.options) || {};
        return {
          format: format || DEFAULT_DAILY_NOTE_FORMAT,
          folder: (folder == null ? void 0 : folder.trim()) || "",
          template: (template == null ? void 0 : template.trim()) || ""
        };
      } catch (err) {
        console.info("No custom daily note settings found!", err);
      }
    }
    function getWeeklyNoteSettings() {
      var _a, _b, _c, _d, _e, _f, _g;
      try {
        const pluginManager = window.app.plugins;
        const calendarSettings = (_a = pluginManager.getPlugin("calendar")) == null ? void 0 : _a.options;
        const periodicNotesSettings = (_c = (_b = pluginManager.getPlugin("periodic-notes")) == null ? void 0 : _b.settings) == null ? void 0 : _c.weekly;
        if (shouldUsePeriodicNotesSettings("weekly")) {
          return {
            format: periodicNotesSettings.format || DEFAULT_WEEKLY_NOTE_FORMAT,
            folder: ((_d = periodicNotesSettings.folder) == null ? void 0 : _d.trim()) || "",
            template: ((_e = periodicNotesSettings.template) == null ? void 0 : _e.trim()) || ""
          };
        }
        const settings = calendarSettings || {};
        return {
          format: settings.weeklyNoteFormat || DEFAULT_WEEKLY_NOTE_FORMAT,
          folder: ((_f = settings.weeklyNoteFolder) == null ? void 0 : _f.trim()) || "",
          template: ((_g = settings.weeklyNoteTemplate) == null ? void 0 : _g.trim()) || ""
        };
      } catch (err) {
        console.info("No custom weekly note settings found!", err);
      }
    }
    function getMonthlyNoteSettings() {
      var _a, _b, _c, _d;
      const pluginManager = window.app.plugins;
      try {
        const settings = shouldUsePeriodicNotesSettings("monthly") && ((_b = (_a = pluginManager.getPlugin("periodic-notes")) == null ? void 0 : _a.settings) == null ? void 0 : _b.monthly) || {};
        return {
          format: settings.format || DEFAULT_MONTHLY_NOTE_FORMAT,
          folder: ((_c = settings.folder) == null ? void 0 : _c.trim()) || "",
          template: ((_d = settings.template) == null ? void 0 : _d.trim()) || ""
        };
      } catch (err) {
        console.info("No custom monthly note settings found!", err);
      }
    }
    function getQuarterlyNoteSettings() {
      var _a, _b, _c, _d;
      const pluginManager = window.app.plugins;
      try {
        const settings = shouldUsePeriodicNotesSettings("quarterly") && ((_b = (_a = pluginManager.getPlugin("periodic-notes")) == null ? void 0 : _a.settings) == null ? void 0 : _b.quarterly) || {};
        return {
          format: settings.format || DEFAULT_QUARTERLY_NOTE_FORMAT,
          folder: ((_c = settings.folder) == null ? void 0 : _c.trim()) || "",
          template: ((_d = settings.template) == null ? void 0 : _d.trim()) || ""
        };
      } catch (err) {
        console.info("No custom quarterly note settings found!", err);
      }
    }
    function getYearlyNoteSettings() {
      var _a, _b, _c, _d;
      const pluginManager = window.app.plugins;
      try {
        const settings = shouldUsePeriodicNotesSettings("yearly") && ((_b = (_a = pluginManager.getPlugin("periodic-notes")) == null ? void 0 : _a.settings) == null ? void 0 : _b.yearly) || {};
        return {
          format: settings.format || DEFAULT_YEARLY_NOTE_FORMAT,
          folder: ((_c = settings.folder) == null ? void 0 : _c.trim()) || "",
          template: ((_d = settings.template) == null ? void 0 : _d.trim()) || ""
        };
      } catch (err) {
        console.info("No custom yearly note settings found!", err);
      }
    }
    function join(...partSegments) {
      let parts = [];
      for (let i = 0, l = partSegments.length; i < l; i++) {
        parts = parts.concat(partSegments[i].split("/"));
      }
      const newParts = [];
      for (let i = 0, l = parts.length; i < l; i++) {
        const part = parts[i];
        if (!part || part === ".")
          continue;
        else
          newParts.push(part);
      }
      if (parts[0] === "")
        newParts.unshift("");
      return newParts.join("/");
    }
    function basename(fullPath) {
      let base = fullPath.substring(fullPath.lastIndexOf("/") + 1);
      if (base.lastIndexOf(".") != -1)
        base = base.substring(0, base.lastIndexOf("."));
      return base;
    }
    async function ensureFolderExists(path) {
      const dirs = path.replace(/\\/g, "/").split("/");
      dirs.pop();
      if (dirs.length) {
        const dir = join(...dirs);
        if (!window.app.vault.getAbstractFileByPath(dir)) {
          await window.app.vault.createFolder(dir);
        }
      }
    }
    async function getNotePath(directory, filename) {
      if (!filename.endsWith(".md")) {
        filename += ".md";
      }
      const path = obsidian.normalizePath(join(directory, filename));
      await ensureFolderExists(path);
      return path;
    }
    async function getTemplateInfo(template) {
      const { metadataCache, vault } = window.app;
      const templatePath = obsidian.normalizePath(template);
      if (templatePath === "/") {
        return Promise.resolve(["", null]);
      }
      try {
        const templateFile = metadataCache.getFirstLinkpathDest(templatePath, "");
        const contents = await vault.cachedRead(templateFile);
        const IFoldInfo = window.app.foldManager.load(templateFile);
        return [contents, IFoldInfo];
      } catch (err) {
        console.error(`Failed to read the daily note template '${templatePath}'`, err);
        new obsidian.Notice("Failed to read the daily note template");
        return ["", null];
      }
    }
    function getDateUID(date, granularity = "day") {
      const ts = date.clone().startOf(granularity).format();
      return `${granularity}-${ts}`;
    }
    function removeEscapedCharacters(format) {
      return format.replace(/\[[^\]]*\]/g, "");
    }
    function isFormatAmbiguous(format, granularity) {
      if (granularity === "week") {
        const cleanFormat = removeEscapedCharacters(format);
        return /w{1,2}/i.test(cleanFormat) && (/M{1,4}/.test(cleanFormat) || /D{1,4}/.test(cleanFormat));
      }
      return false;
    }
    function getDateFromFile(file, granularity) {
      return getDateFromFilename(file.basename, granularity);
    }
    function getDateFromPath(path, granularity) {
      return getDateFromFilename(basename(path), granularity);
    }
    function getDateFromFilename(filename, granularity) {
      const getSettings = {
        day: getDailyNoteSettings,
        week: getWeeklyNoteSettings,
        month: getMonthlyNoteSettings,
        quarter: getQuarterlyNoteSettings,
        year: getYearlyNoteSettings
      };
      const format = getSettings[granularity]().format.split("/").pop();
      const noteDate = window.moment(filename, format, true);
      if (!noteDate.isValid()) {
        return null;
      }
      if (isFormatAmbiguous(format, granularity)) {
        if (granularity === "week") {
          const cleanFormat = removeEscapedCharacters(format);
          if (/w{1,2}/i.test(cleanFormat)) {
            return window.moment(filename, format.replace(/M{1,4}/g, "").replace(/D{1,4}/g, ""), false);
          }
        }
      }
      return noteDate;
    }
    var DailyNotesFolderMissingError = class extends Error {
    };
    async function createDailyNote2(date) {
      const app = window.app;
      const { vault } = app;
      const moment2 = window.moment;
      const { template, format, folder } = getDailyNoteSettings();
      const [templateContents, IFoldInfo] = await getTemplateInfo(template);
      const filename = date.format(format);
      const normalizedPath = await getNotePath(folder, filename);
      try {
        const createdFile = await vault.create(normalizedPath, templateContents.replace(/{{\s*date\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, moment2().format("HH:mm")).replace(/{{\s*title\s*}}/gi, filename).replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
          const now = moment2();
          const currentDate = date.clone().set({
            hour: now.get("hour"),
            minute: now.get("minute"),
            second: now.get("second")
          });
          if (calc) {
            currentDate.add(parseInt(timeDelta, 10), unit);
          }
          if (momentFormat) {
            return currentDate.format(momentFormat.substring(1).trim());
          }
          return currentDate.format(format);
        }).replace(/{{\s*yesterday\s*}}/gi, date.clone().subtract(1, "day").format(format)).replace(/{{\s*tomorrow\s*}}/gi, date.clone().add(1, "d").format(format)));
        app.foldManager.save(createdFile, IFoldInfo);
        return createdFile;
      } catch (err) {
        console.error(`Failed to create file: '${normalizedPath}'`, err);
        new obsidian.Notice("Unable to create new file.");
      }
    }
    function getDailyNote2(date, dailyNotes) {
      var _a;
      return (_a = dailyNotes[getDateUID(date, "day")]) != null ? _a : null;
    }
    function getAllDailyNotes2() {
      const { vault } = window.app;
      const { folder } = getDailyNoteSettings();
      const dailyNotesFolder = vault.getAbstractFileByPath(obsidian.normalizePath(folder));
      if (!dailyNotesFolder) {
        throw new DailyNotesFolderMissingError("Failed to find daily notes folder");
      }
      const dailyNotes = {};
      obsidian.Vault.recurseChildren(dailyNotesFolder, (note) => {
        if (note instanceof obsidian.TFile) {
          const date = getDateFromFile(note, "day");
          if (date) {
            const dateString = getDateUID(date, "day");
            dailyNotes[dateString] = note;
          }
        }
      });
      return dailyNotes;
    }
    var WeeklyNotesFolderMissingError = class extends Error {
    };
    function getDaysOfWeek() {
      const { moment: moment2 } = window;
      let weekStart = moment2.localeData()._week.dow;
      const daysOfWeek = [
        "sunday",
        "monday",
        "tuesday",
        "wednesday",
        "thursday",
        "friday",
        "saturday"
      ];
      while (weekStart) {
        daysOfWeek.push(daysOfWeek.shift());
        weekStart--;
      }
      return daysOfWeek;
    }
    function getDayOfWeekNumericalValue(dayOfWeekName) {
      return getDaysOfWeek().indexOf(dayOfWeekName.toLowerCase());
    }
    async function createWeeklyNote(date) {
      const { vault } = window.app;
      const { template, format, folder } = getWeeklyNoteSettings();
      const [templateContents, IFoldInfo] = await getTemplateInfo(template);
      const filename = date.format(format);
      const normalizedPath = await getNotePath(folder, filename);
      try {
        const createdFile = await vault.create(normalizedPath, templateContents.replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
          const now = window.moment();
          const currentDate = date.clone().set({
            hour: now.get("hour"),
            minute: now.get("minute"),
            second: now.get("second")
          });
          if (calc) {
            currentDate.add(parseInt(timeDelta, 10), unit);
          }
          if (momentFormat) {
            return currentDate.format(momentFormat.substring(1).trim());
          }
          return currentDate.format(format);
        }).replace(/{{\s*title\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm")).replace(/{{\s*(sunday|monday|tuesday|wednesday|thursday|friday|saturday)\s*:(.*?)}}/gi, (_, dayOfWeek, momentFormat) => {
          const day = getDayOfWeekNumericalValue(dayOfWeek);
          return date.weekday(day).format(momentFormat.trim());
        }));
        window.app.foldManager.save(createdFile, IFoldInfo);
        return createdFile;
      } catch (err) {
        console.error(`Failed to create file: '${normalizedPath}'`, err);
        new obsidian.Notice("Unable to create new file.");
      }
    }
    function getWeeklyNote(date, weeklyNotes) {
      var _a;
      return (_a = weeklyNotes[getDateUID(date, "week")]) != null ? _a : null;
    }
    function getAllWeeklyNotes() {
      const weeklyNotes = {};
      if (!appHasWeeklyNotesPluginLoaded()) {
        return weeklyNotes;
      }
      const { vault } = window.app;
      const { folder } = getWeeklyNoteSettings();
      const weeklyNotesFolder = vault.getAbstractFileByPath(obsidian.normalizePath(folder));
      if (!weeklyNotesFolder) {
        throw new WeeklyNotesFolderMissingError("Failed to find weekly notes folder");
      }
      obsidian.Vault.recurseChildren(weeklyNotesFolder, (note) => {
        if (note instanceof obsidian.TFile) {
          const date = getDateFromFile(note, "week");
          if (date) {
            const dateString = getDateUID(date, "week");
            weeklyNotes[dateString] = note;
          }
        }
      });
      return weeklyNotes;
    }
    var MonthlyNotesFolderMissingError = class extends Error {
    };
    async function createMonthlyNote(date) {
      const { vault } = window.app;
      const { template, format, folder } = getMonthlyNoteSettings();
      const [templateContents, IFoldInfo] = await getTemplateInfo(template);
      const filename = date.format(format);
      const normalizedPath = await getNotePath(folder, filename);
      try {
        const createdFile = await vault.create(normalizedPath, templateContents.replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
          const now = window.moment();
          const currentDate = date.clone().set({
            hour: now.get("hour"),
            minute: now.get("minute"),
            second: now.get("second")
          });
          if (calc) {
            currentDate.add(parseInt(timeDelta, 10), unit);
          }
          if (momentFormat) {
            return currentDate.format(momentFormat.substring(1).trim());
          }
          return currentDate.format(format);
        }).replace(/{{\s*date\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm")).replace(/{{\s*title\s*}}/gi, filename));
        window.app.foldManager.save(createdFile, IFoldInfo);
        return createdFile;
      } catch (err) {
        console.error(`Failed to create file: '${normalizedPath}'`, err);
        new obsidian.Notice("Unable to create new file.");
      }
    }
    function getMonthlyNote(date, monthlyNotes) {
      var _a;
      return (_a = monthlyNotes[getDateUID(date, "month")]) != null ? _a : null;
    }
    function getAllMonthlyNotes() {
      const monthlyNotes = {};
      if (!appHasMonthlyNotesPluginLoaded()) {
        return monthlyNotes;
      }
      const { vault } = window.app;
      const { folder } = getMonthlyNoteSettings();
      const monthlyNotesFolder = vault.getAbstractFileByPath(obsidian.normalizePath(folder));
      if (!monthlyNotesFolder) {
        throw new MonthlyNotesFolderMissingError("Failed to find monthly notes folder");
      }
      obsidian.Vault.recurseChildren(monthlyNotesFolder, (note) => {
        if (note instanceof obsidian.TFile) {
          const date = getDateFromFile(note, "month");
          if (date) {
            const dateString = getDateUID(date, "month");
            monthlyNotes[dateString] = note;
          }
        }
      });
      return monthlyNotes;
    }
    var QuarterlyNotesFolderMissingError = class extends Error {
    };
    async function createQuarterlyNote(date) {
      const { vault } = window.app;
      const { template, format, folder } = getQuarterlyNoteSettings();
      const [templateContents, IFoldInfo] = await getTemplateInfo(template);
      const filename = date.format(format);
      const normalizedPath = await getNotePath(folder, filename);
      try {
        const createdFile = await vault.create(normalizedPath, templateContents.replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
          const now = window.moment();
          const currentDate = date.clone().set({
            hour: now.get("hour"),
            minute: now.get("minute"),
            second: now.get("second")
          });
          if (calc) {
            currentDate.add(parseInt(timeDelta, 10), unit);
          }
          if (momentFormat) {
            return currentDate.format(momentFormat.substring(1).trim());
          }
          return currentDate.format(format);
        }).replace(/{{\s*date\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm")).replace(/{{\s*title\s*}}/gi, filename));
        window.app.foldManager.save(createdFile, IFoldInfo);
        return createdFile;
      } catch (err) {
        console.error(`Failed to create file: '${normalizedPath}'`, err);
        new obsidian.Notice("Unable to create new file.");
      }
    }
    function getQuarterlyNote(date, quarterly) {
      var _a;
      return (_a = quarterly[getDateUID(date, "quarter")]) != null ? _a : null;
    }
    function getAllQuarterlyNotes() {
      const quarterly = {};
      if (!appHasQuarterlyNotesPluginLoaded()) {
        return quarterly;
      }
      const { vault } = window.app;
      const { folder } = getQuarterlyNoteSettings();
      const quarterlyFolder = vault.getAbstractFileByPath(obsidian.normalizePath(folder));
      if (!quarterlyFolder) {
        throw new QuarterlyNotesFolderMissingError("Failed to find quarterly notes folder");
      }
      obsidian.Vault.recurseChildren(quarterlyFolder, (note) => {
        if (note instanceof obsidian.TFile) {
          const date = getDateFromFile(note, "quarter");
          if (date) {
            const dateString = getDateUID(date, "quarter");
            quarterly[dateString] = note;
          }
        }
      });
      return quarterly;
    }
    var YearlyNotesFolderMissingError = class extends Error {
    };
    async function createYearlyNote(date) {
      const { vault } = window.app;
      const { template, format, folder } = getYearlyNoteSettings();
      const [templateContents, IFoldInfo] = await getTemplateInfo(template);
      const filename = date.format(format);
      const normalizedPath = await getNotePath(folder, filename);
      try {
        const createdFile = await vault.create(normalizedPath, templateContents.replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
          const now = window.moment();
          const currentDate = date.clone().set({
            hour: now.get("hour"),
            minute: now.get("minute"),
            second: now.get("second")
          });
          if (calc) {
            currentDate.add(parseInt(timeDelta, 10), unit);
          }
          if (momentFormat) {
            return currentDate.format(momentFormat.substring(1).trim());
          }
          return currentDate.format(format);
        }).replace(/{{\s*date\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm")).replace(/{{\s*title\s*}}/gi, filename));
        window.app.foldManager.save(createdFile, IFoldInfo);
        return createdFile;
      } catch (err) {
        console.error(`Failed to create file: '${normalizedPath}'`, err);
        new obsidian.Notice("Unable to create new file.");
      }
    }
    function getYearlyNote(date, yearlyNotes) {
      var _a;
      return (_a = yearlyNotes[getDateUID(date, "year")]) != null ? _a : null;
    }
    function getAllYearlyNotes() {
      const yearlyNotes = {};
      if (!appHasYearlyNotesPluginLoaded()) {
        return yearlyNotes;
      }
      const { vault } = window.app;
      const { folder } = getYearlyNoteSettings();
      const yearlyNotesFolder = vault.getAbstractFileByPath(obsidian.normalizePath(folder));
      if (!yearlyNotesFolder) {
        throw new YearlyNotesFolderMissingError("Failed to find yearly notes folder");
      }
      obsidian.Vault.recurseChildren(yearlyNotesFolder, (note) => {
        if (note instanceof obsidian.TFile) {
          const date = getDateFromFile(note, "year");
          if (date) {
            const dateString = getDateUID(date, "year");
            yearlyNotes[dateString] = note;
          }
        }
      });
      return yearlyNotes;
    }
    function appHasDailyNotesPluginLoaded() {
      var _a, _b;
      const { app } = window;
      const dailyNotesPlugin = app.internalPlugins.plugins["daily-notes"];
      if (dailyNotesPlugin && dailyNotesPlugin.enabled) {
        return true;
      }
      const periodicNotes = app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a.daily) == null ? void 0 : _b.enabled);
    }
    function appHasWeeklyNotesPluginLoaded() {
      var _a, _b;
      const { app } = window;
      if (app.plugins.getPlugin("calendar")) {
        return true;
      }
      const periodicNotes = app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a.weekly) == null ? void 0 : _b.enabled);
    }
    function appHasMonthlyNotesPluginLoaded() {
      var _a, _b;
      const { app } = window;
      const periodicNotes = app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a.monthly) == null ? void 0 : _b.enabled);
    }
    function appHasQuarterlyNotesPluginLoaded() {
      var _a, _b;
      const { app } = window;
      const periodicNotes = app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a.quarterly) == null ? void 0 : _b.enabled);
    }
    function appHasYearlyNotesPluginLoaded() {
      var _a, _b;
      const { app } = window;
      const periodicNotes = app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a.yearly) == null ? void 0 : _b.enabled);
    }
    function getPeriodicNoteSettings(granularity) {
      const getSettings = {
        day: getDailyNoteSettings,
        week: getWeeklyNoteSettings,
        month: getMonthlyNoteSettings,
        quarter: getQuarterlyNoteSettings,
        year: getYearlyNoteSettings
      }[granularity];
      return getSettings();
    }
    function createPeriodicNote(granularity, date) {
      const createFn = {
        day: createDailyNote2,
        month: createMonthlyNote,
        week: createWeeklyNote
      };
      return createFn[granularity](date);
    }
    exports.DEFAULT_DAILY_NOTE_FORMAT = DEFAULT_DAILY_NOTE_FORMAT;
    exports.DEFAULT_MONTHLY_NOTE_FORMAT = DEFAULT_MONTHLY_NOTE_FORMAT;
    exports.DEFAULT_QUARTERLY_NOTE_FORMAT = DEFAULT_QUARTERLY_NOTE_FORMAT;
    exports.DEFAULT_WEEKLY_NOTE_FORMAT = DEFAULT_WEEKLY_NOTE_FORMAT;
    exports.DEFAULT_YEARLY_NOTE_FORMAT = DEFAULT_YEARLY_NOTE_FORMAT;
    exports.appHasDailyNotesPluginLoaded = appHasDailyNotesPluginLoaded;
    exports.appHasMonthlyNotesPluginLoaded = appHasMonthlyNotesPluginLoaded;
    exports.appHasQuarterlyNotesPluginLoaded = appHasQuarterlyNotesPluginLoaded;
    exports.appHasWeeklyNotesPluginLoaded = appHasWeeklyNotesPluginLoaded;
    exports.appHasYearlyNotesPluginLoaded = appHasYearlyNotesPluginLoaded;
    exports.createDailyNote = createDailyNote2;
    exports.createMonthlyNote = createMonthlyNote;
    exports.createPeriodicNote = createPeriodicNote;
    exports.createQuarterlyNote = createQuarterlyNote;
    exports.createWeeklyNote = createWeeklyNote;
    exports.createYearlyNote = createYearlyNote;
    exports.getAllDailyNotes = getAllDailyNotes2;
    exports.getAllMonthlyNotes = getAllMonthlyNotes;
    exports.getAllQuarterlyNotes = getAllQuarterlyNotes;
    exports.getAllWeeklyNotes = getAllWeeklyNotes;
    exports.getAllYearlyNotes = getAllYearlyNotes;
    exports.getDailyNote = getDailyNote2;
    exports.getDailyNoteSettings = getDailyNoteSettings;
    exports.getDateFromFile = getDateFromFile;
    exports.getDateFromPath = getDateFromPath;
    exports.getDateUID = getDateUID;
    exports.getMonthlyNote = getMonthlyNote;
    exports.getMonthlyNoteSettings = getMonthlyNoteSettings;
    exports.getPeriodicNoteSettings = getPeriodicNoteSettings;
    exports.getQuarterlyNote = getQuarterlyNote;
    exports.getQuarterlyNoteSettings = getQuarterlyNoteSettings;
    exports.getTemplateInfo = getTemplateInfo;
    exports.getWeeklyNote = getWeeklyNote;
    exports.getWeeklyNoteSettings = getWeeklyNoteSettings;
    exports.getYearlyNote = getYearlyNote;
    exports.getYearlyNoteSettings = getYearlyNoteSettings;
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  DEFAULT_SETTINGS: () => DEFAULT_SETTINGS,
  addIncompleteTodosToTodaysNote: () => addIncompleteTodosToTodaysNote,
  default: () => NestedDailyTodos2,
  parseFilesForTodos: () => parseFilesForTodos
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");
var import_obsidian_daily_notes_interface = __toESM(require_main());

// src/todo.ts
function escapeRegexCharacter(character) {
  if (["-", "^", "\\"].includes(character)) {
    return "\\" + character;
  }
  return character;
}
function parseForTodos(allowedChars, completeChars, lines, lineNum, level = -1) {
  const charsForRegex = Array.from(allowedChars).map(escapeRegexCharacter).join("");
  const regexPattern = `^\\s*- \\[([${charsForRegex}])]`;
  const todoRegex = new RegExp(`${regexPattern} (.*)`, "g");
  if (lineNum >= lines.length) {
    return { todo: null, numItems: 0 };
  }
  const line = lines[lineNum];
  const match = todoRegex.exec(line);
  if (match == null) {
    return { todo: null, numItems: 0 };
  }
  const indentLevel = line.split("-")[0].length;
  if (indentLevel <= level) {
    return { todo: null, numItems: 0 };
  }
  const state = match[1];
  const todoText = match[2];
  const complete = completeChars.has(state);
  const newNode = { item: todoText, state, children: [], complete };
  let numItems = 1;
  let child;
  for (; (child = parseForTodos(allowedChars, completeChars, lines, lineNum + numItems, indentLevel)).todo !== null; numItems += child.numItems) {
    newNode.children.push(child.todo);
  }
  return { todo: newNode, numItems };
}
function todoHasIncompleteItem(node) {
  if (!node.complete) {
    return true;
  }
  for (const child of node.children) {
    if (todoHasIncompleteItem(child)) {
      return true;
    }
  }
  return false;
}
function parseTextForTodos(text, bySection, allowedChars, completeChars) {
  const lines = text.split("\n");
  let sectionTitle = null;
  const todosBySection = /* @__PURE__ */ new Map();
  const untitled = "Untitled";
  for (let i = 0; i < lines.length; i++) {
    const result = parseForTodos(allowedChars, completeChars, lines, i, -1);
    if (result.todo === null) {
      sectionTitle = parseLineForTitle(lines[i]);
    }
    if (result.todo !== null && result.todo.item !== "") {
      i += result.numItems - 1;
      if (bySection && sectionTitle != null) {
        updateElseSet(todosBySection, sectionTitle, result.todo);
      } else {
        updateElseSet(todosBySection, untitled, result.todo);
      }
    }
  }
  return todosBySection;
}
function parseLineForTitle(line) {
  const titleRegex = /^#+\s(.+)/;
  if (titleRegex.test(line)) {
    return line;
  } else {
    return null;
  }
}
function calculateRemainingIncompleteTodos(previousTodos) {
  var _a, _b;
  const incompleteTodos = /* @__PURE__ */ new Map();
  for (const dayOfTodos of previousTodos) {
    for (const [sectionTitle, sectionTodos] of dayOfTodos.entries()) {
      for (const todo of sectionTodos) {
        if (todoHasIncompleteItem(todo)) {
          if (incompleteTodos.has(sectionTitle)) {
            const previousIncompleteTodos = (_a = incompleteTodos.get(sectionTitle)) != null ? _a : [];
            const index = previousIncompleteTodos.findIndex((previousTodo) => previousTodo.item == todo.item);
            if (index !== -1) {
              previousIncompleteTodos[index] = todo;
            } else {
              previousIncompleteTodos.push(todo);
            }
          } else {
            incompleteTodos.set(sectionTitle, [todo]);
          }
        } else {
          if (incompleteTodos.has(sectionTitle)) {
            const previousIncompleteTodos = (_b = incompleteTodos.get(sectionTitle)) != null ? _b : [];
            const index = previousIncompleteTodos.findIndex((previousTodo) => previousTodo.item == todo.item);
            if (index !== -1) {
              previousIncompleteTodos.splice(index, 1);
            }
          }
        }
      }
    }
  }
  return incompleteTodos;
}
function filterOutExistingTodos(previousTodos, existingTodos) {
  const remainingTodos = /* @__PURE__ */ new Map();
  for (const [sectionTitle, entries] of previousTodos) {
    const existingEntries = existingTodos.get(sectionTitle);
    if (!existingEntries) {
      remainingTodos.set(sectionTitle, entries);
    } else {
      const newEntries = entries.filter((entry) => !existingEntries.some((existingEntry) => existingEntry.item === entry.item));
      if (newEntries.length > 0) {
        remainingTodos.set(sectionTitle, newEntries);
      }
    }
  }
  return remainingTodos;
}
function todoToString(todo, indentLevel) {
  let entries = [`${"	".repeat(indentLevel)}- [${todo.state}] ${todo.item}`];
  for (const node of todo.children) {
    entries = entries.concat(todoToString(node, indentLevel + 1));
  }
  return entries;
}
function todosToString(todos) {
  let entries = [];
  for (const todo of todos) {
    entries = entries.concat(todoToString(todo, 0));
  }
  return entries.join("\n");
}
function insertIncompleteTodos(incompleteTodos, bySection, noteText) {
  var _a, _b;
  console.info(`Adding missing todos to today's note.`);
  let newNoteText = noteText;
  if (bySection) {
    for (const sectionTitle of incompleteTodos.keys()) {
      const sectionTitleIndex = noteText.indexOf(sectionTitle);
      if (sectionTitleIndex === -1) {
        console.error(`Failed to find header: ${sectionTitle} in new note. Adding items to end of note`);
        newNoteText += "\n" + todosToString((_a = incompleteTodos.get(sectionTitle)) != null ? _a : []);
      } else {
        console.debug(`Adding todos for section ${sectionTitle} under matching header`);
        const splitNote = newNoteText.split(sectionTitle);
        newNoteText = `${splitNote[0]}${sectionTitle}
`;
        newNoteText += todosToString((_b = incompleteTodos.get(sectionTitle)) != null ? _b : []);
        newNoteText += splitNote[1];
      }
    }
  } else {
    console.debug("Adding incomplete todos to end of note");
    for (const sectionOfTodos of incompleteTodos.values()) {
      newNoteText += "\n" + todosToString(sectionOfTodos);
    }
  }
  return newNoteText;
}
function removeEmptyTodos(noteText) {
  console.info("Removing empty todos from today's note");
  const emptyTodoRegex = new RegExp(`^\\s*- \\[ \\]\\s*$`, "gm");
  return noteText.replace(emptyTodoRegex, "");
}
function updateElseSet(m, k, v) {
  const entries = m.get(k) || [];
  entries.push(v);
  m.set(k, entries);
}

// src/settings.ts
var import_obsidian = require("obsidian");
var NestedDailyTodosSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Number of previous days to check for todos").addText((text) => {
      text.setPlaceholder("7");
      text.inputEl.type = "number";
      text.setValue(this.plugin.settings.daysLookBack.toString());
      text.onChange(async (value) => {
        this.plugin.settings.daysLookBack = parseInt(value, 10);
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Check previous existing notes instead of days").setDesc("Enable this to check existing previous notes rather than days. For example, if set to check 1 previous day, and this option is enabled, the plugin will look for todos in the latest daily note, even if that note is older than 1 day.").addToggle((toggle) => toggle.setValue(this.plugin.settings.lookBackExistingNotesInsteadOfDays).onChange(async (value) => {
      this.plugin.settings.lookBackExistingNotesInsteadOfDays = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Group todos by section").setDesc("Enable this to group incomplete todos by any headings they are under. If disabled, or a previousheading is not found in today's note, the incomplete todos are ended to the end of today's note.").addToggle((toggle) => toggle.setValue(this.plugin.settings.groupBySection).onChange(async (value) => {
      this.plugin.settings.groupBySection = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Remove empty todos").setDesc("Remove empty todos from the updated note.").addToggle((toggle) => toggle.setValue(this.plugin.settings.removeEmptyTodos).onChange(async (value) => {
      this.plugin.settings.removeEmptyTodos = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Supported Todo characters").setDesc('Todo items with these values will be considered todos and carried forward if incomplete. If you use a theme or plugin that makes use of non-standard values like - [!] and you want that entry to carry forward, include "!" in this setting.').addText((text) => text.setPlaceholder("xX/-").setValue(Array.from(this.plugin.settings.supportedTodoChars).join("")).onChange(async (value) => {
      this.plugin.settings.supportedTodoChars = new Set(value.length > 0 ? value.split("") : DEFAULT_SETTINGS.supportedTodoChars);
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName('"complete" Todo Values').setDesc(`Todo items with these values will be considered "compete" and won't carry forward.`).addText((text) => text.setPlaceholder("xX-").setValue([...this.plugin.settings.completeTodoChars].join("")).onChange(async (value) => {
      this.plugin.settings.completeTodoChars = new Set(value.length > 0 ? value.split("") : DEFAULT_SETTINGS.completeTodoChars);
      await this.plugin.saveSettings();
    }));
  }
};

// src/main.ts
var DEFAULT_SETTINGS = {
  daysLookBack: 7,
  lookBackExistingNotesInsteadOfDays: false,
  groupBySection: true,
  removeEmptyTodos: true,
  supportedTodoChars: /* @__PURE__ */ new Set(["x", "X", "/", "-"]),
  completeTodoChars: /* @__PURE__ */ new Set(["x", "X", "-"])
};
var NestedDailyTodos2 = class extends import_obsidian2.Plugin {
  async onload() {
    console.info("Loading Nested Daily Todos plugin");
    await this.loadSettings();
    this.addRibbonIcon("bullet-list-glyph", "Add incomplete todos to today's note", (evt) => {
      new import_obsidian2.Notice("Running Nested Daily Todos");
      addIncompleteTodosToTodaysNote(this);
    });
    this.addCommand({
      id: "add-incomplete-todos",
      name: "Add previous incomplete todos",
      callback: () => addIncompleteTodosToTodaysNote(this)
    });
    this.addSettingTab(new NestedDailyTodosSettingTab(this.app, this));
  }
  onunload() {
    console.info("Unloading Nested Daily Todos plugin");
  }
  async loadSettings() {
    const savedSettings = await this.loadData();
    if (typeof (savedSettings == null ? void 0 : savedSettings.supportedTodoChars) === "string" && (savedSettings == null ? void 0 : savedSettings.supportedTodoChars.length) !== 0) {
      savedSettings.supportedTodoChars = new Set(savedSettings.supportedTodoChars.split(""));
    }
    if (typeof (savedSettings == null ? void 0 : savedSettings.completeTodoChars) === "string" && (savedSettings == null ? void 0 : savedSettings.completeTodoChars.length) !== 0) {
      savedSettings.completeTodoChars = new Set(savedSettings.completeTodoChars.split(""));
    }
    this.settings = {
      ...DEFAULT_SETTINGS,
      ...savedSettings,
      supportedTodoChars: (savedSettings == null ? void 0 : savedSettings.supportedTodoChars) || new Set(DEFAULT_SETTINGS.supportedTodoChars),
      completeTodoChars: (savedSettings == null ? void 0 : savedSettings.completeTodoChars) || new Set(DEFAULT_SETTINGS.completeTodoChars)
    };
    this.settings.supportedTodoChars.add(" ");
  }
  async saveSettings() {
    const supportedTodoChars = Array.from(this.settings.supportedTodoChars).join("");
    const completeTodoChars = Array.from(this.settings.completeTodoChars).join("");
    await this.saveData({
      ...this.settings,
      supportedTodoChars,
      completeTodoChars
    });
  }
};
async function addIncompleteTodosToTodaysNote(plugin) {
  const settings = plugin.settings;
  let allDailyNotes = (0, import_obsidian_daily_notes_interface.getAllDailyNotes)();
  const today = (0, import_obsidian2.moment)().startOf("day");
  let todayNote = (0, import_obsidian_daily_notes_interface.getDailyNote)(today, allDailyNotes);
  if (todayNote === null) {
    try {
      console.info("Today's Daily Note not found. Creating daily note for today");
      await (0, import_obsidian_daily_notes_interface.createDailyNote)(today).then((newNote) => todayNote = newNote);
    } catch (e) {
      console.error(`Failed to create missing note for today: ${e}`);
      throw e;
    }
    allDailyNotes = (0, import_obsidian_daily_notes_interface.getAllDailyNotes)();
  }
  let notesToProcess = [];
  if (!settings.lookBackExistingNotesInsteadOfDays) {
    const prevDays = Array.from({ length: settings.daysLookBack + 1 }, (_, i) => {
      const d = new Date();
      d.setDate(d.getDate() - (settings.daysLookBack - i));
      return (0, import_obsidian2.moment)(d);
    });
    notesToProcess = Array.from(prevDays, (date) => (0, import_obsidian_daily_notes_interface.getDailyNote)(date, allDailyNotes)).filter((note) => note !== null);
  } else {
    const sortedKeys = Object.keys(allDailyNotes).sort((a, b) => parseDateFromDailyNoteKey(b).getTime() - parseDateFromDailyNoteKey(a).getTime());
    const todaysIndex = sortedKeys.indexOf(today.format("[day-]YYYY-MM-DDTHH:mm:ssZ"));
    const prevNotes = sortedKeys.slice(todaysIndex, todaysIndex + settings.daysLookBack + 1);
    notesToProcess = [...prevNotes.map((key) => allDailyNotes[key])];
  }
  notesToProcess = notesToProcess.reverse();
  console.debug(`Running with: supportedTodoChars: "${Array.from(settings.supportedTodoChars).join("")}", completeTodoChars: "${Array.from(settings.completeTodoChars).join("")}"`);
  console.info(`Checking notes: ${notesToProcess.map((note) => note.name).join(", ")}`);
  const existingTodos = await parseFilesForTodos(notesToProcess, settings.groupBySection, settings.supportedTodoChars, settings.completeTodoChars);
  existingTodos.forEach((dayOfTodos, index) => {
    console.info(`Todos for ${notesToProcess[index].name}`);
    const numberOfTopLevelTodos = Array.from(dayOfTodos.values()).reduce((sum, currentArray) => sum + currentArray.length, 0);
    console.info(`Number of top-level todos found: ${numberOfTopLevelTodos}`);
    dayOfTodos.forEach((todos, group) => {
      console.debug(`  Group: ${group}`);
      console.debug(todos);
    });
  });
  const previousExistingTodos = existingTodos.slice(0, -1);
  const incompleteTodos = calculateRemainingIncompleteTodos(previousExistingTodos);
  const numberOfIncompleteTodos = Array.from(incompleteTodos.values()).reduce((sum, currentArray) => sum + currentArray.length, 0);
  const incompleteTodosNotice = `${numberOfIncompleteTodos} top-level incomplete todos found in previous days`;
  new import_obsidian2.Notice(incompleteTodosNotice);
  console.info(incompleteTodosNotice);
  const todaysExistingTodos = existingTodos[existingTodos.length - 1];
  const missingIncompleteTodos = filterOutExistingTodos(incompleteTodos, todaysExistingTodos);
  const numMissingTodos = Array.from(missingIncompleteTodos.values()).reduce((sum, currentArray) => sum + currentArray.length, 0);
  const numMissingTodosNotice = `Of previous todos, ${numMissingTodos} not found in today's note.`;
  new import_obsidian2.Notice(numMissingTodosNotice);
  console.info(numMissingTodosNotice);
  if (numMissingTodos > 0) {
    this.app.vault.process(todayNote, insertIncompleteTodos.bind(null, missingIncompleteTodos, settings.groupBySection));
  }
  if (settings.removeEmptyTodos) {
    this.app.vault.process(todayNote, removeEmptyTodos.bind(null));
  }
}
async function parseFilesForTodos(notes, groupBySection, supportedChars, completeTodoChars) {
  const todos = [];
  for (const note of notes) {
    if (note !== null) {
      const text = await this.app.vault.read(note);
      const found = parseTextForTodos(text, groupBySection, supportedChars, completeTodoChars);
      todos.push(found);
    }
  }
  return todos;
}
function parseDateFromDailyNoteKey(key) {
  const dateString = key.substring(4);
  return new Date(dateString);
}
