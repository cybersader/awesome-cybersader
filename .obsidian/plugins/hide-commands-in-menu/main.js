/*
THIS IS A GENERATED/BUNDLED FILE BY ROLLUP
if you want to view the source visit the plugins github repository
*/

'use strict';

var obsidian = require('obsidian');

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

const EmptyCommands = {
    plainTexts: [],
    regexTexts: [],
};
const DEFAULT_SETTINGS = {
    fileMenu: {
        tabHeader: Object.assign({}, EmptyCommands),
        moreOptions: Object.assign({}, EmptyCommands),
        fileExplorerContext: Object.assign({}, EmptyCommands),
        linkContext: Object.assign({}, EmptyCommands),
    },
    filesMenu: {
        fileExplorerContext: Object.assign({}, EmptyCommands),
    },
    editorMenu: Object.assign({}, EmptyCommands),
    urlMenu: Object.assign({}, EmptyCommands),
    otherMenu: Object.assign({}, EmptyCommands),
    delayTime: 1,
};
class HidingCommandSettingsTab extends obsidian.PluginSettingTab {
    constructor(app, plugin) {
        super(app, plugin);
        this.plugin = plugin;
    }
    display() {
        const { containerEl } = this;
        const { settings } = this.plugin;
        containerEl.empty();
        containerEl.addClass('hide-commands-settings');
        containerEl.createEl('div', {
            text: 'Enter command names as a line-separated list (one command per line). Commands are case-sensitive. Changes will take effect after restarting Obsidian or reloading the plugin.',
            cls: 'hide-commands-description',
        });
        this.createMenuSettings(containerEl, 'File menu (tab header)', settings.fileMenu.tabHeader, 'Hide commands from the file menu when right-clicking on the tab header.');
        this.createMenuSettings(containerEl, 'File menu (more options)', settings.fileMenu.moreOptions, 'Hide commands from the file menu when clicking the "More Options" button.');
        this.createMenuSettings(containerEl, 'File menu (file explorer)', settings.fileMenu.fileExplorerContext, 'Hide commands from the file menu when right-clicking on a file or folder in the file explorer.');
        this.createMenuSettings(containerEl, 'File menu (link context)', settings.fileMenu.linkContext, 'Hide commands from the file menu when right-clicking on a file link.');
        this.createMenuSettings(containerEl, 'Files menu (file explorer)', settings.filesMenu.fileExplorerContext, 'Hide commands from the files menu when right-clicking on files or folders in the file explorer.');
        this.createMenuSettings(containerEl, 'Editor menu', settings.editorMenu, 'Hide commands from the editor menu when right-clicking in the editor view.');
        this.createMenuSettings(containerEl, 'URL menu', settings.urlMenu, 'Hide commands from the URL menu when right-clicking on an external URL.');
        this.createMenuSettings(containerEl, 'Other menus', settings.otherMenu, 'Hide commands from additional menus not covered above.');
        this.createDelayTimeSetting(containerEl, settings);
    }
    /**
     * Create specific menu settings
     * @param parentEl - Parent element
     * @param title - Menu title
     * @param commands - Menu commands configuration
     * @param description - Menu description
     */
    createMenuSettings(parentEl, title, commands, description) {
        // const detailsEl = parentEl.createEl('details');
        // detailsEl.createEl('summary', { text: title });
        // detailsEl.createEl('div', {
        //   text: description,
        //   cls: 'hide-commands-detail-description',
        // });
        const collapsible = createCollapsibleSection(parentEl, title, false);
        collapsible.content.createEl('div', {
            text: description,
            cls: 'hide-commands-detail-description',
        });
        // Create plain text settings
        createTextAreaSetting(collapsible.content, 'Enter commands to hide (plain text format)', 'Enter command names (one per line)', commands.plainTexts, (value) => __awaiter(this, void 0, void 0, function* () {
            commands.plainTexts = parseCmdString(value);
            yield this.plugin.saveSettings();
        }));
        // Create regex settings
        createTextAreaSetting(collapsible.content, 'Enter commands to hide (regex format)', 'Enter command names (one per line)', commands.regexTexts, (value) => __awaiter(this, void 0, void 0, function* () {
            commands.regexTexts = parseCmdString(value);
            yield this.plugin.saveSettings();
        }), 3 // Set rows to 3
        );
    }
    /**
     * Create delay time setting
     * @param parentEl - Parent element
     * @param settings - Plugin settings
     */
    createDelayTimeSetting(parentEl, settings) {
        let delayTime = settings.delayTime;
        new obsidian.Setting(parentEl)
            .setHeading()
            .setName('Delay time (milliseconds)')
            .setDesc('Delay time to process menu hiding (default 1 millisecond).')
            .addText((text) => text.setValue(delayTime.toString()).onChange(obsidian.debounce((value) => __awaiter(this, void 0, void 0, function* () {
            const parsedValue = parseInt(value);
            if (isNaN(parsedValue)) {
                delayTime = 1;
                text.setValue(delayTime.toString());
            }
            settings.delayTime = parsedValue;
            yield this.plugin.saveSettings();
        }), 1000, true)));
    }
}
/**
 * Create textarea setting
 * @param parentEl - Parent element
 * @param name - Setting name
 * @param placeholder - Placeholder text
 * @param value - Initial value
 * @param onChange - Callback when value changes
 * @param rows - Number of rows (default 8)
 * @param cols - Number of columns (default 30)
 */
function createTextAreaSetting(parentEl, name, placeholder, value, onChange, rows = 8, cols = 30) {
    return new obsidian.Setting(parentEl).setName(name).addTextArea((text) => {
        text
            .setPlaceholder(placeholder)
            .setValue(value.join('\n'))
            .onChange(obsidian.debounce(onChange, 500, true));
        text.inputEl.rows = rows;
        text.inputEl.cols = cols;
    });
}
/**
 * Parse command string
 * @param commands - Command string
 * @returns Parsed command array
 */
function parseCmdString(commands) {
    return commands
        .split('\n')
        .map((v) => v.trim())
        .filter((v) => v !== '');
}
// 修改后的 createCollapsibleSection 函数
function createCollapsibleSection(parentEl, title, isOpen = false) {
    const container = parentEl.createEl('div', {
        cls: 'hide-commands-collapsible sidebar-style'
    });
    const header = container.createEl('div', {
        cls: 'hide-commands-collapsible-header',
        text: title
    });
    const content = container.createEl('div', {
        cls: 'hide-commands-collapsible-content',
        attr: { style: `display: ${isOpen ? 'block' : 'none'};` }
    });
    // 点击事件
    header.onclick = () => {
        const isVisible = content.style.display === 'none';
        content.style.display = isVisible ? 'block' : 'none';
        container.classList.toggle('is-open', isVisible);
    };
    return { container, header, content };
}

/**
 * Check if the separator needs to be hidden
 * @param children - Array of child elements
 * @param startIndex - Start index
 * @param endIndex - End index
 * @returns Whether the separator should be hidden
 */
function shouldHideSeparator(children, startIndex, endIndex) {
    for (let i = startIndex + 1; i < endIndex; i++) {
        if (!children[i].classList.contains('custom-menu-hide-item')) {
            return false;
        }
    }
    return true;
}
/**
 * Calculate the display position of the menu
 * @param clickX - X coordinate of the click
 * @param clickY - Y coordinate of the click
 * @param menuWidth - Width of the menu
 * @param menuHeight - Height of the menu
 * @param containerWidth - Width of the container
 * @param containerHeight - Height of the container
 * @param padding - Redundant padding (default 2px)
 * @returns Left and top coordinates of the menu
 */
function calculateMenuPositionWithPadding(clickX, clickY, menuWidth, menuHeight, containerWidth, containerHeight, padding = 2) {
    let left = clickX + padding;
    let top = clickY + padding;
    if (left + menuWidth > containerWidth) {
        left = clickX - menuWidth - padding;
    }
    if (top + menuHeight > containerHeight) {
        top = clickY - menuHeight - padding;
    }
    left = Math.max(0, Math.min(left, containerWidth - menuWidth));
    top = Math.max(0, Math.min(top, containerHeight - menuHeight));
    return { left, top };
}
/**
 * Position the menu and hide specified menu items
 * @param menuHideCommands - Hide commands configuration
 * @param ev - Mouse event
 */
function hideMenuItems(menuHideCommands, ev) {
    const container = document.querySelector('.app-container');
    if (!container)
        return;
    const { offsetHeight: containerHeight, offsetWidth: containerWidth } = container;
    const { clientX: clickX, clientY: clickY } = ev;
    const menus = document.body.querySelectorAll('.menu');
    const menu = menus[menus.length - 1];
    if (!menu)
        return;
    const menuContainer = menu.querySelector('.menu-scroll');
    if (!menuContainer)
        return;
    // Get menu class names
    const menuClasses = Array.from(menu.classList).filter((className) => menuHideCommands[className]);
    if (!menuClasses.length)
        menuClasses.push('other-menu');
    // Extract plainTexts and regexTexts
    const plainTexts = menuClasses.flatMap((className) => menuHideCommands[className].plainTexts);
    const regexTexts = [
        ...new Set(menuClasses.flatMap((className) => menuHideCommands[className].regexTexts)),
    ].map((regexStr) => new RegExp(regexStr));
    // Handle menu items and separators hiding logic
    const children = Array.from(menuContainer.children);
    const totalChildren = children.length;
    let lastSeparatorIdx = -1;
    children.forEach((child, index) => {
        var _a;
        if (child.classList.contains('menu-item')) {
            const titleElement = child.querySelector('.menu-item-title');
            const title = (_a = titleElement === null || titleElement === void 0 ? void 0 : titleElement.textContent) === null || _a === void 0 ? void 0 : _a.trim();
            if (!title)
                return;
            const shouldHide = plainTexts.includes(title) ||
                regexTexts.some((regex) => regex.test(title));
            if (shouldHide) {
                child.classList.add('custom-menu-hide-item');
            }
        }
        else if (child.classList.contains('menu-separator')) {
            if (shouldHideSeparator(children, lastSeparatorIdx, index)) {
                child.classList.add('custom-menu-hide-separator');
            }
            lastSeparatorIdx = index;
        }
    });
    // Handle the last separator
    if (shouldHideSeparator(children, lastSeparatorIdx, totalChildren)) {
        children[lastSeparatorIdx].classList.add('custom-menu-hide-separator');
    }
    // Calculate menu position and set styles
    const { offsetHeight: menuHeight, offsetWidth: menuWidth } = menu;
    const { left, top } = calculateMenuPositionWithPadding(clickX, clickY, menuWidth, menuHeight, containerWidth, containerHeight);
    menu.style.left = `${left}px`;
    menu.style.top = `${top}px`;
}

class HidingCommandPlugin extends obsidian.Plugin {
    onload() {
        return __awaiter(this, void 0, void 0, function* () {
            console.log('Loading Hide-Commands-in-Menu');
            yield this.loadSettings();
            this.addSettingTab(new HidingCommandSettingsTab(this.app, this));
            const menuHideCommands = {
                'file-menu-tab-header': this.settings.fileMenu.tabHeader,
                'file-menu-more-options': this.settings.fileMenu.moreOptions,
                'file-menu-file-explorer-context-menu': this.settings.fileMenu.fileExplorerContext,
                'file-menu-link-context-menu': this.settings.fileMenu.linkContext,
                'files-menu-file-explorer-context-menu': this.settings.filesMenu.fileExplorerContext,
                'editor-menu': this.settings.editorMenu,
                'url-menu': this.settings.urlMenu,
                'other-menu': this.settings.otherMenu,
            };
            const delayTime = this.settings.delayTime ? this.settings.delayTime : 1;
            const clickEvents = [
                'auxclick',
                'contextmenu',
                'click',
                'dblclick',
            ];
            for (const event of clickEvents) {
                this.registerDomEvent(document.body, event, (ev) => {
                    setTimeout(() => hideMenuItems(menuHideCommands, ev), delayTime);
                });
            }
            this.registerEvent(this.app.workspace.on('file-menu', (menu, file, source) => {
                // console.log('file-menu', source);
                menu.dom.addClass(`file-menu-${source}`);
            }));
            this.registerEvent(this.app.workspace.on('files-menu', (menu, files, source) => {
                // console.log('files-menu', source);
                menu.dom.addClass(`files-menu-${source}`);
            }));
            this.registerEvent(this.app.workspace.on('editor-menu', (menu) => {
                // console.log('editor-menu');
                menu.dom.addClass('editor-menu');
            }));
            this.registerEvent(this.app.workspace.on('url-menu', (menu) => {
                // console.log('url-menu');
                menu.dom.addClass('url-menu');
            }));
        });
    }
    loadSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            this.settings = Object.assign(Object.assign({}, DEFAULT_SETTINGS), (yield this.loadData()));
        });
    }
    saveSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.saveData(this.settings);
        });
    }
}

module.exports = HidingCommandPlugin;


/* nosourcemap */