/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ImagesToGist
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// src/ui/SettingsTab.ts
var import_obsidian2 = require("obsidian");

// src/lib/utils.ts
var import_obsidian = require("obsidian");
var appendBrToFragment = (fragment) => {
  fragment.append(document.createElement("br"));
};
var appendAnchorToFragment = (fragment, textContent, href) => {
  const a = document.createElement("a");
  a.textContent = textContent;
  a.setAttribute("href", href);
  fragment.append(a);
};
var allFilesAreImages = (files) => {
  if (files.length === 0) return false;
  for (let i = 0; i < files.length; i++) {
    if (!files[i].type.startsWith("image")) return false;
  }
  return true;
};
var removeCommitHash = (url) => {
  var _a;
  const splitUrl = url.split("raw");
  const fileName = (_a = splitUrl.pop()) == null ? void 0 : _a.split("/").pop();
  return `${splitUrl[0]}raw/${fileName}`;
};
var createGist = async (file, token) => {
  const base64String = await new Promise((res, rej) => {
    const reader = new FileReader();
    reader.onload = () => {
      const result = reader.result;
      if (!result)
        return rej(new Error(`Unable to convert ${file.name} to base64 string`));
      res((typeof result !== "string" ? result.toString() : result).split(",")[1]);
    };
    reader.onerror = (e) => rej(e);
    reader.readAsDataURL(file);
  });
  const response = await (0, import_obsidian.requestUrl)({
    url: "https://api.github.com/gists",
    method: "POST",
    headers: {
      Authorization: `Bearer ${token}`,
      Accept: "application/vnd.github+json",
      "X-GitHub-Api-Version": "2022-11-28"
    },
    body: JSON.stringify({
      public: false,
      files: { [file.name]: { content: base64String } }
    })
  });
  return response.json;
};
var markdownImgTagRegex = /!\[(.*?)\]\((.*?)\)/g;
var altAndSrcRegex = /!\[(.*?)\]\((.*?)\)/;
var extractAltAndSrcFromMarkdownImg = (markdownImg) => {
  const matchedGroup = markdownImg.match(altAndSrcRegex);
  return matchedGroup ? { alt: matchedGroup[1], src: matchedGroup[2] } : null;
};

// src/ui/SettingsTab.ts
var DEFAULT_SETTINGS = {
  serverUrl: "https://itg.singhinder.com",
  showConfirmationModal: false
};
var GUIDE_BASE_URL = "https://pluginguide.singhinder.com";
var GITHUB_TOKEN_GUIDE = `${GUIDE_BASE_URL}?g=token`;
var SERVER_URL_GUIDE = `${GUIDE_BASE_URL}?g=serverurl`;
var SettingsTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    const token = this.plugin.getToken();
    new import_obsidian2.Setting(containerEl).setName("GitHub token").setDesc(this.githubTokenSettingDesc()).addText((text) => {
      text.inputEl.setAttribute("type", "password");
      text.setPlaceholder("Enter GitHub token");
      text.setValue(token || "");
      text.onChange(async (val) => {
        this.plugin.settings.githubToken = val;
        try {
          await this.app.vault.adapter.write(
            this.plugin.getEnvFilePath(),
            `${this.plugin.githubTokenEnv}=${val}`
          );
        } catch (error) {
          console.error(error);
        }
      });
    });
    new import_obsidian2.Setting(containerEl).setName("Image server url").setDesc(this.getServerUrlDesc()).addText((text) => {
      text.setValue(this.plugin.settings.serverUrl || "");
      text.setPlaceholder(DEFAULT_SETTINGS.serverUrl);
      text.onChange(async (val) => {
        this.plugin.settings.serverUrl = val;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian2.Setting(containerEl).setName("Confirm before upload").setDesc(
      "A dialog appears when you add an image, allowing you to choose between uploading the image or keeping it local."
    ).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.showConfirmationModal);
      toggle.onChange(async (val) => {
        this.plugin.settings.showConfirmationModal = val;
        await this.plugin.saveSettings();
      });
    });
  }
  githubTokenSettingDesc() {
    const fragment = document.createDocumentFragment();
    fragment.append("Token is saved in ");
    const strongTag = document.createElement("strong");
    strongTag.textContent = (0, import_obsidian2.normalizePath)(
      `${this.app.vault.getName()}/${this.plugin.getPluginPath()}/.env`
    );
    fragment.append(strongTag);
    appendBrToFragment(fragment);
    fragment.append("Make sure to exclude this file if you use any sync service.");
    appendBrToFragment(fragment);
    appendAnchorToFragment(
      fragment,
      "Learn how to generate GitHub token",
      GITHUB_TOKEN_GUIDE
    );
    return fragment;
  }
  getServerUrlDesc() {
    const fragment = document.createDocumentFragment();
    fragment.append(
      "Continue to use the default server (completely private & absolutely free) or provide your own."
    );
    appendBrToFragment(fragment);
    appendAnchorToFragment(fragment, "Learn what image server does", SERVER_URL_GUIDE);
    return fragment;
  }
};

// src/ui/UploadConfirmationModal.ts
var import_obsidian3 = require("obsidian");
var UploadConfirmationModal = class extends import_obsidian3.Modal {
  // private localReject: (error: Error) => void;
  constructor(app) {
    super(app);
    this.userResponded = false;
    this.localPromise = new Promise((res, rej) => {
      this.localResolve = res;
    });
  }
  waitForResponse() {
    return this.localPromise;
  }
  respond(response) {
    this.userResponded = true;
    this.localResolve(response);
    this.close();
  }
  onOpen() {
    const { contentEl, titleEl } = this;
    titleEl.setText("Images to gist");
    contentEl.setText("Would you like to create a gist paste your content locally?");
    const buttonsDiv = contentEl.createDiv("modal-button-container");
    new import_obsidian3.ButtonComponent(buttonsDiv).setButtonText("Always upload").setCta().onClick(() => this.respond("alwaysUpload"));
    new import_obsidian3.ButtonComponent(buttonsDiv).setButtonText("Upload").setCta().onClick(() => this.respond("upload"));
    new import_obsidian3.ButtonComponent(buttonsDiv).setButtonText("Paste locally").onClick(() => this.respond("local"));
    contentEl.appendChild(buttonsDiv);
  }
  onClose() {
    [this.contentEl, this.titleEl].forEach((el) => el.empty());
    if (!this.userResponded) this.localResolve();
  }
};

// src/lib/parseEnv.ts
var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/gm;
function parseEnv(lines) {
  const obj = {};
  lines = lines.replace(/\r\n?/gm, "\n");
  let match;
  while ((match = LINE.exec(lines)) != null) {
    const key = match[1];
    let value = match[2] || "";
    value = value.trim();
    const maybeQuote = value[0];
    value = value.replace(/^(['"`])([\s\S]*)\1$/gm, "$2");
    if (maybeQuote === '"') {
      value = value.replace(/\\n/g, "\n");
      value = value.replace(/\\r/g, "\r");
    }
    obj[key] = value;
  }
  return obj;
}

// src/eventClasses/PasteEventCopy.ts
var PasteEventCopy = class extends ClipboardEvent {
  constructor(originalEvent) {
    const data = originalEvent.clipboardData;
    if (!data) return;
    const dt = new DataTransfer();
    const files = data.files;
    for (let i = 0; i < files.length; i += 1) {
      const value = files.item(i);
      if (value) dt.items.add(value);
    }
    super("paste", { clipboardData: dt });
  }
};

// src/eventClasses/DragEventCopy.ts
var DragEventCopy = class _DragEventCopy extends DragEvent {
  static create(fromEvent, files) {
    const dataTransfer = new DataTransfer();
    for (let i = 0; i < files.length; i += 1) {
      dataTransfer.items.add(files[i]);
    }
    return new _DragEventCopy(fromEvent.type, {
      dataTransfer,
      clientX: fromEvent.clientX,
      clientY: fromEvent.clientY
    });
  }
};

// src/ui/UploadBlockingModal.ts
var import_obsidian4 = require("obsidian");
var UploadBlockingModal = class extends import_obsidian4.Modal {
  constructor(app) {
    super(app);
    this.isOpen = false;
  }
  onOpen() {
    this.isOpen = true;
    const { contentEl, titleEl } = this;
    titleEl.setText("Images to gist");
    contentEl.setText("Uploading image...");
    const buttonsDiv = contentEl.createDiv("modal-button-container");
    new import_obsidian4.ButtonComponent(buttonsDiv).setButtonText("Cancel").setCta().onClick(this.close);
    contentEl.append(buttonsDiv);
  }
  onClose() {
    [this.contentEl, this.titleEl].forEach((el) => el.empty());
    this.isOpen = false;
  }
};

// src/lib/Canvas.ts
function buildPasteEventCopy(originalEvent, files) {
  const clipboardData = new DataTransfer();
  for (let i = 0; i < files.length; i += 1) {
    clipboardData.items.add(files[i]);
  }
  return new ClipboardEvent(originalEvent.type, { clipboardData });
}
function createCanvasPasteHandler(plugin, originalPasteHandler) {
  return function(e) {
    return canvasPaste.call(this, plugin, originalPasteHandler, e);
  };
}
async function canvasPaste(plugin, originalPasteHandler, e) {
  var _a;
  const files = (_a = e.clipboardData) == null ? void 0 : _a.files;
  if (!files || !allFilesAreImages(files) || files.length != 1) {
    originalPasteHandler.call(this, e);
    return;
  }
  if (plugin.settings.showConfirmationModal) {
    const modal = new UploadConfirmationModal(plugin.app);
    modal.open();
    const result = await modal.waitForResponse();
    if (!result) return;
    if (result === "alwaysUpload") {
      this.settings.showConfirmationModal = false;
      this.saveSettings();
    } else if (result === "local") {
      originalPasteHandler.call(this, e);
      return;
    }
  }
  const canvas = this.canvas;
  uploadImageOnCanvas(canvas, plugin, buildPasteEventCopy(e, files)).catch(() => {
    originalPasteHandler.call(this, e);
  });
}
async function uploadImageOnCanvas(canvas, plugin, e) {
  var _a;
  const modal = new UploadBlockingModal(plugin.app);
  modal.open();
  const file = (_a = e.clipboardData) == null ? void 0 : _a.files[0];
  if (!file) return;
  try {
    const imgUrl = await plugin.upload(file);
    if (!modal.isOpen) return;
    modal.close();
    canvas.createTextNode({
      pos: canvas.posCenter(),
      position: "center",
      text: `![](${imgUrl})`
    });
  } catch (error) {
    modal.close();
    throw error;
  }
}

// src/main.ts
var ImagesToGist = class _ImagesToGist extends import_obsidian5.Plugin {
  constructor() {
    super(...arguments);
    this.githubTokenEnv = "GITHUB_TOKEN";
    this.customPasteEventCb = async (e, _, markdownView) => {
      var _a;
      if (e instanceof PasteEventCopy) return;
      const files = (_a = e.clipboardData) == null ? void 0 : _a.files;
      if (!files || !allFilesAreImages(files)) return;
      if (!this.getToken()) return this.noGithubTokenNotice();
      if (!this.settings.serverUrl) return this.noServerUrlNotice();
      e.preventDefault();
      if (this.settings.showConfirmationModal) {
        const modal = new UploadConfirmationModal(this.app);
        modal.open();
        const result = await modal.waitForResponse();
        if (!result) return;
        if (result === "alwaysUpload") {
          this.settings.showConfirmationModal = false;
          this.saveSettings();
        } else if (result === "local") {
          return markdownView.currentMode.clipboardManager.handlePaste(
            new PasteEventCopy(e)
          );
        }
      }
      for (let i = 0; i < files.length; i++) {
        this.createGistAndEmbedImage(files[i]).catch(() => {
          markdownView.currentMode.clipboardManager.handlePaste(new PasteEventCopy(e));
        });
      }
    };
    this.customDropEventListener = async (e, _, markdownView) => {
      var _a;
      if (e instanceof DragEventCopy) return;
      if (!this.getToken()) return this.noGithubTokenNotice();
      if (!this.settings.serverUrl) return this.noServerUrlNotice();
      const dataTransfer = e.dataTransfer;
      if (!dataTransfer || dataTransfer.types.length !== 1 || dataTransfer.types[0] !== "Files") {
        return;
      }
      const { files } = dataTransfer;
      if (!allFilesAreImages(files)) return;
      e.preventDefault();
      if (this.settings.showConfirmationModal) {
        const modal = new UploadConfirmationModal(this.app);
        modal.open();
        const result = await modal.waitForResponse();
        if (!result) return;
        if (result === "alwaysUpload") {
          this.settings.showConfirmationModal = false;
          this.saveSettings();
        } else if (result === "local") {
          return markdownView.currentMode.clipboardManager.handleDrop(
            DragEventCopy.create(e, files)
          );
        }
      }
      (_a = this.getEditor()) == null ? void 0 : _a.replaceSelection("\n");
      const promises = [];
      const filesFailedToUpload = [];
      for (let i = 0; i < files.length; i++) {
        const image = files[i];
        const uploadPromise = this.createGistAndEmbedImage(image).catch(() => {
          filesFailedToUpload.push(image);
        });
        promises.push(uploadPromise);
      }
      await Promise.all(promises);
      if (filesFailedToUpload.length === 0) return;
      markdownView.currentMode.clipboardManager.handleDrop(
        DragEventCopy.create(e, filesFailedToUpload)
      );
    };
  }
  noGithubTokenNotice() {
    new import_obsidian5.Notice("\u274C No GitHub token", 3 * 1e3);
  }
  noServerUrlNotice() {
    new import_obsidian5.Notice("\u274C No server url", 3 * 1e3);
  }
  getPluginPath() {
    return this.manifest.dir;
  }
  getToken() {
    return this.settings.githubToken;
  }
  getEnvFilePath() {
    return `${this.getPluginPath()}/.env`;
  }
  async loadEnv() {
    try {
      const data = await this.app.vault.adapter.read(this.getEnvFilePath());
      this.settings.githubToken = parseEnv(data)[this.githubTokenEnv];
    } catch (error) {
      console.log("error loading env file", error.message);
    }
  }
  async onload() {
    await this.loadSettings();
    await this.loadEnv();
    if (!this.getToken()) this.noGithubTokenNotice();
    if (!this.settings.serverUrl) this.noServerUrlNotice();
    this.addSettingTab(new SettingsTab(this.app, this));
    this.setupHandlers();
    this.addCommand({
      id: "update-image-server-urls",
      name: "Update all image server urls",
      editorCallback: (editor, view) => {
        const serverUrl = this.settings.serverUrl;
        if (!serverUrl) return this.noServerUrlNotice();
        const newValue = editor.getValue().replace(markdownImgTagRegex, (matched) => {
          const data = extractAltAndSrcFromMarkdownImg(matched);
          if (!data) return matched;
          const val = data.src.split("?url=").pop();
          if (!val) return matched;
          const updatedUrl = `${serverUrl}?url=${val}`;
          return `![${data.alt}](${updatedUrl})`;
        });
        editor.setValue(newValue);
      }
    });
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    const { githubToken, ...rest } = this.settings;
    await this.saveData({ ...rest });
  }
  setupHandlers() {
    const { workspace } = this.app;
    this.registerEvent(workspace.on("editor-paste", this.customPasteEventCb));
    this.registerEvent(workspace.on("editor-drop", this.customDropEventListener));
    this.registerEvent(
      workspace.on("active-leaf-change", (leaf) => {
        if (!leaf) return;
        const view = leaf.view;
        if (view.getViewType() === "canvas") {
          this.overridePasteHandlerForCanvasView(view);
        }
      })
    );
  }
  async createGistAndEmbedImage(file, atPos) {
    const token = this.getToken();
    const { serverUrl } = this.settings;
    if (!token) return this.noGithubTokenNotice();
    if (!serverUrl) return this.noServerUrlNotice();
    const pasteId = (Math.random() + 1).toString(36).substring(2, 7);
    this.insertTemporaryText(pasteId, atPos);
    try {
      const imgUrl = await this.upload(file);
      const progressText = _ImagesToGist.progressTextFor(pasteId);
      const markDownImage = `![${file.name}](${imgUrl})`;
      const editor = this.getEditor();
      if (editor)
        _ImagesToGist.replaceFirstOccurrence(editor, progressText, markDownImage);
    } catch (error) {
      console.error(`Failed to create gist for ${pasteId}: `, error);
      this.handleFailedUpload(pasteId, `\u26A0\uFE0Ffailed to create gist, ${error.message}`);
      throw error;
    }
  }
  async upload(file) {
    const res = await createGist(file, this.getToken());
    return `${this.settings.serverUrl}?url=${removeCommitHash(res.files[file.name].raw_url)}`;
  }
  handleFailedUpload(pasteId, message) {
    const progressText = _ImagesToGist.progressTextFor(pasteId);
    const editor = this.getEditor();
    if (editor)
      _ImagesToGist.replaceFirstOccurrence(editor, progressText, `<!--${message}-->`);
  }
  static progressTextFor(id) {
    return `![Uploading file...${id}]()`;
  }
  insertTemporaryText(pasteId, atPos) {
    const progressText = _ImagesToGist.progressTextFor(pasteId);
    const replacement = `${progressText}
`;
    const editor = this.getEditor();
    if (!editor) return;
    if (atPos) {
      editor.replaceRange(replacement, atPos, atPos);
    } else {
      editor.replaceSelection(replacement);
    }
  }
  getEditor() {
    const mdView = this.app.workspace.getActiveViewOfType(import_obsidian5.MarkdownView);
    return mdView == null ? void 0 : mdView.editor;
  }
  static replaceFirstOccurrence(editor, target, replacement) {
    const lines = editor.getValue().split("\n");
    for (let i = 0; i < lines.length; i += 1) {
      const ch = lines[i].indexOf(target);
      if (ch === -1) continue;
      const from = { line: i, ch };
      const to = { line: i, ch: ch + target.length };
      editor.replaceRange(replacement, from, to);
      break;
    }
  }
  overridePasteHandlerForCanvasView(view) {
    const originalPasteFn = view.handlePaste;
    view.handlePaste = createCanvasPasteHandler(this, originalPasteFn);
  }
};

/* nosourcemap */