/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all3) => {
  for (var name in all3)
    __defProp(target, name, { get: all3[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => NostrWriterPlugin,
  setAttributes: () => setAttributes
});
module.exports = __toCommonJS(main_exports);
var import_obsidian9 = require("obsidian");

// src/ShortFormModal.ts
var import_obsidian = require("obsidian");
var ShortFormModal = class extends import_obsidian.Modal {
  constructor(app, nostrService, plugin) {
    super(app);
    this.nostrService = nostrService;
    this.plugin = plugin;
  }
  async onOpen() {
    let { contentEl } = this;
    contentEl.createEl("h2", { text: `Write A Short Note` });
    let summaryText = new import_obsidian.TextAreaComponent(contentEl).setPlaceholder("Write a Nostr message here...").setValue("");
    summaryText.inputEl.setCssStyles({
      width: "100%",
      height: "300px",
      marginBottom: "10px",
      marginTop: "10px",
      flex: "row"
    });
    let selectedProfileKey = "default";
    if (this.plugin.settings.profiles.length > 0 && this.plugin.settings.multipleProfilesEnabled) {
      new import_obsidian.Setting(contentEl).setName("Select Profile").setDesc("Select a profile to send this note from.").addDropdown((dropdown) => {
        dropdown.addOption("default", "Default");
        for (const { profileNickname } of this.plugin.settings.profiles) {
          dropdown.addOption(profileNickname, profileNickname);
        }
        dropdown.setValue("default");
        dropdown.onChange(async (value) => {
          selectedProfileKey = value;
          new import_obsidian.Notice(`${selectedProfileKey} selected`);
          console.log(selectedProfileKey);
        });
      });
    }
    contentEl.createEl("hr");
    contentEl.createEl("p", {
      text: `Are you sure you want to send this message to Nostr?`
    }).addClass("publish-modal-info");
    let publishButton = new import_obsidian.ButtonComponent(contentEl);
    publishButton.setButtonText(this.plugin.settings.multipleProfilesEnabled ? `Confirm and Send with Selected Profile` : `Confirm and Send`).setCta().onClick(async () => {
      if (summaryText.getValue().length > 1) {
        publishButton.setButtonText("Sending...").setDisabled(true);
        setTimeout(async () => {
          const summary = summaryText.getValue();
          try {
            let res = await this.nostrService.publishShortFormNote(
              summary,
              selectedProfileKey
            );
            if (res.success) {
              setTimeout(() => {
                new import_obsidian.Notice(
                  `Successfully sent note to Nostr.`
                );
              }, 500);
              for (let relay of res.publishedRelays) {
                setTimeout(() => {
                  new import_obsidian.Notice(`\u2705 - Sent to ${relay}`);
                }, 500);
              }
            } else {
              new import_obsidian.Notice(`\u274C Failed to send note to Nostr.`);
            }
          } catch (e) {
            new import_obsidian.Notice(`\u274C Failed to send note to Nostr.`);
          }
          summaryText.setValue("");
          publishButton.setButtonText("Confirm and Publish").setDisabled(false);
          this.close();
        }, 3e3);
      } else {
        new import_obsidian.Notice(`Please enter text to publish to Nostr`);
      }
    });
    contentEl.classList.add("short-form-modal-content");
    publishButton.buttonEl.classList.add("short-form-modal-button");
    summaryText.inputEl.classList.add("short-form-modal-input");
  }
};

// src/ConfirmPublishModal.ts
var import_obsidian2 = require("obsidian");
var ConfirmPublishModal = class extends import_obsidian2.Modal {
  constructor(app, nostrService, file, plugin) {
    super(app);
    this.nostrService = nostrService;
    this.file = file;
    this.plugin = plugin;
  }
  async onOpen() {
    var _a;
    let { contentEl } = this;
    const frontmatter = (_a = this.app.metadataCache.getFileCache(this.file)) == null ? void 0 : _a.frontmatter;
    if (this.file.extension !== "md") {
      new import_obsidian2.Notice("\u274C Only markdown files can be published.");
      this.close();
      return;
    }
    const frontmatterRegex = /---\s*[\s\S]*?\s*---/g;
    const content = (await this.app.vault.read(this.file)).replace(frontmatterRegex, "").trim();
    const noteWordCount = content.split(" ").length;
    let noteCategoryTags = [];
    const regex3 = /#\w+/g;
    const matches = content.match(regex3) || [];
    const hashtags = matches.map((match) => match.slice(1));
    const properties = {
      title: (frontmatter == null ? void 0 : frontmatter.title) || this.file.basename,
      summary: (frontmatter == null ? void 0 : frontmatter.summary) || "",
      image: isValidURL(frontmatter == null ? void 0 : frontmatter.image) ? frontmatter == null ? void 0 : frontmatter.image : "",
      tags: (frontmatter == null ? void 0 : frontmatter.tags) || hashtags
    };
    for (const tag of properties.tags) {
      noteCategoryTags.push(tag);
    }
    contentEl.createEl("h2", { text: `Publish` });
    const titleContainer = contentEl.createEl("div");
    titleContainer.addClass("publish-title-container");
    titleContainer.createEl("p", { text: `${noteWordCount} words` });
    contentEl.createEl("h6", { text: `Title` });
    let titleText = new import_obsidian2.TextComponent(contentEl).setPlaceholder(`${properties.title}`).setValue(`${properties.title}`);
    contentEl.createEl("h6", { text: `Tags` });
    const tagContainer = contentEl.createEl("div");
    tagContainer.addClass("publish-title-container");
    tagContainer.createEl("p", {
      text: `Tags (#tags) from your file are automatically added below. Add more to help people discover your work. Remove any by clicking the X. `
    });
    let tagsText = new import_obsidian2.TextComponent(contentEl).setPlaceholder(
      `Add a tag here and press enter`
    );
    tagsText.inputEl.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        addTagAsPill(tagsText.getValue());
      }
    });
    tagsText.inputEl.setCssStyles({
      width: "100%",
      marginBottom: "10px"
    });
    const pillsContainer = contentEl.createEl("div");
    pillsContainer.addClass("pills-container");
    noteCategoryTags.forEach((tag) => {
      const pillElement = createPillElement(tag);
      pillsContainer.appendChild(pillElement);
    });
    contentEl.createEl("h6", { text: `Summary` });
    let summaryText = new import_obsidian2.TextAreaComponent(contentEl).setPlaceholder("Optional brief summary of your article...").setValue(properties.summary);
    let selectedBannerImage = null;
    new import_obsidian2.Setting(contentEl).setName("Upload Banner Image").setDesc("Optional image to be shown alongside your articles title.").addButton(
      (button) => button.setButtonText("Upload").setIcon("upload").setTooltip("Upload an image file for your article banner.").onClick(async () => {
        const input = document.createElement("input");
        input.type = "file";
        input.multiple = false;
        input.click();
        input.addEventListener("change", async () => {
          if (input.files !== null) {
            const file = input.files[0];
            if (file) {
              if (!file.type.startsWith("image/")) {
                new import_obsidian2.Notice("\u274C Invalid file type. Please upload an image.");
                return;
              }
              let maxSizeInBytes = 10 * 1024 * 1024;
              if (this.plugin.settings.premiumStorageEnabled) {
                maxSizeInBytes = 100 * 1024 * 1024;
              }
              if (file.size > maxSizeInBytes) {
                new import_obsidian2.Notice("\u274C File size exceeds the limit. Please upload a smaller image.");
                return;
              }
              selectedBannerImage = file;
              imagePreview.src = URL.createObjectURL(selectedBannerImage);
              imagePreview.style.display = "block";
              clearImageButton.style.display = "inline-block";
              imageNameDiv.textContent = selectedBannerImage.name;
              new import_obsidian2.Notice(`\u2705 Selected image : ${file.name}`);
            }
          } else {
            new import_obsidian2.Notice(`\u2757\uFE0F No file selected.`);
          }
        });
      })
    );
    let imagePreview = contentEl.createEl("img");
    imagePreview.setCssStyles({
      maxWidth: "100%",
      display: "none"
    });
    const imageNameDiv = contentEl.createEl("div");
    imageNameDiv.setCssStyles({
      display: "none"
    });
    const clearImageButton = contentEl.createEl("div");
    clearImageButton.setCssStyles({
      display: "none",
      background: "none",
      border: "none",
      cursor: "pointer",
      fontSize: "14px",
      color: "red"
    });
    clearImageButton.textContent = "\u274C Remove image.";
    function clearSelectedImage() {
      selectedBannerImage = null;
      imagePreview.src = "";
      imagePreview.style.display = "none";
      imageNameDiv.textContent = "";
      imageNameDiv.style.display = "none";
      clearImageButton.style.display = "none";
    }
    clearImageButton.addEventListener("click", clearSelectedImage);
    titleText.inputEl.setCssStyles({
      width: "100%",
      marginBottom: "10px"
    });
    summaryText.inputEl.setCssStyles({
      width: "100%",
      height: "75px",
      marginBottom: "10px"
    });
    tagsText.inputEl.setCssStyles({
      width: "100%"
    });
    tagsText.inputEl.addClass("features");
    let selectedProfileKey = "default";
    if (this.plugin.settings.profiles.length > 0 && this.plugin.settings.multipleProfilesEnabled) {
      let x = new import_obsidian2.Setting(contentEl).setName("Select Profile").setDesc("Select a profile to send this note from.").addDropdown((dropdown) => {
        dropdown.addOption("default", "Default");
        for (const { profileNickname } of this.plugin.settings.profiles) {
          dropdown.addOption(profileNickname, profileNickname);
        }
        dropdown.setValue("default");
        dropdown.onChange(async (value) => {
          selectedProfileKey = value;
          new import_obsidian2.Notice(`${selectedProfileKey} selected`);
        });
      });
    }
    let publishAsDraft = false;
    new import_obsidian2.Setting(contentEl).setName("Publish as a draft").setDesc("Nostr clients allow you to edit your drafts later.").addToggle(
      (toggle) => toggle.setValue(false).onChange(async (value) => {
        publishAsDraft = value;
        if (publishAsDraft) {
          new import_obsidian2.Notice(`\u{1F5D2}\uFE0F Publishing as a draft.`);
        } else {
          new import_obsidian2.Notice(`\u{1F4DC} Publishing as final.`);
        }
      })
    );
    contentEl.createEl("hr");
    let info = contentEl.createEl("p", {
      text: `Are you sure you want to publish this note to Nostr?`
    });
    info.addClass("publish-modal-info");
    let publishButton = new import_obsidian2.ButtonComponent(contentEl).setButtonText("Confirm and Publish").setCta().onClick(async () => {
      if (confirm(`Are you sure you want to publish this note ${publishAsDraft ? "as a draft" : "publically"} to Nostr?`)) {
        publishButton.setButtonText("Publishing...").setDisabled(true);
        setTimeout(async () => {
          try {
            const fileContent = content;
            const title = titleText.getValue();
            const summary = summaryText.getValue();
            let res = await this.nostrService.publishNote(
              fileContent,
              this.file,
              summary,
              selectedBannerImage && selectedBannerImage.path ? selectedBannerImage.path : null,
              title,
              noteCategoryTags,
              selectedProfileKey,
              publishAsDraft
            );
            if (res.success) {
              setTimeout(() => {
                new import_obsidian2.Notice(`\u2705 Successfully sent note to Nostr.`);
              }, 500);
              for (let relay of res.publishedRelays) {
                setTimeout(() => {
                  new import_obsidian2.Notice(`\u2705 - Sent to ${relay}`);
                }, 500);
              }
            } else {
              new import_obsidian2.Notice(`\u274C Failed to send note to Nostr.`);
            }
          } catch (error) {
            console.error(error);
            new import_obsidian2.Notice(`\u274C Failed to publish note to Nostr.`);
          }
          publishButton.setButtonText("Confirm and Publish").setDisabled(false);
          this.close();
        }, 3e3);
      }
    });
    contentEl.classList.add("publish-modal-content");
    publishButton.buttonEl.classList.add("publish-modal-button");
    summaryText.inputEl.classList.add("publish-modal-input");
    function createPillElement(tag) {
      const pillElement = document.createElement("div");
      pillElement.className = "pill";
      pillElement.textContent = tag;
      const deleteButton = document.createElement("div");
      deleteButton.className = "delete-button";
      deleteButton.textContent = "x";
      deleteButton.addEventListener("click", () => {
        noteCategoryTags = noteCategoryTags.filter((t) => t !== tag);
        pillElement.remove();
      });
      pillElement.appendChild(deleteButton);
      return pillElement;
    }
    function addTagAsPill(tag) {
      if (tag.trim() === "")
        return;
      noteCategoryTags.push(tag.trim());
      const pillElement = createPillElement(tag.trim());
      pillsContainer.appendChild(pillElement);
      tagsText.setValue("");
    }
  }
};
function isValidURL(url) {
  try {
    new URL(url);
    return true;
  } catch (_) {
    return false;
  }
}

// src/service/NostrService.ts
var path = __toESM(require("path"));

// node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js
function number(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`Wrong positive integer: ${n}`);
}
function bytes(b, ...lengths) {
  if (!(b instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
function hash(hash3) {
  if (typeof hash3 !== "function" || typeof hash3.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(hash3.outputLen);
  number(hash3.blockLen);
}
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}

// node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/crypto.js
var crypto2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

// node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js
var u8a = (a) => a instanceof Uint8Array;
var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var rotr = (word, shift) => word << 32 - shift | word >>> shift;
var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  if (!u8a(data))
    throw new Error(`expected Uint8Array, got ${typeof data}`);
  return data;
}
function concatBytes(...arrays) {
  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
  let pad = 0;
  arrays.forEach((a) => {
    if (!u8a(a))
      throw new Error("Uint8Array expected");
    r.set(a, pad);
    pad += a.length;
  });
  return r;
}
var Hash = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
var toStr = {}.toString;
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes(bytesLength = 32) {
  if (crypto2 && typeof crypto2.getRandomValues === "function") {
    return crypto2.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}

// node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_sha2.js
function setBigUint64(view, byteOffset, value, isLE4) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE4);
  const _32n = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE4 ? 4 : 0;
  const l = isLE4 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE4);
  view.setUint32(byteOffset + l, wl, isLE4);
}
var SHA2 = class extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE4) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE4;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    exists(this);
    const { view, buffer, blockLen } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists(this);
    output(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE4 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i5 = pos; i5 < blockLen; i5++)
      buffer[i5] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE4);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i5 = 0; i5 < outLen; i5++)
      oview.setUint32(4 * i5, state[i5], isLE4);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
};

// node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js
var Chi = (a, b, c) => a & b ^ ~a & c;
var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
var SHA256_K = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
var SHA256 = class extends SHA2 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV[0] | 0;
    this.B = IV[1] | 0;
    this.C = IV[2] | 0;
    this.D = IV[3] | 0;
    this.E = IV[4] | 0;
    this.F = IV[5] | 0;
    this.G = IV[6] | 0;
    this.H = IV[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i5 = 0; i5 < 16; i5++, offset += 4)
      SHA256_W[i5] = view.getUint32(offset, false);
    for (let i5 = 16; i5 < 64; i5++) {
      const W15 = SHA256_W[i5 - 15];
      const W2 = SHA256_W[i5 - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i5] = s1 + SHA256_W[i5 - 7] + s0 + SHA256_W[i5 - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i5 = 0; i5 < 64; i5++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i5] + SHA256_W[i5] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T2 = sigma0 + Maj(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());

// node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/utils.js
var utils_exports = {};
__export(utils_exports, {
  bitGet: () => bitGet,
  bitLen: () => bitLen,
  bitMask: () => bitMask,
  bitSet: () => bitSet,
  bytesToHex: () => bytesToHex,
  bytesToNumberBE: () => bytesToNumberBE,
  bytesToNumberLE: () => bytesToNumberLE,
  concatBytes: () => concatBytes2,
  createHmacDrbg: () => createHmacDrbg,
  ensureBytes: () => ensureBytes,
  equalBytes: () => equalBytes,
  hexToBytes: () => hexToBytes,
  hexToNumber: () => hexToNumber,
  numberToBytesBE: () => numberToBytesBE,
  numberToBytesLE: () => numberToBytesLE,
  numberToHexUnpadded: () => numberToHexUnpadded,
  numberToVarBytesBE: () => numberToVarBytesBE,
  utf8ToBytes: () => utf8ToBytes2,
  validateObject: () => validateObject
});
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
var u8a2 = (a) => a instanceof Uint8Array;
var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i5) => i5.toString(16).padStart(2, "0"));
function bytesToHex(bytes4) {
  if (!u8a2(bytes4))
    throw new Error("Uint8Array expected");
  let hex2 = "";
  for (let i5 = 0; i5 < bytes4.length; i5++) {
    hex2 += hexes[bytes4[i5]];
  }
  return hex2;
}
function numberToHexUnpadded(num) {
  const hex2 = num.toString(16);
  return hex2.length & 1 ? `0${hex2}` : hex2;
}
function hexToNumber(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  return BigInt(hex2 === "" ? "0" : `0x${hex2}`);
}
function hexToBytes(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  const len = hex2.length;
  if (len % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + len);
  const array = new Uint8Array(len / 2);
  for (let i5 = 0; i5 < array.length; i5++) {
    const j = i5 * 2;
    const hexByte = hex2.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array[i5] = byte;
  }
  return array;
}
function bytesToNumberBE(bytes4) {
  return hexToNumber(bytesToHex(bytes4));
}
function bytesToNumberLE(bytes4) {
  if (!u8a2(bytes4))
    throw new Error("Uint8Array expected");
  return hexToNumber(bytesToHex(Uint8Array.from(bytes4).reverse()));
}
function numberToBytesBE(n, len) {
  return hexToBytes(n.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n, len) {
  return numberToBytesBE(n, len).reverse();
}
function numberToVarBytesBE(n) {
  return hexToBytes(numberToHexUnpadded(n));
}
function ensureBytes(title, hex2, expectedLength) {
  let res;
  if (typeof hex2 === "string") {
    try {
      res = hexToBytes(hex2);
    } catch (e) {
      throw new Error(`${title} must be valid hex string, got "${hex2}". Cause: ${e}`);
    }
  } else if (u8a2(hex2)) {
    res = Uint8Array.from(hex2);
  } else {
    throw new Error(`${title} must be hex string or Uint8Array`);
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
  return res;
}
function concatBytes2(...arrays) {
  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
  let pad = 0;
  arrays.forEach((a) => {
    if (!u8a2(a))
      throw new Error("Uint8Array expected");
    r.set(a, pad);
    pad += a.length;
  });
  return r;
}
function equalBytes(b1, b2) {
  if (b1.length !== b2.length)
    return false;
  for (let i5 = 0; i5 < b1.length; i5++)
    if (b1[i5] !== b2[i5])
      return false;
  return true;
}
function utf8ToBytes2(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function bitLen(n) {
  let len;
  for (len = 0; n > _0n; n >>= _1n, len += 1)
    ;
  return len;
}
function bitGet(n, pos) {
  return n >> BigInt(pos) & _1n;
}
var bitSet = (n, pos, value) => {
  return n | (value ? _1n : _0n) << BigInt(pos);
};
var bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
var u8n = (data) => new Uint8Array(data);
var u8fr = (arr) => Uint8Array.from(arr);
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v = u8n(hashLen);
  let k = u8n(hashLen);
  let i5 = 0;
  const reset = () => {
    v.fill(1);
    k.fill(0);
    i5 = 0;
  };
  const h = (...b) => hmacFn(k, v, ...b);
  const reseed = (seed = u8n()) => {
    k = h(u8fr([0]), seed);
    v = h();
    if (seed.length === 0)
      return;
    k = h(u8fr([1]), seed);
    v = h();
  };
  const gen = () => {
    if (i5++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v = h();
      const sl = v.slice();
      out.push(sl);
      len += v.length;
    }
    return concatBytes2(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
var validatorFns = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || val instanceof Uint8Array,
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object) => object.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject(object, validators3, optValidators = {}) {
  const checkField = (fieldName, type, isOptional) => {
    const checkVal = validatorFns[type];
    if (typeof checkVal !== "function")
      throw new Error(`Invalid validator "${type}", expected function`);
    const val = object[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
    }
  };
  for (const [fieldName, type] of Object.entries(validators3))
    checkField(fieldName, type, false);
  for (const [fieldName, type] of Object.entries(optValidators))
    checkField(fieldName, type, true);
  return object;
}

// node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/modular.js
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n2 = BigInt(2);
var _3n = BigInt(3);
var _4n = BigInt(4);
var _5n = BigInt(5);
var _8n = BigInt(8);
var _9n = BigInt(9);
var _16n = BigInt(16);
function mod(a, b) {
  const result = a % b;
  return result >= _0n2 ? result : b + result;
}
function pow(num, power, modulo) {
  if (modulo <= _0n2 || power < _0n2)
    throw new Error("Expected power/modulo > 0");
  if (modulo === _1n2)
    return _0n2;
  let res = _1n2;
  while (power > _0n2) {
    if (power & _1n2)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n2;
  }
  return res;
}
function pow2(x, power, modulo) {
  let res = x;
  while (power-- > _0n2) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number4, modulo) {
  if (number4 === _0n2 || modulo <= _0n2) {
    throw new Error(`invert: expected positive integers, got n=${number4} mod=${modulo}`);
  }
  let a = mod(number4, modulo);
  let b = modulo;
  let x = _0n2, y = _1n2, u2 = _1n2, v = _0n2;
  while (a !== _0n2) {
    const q = b / a;
    const r = b % a;
    const m = x - u2 * q;
    const n = y - v * q;
    b = a, a = r, x = u2, y = v, u2 = m, v = n;
  }
  const gcd2 = b;
  if (gcd2 !== _1n2)
    throw new Error("invert: does not exist");
  return mod(x, modulo);
}
function tonelliShanks(P) {
  const legendreC = (P - _1n2) / _2n2;
  let Q, S, Z;
  for (Q = P - _1n2, S = 0; Q % _2n2 === _0n2; Q /= _2n2, S++)
    ;
  for (Z = _2n2; Z < P && pow(Z, legendreC, P) !== P - _1n2; Z++)
    ;
  if (S === 1) {
    const p1div4 = (P + _1n2) / _4n;
    return function tonelliFast(Fp2, n) {
      const root = Fp2.pow(n, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q + _1n2) / _2n2;
  return function tonelliSlow(Fp2, n) {
    if (Fp2.pow(n, legendreC) === Fp2.neg(Fp2.ONE))
      throw new Error("Cannot find square root");
    let r = S;
    let g = Fp2.pow(Fp2.mul(Fp2.ONE, Z), Q);
    let x = Fp2.pow(n, Q1div2);
    let b = Fp2.pow(n, Q);
    while (!Fp2.eql(b, Fp2.ONE)) {
      if (Fp2.eql(b, Fp2.ZERO))
        return Fp2.ZERO;
      let m = 1;
      for (let t2 = Fp2.sqr(b); m < r; m++) {
        if (Fp2.eql(t2, Fp2.ONE))
          break;
        t2 = Fp2.sqr(t2);
      }
      const ge2 = Fp2.pow(g, _1n2 << BigInt(r - m - 1));
      g = Fp2.sqr(ge2);
      x = Fp2.mul(x, ge2);
      b = Fp2.mul(b, g);
      r = m;
    }
    return x;
  };
}
function FpSqrt(P) {
  if (P % _4n === _3n) {
    const p1div4 = (P + _1n2) / _4n;
    return function sqrt3mod4(Fp2, n) {
      const root = Fp2.pow(n, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _8n === _5n) {
    const c1 = (P - _5n) / _8n;
    return function sqrt5mod8(Fp2, n) {
      const n2 = Fp2.mul(n, _2n2);
      const v = Fp2.pow(n2, c1);
      const nv = Fp2.mul(n, v);
      const i5 = Fp2.mul(Fp2.mul(nv, _2n2), v);
      const root = Fp2.mul(nv, Fp2.sub(i5, Fp2.ONE));
      if (!Fp2.eql(Fp2.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _16n === _9n) {
  }
  return tonelliShanks(P);
}
var FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  return validateObject(field, opts);
}
function FpPow(f, num, power) {
  if (power < _0n2)
    throw new Error("Expected power > 0");
  if (power === _0n2)
    return f.ONE;
  if (power === _1n2)
    return num;
  let p = f.ONE;
  let d = num;
  while (power > _0n2) {
    if (power & _1n2)
      p = f.mul(p, d);
    d = f.sqr(d);
    power >>= _1n2;
  }
  return p;
}
function FpInvertBatch(f, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i5) => {
    if (f.is0(num))
      return acc;
    tmp[i5] = acc;
    return f.mul(acc, num);
  }, f.ONE);
  const inverted = f.inv(lastMultiplied);
  nums.reduceRight((acc, num, i5) => {
    if (f.is0(num))
      return acc;
    tmp[i5] = f.mul(acc, tmp[i5]);
    return f.mul(acc, num);
  }, inverted);
  return tmp;
}
function nLength(n, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLen2, isLE4 = false, redef = {}) {
  if (ORDER <= _0n2)
    throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const sqrtP = FpSqrt(ORDER);
  const f = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n2,
    ONE: _1n2,
    create: (num) => mod(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
      return _0n2 <= num && num < ORDER;
    },
    is0: (num) => num === _0n2,
    isOdd: (num) => (num & _1n2) === _1n2,
    neg: (num) => mod(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod(num * num, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f, num, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
    invertBatch: (lst) => FpInvertBatch(f, lst),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (a, b, c) => c ? b : a,
    toBytes: (num) => isLE4 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes4) => {
      if (bytes4.length !== BYTES)
        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes4.length}`);
      return isLE4 ? bytesToNumberLE(bytes4) : bytesToNumberBE(bytes4);
    }
  });
  return Object.freeze(f);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField(key, fieldOrder, isLE4 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
  const num = isLE4 ? bytesToNumberBE(key) : bytesToNumberLE(key);
  const reduced = mod(num, fieldOrder - _1n2) + _1n2;
  return isLE4 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}

// node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/curve.js
var _0n3 = BigInt(0);
var _1n3 = BigInt(1);
function wNAF(c, bits) {
  const constTimeNegate = (condition, item) => {
    const neg = item.negate();
    return condition ? neg : item;
  };
  const opts = (W) => {
    const windows = Math.ceil(bits / W) + 1;
    const windowSize = 2 ** (W - 1);
    return { windows, windowSize };
  };
  return {
    constTimeNegate,
    // non-const time multiplication ladder
    unsafeLadder(elm, n) {
      let p = c.ZERO;
      let d = elm;
      while (n > _0n3) {
        if (n & _1n3)
          p = p.add(d);
        d = d.double();
        n >>= _1n3;
      }
      return p;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(ùëä‚àí1) * (Math.ceil(ùëõ / ùëä) + 1), where:
     * - ùëä is the window size
     * - ùëõ is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W) {
      const { windows, windowSize } = opts(W);
      const points = [];
      let p = elm;
      let base = p;
      for (let window2 = 0; window2 < windows; window2++) {
        base = p;
        points.push(base);
        for (let i5 = 1; i5 < windowSize; i5++) {
          base = base.add(p);
          points.push(base);
        }
        p = base.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W, precomputes, n) {
      const { windows, windowSize } = opts(W);
      let p = c.ZERO;
      let f = c.BASE;
      const mask = BigInt(2 ** W - 1);
      const maxNumber = 2 ** W;
      const shiftBy = BigInt(W);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset = window2 * windowSize;
        let wbits = Number(n & mask);
        n >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n += _1n3;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f = f.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p = p.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return { p, f };
    },
    wNAFCached(P, precomputesMap, n, transform) {
      const W = P._WINDOW_SIZE || 1;
      let comp = precomputesMap.get(P);
      if (!comp) {
        comp = this.precomputeWindow(P, W);
        if (W !== 1) {
          precomputesMap.set(P, transform(comp));
        }
      }
      return this.wNAF(W, comp, n);
    }
  };
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}

// node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/weierstrass.js
function validatePointOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp: Fp2, a } = opts;
  if (endo) {
    if (!Fp2.eql(a, Fp2.ZERO)) {
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
var { bytesToNumberBE: b2n, hexToBytes: h2b } = utils_exports;
var DER = {
  // asn.1 DER encoding utils
  Err: class DERErr extends Error {
    constructor(m = "") {
      super(m);
    }
  },
  _parseInt(data) {
    const { Err: E } = DER;
    if (data.length < 2 || data[0] !== 2)
      throw new E("Invalid signature integer tag");
    const len = data[1];
    const res = data.subarray(2, len + 2);
    if (!len || res.length !== len)
      throw new E("Invalid signature integer: wrong length");
    if (res[0] & 128)
      throw new E("Invalid signature integer: negative");
    if (res[0] === 0 && !(res[1] & 128))
      throw new E("Invalid signature integer: unnecessary leading zero");
    return { d: b2n(res), l: data.subarray(len + 2) };
  },
  toSig(hex2) {
    const { Err: E } = DER;
    const data = typeof hex2 === "string" ? h2b(hex2) : hex2;
    if (!(data instanceof Uint8Array))
      throw new Error("ui8a expected");
    let l = data.length;
    if (l < 2 || data[0] != 48)
      throw new E("Invalid signature tag");
    if (data[1] !== l - 2)
      throw new E("Invalid signature: incorrect length");
    const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));
    const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);
    if (rBytesLeft.length)
      throw new E("Invalid signature: left bytes after parsing");
    return { r, s };
  },
  hexFromSig(sig) {
    const slice = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
    const h = (num) => {
      const hex2 = num.toString(16);
      return hex2.length & 1 ? `0${hex2}` : hex2;
    };
    const s = slice(h(sig.s));
    const r = slice(h(sig.r));
    const shl = s.length / 2;
    const rhl = r.length / 2;
    const sl = h(shl);
    const rl = h(rhl);
    return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
  }
};
var _0n4 = BigInt(0);
var _1n4 = BigInt(1);
var _2n3 = BigInt(2);
var _3n2 = BigInt(3);
var _4n2 = BigInt(4);
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const { Fp: Fp2 } = CURVE;
  const toBytes4 = CURVE.toBytes || ((_c, point, _isCompressed) => {
    const a = point.toAffine();
    return concatBytes2(Uint8Array.from([4]), Fp2.toBytes(a.x), Fp2.toBytes(a.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes4) => {
    const tail = bytes4.subarray(1);
    const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
    const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
    return { x, y };
  });
  function weierstrassEquation(x) {
    const { a, b } = CURVE;
    const x2 = Fp2.sqr(x);
    const x3 = Fp2.mul(x2, x);
    return Fp2.add(Fp2.add(x3, Fp2.mul(x, a)), b);
  }
  if (!Fp2.eql(Fp2.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return typeof num === "bigint" && _0n4 < num && num < CURVE.n;
  }
  function assertGE(num) {
    if (!isWithinCurveOrder(num))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (key instanceof Uint8Array)
        key = bytesToHex(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("Invalid key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
    } catch (error) {
      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
    }
    if (wrapPrivateKey)
      num = mod(num, n);
    assertGE(num);
    return num;
  }
  const pointPrecomputes = /* @__PURE__ */ new Map();
  function assertPrjPoint(other) {
    if (!(other instanceof Point2))
      throw new Error("ProjectivePoint expected");
  }
  class Point2 {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp2.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp2.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp2.isValid(pz))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p) {
      const { x, y } = p || {};
      if (!p || !Fp2.isValid(x) || !Fp2.isValid(y))
        throw new Error("invalid affine point");
      if (p instanceof Point2)
        throw new Error("projective point not allowed");
      const is0 = (i5) => Fp2.eql(i5, Fp2.ZERO);
      if (is0(x) && is0(y))
        return Point2.ZERO;
      return new Point2(x, y, Fp2.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = Fp2.invertBatch(points.map((p) => p.pz));
      return points.map((p, i5) => p.toAffine(toInv[i5])).map(Point2.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex2) {
      const P = Point2.fromAffine(fromBytes(ensureBytes("pointHex", hex2)));
      P.assertValidity();
      return P;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point2.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (CURVE.allowInfinityPoint && !Fp2.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x, y } = this.toAffine();
      if (!Fp2.isValid(x) || !Fp2.isValid(y))
        throw new Error("bad point: x or y not FE");
      const left = Fp2.sqr(y);
      const right = weierstrassEquation(x);
      if (!Fp2.eql(left, right))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (Fp2.isOdd)
        return !Fp2.isOdd(y);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U1 = Fp2.eql(Fp2.mul(X1, Z2), Fp2.mul(X2, Z1));
      const U2 = Fp2.eql(Fp2.mul(Y1, Z2), Fp2.mul(Y2, Z1));
      return U1 && U2;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point2(this.px, Fp2.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a, b } = CURVE;
      const b3 = Fp2.mul(b, _3n2);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      let t0 = Fp2.mul(X1, X1);
      let t1 = Fp2.mul(Y1, Y1);
      let t2 = Fp2.mul(Z1, Z1);
      let t3 = Fp2.mul(X1, Y1);
      t3 = Fp2.add(t3, t3);
      Z3 = Fp2.mul(X1, Z1);
      Z3 = Fp2.add(Z3, Z3);
      X3 = Fp2.mul(a, Z3);
      Y3 = Fp2.mul(b3, t2);
      Y3 = Fp2.add(X3, Y3);
      X3 = Fp2.sub(t1, Y3);
      Y3 = Fp2.add(t1, Y3);
      Y3 = Fp2.mul(X3, Y3);
      X3 = Fp2.mul(t3, X3);
      Z3 = Fp2.mul(b3, Z3);
      t2 = Fp2.mul(a, t2);
      t3 = Fp2.sub(t0, t2);
      t3 = Fp2.mul(a, t3);
      t3 = Fp2.add(t3, Z3);
      Z3 = Fp2.add(t0, t0);
      t0 = Fp2.add(Z3, t0);
      t0 = Fp2.add(t0, t2);
      t0 = Fp2.mul(t0, t3);
      Y3 = Fp2.add(Y3, t0);
      t2 = Fp2.mul(Y1, Z1);
      t2 = Fp2.add(t2, t2);
      t0 = Fp2.mul(t2, t3);
      X3 = Fp2.sub(X3, t0);
      Z3 = Fp2.mul(t2, t1);
      Z3 = Fp2.add(Z3, Z3);
      Z3 = Fp2.add(Z3, Z3);
      return new Point2(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      const a = CURVE.a;
      const b3 = Fp2.mul(CURVE.b, _3n2);
      let t0 = Fp2.mul(X1, X2);
      let t1 = Fp2.mul(Y1, Y2);
      let t2 = Fp2.mul(Z1, Z2);
      let t3 = Fp2.add(X1, Y1);
      let t4 = Fp2.add(X2, Y2);
      t3 = Fp2.mul(t3, t4);
      t4 = Fp2.add(t0, t1);
      t3 = Fp2.sub(t3, t4);
      t4 = Fp2.add(X1, Z1);
      let t5 = Fp2.add(X2, Z2);
      t4 = Fp2.mul(t4, t5);
      t5 = Fp2.add(t0, t2);
      t4 = Fp2.sub(t4, t5);
      t5 = Fp2.add(Y1, Z1);
      X3 = Fp2.add(Y2, Z2);
      t5 = Fp2.mul(t5, X3);
      X3 = Fp2.add(t1, t2);
      t5 = Fp2.sub(t5, X3);
      Z3 = Fp2.mul(a, t4);
      X3 = Fp2.mul(b3, t2);
      Z3 = Fp2.add(X3, Z3);
      X3 = Fp2.sub(t1, Z3);
      Z3 = Fp2.add(t1, Z3);
      Y3 = Fp2.mul(X3, Z3);
      t1 = Fp2.add(t0, t0);
      t1 = Fp2.add(t1, t0);
      t2 = Fp2.mul(a, t2);
      t4 = Fp2.mul(b3, t4);
      t1 = Fp2.add(t1, t2);
      t2 = Fp2.sub(t0, t2);
      t2 = Fp2.mul(a, t2);
      t4 = Fp2.add(t4, t2);
      t0 = Fp2.mul(t1, t4);
      Y3 = Fp2.add(Y3, t0);
      t0 = Fp2.mul(t5, t4);
      X3 = Fp2.mul(t3, X3);
      X3 = Fp2.sub(X3, t0);
      t0 = Fp2.mul(t3, t1);
      Z3 = Fp2.mul(t5, Z3);
      Z3 = Fp2.add(Z3, t0);
      return new Point2(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point2.ZERO);
    }
    wNAF(n) {
      return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
        const toInv = Fp2.invertBatch(comp.map((p) => p.pz));
        return comp.map((p, i5) => p.toAffine(toInv[i5])).map(Point2.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(n) {
      const I = Point2.ZERO;
      if (n === _0n4)
        return I;
      assertGE(n);
      if (n === _1n4)
        return this;
      const { endo } = CURVE;
      if (!endo)
        return wnaf.unsafeLadder(this, n);
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
      let k1p = I;
      let k2p = I;
      let d = this;
      while (k1 > _0n4 || k2 > _0n4) {
        if (k1 & _1n4)
          k1p = k1p.add(d);
        if (k2 & _1n4)
          k2p = k2p.add(d);
        d = d.double();
        k1 >>= _1n4;
        k2 >>= _1n4;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point2(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      assertGE(scalar);
      let n = scalar;
      let point, fake;
      const { endo } = CURVE;
      if (endo) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point2(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p, f } = this.wNAF(n);
        point = p;
        fake = f;
      }
      return Point2.normalizeZ([point, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q, a, b) {
      const G = Point2.BASE;
      const mul3 = (P, a2) => a2 === _0n4 || a2 === _1n4 || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
      const sum = mul3(this, a).add(mul3(Q, b));
      return sum.is0() ? void 0 : sum;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z) ‚àã (x=x/z, y=y/z)
    toAffine(iz) {
      const { px: x, py: y, pz: z } = this;
      const is0 = this.is0();
      if (iz == null)
        iz = is0 ? Fp2.ONE : Fp2.inv(z);
      const ax = Fp2.mul(x, iz);
      const ay = Fp2.mul(y, iz);
      const zz = Fp2.mul(z, iz);
      if (is0)
        return { x: Fp2.ZERO, y: Fp2.ZERO };
      if (!Fp2.eql(zz, Fp2.ONE))
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n4)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point2, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n4)
        return this;
      if (clearCofactor)
        return clearCofactor(Point2, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      this.assertValidity();
      return toBytes4(Point2, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex(this.toRawBytes(isCompressed));
    }
  }
  Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, Fp2.ONE);
  Point2.ZERO = new Point2(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point2, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point2,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp: Fp2, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp2.BYTES + 1;
  const uncompressedLen = 2 * Fp2.BYTES + 1;
  function isValidFieldElement(num) {
    return _0n4 < num && num < Fp2.ORDER;
  }
  function modN2(a) {
    return mod(a, CURVE_ORDER);
  }
  function invN(a) {
    return invert(a, CURVE_ORDER);
  }
  const { ProjectivePoint: Point2, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(_c, point, isCompressed) {
      const a = point.toAffine();
      const x = Fp2.toBytes(a.x);
      const cat = concatBytes2;
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
      } else {
        return cat(Uint8Array.from([4]), x, Fp2.toBytes(a.y));
      }
    },
    fromBytes(bytes4) {
      const len = bytes4.length;
      const head = bytes4[0];
      const tail = bytes4.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x = bytesToNumberBE(tail);
        if (!isValidFieldElement(x))
          throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x);
        let y = Fp2.sqrt(y2);
        const isYOdd = (y & _1n4) === _1n4;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y = Fp2.neg(y);
        return { x, y };
      } else if (len === uncompressedLen && head === 4) {
        const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
        const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
        return { x, y };
      } else {
        throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
      }
    }
  });
  const numToNByteStr = (num) => bytesToHex(numberToBytesBE(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number4) {
    const HALF = CURVE_ORDER >> _1n4;
    return number4 > HALF;
  }
  function normalizeS(s) {
    return isBiggerThanHalfOrder(s) ? modN2(-s) : s;
  }
  const slcNum = (b, from, to) => bytesToNumberBE(b.slice(from, to));
  class Signature {
    constructor(r, s, recovery) {
      this.r = r;
      this.s = s;
      this.recovery = recovery;
      this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex2) {
      const l = CURVE.nByteLength;
      hex2 = ensureBytes("compactSignature", hex2, l * 2);
      return new Signature(slcNum(hex2, 0, l), slcNum(hex2, l, 2 * l));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex2) {
      const { r, s } = DER.toSig(ensureBytes("DER", hex2));
      return new Signature(r, s);
    }
    assertValidity() {
      if (!isWithinCurveOrder(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!isWithinCurveOrder(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r, s, recovery: rec } = this;
      const h = bits2int_modN(ensureBytes("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
      if (radj >= Fp2.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R = Point2.fromHex(prefix + numToNByteStr(radj));
      const ir = invN(radj);
      const u1 = modN2(-h * ir);
      const u2 = modN2(s * ir);
      const Q = Point2.BASE.multiplyAndAddUnsafe(R, u1, u2);
      if (!Q)
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature(this.r, modN2(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const length = getMinHashLength(CURVE.n);
      return mapHashToField(CURVE.randomBytes(length), CURVE.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(windowSize = 8, point = Point2.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey5(privateKey, isCompressed = true) {
    return Point2.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = item instanceof Uint8Array;
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point2)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b = Point2.fromHex(publicB);
    return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes4) {
    const num = bytesToNumberBE(bytes4);
    const delta = bytes4.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes4) {
    return modN2(bits2int(bytes4));
  };
  const ORDER_MASK = bitMask(CURVE.nBitLength);
  function int2octets(num) {
    if (typeof num !== "bigint")
      throw new Error("bigint expected");
    if (!(_0n4 <= num && num < ORDER_MASK))
      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
    return numberToBytesBE(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k) => k in opts))
      throw new Error("sign() legacy options not supported");
    const { hash: hash3, randomBytes: randomBytes3 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash3(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d), int2octets(h1int)];
    if (ent != null) {
      const e = ent === true ? randomBytes3(Fp2.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e));
    }
    const seed = concatBytes2(...seedArgs);
    const m = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!isWithinCurveOrder(k))
        return;
      const ik = invN(k);
      const q = Point2.BASE.multiply(k).toAffine();
      const r = modN2(q.x);
      if (r === _0n4)
        return;
      const s = modN2(ik * modN2(m + r * d));
      if (s === _0n4)
        return;
      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n4);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = normalizeS(s);
        recovery ^= 1;
      }
      return new Signature(r, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C = CURVE;
    const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
    return drbg(seed, k2sig);
  }
  Point2.BASE._setWindowSize(8);
  function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
    var _a;
    const sg = signature;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey = ensureBytes("publicKey", publicKey);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    const { lowS, prehash } = opts;
    let _sig = void 0;
    let P;
    try {
      if (typeof sg === "string" || sg instanceof Uint8Array) {
        try {
          _sig = Signature.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
          _sig = Signature.fromCompact(sg);
        }
      } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
        const { r: r2, s: s2 } = sg;
        _sig = new Signature(r2, s2);
      } else {
        throw new Error("PARSE");
      }
      P = Point2.fromHex(publicKey);
    } catch (error) {
      if (error.message === "PARSE")
        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
      return false;
    }
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r, s } = _sig;
    const h = bits2int_modN(msgHash);
    const is = invN(s);
    const u1 = modN2(h * is);
    const u2 = modN2(r * is);
    const R = (_a = Point2.BASE.multiplyAndAddUnsafe(P, u1, u2)) == null ? void 0 : _a.toAffine();
    if (!R)
      return false;
    const v = modN2(R.x);
    return v === r;
  }
  return {
    CURVE,
    getPublicKey: getPublicKey5,
    getSharedSecret,
    sign,
    verify,
    ProjectivePoint: Point2,
    Signature,
    utils
  };
}

// node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js
var HMAC = class extends Hash {
  constructor(hash3, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash(hash3);
    const key = toBytes(_key);
    this.iHash = hash3.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash3.create().update(key).digest() : key);
    for (let i5 = 0; i5 < pad.length; i5++)
      pad[i5] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash3.create();
    for (let i5 = 0; i5 < pad.length; i5++)
      pad[i5] ^= 54 ^ 92;
    this.oHash.update(pad);
    pad.fill(0);
  }
  update(buf) {
    exists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    exists(this);
    bytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac = (hash3, key, message) => new HMAC(hash3, key).update(message).digest();
hmac.create = (hash3, key) => new HMAC(hash3, key);

// node_modules/nostr-tools/node_modules/@noble/curves/esm/_shortw_utils.js
function getHash(hash3) {
  return {
    hash: hash3,
    hmac: (key, ...msgs) => hmac(hash3, key, concatBytes(...msgs)),
    randomBytes
  };
}
function createCurve(curveDef, defHash) {
  const create = (hash3) => weierstrass({ ...curveDef, ...getHash(hash3) });
  return Object.freeze({ ...create(defHash), create });
}

// node_modules/nostr-tools/node_modules/@noble/curves/esm/secp256k1.js
var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var _1n5 = BigInt(1);
var _2n4 = BigInt(2);
var divNearest = (a, b) => (a + b / _2n4) / b;
function sqrtMod(y) {
  const P = secp256k1P;
  const _3n3 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P;
  const b3 = b2 * b2 * y % P;
  const b6 = pow2(b3, _3n3, P) * b3 % P;
  const b9 = pow2(b6, _3n3, P) * b3 % P;
  const b11 = pow2(b9, _2n4, P) * b2 % P;
  const b22 = pow2(b11, _11n, P) * b11 % P;
  const b44 = pow2(b22, _22n, P) * b22 % P;
  const b88 = pow2(b44, _44n, P) * b44 % P;
  const b176 = pow2(b88, _88n, P) * b88 % P;
  const b220 = pow2(b176, _44n, P) * b44 % P;
  const b223 = pow2(b220, _3n3, P) * b3 % P;
  const t1 = pow2(b223, _23n, P) * b22 % P;
  const t2 = pow2(t1, _6n, P) * b2 % P;
  const root = pow2(t2, _2n4, P);
  if (!Fp.eql(Fp.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
}
var Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
var secp256k1 = createCurve({
  a: BigInt(0),
  b: BigInt(7),
  Fp,
  n: secp256k1N,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: true,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k) => {
      const n = secp256k1N;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n5 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b2 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest(b2 * k, n);
      const c2 = divNearest(-b1 * k, n);
      let k1 = mod(k - c1 * a1 - c2 * a2, n);
      let k2 = mod(-c1 * b1 - c2 * b2, n);
      const k1neg = k1 > POW_2_128;
      const k2neg = k2 > POW_2_128;
      if (k1neg)
        k1 = n - k1;
      if (k2neg)
        k2 = n - k2;
      if (k1 > POW_2_128 || k2 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k);
      }
      return { k1neg, k1, k2neg, k2 };
    }
  }
}, sha256);
var _0n5 = BigInt(0);
var fe = (x) => typeof x === "bigint" && _0n5 < x && x < secp256k1P;
var ge = (x) => typeof x === "bigint" && _0n5 < x && x < secp256k1N;
var TAGGED_HASH_PREFIXES = {};
function taggedHash(tag, ...messages) {
  let tagP = TAGGED_HASH_PREFIXES[tag];
  if (tagP === void 0) {
    const tagH = sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
    tagP = concatBytes2(tagH, tagH);
    TAGGED_HASH_PREFIXES[tag] = tagP;
  }
  return sha256(concatBytes2(tagP, ...messages));
}
var pointToBytes = (point) => point.toRawBytes(true).slice(1);
var numTo32b = (n) => numberToBytesBE(n, 32);
var modP = (x) => mod(x, secp256k1P);
var modN = (x) => mod(x, secp256k1N);
var Point = secp256k1.ProjectivePoint;
var GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);
function schnorrGetExtPubKey(priv) {
  let d_ = secp256k1.utils.normPrivateKeyToScalar(priv);
  let p = Point.fromPrivateKey(d_);
  const scalar = p.hasEvenY() ? d_ : modN(-d_);
  return { scalar, bytes: pointToBytes(p) };
}
function lift_x(x) {
  if (!fe(x))
    throw new Error("bad x: need 0 < x < p");
  const xx = modP(x * x);
  const c = modP(xx * x + BigInt(7));
  let y = sqrtMod(c);
  if (y % _2n4 !== _0n5)
    y = modP(-y);
  const p = new Point(x, y, _1n5);
  p.assertValidity();
  return p;
}
function challenge(...args) {
  return modN(bytesToNumberBE(taggedHash("BIP0340/challenge", ...args)));
}
function schnorrGetPublicKey(privateKey) {
  return schnorrGetExtPubKey(privateKey).bytes;
}
function schnorrSign(message, privateKey, auxRand = randomBytes(32)) {
  const m = ensureBytes("message", message);
  const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey);
  const a = ensureBytes("auxRand", auxRand, 32);
  const t = numTo32b(d ^ bytesToNumberBE(taggedHash("BIP0340/aux", a)));
  const rand = taggedHash("BIP0340/nonce", t, px, m);
  const k_ = modN(bytesToNumberBE(rand));
  if (k_ === _0n5)
    throw new Error("sign failed: k is zero");
  const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_);
  const e = challenge(rx, px, m);
  const sig = new Uint8Array(64);
  sig.set(rx, 0);
  sig.set(numTo32b(modN(k + e * d)), 32);
  if (!schnorrVerify(sig, m, px))
    throw new Error("sign: Invalid signature produced");
  return sig;
}
function schnorrVerify(signature, message, publicKey) {
  const sig = ensureBytes("signature", signature, 64);
  const m = ensureBytes("message", message);
  const pub = ensureBytes("publicKey", publicKey, 32);
  try {
    const P = lift_x(bytesToNumberBE(pub));
    const r = bytesToNumberBE(sig.subarray(0, 32));
    if (!fe(r))
      return false;
    const s = bytesToNumberBE(sig.subarray(32, 64));
    if (!ge(s))
      return false;
    const e = challenge(numTo32b(r), pointToBytes(P), m);
    const R = GmulAdd(P, s, modN(-e));
    if (!R || !R.hasEvenY() || R.toAffine().x !== r)
      return false;
    return true;
  } catch (error) {
    return false;
  }
}
var schnorr = /* @__PURE__ */ (() => ({
  getPublicKey: schnorrGetPublicKey,
  sign: schnorrSign,
  verify: schnorrVerify,
  utils: {
    randomPrivateKey: secp256k1.utils.randomPrivateKey,
    lift_x,
    pointToBytes,
    numberToBytesBE,
    bytesToNumberBE,
    taggedHash,
    mod
  }
}))();

// node_modules/@noble/hashes/esm/crypto.js
var crypto3 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

// node_modules/@noble/hashes/esm/utils.js
var u8a3 = (a) => a instanceof Uint8Array;
var createView2 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var rotr2 = (word, shift) => word << 32 - shift | word >>> shift;
var isLE2 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE2)
  throw new Error("Non little-endian hardware is not supported");
var hexes2 = Array.from({ length: 256 }, (v, i5) => i5.toString(16).padStart(2, "0"));
function bytesToHex2(bytes4) {
  if (!u8a3(bytes4))
    throw new Error("Uint8Array expected");
  let hex2 = "";
  for (let i5 = 0; i5 < bytes4.length; i5++) {
    hex2 += hexes2[bytes4[i5]];
  }
  return hex2;
}
function hexToBytes2(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  const len = hex2.length;
  if (len % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + len);
  const array = new Uint8Array(len / 2);
  for (let i5 = 0; i5 < array.length; i5++) {
    const j = i5 * 2;
    const hexByte = hex2.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array[i5] = byte;
  }
  return array;
}
function utf8ToBytes3(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes2(data) {
  if (typeof data === "string")
    data = utf8ToBytes3(data);
  if (!u8a3(data))
    throw new Error(`expected Uint8Array, got ${typeof data}`);
  return data;
}
function concatBytes3(...arrays) {
  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
  let pad = 0;
  arrays.forEach((a) => {
    if (!u8a3(a))
      throw new Error("Uint8Array expected");
    r.set(a, pad);
    pad += a.length;
  });
  return r;
}
var Hash2 = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function wrapConstructor2(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes2(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes2(bytesLength = 32) {
  if (crypto3 && typeof crypto3.getRandomValues === "function") {
    return crypto3.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}

// node_modules/@noble/hashes/esm/_assert.js
function number2(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`Wrong positive integer: ${n}`);
}
function bool(b) {
  if (typeof b !== "boolean")
    throw new Error(`Expected boolean, not ${b}`);
}
function bytes2(b, ...lengths) {
  if (!(b instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
function hash2(hash3) {
  if (typeof hash3 !== "function" || typeof hash3.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number2(hash3.outputLen);
  number2(hash3.blockLen);
}
function exists2(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output2(out, instance) {
  bytes2(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}
var assert = {
  number: number2,
  bool,
  bytes: bytes2,
  hash: hash2,
  exists: exists2,
  output: output2
};
var assert_default = assert;

// node_modules/@noble/hashes/esm/_sha2.js
function setBigUint642(view, byteOffset, value, isLE4) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE4);
  const _32n = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE4 ? 4 : 0;
  const l = isLE4 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE4);
  view.setUint32(byteOffset + l, wl, isLE4);
}
var SHA22 = class extends Hash2 {
  constructor(blockLen, outputLen, padOffset, isLE4) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE4;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView2(this.buffer);
  }
  update(data) {
    assert_default.exists(this);
    const { view, buffer, blockLen } = this;
    data = toBytes2(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView2(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    assert_default.exists(this);
    assert_default.output(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE4 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i5 = pos; i5 < blockLen; i5++)
      buffer[i5] = 0;
    setBigUint642(view, blockLen - 8, BigInt(this.length * 8), isLE4);
    this.process(view, 0);
    const oview = createView2(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i5 = 0; i5 < outLen; i5++)
      oview.setUint32(4 * i5, state[i5], isLE4);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
};

// node_modules/@noble/hashes/esm/sha256.js
var Chi2 = (a, b, c) => a & b ^ ~a & c;
var Maj2 = (a, b, c) => a & b ^ a & c ^ b & c;
var SHA256_K2 = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var IV2 = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W2 = new Uint32Array(64);
var SHA2562 = class extends SHA22 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV2[0] | 0;
    this.B = IV2[1] | 0;
    this.C = IV2[2] | 0;
    this.D = IV2[3] | 0;
    this.E = IV2[4] | 0;
    this.F = IV2[5] | 0;
    this.G = IV2[6] | 0;
    this.H = IV2[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i5 = 0; i5 < 16; i5++, offset += 4)
      SHA256_W2[i5] = view.getUint32(offset, false);
    for (let i5 = 16; i5 < 64; i5++) {
      const W15 = SHA256_W2[i5 - 15];
      const W2 = SHA256_W2[i5 - 2];
      const s0 = rotr2(W15, 7) ^ rotr2(W15, 18) ^ W15 >>> 3;
      const s1 = rotr2(W2, 17) ^ rotr2(W2, 19) ^ W2 >>> 10;
      SHA256_W2[i5] = s1 + SHA256_W2[i5 - 7] + s0 + SHA256_W2[i5 - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i5 = 0; i5 < 64; i5++) {
      const sigma1 = rotr2(E, 6) ^ rotr2(E, 11) ^ rotr2(E, 25);
      const T1 = H + sigma1 + Chi2(E, F, G) + SHA256_K2[i5] + SHA256_W2[i5] | 0;
      const sigma0 = rotr2(A, 2) ^ rotr2(A, 13) ^ rotr2(A, 22);
      const T2 = sigma0 + Maj2(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    SHA256_W2.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var SHA224 = class extends SHA2562 {
  constructor() {
    super();
    this.A = 3238371032 | 0;
    this.B = 914150663 | 0;
    this.C = 812702999 | 0;
    this.D = 4144912697 | 0;
    this.E = 4290775857 | 0;
    this.F = 1750603025 | 0;
    this.G = 1694076839 | 0;
    this.H = 3204075428 | 0;
    this.outputLen = 28;
  }
};
var sha2562 = wrapConstructor2(() => new SHA2562());
var sha224 = wrapConstructor2(() => new SHA224());

// node_modules/@scure/base/lib/esm/index.js
function assertNumber(n) {
  if (!Number.isSafeInteger(n))
    throw new Error(`Wrong integer: ${n}`);
}
function chain(...args) {
  const wrap = (a, b) => (c) => a(b(c));
  const encode3 = Array.from(args).reverse().reduce((acc, i5) => acc ? wrap(acc, i5.encode) : i5.encode, void 0);
  const decode3 = args.reduce((acc, i5) => acc ? wrap(acc, i5.decode) : i5.decode, void 0);
  return { encode: encode3, decode: decode3 };
}
function alphabet(alphabet2) {
  return {
    encode: (digits) => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
        throw new Error("alphabet.encode input should be an array of numbers");
      return digits.map((i5) => {
        assertNumber(i5);
        if (i5 < 0 || i5 >= alphabet2.length)
          throw new Error(`Digit index outside alphabet: ${i5} (alphabet: ${alphabet2.length})`);
        return alphabet2[i5];
      });
    },
    decode: (input) => {
      if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
        throw new Error("alphabet.decode input should be array of strings");
      return input.map((letter) => {
        if (typeof letter !== "string")
          throw new Error(`alphabet.decode: not string element=${letter}`);
        const index = alphabet2.indexOf(letter);
        if (index === -1)
          throw new Error(`Unknown letter: "${letter}". Allowed: ${alphabet2}`);
        return index;
      });
    }
  };
}
function join(separator = "") {
  if (typeof separator !== "string")
    throw new Error("join separator should be string");
  return {
    encode: (from) => {
      if (!Array.isArray(from) || from.length && typeof from[0] !== "string")
        throw new Error("join.encode input should be array of strings");
      for (let i5 of from)
        if (typeof i5 !== "string")
          throw new Error(`join.encode: non-string input=${i5}`);
      return from.join(separator);
    },
    decode: (to) => {
      if (typeof to !== "string")
        throw new Error("join.decode input should be string");
      return to.split(separator);
    }
  };
}
function padding(bits, chr = "=") {
  assertNumber(bits);
  if (typeof chr !== "string")
    throw new Error("padding chr should be string");
  return {
    encode(data) {
      if (!Array.isArray(data) || data.length && typeof data[0] !== "string")
        throw new Error("padding.encode input should be array of strings");
      for (let i5 of data)
        if (typeof i5 !== "string")
          throw new Error(`padding.encode: non-string input=${i5}`);
      while (data.length * bits % 8)
        data.push(chr);
      return data;
    },
    decode(input) {
      if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
        throw new Error("padding.encode input should be array of strings");
      for (let i5 of input)
        if (typeof i5 !== "string")
          throw new Error(`padding.decode: non-string input=${i5}`);
      let end = input.length;
      if (end * bits % 8)
        throw new Error("Invalid padding: string should have whole number of bytes");
      for (; end > 0 && input[end - 1] === chr; end--) {
        if (!((end - 1) * bits % 8))
          throw new Error("Invalid padding: string has too much padding");
      }
      return input.slice(0, end);
    }
  };
}
function normalize(fn) {
  if (typeof fn !== "function")
    throw new Error("normalize fn should be function");
  return { encode: (from) => from, decode: (to) => fn(to) };
}
function convertRadix(data, from, to) {
  if (from < 2)
    throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);
  if (to < 2)
    throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);
  if (!Array.isArray(data))
    throw new Error("convertRadix: data should be array");
  if (!data.length)
    return [];
  let pos = 0;
  const res = [];
  const digits = Array.from(data);
  digits.forEach((d) => {
    assertNumber(d);
    if (d < 0 || d >= from)
      throw new Error(`Wrong integer: ${d}`);
  });
  while (true) {
    let carry = 0;
    let done = true;
    for (let i5 = pos; i5 < digits.length; i5++) {
      const digit = digits[i5];
      const digitBase = from * carry + digit;
      if (!Number.isSafeInteger(digitBase) || from * carry / from !== carry || digitBase - digit !== from * carry) {
        throw new Error("convertRadix: carry overflow");
      }
      carry = digitBase % to;
      digits[i5] = Math.floor(digitBase / to);
      if (!Number.isSafeInteger(digits[i5]) || digits[i5] * to + carry !== digitBase)
        throw new Error("convertRadix: carry overflow");
      if (!done)
        continue;
      else if (!digits[i5])
        pos = i5;
      else
        done = false;
    }
    res.push(carry);
    if (done)
      break;
  }
  for (let i5 = 0; i5 < data.length - 1 && data[i5] === 0; i5++)
    res.push(0);
  return res.reverse();
}
var gcd = (a, b) => !b ? a : gcd(b, a % b);
var radix2carry = (from, to) => from + (to - gcd(from, to));
function convertRadix2(data, from, to, padding2) {
  if (!Array.isArray(data))
    throw new Error("convertRadix2: data should be array");
  if (from <= 0 || from > 32)
    throw new Error(`convertRadix2: wrong from=${from}`);
  if (to <= 0 || to > 32)
    throw new Error(`convertRadix2: wrong to=${to}`);
  if (radix2carry(from, to) > 32) {
    throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);
  }
  let carry = 0;
  let pos = 0;
  const mask = 2 ** to - 1;
  const res = [];
  for (const n of data) {
    assertNumber(n);
    if (n >= 2 ** from)
      throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);
    carry = carry << from | n;
    if (pos + from > 32)
      throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
    pos += from;
    for (; pos >= to; pos -= to)
      res.push((carry >> pos - to & mask) >>> 0);
    carry &= 2 ** pos - 1;
  }
  carry = carry << to - pos & mask;
  if (!padding2 && pos >= from)
    throw new Error("Excess padding");
  if (!padding2 && carry)
    throw new Error(`Non-zero padding: ${carry}`);
  if (padding2 && pos > 0)
    res.push(carry >>> 0);
  return res;
}
function radix(num) {
  assertNumber(num);
  return {
    encode: (bytes4) => {
      if (!(bytes4 instanceof Uint8Array))
        throw new Error("radix.encode input should be Uint8Array");
      return convertRadix(Array.from(bytes4), 2 ** 8, num);
    },
    decode: (digits) => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
        throw new Error("radix.decode input should be array of strings");
      return Uint8Array.from(convertRadix(digits, num, 2 ** 8));
    }
  };
}
function radix2(bits, revPadding = false) {
  assertNumber(bits);
  if (bits <= 0 || bits > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (bytes4) => {
      if (!(bytes4 instanceof Uint8Array))
        throw new Error("radix2.encode input should be Uint8Array");
      return convertRadix2(Array.from(bytes4), 8, bits, !revPadding);
    },
    decode: (digits) => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
        throw new Error("radix2.decode input should be array of strings");
      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
    }
  };
}
function unsafeWrapper(fn) {
  if (typeof fn !== "function")
    throw new Error("unsafeWrapper fn should be function");
  return function(...args) {
    try {
      return fn.apply(null, args);
    } catch (e) {
    }
  };
}
var base16 = chain(radix2(4), alphabet("0123456789ABCDEF"), join(""));
var base32 = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding(5), join(""));
var base32hex = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding(5), join(""));
var base32crockford = chain(radix2(5), alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join(""), normalize((s) => s.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
var base64 = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding(6), join(""));
var base64url = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding(6), join(""));
var genBase58 = (abc) => chain(radix(58), alphabet(abc), join(""));
var base58 = genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
var base58flickr = genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
var base58xrp = genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
var XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];
var base58xmr = {
  encode(data) {
    let res = "";
    for (let i5 = 0; i5 < data.length; i5 += 8) {
      const block = data.subarray(i5, i5 + 8);
      res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], "1");
    }
    return res;
  },
  decode(str) {
    let res = [];
    for (let i5 = 0; i5 < str.length; i5 += 11) {
      const slice = str.slice(i5, i5 + 11);
      const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);
      const block = base58.decode(slice);
      for (let j = 0; j < block.length - blockLen; j++) {
        if (block[j] !== 0)
          throw new Error("base58xmr: wrong padding");
      }
      res = res.concat(Array.from(block.slice(block.length - blockLen)));
    }
    return Uint8Array.from(res);
  }
};
var BECH_ALPHABET = chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join(""));
var POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
function bech32Polymod(pre) {
  const b = pre >> 25;
  let chk = (pre & 33554431) << 5;
  for (let i5 = 0; i5 < POLYMOD_GENERATORS.length; i5++) {
    if ((b >> i5 & 1) === 1)
      chk ^= POLYMOD_GENERATORS[i5];
  }
  return chk;
}
function bechChecksum(prefix, words, encodingConst = 1) {
  const len = prefix.length;
  let chk = 1;
  for (let i5 = 0; i5 < len; i5++) {
    const c = prefix.charCodeAt(i5);
    if (c < 33 || c > 126)
      throw new Error(`Invalid prefix (${prefix})`);
    chk = bech32Polymod(chk) ^ c >> 5;
  }
  chk = bech32Polymod(chk);
  for (let i5 = 0; i5 < len; i5++)
    chk = bech32Polymod(chk) ^ prefix.charCodeAt(i5) & 31;
  for (let v of words)
    chk = bech32Polymod(chk) ^ v;
  for (let i5 = 0; i5 < 6; i5++)
    chk = bech32Polymod(chk);
  chk ^= encodingConst;
  return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));
}
function genBech32(encoding) {
  const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
  const _words = radix2(5);
  const fromWords = _words.decode;
  const toWords = _words.encode;
  const fromWordsUnsafe = unsafeWrapper(fromWords);
  function encode3(prefix, words, limit2 = 90) {
    if (typeof prefix !== "string")
      throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);
    if (!Array.isArray(words) || words.length && typeof words[0] !== "number")
      throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);
    const actualLength = prefix.length + 7 + words.length;
    if (limit2 !== false && actualLength > limit2)
      throw new TypeError(`Length ${actualLength} exceeds limit ${limit2}`);
    prefix = prefix.toLowerCase();
    return `${prefix}1${BECH_ALPHABET.encode(words)}${bechChecksum(prefix, words, ENCODING_CONST)}`;
  }
  function decode3(str, limit2 = 90) {
    if (typeof str !== "string")
      throw new Error(`bech32.decode input should be string, not ${typeof str}`);
    if (str.length < 8 || limit2 !== false && str.length > limit2)
      throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit2})`);
    const lowered = str.toLowerCase();
    if (str !== lowered && str !== str.toUpperCase())
      throw new Error(`String must be lowercase or uppercase`);
    str = lowered;
    const sepIndex = str.lastIndexOf("1");
    if (sepIndex === 0 || sepIndex === -1)
      throw new Error(`Letter "1" must be present between prefix and data only`);
    const prefix = str.slice(0, sepIndex);
    const _words2 = str.slice(sepIndex + 1);
    if (_words2.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const words = BECH_ALPHABET.decode(_words2).slice(0, -6);
    const sum = bechChecksum(prefix, words, ENCODING_CONST);
    if (!_words2.endsWith(sum))
      throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
    return { prefix, words };
  }
  const decodeUnsafe = unsafeWrapper(decode3);
  function decodeToBytes(str) {
    const { prefix, words } = decode3(str, false);
    return { prefix, words, bytes: fromWords(words) };
  }
  return { encode: encode3, decode: decode3, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };
}
var bech32 = genBech32("bech32");
var bech32m = genBech32("bech32m");
var utf8 = {
  encode: (data) => new TextDecoder().decode(data),
  decode: (str) => new TextEncoder().encode(str)
};
var hex = chain(radix2(4), alphabet("0123456789abcdef"), join(""), normalize((s) => {
  if (typeof s !== "string" || s.length % 2)
    throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
  return s.toLowerCase();
}));
var CODERS = {
  utf8,
  hex,
  base16,
  base32,
  base64,
  base64url,
  base58,
  base58xmr
};
var coderTypeError = `Invalid encoding type. Available types: ${Object.keys(CODERS).join(", ")}`;

// node_modules/@noble/ciphers/esm/_assert.js
function number3(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`positive integer expected, not ${n}`);
}
function bool2(b) {
  if (typeof b !== "boolean")
    throw new Error(`boolean expected, not ${b}`);
}
function isBytes(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
function bytes3(b, ...lengths) {
  if (!isBytes(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);
}
function exists3(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output3(out, instance) {
  bytes3(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}

// node_modules/@noble/ciphers/esm/utils.js
var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
var createView3 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var isLE3 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE3)
  throw new Error("Non little-endian hardware is not supported");
function utf8ToBytes4(str) {
  if (typeof str !== "string")
    throw new Error(`string expected, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes3(data) {
  if (typeof data === "string")
    data = utf8ToBytes4(data);
  else if (isBytes(data))
    data = data.slice();
  else
    throw new Error(`Uint8Array expected, got ${typeof data}`);
  return data;
}
function checkOpts(defaults2, opts) {
  if (opts == null || typeof opts !== "object")
    throw new Error("options must be defined");
  const merged = Object.assign(defaults2, opts);
  return merged;
}
function equalBytes2(a, b) {
  if (a.length !== b.length)
    return false;
  let diff = 0;
  for (let i5 = 0; i5 < a.length; i5++)
    diff |= a[i5] ^ b[i5];
  return diff === 0;
}
var wrapCipher = (params, c) => {
  Object.assign(c, params);
  return c;
};
function setBigUint643(view, byteOffset, value, isLE4) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE4);
  const _32n = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE4 ? 4 : 0;
  const l = isLE4 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE4);
  view.setUint32(byteOffset + l, wl, isLE4);
}

// node_modules/@noble/ciphers/esm/_polyval.js
var BLOCK_SIZE = 16;
var ZEROS16 = /* @__PURE__ */ new Uint8Array(16);
var ZEROS32 = u32(ZEROS16);
var POLY = 225;
var mul2 = (s0, s1, s2, s3) => {
  const hiBit = s3 & 1;
  return {
    s3: s2 << 31 | s3 >>> 1,
    s2: s1 << 31 | s2 >>> 1,
    s1: s0 << 31 | s1 >>> 1,
    s0: s0 >>> 1 ^ POLY << 24 & -(hiBit & 1)
    // reduce % poly
  };
};
var swapLE = (n) => (n >>> 0 & 255) << 24 | (n >>> 8 & 255) << 16 | (n >>> 16 & 255) << 8 | n >>> 24 & 255 | 0;
function _toGHASHKey(k) {
  k.reverse();
  const hiBit = k[15] & 1;
  let carry = 0;
  for (let i5 = 0; i5 < k.length; i5++) {
    const t = k[i5];
    k[i5] = t >>> 1 | carry;
    carry = (t & 1) << 7;
  }
  k[0] ^= -hiBit & 225;
  return k;
}
var estimateWindow = (bytes4) => {
  if (bytes4 > 64 * 1024)
    return 8;
  if (bytes4 > 1024)
    return 4;
  return 2;
};
var GHASH = class {
  // We select bits per window adaptively based on expectedLength
  constructor(key, expectedLength) {
    this.blockLen = BLOCK_SIZE;
    this.outputLen = BLOCK_SIZE;
    this.s0 = 0;
    this.s1 = 0;
    this.s2 = 0;
    this.s3 = 0;
    this.finished = false;
    key = toBytes3(key);
    bytes3(key, 16);
    const kView = createView3(key);
    let k0 = kView.getUint32(0, false);
    let k1 = kView.getUint32(4, false);
    let k2 = kView.getUint32(8, false);
    let k3 = kView.getUint32(12, false);
    const doubles = [];
    for (let i5 = 0; i5 < 128; i5++) {
      doubles.push({ s0: swapLE(k0), s1: swapLE(k1), s2: swapLE(k2), s3: swapLE(k3) });
      ({ s0: k0, s1: k1, s2: k2, s3: k3 } = mul2(k0, k1, k2, k3));
    }
    const W = estimateWindow(expectedLength || 1024);
    if (![1, 2, 4, 8].includes(W))
      throw new Error(`ghash: wrong window size=${W}, should be 2, 4 or 8`);
    this.W = W;
    const bits = 128;
    const windows = bits / W;
    const windowSize = this.windowSize = 2 ** W;
    const items = [];
    for (let w = 0; w < windows; w++) {
      for (let byte = 0; byte < windowSize; byte++) {
        let s0 = 0, s1 = 0, s2 = 0, s3 = 0;
        for (let j = 0; j < W; j++) {
          const bit = byte >>> W - j - 1 & 1;
          if (!bit)
            continue;
          const { s0: d0, s1: d1, s2: d2, s3: d3 } = doubles[W * w + j];
          s0 ^= d0, s1 ^= d1, s2 ^= d2, s3 ^= d3;
        }
        items.push({ s0, s1, s2, s3 });
      }
    }
    this.t = items;
  }
  _updateBlock(s0, s1, s2, s3) {
    s0 ^= this.s0, s1 ^= this.s1, s2 ^= this.s2, s3 ^= this.s3;
    const { W, t, windowSize } = this;
    let o0 = 0, o1 = 0, o2 = 0, o3 = 0;
    const mask = (1 << W) - 1;
    let w = 0;
    for (const num of [s0, s1, s2, s3]) {
      for (let bytePos = 0; bytePos < 4; bytePos++) {
        const byte = num >>> 8 * bytePos & 255;
        for (let bitPos = 8 / W - 1; bitPos >= 0; bitPos--) {
          const bit = byte >>> W * bitPos & mask;
          const { s0: e0, s1: e1, s2: e2, s3: e3 } = t[w * windowSize + bit];
          o0 ^= e0, o1 ^= e1, o2 ^= e2, o3 ^= e3;
          w += 1;
        }
      }
    }
    this.s0 = o0;
    this.s1 = o1;
    this.s2 = o2;
    this.s3 = o3;
  }
  update(data) {
    data = toBytes3(data);
    exists3(this);
    const b32 = u32(data);
    const blocks = Math.floor(data.length / BLOCK_SIZE);
    const left = data.length % BLOCK_SIZE;
    for (let i5 = 0; i5 < blocks; i5++) {
      this._updateBlock(b32[i5 * 4 + 0], b32[i5 * 4 + 1], b32[i5 * 4 + 2], b32[i5 * 4 + 3]);
    }
    if (left) {
      ZEROS16.set(data.subarray(blocks * BLOCK_SIZE));
      this._updateBlock(ZEROS32[0], ZEROS32[1], ZEROS32[2], ZEROS32[3]);
      ZEROS32.fill(0);
    }
    return this;
  }
  destroy() {
    const { t } = this;
    for (const elm of t) {
      elm.s0 = 0, elm.s1 = 0, elm.s2 = 0, elm.s3 = 0;
    }
  }
  digestInto(out) {
    exists3(this);
    output3(out, this);
    this.finished = true;
    const { s0, s1, s2, s3 } = this;
    const o32 = u32(out);
    o32[0] = s0;
    o32[1] = s1;
    o32[2] = s2;
    o32[3] = s3;
    return out;
  }
  digest() {
    const res = new Uint8Array(BLOCK_SIZE);
    this.digestInto(res);
    this.destroy();
    return res;
  }
};
var Polyval = class extends GHASH {
  constructor(key, expectedLength) {
    key = toBytes3(key);
    const ghKey = _toGHASHKey(key.slice());
    super(ghKey, expectedLength);
    ghKey.fill(0);
  }
  update(data) {
    data = toBytes3(data);
    exists3(this);
    const b32 = u32(data);
    const left = data.length % BLOCK_SIZE;
    const blocks = Math.floor(data.length / BLOCK_SIZE);
    for (let i5 = 0; i5 < blocks; i5++) {
      this._updateBlock(swapLE(b32[i5 * 4 + 3]), swapLE(b32[i5 * 4 + 2]), swapLE(b32[i5 * 4 + 1]), swapLE(b32[i5 * 4 + 0]));
    }
    if (left) {
      ZEROS16.set(data.subarray(blocks * BLOCK_SIZE));
      this._updateBlock(swapLE(ZEROS32[3]), swapLE(ZEROS32[2]), swapLE(ZEROS32[1]), swapLE(ZEROS32[0]));
      ZEROS32.fill(0);
    }
    return this;
  }
  digestInto(out) {
    exists3(this);
    output3(out, this);
    this.finished = true;
    const { s0, s1, s2, s3 } = this;
    const o32 = u32(out);
    o32[0] = s0;
    o32[1] = s1;
    o32[2] = s2;
    o32[3] = s3;
    return out.reverse();
  }
};
function wrapConstructorWithKey(hashCons) {
  const hashC = (msg, key) => hashCons(key, msg.length).update(toBytes3(msg)).digest();
  const tmp = hashCons(new Uint8Array(16), 0);
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (key, expectedLength) => hashCons(key, expectedLength);
  return hashC;
}
var ghash = wrapConstructorWithKey((key, expectedLength) => new GHASH(key, expectedLength));
var polyval = wrapConstructorWithKey((key, expectedLength) => new Polyval(key, expectedLength));

// node_modules/@noble/ciphers/esm/aes.js
var BLOCK_SIZE2 = 16;
var BLOCK_SIZE32 = 4;
var EMPTY_BLOCK = new Uint8Array(BLOCK_SIZE2);
var POLY2 = 283;
function mul22(n) {
  return n << 1 ^ POLY2 & -(n >> 7);
}
function mul(a, b) {
  let res = 0;
  for (; b > 0; b >>= 1) {
    res ^= a & -(b & 1);
    a = mul22(a);
  }
  return res;
}
var sbox = /* @__PURE__ */ (() => {
  let t = new Uint8Array(256);
  for (let i5 = 0, x = 1; i5 < 256; i5++, x ^= mul22(x))
    t[i5] = x;
  const box = new Uint8Array(256);
  box[0] = 99;
  for (let i5 = 0; i5 < 255; i5++) {
    let x = t[255 - i5];
    x |= x << 8;
    box[t[i5]] = (x ^ x >> 4 ^ x >> 5 ^ x >> 6 ^ x >> 7 ^ 99) & 255;
  }
  return box;
})();
var invSbox = /* @__PURE__ */ sbox.map((_, j) => sbox.indexOf(j));
var rotr32_8 = (n) => n << 24 | n >>> 8;
var rotl32_8 = (n) => n << 8 | n >>> 24;
function genTtable(sbox2, fn) {
  if (sbox2.length !== 256)
    throw new Error("Wrong sbox length");
  const T0 = new Uint32Array(256).map((_, j) => fn(sbox2[j]));
  const T1 = T0.map(rotl32_8);
  const T2 = T1.map(rotl32_8);
  const T3 = T2.map(rotl32_8);
  const T01 = new Uint32Array(256 * 256);
  const T23 = new Uint32Array(256 * 256);
  const sbox22 = new Uint16Array(256 * 256);
  for (let i5 = 0; i5 < 256; i5++) {
    for (let j = 0; j < 256; j++) {
      const idx = i5 * 256 + j;
      T01[idx] = T0[i5] ^ T1[j];
      T23[idx] = T2[i5] ^ T3[j];
      sbox22[idx] = sbox2[i5] << 8 | sbox2[j];
    }
  }
  return { sbox: sbox2, sbox2: sbox22, T0, T1, T2, T3, T01, T23 };
}
var tableEncoding = /* @__PURE__ */ genTtable(sbox, (s) => mul(s, 3) << 24 | s << 16 | s << 8 | mul(s, 2));
var tableDecoding = /* @__PURE__ */ genTtable(invSbox, (s) => mul(s, 11) << 24 | mul(s, 13) << 16 | mul(s, 9) << 8 | mul(s, 14));
var xPowers = /* @__PURE__ */ (() => {
  const p = new Uint8Array(16);
  for (let i5 = 0, x = 1; i5 < 16; i5++, x = mul22(x))
    p[i5] = x;
  return p;
})();
function expandKeyLE(key) {
  bytes3(key);
  const len = key.length;
  if (![16, 24, 32].includes(len))
    throw new Error(`aes: wrong key size: should be 16, 24 or 32, got: ${len}`);
  const { sbox2 } = tableEncoding;
  const k32 = u32(key);
  const Nk = k32.length;
  const subByte = (n) => applySbox(sbox2, n, n, n, n);
  const xk = new Uint32Array(len + 28);
  xk.set(k32);
  for (let i5 = Nk; i5 < xk.length; i5++) {
    let t = xk[i5 - 1];
    if (i5 % Nk === 0)
      t = subByte(rotr32_8(t)) ^ xPowers[i5 / Nk - 1];
    else if (Nk > 6 && i5 % Nk === 4)
      t = subByte(t);
    xk[i5] = xk[i5 - Nk] ^ t;
  }
  return xk;
}
function expandKeyDecLE(key) {
  const encKey = expandKeyLE(key);
  const xk = encKey.slice();
  const Nk = encKey.length;
  const { sbox2 } = tableEncoding;
  const { T0, T1, T2, T3 } = tableDecoding;
  for (let i5 = 0; i5 < Nk; i5 += 4) {
    for (let j = 0; j < 4; j++)
      xk[i5 + j] = encKey[Nk - i5 - 4 + j];
  }
  encKey.fill(0);
  for (let i5 = 4; i5 < Nk - 4; i5++) {
    const x = xk[i5];
    const w = applySbox(sbox2, x, x, x, x);
    xk[i5] = T0[w & 255] ^ T1[w >>> 8 & 255] ^ T2[w >>> 16 & 255] ^ T3[w >>> 24];
  }
  return xk;
}
function apply0123(T01, T23, s0, s1, s2, s3) {
  return T01[s0 << 8 & 65280 | s1 >>> 8 & 255] ^ T23[s2 >>> 8 & 65280 | s3 >>> 24 & 255];
}
function applySbox(sbox2, s0, s1, s2, s3) {
  return sbox2[s0 & 255 | s1 & 65280] | sbox2[s2 >>> 16 & 255 | s3 >>> 16 & 65280] << 16;
}
function encrypt(xk, s0, s1, s2, s3) {
  const { sbox2, T01, T23 } = tableEncoding;
  let k = 0;
  s0 ^= xk[k++], s1 ^= xk[k++], s2 ^= xk[k++], s3 ^= xk[k++];
  const rounds = xk.length / 4 - 2;
  for (let i5 = 0; i5 < rounds; i5++) {
    const t02 = xk[k++] ^ apply0123(T01, T23, s0, s1, s2, s3);
    const t12 = xk[k++] ^ apply0123(T01, T23, s1, s2, s3, s0);
    const t22 = xk[k++] ^ apply0123(T01, T23, s2, s3, s0, s1);
    const t32 = xk[k++] ^ apply0123(T01, T23, s3, s0, s1, s2);
    s0 = t02, s1 = t12, s2 = t22, s3 = t32;
  }
  const t0 = xk[k++] ^ applySbox(sbox2, s0, s1, s2, s3);
  const t1 = xk[k++] ^ applySbox(sbox2, s1, s2, s3, s0);
  const t2 = xk[k++] ^ applySbox(sbox2, s2, s3, s0, s1);
  const t3 = xk[k++] ^ applySbox(sbox2, s3, s0, s1, s2);
  return { s0: t0, s1: t1, s2: t2, s3: t3 };
}
function decrypt(xk, s0, s1, s2, s3) {
  const { sbox2, T01, T23 } = tableDecoding;
  let k = 0;
  s0 ^= xk[k++], s1 ^= xk[k++], s2 ^= xk[k++], s3 ^= xk[k++];
  const rounds = xk.length / 4 - 2;
  for (let i5 = 0; i5 < rounds; i5++) {
    const t02 = xk[k++] ^ apply0123(T01, T23, s0, s3, s2, s1);
    const t12 = xk[k++] ^ apply0123(T01, T23, s1, s0, s3, s2);
    const t22 = xk[k++] ^ apply0123(T01, T23, s2, s1, s0, s3);
    const t32 = xk[k++] ^ apply0123(T01, T23, s3, s2, s1, s0);
    s0 = t02, s1 = t12, s2 = t22, s3 = t32;
  }
  const t0 = xk[k++] ^ applySbox(sbox2, s0, s3, s2, s1);
  const t1 = xk[k++] ^ applySbox(sbox2, s1, s0, s3, s2);
  const t2 = xk[k++] ^ applySbox(sbox2, s2, s1, s0, s3);
  const t3 = xk[k++] ^ applySbox(sbox2, s3, s2, s1, s0);
  return { s0: t0, s1: t1, s2: t2, s3: t3 };
}
function getDst(len, dst) {
  if (!dst)
    return new Uint8Array(len);
  bytes3(dst);
  if (dst.length < len)
    throw new Error(`aes: wrong destination length, expected at least ${len}, got: ${dst.length}`);
  return dst;
}
function ctrCounter(xk, nonce, src, dst) {
  bytes3(nonce, BLOCK_SIZE2);
  bytes3(src);
  const srcLen = src.length;
  dst = getDst(srcLen, dst);
  const ctr3 = nonce;
  const c32 = u32(ctr3);
  let { s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]);
  const src32 = u32(src);
  const dst32 = u32(dst);
  for (let i5 = 0; i5 + 4 <= src32.length; i5 += 4) {
    dst32[i5 + 0] = src32[i5 + 0] ^ s0;
    dst32[i5 + 1] = src32[i5 + 1] ^ s1;
    dst32[i5 + 2] = src32[i5 + 2] ^ s2;
    dst32[i5 + 3] = src32[i5 + 3] ^ s3;
    let carry = 1;
    for (let i6 = ctr3.length - 1; i6 >= 0; i6--) {
      carry = carry + (ctr3[i6] & 255) | 0;
      ctr3[i6] = carry & 255;
      carry >>>= 8;
    }
    ({ s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]));
  }
  const start = BLOCK_SIZE2 * Math.floor(src32.length / BLOCK_SIZE32);
  if (start < srcLen) {
    const b32 = new Uint32Array([s0, s1, s2, s3]);
    const buf = u8(b32);
    for (let i5 = start, pos = 0; i5 < srcLen; i5++, pos++)
      dst[i5] = src[i5] ^ buf[pos];
  }
  return dst;
}
function ctr32(xk, isLE4, nonce, src, dst) {
  bytes3(nonce, BLOCK_SIZE2);
  bytes3(src);
  dst = getDst(src.length, dst);
  const ctr3 = nonce;
  const c32 = u32(ctr3);
  const view = createView3(ctr3);
  const src32 = u32(src);
  const dst32 = u32(dst);
  const ctrPos = isLE4 ? 0 : 12;
  const srcLen = src.length;
  let ctrNum = view.getUint32(ctrPos, isLE4);
  let { s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]);
  for (let i5 = 0; i5 + 4 <= src32.length; i5 += 4) {
    dst32[i5 + 0] = src32[i5 + 0] ^ s0;
    dst32[i5 + 1] = src32[i5 + 1] ^ s1;
    dst32[i5 + 2] = src32[i5 + 2] ^ s2;
    dst32[i5 + 3] = src32[i5 + 3] ^ s3;
    ctrNum = ctrNum + 1 >>> 0;
    view.setUint32(ctrPos, ctrNum, isLE4);
    ({ s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]));
  }
  const start = BLOCK_SIZE2 * Math.floor(src32.length / BLOCK_SIZE32);
  if (start < srcLen) {
    const b32 = new Uint32Array([s0, s1, s2, s3]);
    const buf = u8(b32);
    for (let i5 = start, pos = 0; i5 < srcLen; i5++, pos++)
      dst[i5] = src[i5] ^ buf[pos];
  }
  return dst;
}
var ctr = wrapCipher({ blockSize: 16, nonceLength: 16 }, function ctr2(key, nonce) {
  bytes3(key);
  bytes3(nonce, BLOCK_SIZE2);
  function processCtr(buf, dst) {
    const xk = expandKeyLE(key);
    const n = nonce.slice();
    const out = ctrCounter(xk, n, buf, dst);
    xk.fill(0);
    n.fill(0);
    return out;
  }
  return {
    encrypt: (plaintext, dst) => processCtr(plaintext, dst),
    decrypt: (ciphertext, dst) => processCtr(ciphertext, dst)
  };
});
function validateBlockDecrypt(data) {
  bytes3(data);
  if (data.length % BLOCK_SIZE2 !== 0) {
    throw new Error(`aes/(cbc-ecb).decrypt ciphertext should consist of blocks with size ${BLOCK_SIZE2}`);
  }
}
function validateBlockEncrypt(plaintext, pcks5, dst) {
  let outLen = plaintext.length;
  const remaining = outLen % BLOCK_SIZE2;
  if (!pcks5 && remaining !== 0)
    throw new Error("aec/(cbc-ecb): unpadded plaintext with disabled padding");
  const b = u32(plaintext);
  if (pcks5) {
    let left = BLOCK_SIZE2 - remaining;
    if (!left)
      left = BLOCK_SIZE2;
    outLen = outLen + left;
  }
  const out = getDst(outLen, dst);
  const o = u32(out);
  return { b, o, out };
}
function validatePCKS(data, pcks5) {
  if (!pcks5)
    return data;
  const len = data.length;
  if (!len)
    throw new Error(`aes/pcks5: empty ciphertext not allowed`);
  const lastByte = data[len - 1];
  if (lastByte <= 0 || lastByte > 16)
    throw new Error(`aes/pcks5: wrong padding byte: ${lastByte}`);
  const out = data.subarray(0, -lastByte);
  for (let i5 = 0; i5 < lastByte; i5++)
    if (data[len - i5 - 1] !== lastByte)
      throw new Error(`aes/pcks5: wrong padding`);
  return out;
}
function padPCKS(left) {
  const tmp = new Uint8Array(16);
  const tmp32 = u32(tmp);
  tmp.set(left);
  const paddingByte = BLOCK_SIZE2 - left.length;
  for (let i5 = BLOCK_SIZE2 - paddingByte; i5 < BLOCK_SIZE2; i5++)
    tmp[i5] = paddingByte;
  return tmp32;
}
var ecb = wrapCipher({ blockSize: 16 }, function ecb2(key, opts = {}) {
  bytes3(key);
  const pcks5 = !opts.disablePadding;
  return {
    encrypt: (plaintext, dst) => {
      bytes3(plaintext);
      const { b, o, out: _out } = validateBlockEncrypt(plaintext, pcks5, dst);
      const xk = expandKeyLE(key);
      let i5 = 0;
      for (; i5 + 4 <= b.length; ) {
        const { s0, s1, s2, s3 } = encrypt(xk, b[i5 + 0], b[i5 + 1], b[i5 + 2], b[i5 + 3]);
        o[i5++] = s0, o[i5++] = s1, o[i5++] = s2, o[i5++] = s3;
      }
      if (pcks5) {
        const tmp32 = padPCKS(plaintext.subarray(i5 * 4));
        const { s0, s1, s2, s3 } = encrypt(xk, tmp32[0], tmp32[1], tmp32[2], tmp32[3]);
        o[i5++] = s0, o[i5++] = s1, o[i5++] = s2, o[i5++] = s3;
      }
      xk.fill(0);
      return _out;
    },
    decrypt: (ciphertext, dst) => {
      validateBlockDecrypt(ciphertext);
      const xk = expandKeyDecLE(key);
      const out = getDst(ciphertext.length, dst);
      const b = u32(ciphertext);
      const o = u32(out);
      for (let i5 = 0; i5 + 4 <= b.length; ) {
        const { s0, s1, s2, s3 } = decrypt(xk, b[i5 + 0], b[i5 + 1], b[i5 + 2], b[i5 + 3]);
        o[i5++] = s0, o[i5++] = s1, o[i5++] = s2, o[i5++] = s3;
      }
      xk.fill(0);
      return validatePCKS(out, pcks5);
    }
  };
});
var cbc = wrapCipher({ blockSize: 16, nonceLength: 16 }, function cbc2(key, iv, opts = {}) {
  bytes3(key);
  bytes3(iv, 16);
  const pcks5 = !opts.disablePadding;
  return {
    encrypt: (plaintext, dst) => {
      const xk = expandKeyLE(key);
      const { b, o, out: _out } = validateBlockEncrypt(plaintext, pcks5, dst);
      const n32 = u32(iv);
      let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];
      let i5 = 0;
      for (; i5 + 4 <= b.length; ) {
        s0 ^= b[i5 + 0], s1 ^= b[i5 + 1], s2 ^= b[i5 + 2], s3 ^= b[i5 + 3];
        ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));
        o[i5++] = s0, o[i5++] = s1, o[i5++] = s2, o[i5++] = s3;
      }
      if (pcks5) {
        const tmp32 = padPCKS(plaintext.subarray(i5 * 4));
        s0 ^= tmp32[0], s1 ^= tmp32[1], s2 ^= tmp32[2], s3 ^= tmp32[3];
        ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));
        o[i5++] = s0, o[i5++] = s1, o[i5++] = s2, o[i5++] = s3;
      }
      xk.fill(0);
      return _out;
    },
    decrypt: (ciphertext, dst) => {
      validateBlockDecrypt(ciphertext);
      const xk = expandKeyDecLE(key);
      const n32 = u32(iv);
      const out = getDst(ciphertext.length, dst);
      const b = u32(ciphertext);
      const o = u32(out);
      let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];
      for (let i5 = 0; i5 + 4 <= b.length; ) {
        const ps0 = s0, ps1 = s1, ps2 = s2, ps3 = s3;
        s0 = b[i5 + 0], s1 = b[i5 + 1], s2 = b[i5 + 2], s3 = b[i5 + 3];
        const { s0: o0, s1: o1, s2: o2, s3: o3 } = decrypt(xk, s0, s1, s2, s3);
        o[i5++] = o0 ^ ps0, o[i5++] = o1 ^ ps1, o[i5++] = o2 ^ ps2, o[i5++] = o3 ^ ps3;
      }
      xk.fill(0);
      return validatePCKS(out, pcks5);
    }
  };
});
function computeTag(fn, isLE4, key, data, AAD) {
  const h = fn.create(key, data.length + ((AAD == null ? void 0 : AAD.length) || 0));
  if (AAD)
    h.update(AAD);
  h.update(data);
  const num = new Uint8Array(16);
  const view = createView3(num);
  if (AAD)
    setBigUint643(view, 0, BigInt(AAD.length * 8), isLE4);
  setBigUint643(view, 8, BigInt(data.length * 8), isLE4);
  h.update(num);
  return h.digest();
}
var gcm = wrapCipher({ blockSize: 16, nonceLength: 12, tagLength: 16 }, function gcm2(key, nonce, AAD) {
  bytes3(nonce);
  if (nonce.length === 0)
    throw new Error("aes/gcm: empty nonce");
  const tagLength = 16;
  function _computeTag(authKey, tagMask, data) {
    const tag = computeTag(ghash, false, authKey, data, AAD);
    for (let i5 = 0; i5 < tagMask.length; i5++)
      tag[i5] ^= tagMask[i5];
    return tag;
  }
  function deriveKeys() {
    const xk = expandKeyLE(key);
    const authKey = EMPTY_BLOCK.slice();
    const counter = EMPTY_BLOCK.slice();
    ctr32(xk, false, counter, counter, authKey);
    if (nonce.length === 12) {
      counter.set(nonce);
    } else {
      const nonceLen = EMPTY_BLOCK.slice();
      const view = createView3(nonceLen);
      setBigUint643(view, 8, BigInt(nonce.length * 8), false);
      ghash.create(authKey).update(nonce).update(nonceLen).digestInto(counter);
    }
    const tagMask = ctr32(xk, false, counter, EMPTY_BLOCK);
    return { xk, authKey, counter, tagMask };
  }
  return {
    encrypt: (plaintext) => {
      bytes3(plaintext);
      const { xk, authKey, counter, tagMask } = deriveKeys();
      const out = new Uint8Array(plaintext.length + tagLength);
      ctr32(xk, false, counter, plaintext, out);
      const tag = _computeTag(authKey, tagMask, out.subarray(0, out.length - tagLength));
      out.set(tag, plaintext.length);
      xk.fill(0);
      return out;
    },
    decrypt: (ciphertext) => {
      bytes3(ciphertext);
      if (ciphertext.length < tagLength)
        throw new Error(`aes/gcm: ciphertext less than tagLen (${tagLength})`);
      const { xk, authKey, counter, tagMask } = deriveKeys();
      const data = ciphertext.subarray(0, -tagLength);
      const passedTag = ciphertext.subarray(-tagLength);
      const tag = _computeTag(authKey, tagMask, data);
      if (!equalBytes2(tag, passedTag))
        throw new Error("aes/gcm: invalid ghash tag");
      const out = ctr32(xk, false, counter, data);
      authKey.fill(0);
      tagMask.fill(0);
      xk.fill(0);
      return out;
    }
  };
});
var limit = (name, min, max) => (value) => {
  if (!Number.isSafeInteger(value) || min > value || value > max)
    throw new Error(`${name}: invalid value=${value}, must be [${min}..${max}]`);
};
var siv = wrapCipher({ blockSize: 16, nonceLength: 12, tagLength: 16 }, function siv2(key, nonce, AAD) {
  const tagLength = 16;
  const AAD_LIMIT = limit("AAD", 0, 2 ** 36);
  const PLAIN_LIMIT = limit("plaintext", 0, 2 ** 36);
  const NONCE_LIMIT = limit("nonce", 12, 12);
  const CIPHER_LIMIT = limit("ciphertext", 16, 2 ** 36 + 16);
  bytes3(nonce);
  NONCE_LIMIT(nonce.length);
  if (AAD) {
    bytes3(AAD);
    AAD_LIMIT(AAD.length);
  }
  function deriveKeys() {
    const len = key.length;
    if (len !== 16 && len !== 24 && len !== 32)
      throw new Error(`key length must be 16, 24 or 32 bytes, got: ${len} bytes`);
    const xk = expandKeyLE(key);
    const encKey = new Uint8Array(len);
    const authKey = new Uint8Array(16);
    const n32 = u32(nonce);
    let s0 = 0, s1 = n32[0], s2 = n32[1], s3 = n32[2];
    let counter = 0;
    for (const derivedKey of [authKey, encKey].map(u32)) {
      const d32 = u32(derivedKey);
      for (let i5 = 0; i5 < d32.length; i5 += 2) {
        const { s0: o0, s1: o1 } = encrypt(xk, s0, s1, s2, s3);
        d32[i5 + 0] = o0;
        d32[i5 + 1] = o1;
        s0 = ++counter;
      }
    }
    xk.fill(0);
    return { authKey, encKey: expandKeyLE(encKey) };
  }
  function _computeTag(encKey, authKey, data) {
    const tag = computeTag(polyval, true, authKey, data, AAD);
    for (let i5 = 0; i5 < 12; i5++)
      tag[i5] ^= nonce[i5];
    tag[15] &= 127;
    const t32 = u32(tag);
    let s0 = t32[0], s1 = t32[1], s2 = t32[2], s3 = t32[3];
    ({ s0, s1, s2, s3 } = encrypt(encKey, s0, s1, s2, s3));
    t32[0] = s0, t32[1] = s1, t32[2] = s2, t32[3] = s3;
    return tag;
  }
  function processSiv(encKey, tag, input) {
    let block = tag.slice();
    block[15] |= 128;
    return ctr32(encKey, true, block, input);
  }
  return {
    encrypt: (plaintext) => {
      bytes3(plaintext);
      PLAIN_LIMIT(plaintext.length);
      const { encKey, authKey } = deriveKeys();
      const tag = _computeTag(encKey, authKey, plaintext);
      const out = new Uint8Array(plaintext.length + tagLength);
      out.set(tag, plaintext.length);
      out.set(processSiv(encKey, tag, plaintext));
      encKey.fill(0);
      authKey.fill(0);
      return out;
    },
    decrypt: (ciphertext) => {
      bytes3(ciphertext);
      CIPHER_LIMIT(ciphertext.length);
      const tag = ciphertext.subarray(-tagLength);
      const { encKey, authKey } = deriveKeys();
      const plaintext = processSiv(encKey, tag, ciphertext.subarray(0, -tagLength));
      const expectedTag = _computeTag(encKey, authKey, plaintext);
      encKey.fill(0);
      authKey.fill(0);
      if (!equalBytes2(tag, expectedTag))
        throw new Error("invalid polyval tag");
      return plaintext;
    }
  };
});

// node_modules/@noble/ciphers/esm/_poly1305.js
var u8to16 = (a, i5) => a[i5++] & 255 | (a[i5++] & 255) << 8;
var Poly1305 = class {
  constructor(key) {
    this.blockLen = 16;
    this.outputLen = 16;
    this.buffer = new Uint8Array(16);
    this.r = new Uint16Array(10);
    this.h = new Uint16Array(10);
    this.pad = new Uint16Array(8);
    this.pos = 0;
    this.finished = false;
    key = toBytes3(key);
    bytes3(key, 32);
    const t0 = u8to16(key, 0);
    const t1 = u8to16(key, 2);
    const t2 = u8to16(key, 4);
    const t3 = u8to16(key, 6);
    const t4 = u8to16(key, 8);
    const t5 = u8to16(key, 10);
    const t6 = u8to16(key, 12);
    const t7 = u8to16(key, 14);
    this.r[0] = t0 & 8191;
    this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
    this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
    this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
    this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
    this.r[5] = t4 >>> 1 & 8190;
    this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
    this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
    this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
    this.r[9] = t7 >>> 5 & 127;
    for (let i5 = 0; i5 < 8; i5++)
      this.pad[i5] = u8to16(key, 16 + 2 * i5);
  }
  process(data, offset, isLast = false) {
    const hibit = isLast ? 0 : 1 << 11;
    const { h, r } = this;
    const r0 = r[0];
    const r1 = r[1];
    const r2 = r[2];
    const r3 = r[3];
    const r4 = r[4];
    const r5 = r[5];
    const r6 = r[6];
    const r7 = r[7];
    const r8 = r[8];
    const r9 = r[9];
    const t0 = u8to16(data, offset + 0);
    const t1 = u8to16(data, offset + 2);
    const t2 = u8to16(data, offset + 4);
    const t3 = u8to16(data, offset + 6);
    const t4 = u8to16(data, offset + 8);
    const t5 = u8to16(data, offset + 10);
    const t6 = u8to16(data, offset + 12);
    const t7 = u8to16(data, offset + 14);
    let h0 = h[0] + (t0 & 8191);
    let h1 = h[1] + ((t0 >>> 13 | t1 << 3) & 8191);
    let h2 = h[2] + ((t1 >>> 10 | t2 << 6) & 8191);
    let h3 = h[3] + ((t2 >>> 7 | t3 << 9) & 8191);
    let h4 = h[4] + ((t3 >>> 4 | t4 << 12) & 8191);
    let h5 = h[5] + (t4 >>> 1 & 8191);
    let h6 = h[6] + ((t4 >>> 14 | t5 << 2) & 8191);
    let h7 = h[7] + ((t5 >>> 11 | t6 << 5) & 8191);
    let h8 = h[8] + ((t6 >>> 8 | t7 << 8) & 8191);
    let h9 = h[9] + (t7 >>> 5 | hibit);
    let c = 0;
    let d0 = c + h0 * r0 + h1 * (5 * r9) + h2 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);
    c = d0 >>> 13;
    d0 &= 8191;
    d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r2) + h9 * (5 * r1);
    c += d0 >>> 13;
    d0 &= 8191;
    let d1 = c + h0 * r1 + h1 * r0 + h2 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);
    c = d1 >>> 13;
    d1 &= 8191;
    d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r2);
    c += d1 >>> 13;
    d1 &= 8191;
    let d2 = c + h0 * r2 + h1 * r1 + h2 * r0 + h3 * (5 * r9) + h4 * (5 * r8);
    c = d2 >>> 13;
    d2 &= 8191;
    d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);
    c += d2 >>> 13;
    d2 &= 8191;
    let d3 = c + h0 * r3 + h1 * r2 + h2 * r1 + h3 * r0 + h4 * (5 * r9);
    c = d3 >>> 13;
    d3 &= 8191;
    d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);
    c += d3 >>> 13;
    d3 &= 8191;
    let d4 = c + h0 * r4 + h1 * r3 + h2 * r2 + h3 * r1 + h4 * r0;
    c = d4 >>> 13;
    d4 &= 8191;
    d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);
    c += d4 >>> 13;
    d4 &= 8191;
    let d5 = c + h0 * r5 + h1 * r4 + h2 * r3 + h3 * r2 + h4 * r1;
    c = d5 >>> 13;
    d5 &= 8191;
    d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);
    c += d5 >>> 13;
    d5 &= 8191;
    let d6 = c + h0 * r6 + h1 * r5 + h2 * r4 + h3 * r3 + h4 * r2;
    c = d6 >>> 13;
    d6 &= 8191;
    d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);
    c += d6 >>> 13;
    d6 &= 8191;
    let d7 = c + h0 * r7 + h1 * r6 + h2 * r5 + h3 * r4 + h4 * r3;
    c = d7 >>> 13;
    d7 &= 8191;
    d7 += h5 * r2 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);
    c += d7 >>> 13;
    d7 &= 8191;
    let d8 = c + h0 * r8 + h1 * r7 + h2 * r6 + h3 * r5 + h4 * r4;
    c = d8 >>> 13;
    d8 &= 8191;
    d8 += h5 * r3 + h6 * r2 + h7 * r1 + h8 * r0 + h9 * (5 * r9);
    c += d8 >>> 13;
    d8 &= 8191;
    let d9 = c + h0 * r9 + h1 * r8 + h2 * r7 + h3 * r6 + h4 * r5;
    c = d9 >>> 13;
    d9 &= 8191;
    d9 += h5 * r4 + h6 * r3 + h7 * r2 + h8 * r1 + h9 * r0;
    c += d9 >>> 13;
    d9 &= 8191;
    c = (c << 2) + c | 0;
    c = c + d0 | 0;
    d0 = c & 8191;
    c = c >>> 13;
    d1 += c;
    h[0] = d0;
    h[1] = d1;
    h[2] = d2;
    h[3] = d3;
    h[4] = d4;
    h[5] = d5;
    h[6] = d6;
    h[7] = d7;
    h[8] = d8;
    h[9] = d9;
  }
  finalize() {
    const { h, pad } = this;
    const g = new Uint16Array(10);
    let c = h[1] >>> 13;
    h[1] &= 8191;
    for (let i5 = 2; i5 < 10; i5++) {
      h[i5] += c;
      c = h[i5] >>> 13;
      h[i5] &= 8191;
    }
    h[0] += c * 5;
    c = h[0] >>> 13;
    h[0] &= 8191;
    h[1] += c;
    c = h[1] >>> 13;
    h[1] &= 8191;
    h[2] += c;
    g[0] = h[0] + 5;
    c = g[0] >>> 13;
    g[0] &= 8191;
    for (let i5 = 1; i5 < 10; i5++) {
      g[i5] = h[i5] + c;
      c = g[i5] >>> 13;
      g[i5] &= 8191;
    }
    g[9] -= 1 << 13;
    let mask = (c ^ 1) - 1;
    for (let i5 = 0; i5 < 10; i5++)
      g[i5] &= mask;
    mask = ~mask;
    for (let i5 = 0; i5 < 10; i5++)
      h[i5] = h[i5] & mask | g[i5];
    h[0] = (h[0] | h[1] << 13) & 65535;
    h[1] = (h[1] >>> 3 | h[2] << 10) & 65535;
    h[2] = (h[2] >>> 6 | h[3] << 7) & 65535;
    h[3] = (h[3] >>> 9 | h[4] << 4) & 65535;
    h[4] = (h[4] >>> 12 | h[5] << 1 | h[6] << 14) & 65535;
    h[5] = (h[6] >>> 2 | h[7] << 11) & 65535;
    h[6] = (h[7] >>> 5 | h[8] << 8) & 65535;
    h[7] = (h[8] >>> 8 | h[9] << 5) & 65535;
    let f = h[0] + pad[0];
    h[0] = f & 65535;
    for (let i5 = 1; i5 < 8; i5++) {
      f = (h[i5] + pad[i5] | 0) + (f >>> 16) | 0;
      h[i5] = f & 65535;
    }
  }
  update(data) {
    exists3(this);
    const { buffer, blockLen } = this;
    data = toBytes3(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(data, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(buffer, 0, false);
        this.pos = 0;
      }
    }
    return this;
  }
  destroy() {
    this.h.fill(0);
    this.r.fill(0);
    this.buffer.fill(0);
    this.pad.fill(0);
  }
  digestInto(out) {
    exists3(this);
    output3(out, this);
    this.finished = true;
    const { buffer, h } = this;
    let { pos } = this;
    if (pos) {
      buffer[pos++] = 1;
      for (; pos < 16; pos++)
        buffer[pos] = 0;
      this.process(buffer, 0, true);
    }
    this.finalize();
    let opos = 0;
    for (let i5 = 0; i5 < 8; i5++) {
      out[opos++] = h[i5] >>> 0;
      out[opos++] = h[i5] >>> 8;
    }
    return out;
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
};
function wrapConstructorWithKey2(hashCons) {
  const hashC = (msg, key) => hashCons(key).update(toBytes3(msg)).digest();
  const tmp = hashCons(new Uint8Array(32));
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (key) => hashCons(key);
  return hashC;
}
var poly1305 = wrapConstructorWithKey2((key) => new Poly1305(key));

// node_modules/@noble/ciphers/esm/_arx.js
var sigma16 = utf8ToBytes4("expand 16-byte k");
var sigma32 = utf8ToBytes4("expand 32-byte k");
var sigma16_32 = u32(sigma16);
var sigma32_32 = u32(sigma32);
function rotl(a, b) {
  return a << b | a >>> 32 - b;
}
function isAligned32(b) {
  return b.byteOffset % 4 === 0;
}
var BLOCK_LEN = 64;
var BLOCK_LEN32 = 16;
var MAX_COUNTER = 2 ** 32 - 1;
var U32_EMPTY = new Uint32Array();
function runCipher(core, sigma, key, nonce, data, output4, counter, rounds) {
  const len = data.length;
  const block = new Uint8Array(BLOCK_LEN);
  const b32 = u32(block);
  const isAligned = isAligned32(data) && isAligned32(output4);
  const d32 = isAligned ? u32(data) : U32_EMPTY;
  const o32 = isAligned ? u32(output4) : U32_EMPTY;
  for (let pos = 0; pos < len; counter++) {
    core(sigma, key, nonce, b32, counter, rounds);
    if (counter >= MAX_COUNTER)
      throw new Error("arx: counter overflow");
    const take = Math.min(BLOCK_LEN, len - pos);
    if (isAligned && take === BLOCK_LEN) {
      const pos32 = pos / 4;
      if (pos % 4 !== 0)
        throw new Error("arx: invalid block position");
      for (let j = 0, posj; j < BLOCK_LEN32; j++) {
        posj = pos32 + j;
        o32[posj] = d32[posj] ^ b32[j];
      }
      pos += BLOCK_LEN;
      continue;
    }
    for (let j = 0, posj; j < take; j++) {
      posj = pos + j;
      output4[posj] = data[posj] ^ block[j];
    }
    pos += take;
  }
}
function createCipher(core, opts) {
  const { allowShortKeys, extendNonceFn, counterLength, counterRight, rounds } = checkOpts({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, opts);
  if (typeof core !== "function")
    throw new Error("core must be a function");
  number3(counterLength);
  number3(rounds);
  bool2(counterRight);
  bool2(allowShortKeys);
  return (key, nonce, data, output4, counter = 0) => {
    bytes3(key);
    bytes3(nonce);
    bytes3(data);
    const len = data.length;
    if (!output4)
      output4 = new Uint8Array(len);
    bytes3(output4);
    number3(counter);
    if (counter < 0 || counter >= MAX_COUNTER)
      throw new Error("arx: counter overflow");
    if (output4.length < len)
      throw new Error(`arx: output (${output4.length}) is shorter than data (${len})`);
    const toClean = [];
    let l = key.length, k, sigma;
    if (l === 32) {
      k = key.slice();
      toClean.push(k);
      sigma = sigma32_32;
    } else if (l === 16 && allowShortKeys) {
      k = new Uint8Array(32);
      k.set(key);
      k.set(key, 16);
      sigma = sigma16_32;
      toClean.push(k);
    } else {
      throw new Error(`arx: invalid 32-byte key, got length=${l}`);
    }
    if (!isAligned32(nonce)) {
      nonce = nonce.slice();
      toClean.push(nonce);
    }
    const k32 = u32(k);
    if (extendNonceFn) {
      if (nonce.length !== 24)
        throw new Error(`arx: extended nonce must be 24 bytes`);
      extendNonceFn(sigma, k32, u32(nonce.subarray(0, 16)), k32);
      nonce = nonce.subarray(16);
    }
    const nonceNcLen = 16 - counterLength;
    if (nonceNcLen !== nonce.length)
      throw new Error(`arx: nonce must be ${nonceNcLen} or 16 bytes`);
    if (nonceNcLen !== 12) {
      const nc = new Uint8Array(12);
      nc.set(nonce, counterRight ? 0 : 12 - nonce.length);
      nonce = nc;
      toClean.push(nonce);
    }
    const n32 = u32(nonce);
    runCipher(core, sigma, k32, n32, data, output4, counter, rounds);
    while (toClean.length > 0)
      toClean.pop().fill(0);
    return output4;
  };
}

// node_modules/@noble/ciphers/esm/chacha.js
function chachaCore(s, k, n, out, cnt, rounds = 20) {
  let y00 = s[0], y01 = s[1], y02 = s[2], y03 = s[3], y04 = k[0], y05 = k[1], y06 = k[2], y07 = k[3], y08 = k[4], y09 = k[5], y10 = k[6], y11 = k[7], y12 = cnt, y13 = n[0], y14 = n[1], y15 = n[2];
  let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
  for (let r = 0; r < rounds; r += 2) {
    x00 = x00 + x04 | 0;
    x12 = rotl(x12 ^ x00, 16);
    x08 = x08 + x12 | 0;
    x04 = rotl(x04 ^ x08, 12);
    x00 = x00 + x04 | 0;
    x12 = rotl(x12 ^ x00, 8);
    x08 = x08 + x12 | 0;
    x04 = rotl(x04 ^ x08, 7);
    x01 = x01 + x05 | 0;
    x13 = rotl(x13 ^ x01, 16);
    x09 = x09 + x13 | 0;
    x05 = rotl(x05 ^ x09, 12);
    x01 = x01 + x05 | 0;
    x13 = rotl(x13 ^ x01, 8);
    x09 = x09 + x13 | 0;
    x05 = rotl(x05 ^ x09, 7);
    x02 = x02 + x06 | 0;
    x14 = rotl(x14 ^ x02, 16);
    x10 = x10 + x14 | 0;
    x06 = rotl(x06 ^ x10, 12);
    x02 = x02 + x06 | 0;
    x14 = rotl(x14 ^ x02, 8);
    x10 = x10 + x14 | 0;
    x06 = rotl(x06 ^ x10, 7);
    x03 = x03 + x07 | 0;
    x15 = rotl(x15 ^ x03, 16);
    x11 = x11 + x15 | 0;
    x07 = rotl(x07 ^ x11, 12);
    x03 = x03 + x07 | 0;
    x15 = rotl(x15 ^ x03, 8);
    x11 = x11 + x15 | 0;
    x07 = rotl(x07 ^ x11, 7);
    x00 = x00 + x05 | 0;
    x15 = rotl(x15 ^ x00, 16);
    x10 = x10 + x15 | 0;
    x05 = rotl(x05 ^ x10, 12);
    x00 = x00 + x05 | 0;
    x15 = rotl(x15 ^ x00, 8);
    x10 = x10 + x15 | 0;
    x05 = rotl(x05 ^ x10, 7);
    x01 = x01 + x06 | 0;
    x12 = rotl(x12 ^ x01, 16);
    x11 = x11 + x12 | 0;
    x06 = rotl(x06 ^ x11, 12);
    x01 = x01 + x06 | 0;
    x12 = rotl(x12 ^ x01, 8);
    x11 = x11 + x12 | 0;
    x06 = rotl(x06 ^ x11, 7);
    x02 = x02 + x07 | 0;
    x13 = rotl(x13 ^ x02, 16);
    x08 = x08 + x13 | 0;
    x07 = rotl(x07 ^ x08, 12);
    x02 = x02 + x07 | 0;
    x13 = rotl(x13 ^ x02, 8);
    x08 = x08 + x13 | 0;
    x07 = rotl(x07 ^ x08, 7);
    x03 = x03 + x04 | 0;
    x14 = rotl(x14 ^ x03, 16);
    x09 = x09 + x14 | 0;
    x04 = rotl(x04 ^ x09, 12);
    x03 = x03 + x04 | 0;
    x14 = rotl(x14 ^ x03, 8);
    x09 = x09 + x14 | 0;
    x04 = rotl(x04 ^ x09, 7);
  }
  let oi = 0;
  out[oi++] = y00 + x00 | 0;
  out[oi++] = y01 + x01 | 0;
  out[oi++] = y02 + x02 | 0;
  out[oi++] = y03 + x03 | 0;
  out[oi++] = y04 + x04 | 0;
  out[oi++] = y05 + x05 | 0;
  out[oi++] = y06 + x06 | 0;
  out[oi++] = y07 + x07 | 0;
  out[oi++] = y08 + x08 | 0;
  out[oi++] = y09 + x09 | 0;
  out[oi++] = y10 + x10 | 0;
  out[oi++] = y11 + x11 | 0;
  out[oi++] = y12 + x12 | 0;
  out[oi++] = y13 + x13 | 0;
  out[oi++] = y14 + x14 | 0;
  out[oi++] = y15 + x15 | 0;
}
function hchacha(s, k, i5, o32) {
  let x00 = s[0], x01 = s[1], x02 = s[2], x03 = s[3], x04 = k[0], x05 = k[1], x06 = k[2], x07 = k[3], x08 = k[4], x09 = k[5], x10 = k[6], x11 = k[7], x12 = i5[0], x13 = i5[1], x14 = i5[2], x15 = i5[3];
  for (let r = 0; r < 20; r += 2) {
    x00 = x00 + x04 | 0;
    x12 = rotl(x12 ^ x00, 16);
    x08 = x08 + x12 | 0;
    x04 = rotl(x04 ^ x08, 12);
    x00 = x00 + x04 | 0;
    x12 = rotl(x12 ^ x00, 8);
    x08 = x08 + x12 | 0;
    x04 = rotl(x04 ^ x08, 7);
    x01 = x01 + x05 | 0;
    x13 = rotl(x13 ^ x01, 16);
    x09 = x09 + x13 | 0;
    x05 = rotl(x05 ^ x09, 12);
    x01 = x01 + x05 | 0;
    x13 = rotl(x13 ^ x01, 8);
    x09 = x09 + x13 | 0;
    x05 = rotl(x05 ^ x09, 7);
    x02 = x02 + x06 | 0;
    x14 = rotl(x14 ^ x02, 16);
    x10 = x10 + x14 | 0;
    x06 = rotl(x06 ^ x10, 12);
    x02 = x02 + x06 | 0;
    x14 = rotl(x14 ^ x02, 8);
    x10 = x10 + x14 | 0;
    x06 = rotl(x06 ^ x10, 7);
    x03 = x03 + x07 | 0;
    x15 = rotl(x15 ^ x03, 16);
    x11 = x11 + x15 | 0;
    x07 = rotl(x07 ^ x11, 12);
    x03 = x03 + x07 | 0;
    x15 = rotl(x15 ^ x03, 8);
    x11 = x11 + x15 | 0;
    x07 = rotl(x07 ^ x11, 7);
    x00 = x00 + x05 | 0;
    x15 = rotl(x15 ^ x00, 16);
    x10 = x10 + x15 | 0;
    x05 = rotl(x05 ^ x10, 12);
    x00 = x00 + x05 | 0;
    x15 = rotl(x15 ^ x00, 8);
    x10 = x10 + x15 | 0;
    x05 = rotl(x05 ^ x10, 7);
    x01 = x01 + x06 | 0;
    x12 = rotl(x12 ^ x01, 16);
    x11 = x11 + x12 | 0;
    x06 = rotl(x06 ^ x11, 12);
    x01 = x01 + x06 | 0;
    x12 = rotl(x12 ^ x01, 8);
    x11 = x11 + x12 | 0;
    x06 = rotl(x06 ^ x11, 7);
    x02 = x02 + x07 | 0;
    x13 = rotl(x13 ^ x02, 16);
    x08 = x08 + x13 | 0;
    x07 = rotl(x07 ^ x08, 12);
    x02 = x02 + x07 | 0;
    x13 = rotl(x13 ^ x02, 8);
    x08 = x08 + x13 | 0;
    x07 = rotl(x07 ^ x08, 7);
    x03 = x03 + x04 | 0;
    x14 = rotl(x14 ^ x03, 16);
    x09 = x09 + x14 | 0;
    x04 = rotl(x04 ^ x09, 12);
    x03 = x03 + x04 | 0;
    x14 = rotl(x14 ^ x03, 8);
    x09 = x09 + x14 | 0;
    x04 = rotl(x04 ^ x09, 7);
  }
  let oi = 0;
  o32[oi++] = x00;
  o32[oi++] = x01;
  o32[oi++] = x02;
  o32[oi++] = x03;
  o32[oi++] = x12;
  o32[oi++] = x13;
  o32[oi++] = x14;
  o32[oi++] = x15;
}
var chacha20 = /* @__PURE__ */ createCipher(chachaCore, {
  counterRight: false,
  counterLength: 4,
  allowShortKeys: false
});
var xchacha20 = /* @__PURE__ */ createCipher(chachaCore, {
  counterRight: false,
  counterLength: 8,
  extendNonceFn: hchacha,
  allowShortKeys: false
});
var ZEROS162 = /* @__PURE__ */ new Uint8Array(16);
var updatePadded = (h, msg) => {
  h.update(msg);
  const left = msg.length % 16;
  if (left)
    h.update(ZEROS162.subarray(left));
};
var ZEROS322 = /* @__PURE__ */ new Uint8Array(32);
function computeTag2(fn, key, nonce, data, AAD) {
  const authKey = fn(key, nonce, ZEROS322);
  const h = poly1305.create(authKey);
  if (AAD)
    updatePadded(h, AAD);
  updatePadded(h, data);
  const num = new Uint8Array(16);
  const view = createView3(num);
  setBigUint643(view, 0, BigInt(AAD ? AAD.length : 0), true);
  setBigUint643(view, 8, BigInt(data.length), true);
  h.update(num);
  const res = h.digest();
  authKey.fill(0);
  return res;
}
var _poly1305_aead = (xorStream) => (key, nonce, AAD) => {
  const tagLength = 16;
  bytes3(key, 32);
  bytes3(nonce);
  return {
    encrypt: (plaintext, output4) => {
      const plength = plaintext.length;
      const clength = plength + tagLength;
      if (output4) {
        bytes3(output4, clength);
      } else {
        output4 = new Uint8Array(clength);
      }
      xorStream(key, nonce, plaintext, output4, 1);
      const tag = computeTag2(xorStream, key, nonce, output4.subarray(0, -tagLength), AAD);
      output4.set(tag, plength);
      return output4;
    },
    decrypt: (ciphertext, output4) => {
      const clength = ciphertext.length;
      const plength = clength - tagLength;
      if (clength < tagLength)
        throw new Error(`encrypted data must be at least ${tagLength} bytes`);
      if (output4) {
        bytes3(output4, plength);
      } else {
        output4 = new Uint8Array(plength);
      }
      const data = ciphertext.subarray(0, -tagLength);
      const passedTag = ciphertext.subarray(-tagLength);
      const tag = computeTag2(xorStream, key, nonce, data, AAD);
      if (!equalBytes2(passedTag, tag))
        throw new Error("invalid tag");
      xorStream(key, nonce, data, output4, 1);
      return output4;
    }
  };
};
var chacha20poly1305 = /* @__PURE__ */ wrapCipher({ blockSize: 64, nonceLength: 12, tagLength: 16 }, _poly1305_aead(chacha20));
var xchacha20poly1305 = /* @__PURE__ */ wrapCipher({ blockSize: 64, nonceLength: 24, tagLength: 16 }, _poly1305_aead(xchacha20));

// node_modules/@noble/hashes/esm/hmac.js
var HMAC2 = class extends Hash2 {
  constructor(hash3, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    assert_default.hash(hash3);
    const key = toBytes2(_key);
    this.iHash = hash3.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash3.create().update(key).digest() : key);
    for (let i5 = 0; i5 < pad.length; i5++)
      pad[i5] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash3.create();
    for (let i5 = 0; i5 < pad.length; i5++)
      pad[i5] ^= 54 ^ 92;
    this.oHash.update(pad);
    pad.fill(0);
  }
  update(buf) {
    assert_default.exists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    assert_default.exists(this);
    assert_default.bytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac2 = (hash3, key, message) => new HMAC2(hash3, key).update(message).digest();
hmac2.create = (hash3, key) => new HMAC2(hash3, key);

// node_modules/@noble/hashes/esm/hkdf.js
function extract(hash3, ikm, salt) {
  assert_default.hash(hash3);
  if (salt === void 0)
    salt = new Uint8Array(hash3.outputLen);
  return hmac2(hash3, toBytes2(salt), toBytes2(ikm));
}
var HKDF_COUNTER = new Uint8Array([0]);
var EMPTY_BUFFER = new Uint8Array();
function expand(hash3, prk, info, length = 32) {
  assert_default.hash(hash3);
  assert_default.number(length);
  if (length > 255 * hash3.outputLen)
    throw new Error("Length should be <= 255*HashLen");
  const blocks = Math.ceil(length / hash3.outputLen);
  if (info === void 0)
    info = EMPTY_BUFFER;
  const okm = new Uint8Array(blocks * hash3.outputLen);
  const HMAC3 = hmac2.create(hash3, prk);
  const HMACTmp = HMAC3._cloneInto();
  const T = new Uint8Array(HMAC3.outputLen);
  for (let counter = 0; counter < blocks; counter++) {
    HKDF_COUNTER[0] = counter + 1;
    HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T).update(info).update(HKDF_COUNTER).digestInto(T);
    okm.set(T, hash3.outputLen * counter);
    HMAC3._cloneInto(HMACTmp);
  }
  HMAC3.destroy();
  HMACTmp.destroy();
  T.fill(0);
  HKDF_COUNTER.fill(0);
  return okm.slice(0, length);
}

// node_modules/nostr-tools/lib/esm/index.js
var __defProp2 = Object.defineProperty;
var __export2 = (target, all3) => {
  for (var name in all3)
    __defProp2(target, name, { get: all3[name], enumerable: true });
};
var verifiedSymbol = Symbol("verified");
var isRecord = (obj) => obj instanceof Object;
function validateEvent(event) {
  if (!isRecord(event))
    return false;
  if (typeof event.kind !== "number")
    return false;
  if (typeof event.content !== "string")
    return false;
  if (typeof event.created_at !== "number")
    return false;
  if (typeof event.pubkey !== "string")
    return false;
  if (!event.pubkey.match(/^[a-f0-9]{64}$/))
    return false;
  if (!Array.isArray(event.tags))
    return false;
  for (let i22 = 0; i22 < event.tags.length; i22++) {
    let tag = event.tags[i22];
    if (!Array.isArray(tag))
      return false;
    for (let j = 0; j < tag.length; j++) {
      if (typeof tag[j] === "object")
        return false;
    }
  }
  return true;
}
var utils_exports2 = {};
__export2(utils_exports2, {
  Queue: () => Queue,
  QueueNode: () => QueueNode,
  binarySearch: () => binarySearch,
  insertEventIntoAscendingList: () => insertEventIntoAscendingList,
  insertEventIntoDescendingList: () => insertEventIntoDescendingList,
  normalizeURL: () => normalizeURL,
  utf8Decoder: () => utf8Decoder,
  utf8Encoder: () => utf8Encoder
});
var utf8Decoder = new TextDecoder("utf-8");
var utf8Encoder = new TextEncoder();
function normalizeURL(url) {
  if (url.indexOf("://") === -1)
    url = "wss://" + url;
  let p = new URL(url);
  p.pathname = p.pathname.replace(/\/+/g, "/");
  if (p.pathname.endsWith("/"))
    p.pathname = p.pathname.slice(0, -1);
  if (p.port === "80" && p.protocol === "ws:" || p.port === "443" && p.protocol === "wss:")
    p.port = "";
  p.searchParams.sort();
  p.hash = "";
  return p.toString();
}
function insertEventIntoDescendingList(sortedArray, event) {
  const [idx, found] = binarySearch(sortedArray, (b) => {
    if (event.id === b.id)
      return 0;
    if (event.created_at === b.created_at)
      return -1;
    return b.created_at - event.created_at;
  });
  if (!found) {
    sortedArray.splice(idx, 0, event);
  }
  return sortedArray;
}
function insertEventIntoAscendingList(sortedArray, event) {
  const [idx, found] = binarySearch(sortedArray, (b) => {
    if (event.id === b.id)
      return 0;
    if (event.created_at === b.created_at)
      return -1;
    return event.created_at - b.created_at;
  });
  if (!found) {
    sortedArray.splice(idx, 0, event);
  }
  return sortedArray;
}
function binarySearch(arr, compare) {
  let start = 0;
  let end = arr.length - 1;
  while (start <= end) {
    const mid = Math.floor((start + end) / 2);
    const cmp = compare(arr[mid]);
    if (cmp === 0) {
      return [mid, true];
    }
    if (cmp < 0) {
      end = mid - 1;
    } else {
      start = mid + 1;
    }
  }
  return [start, false];
}
var QueueNode = class {
  constructor(message) {
    __publicField(this, "value");
    __publicField(this, "next", null);
    __publicField(this, "prev", null);
    this.value = message;
  }
};
var Queue = class {
  constructor() {
    __publicField(this, "first");
    __publicField(this, "last");
    this.first = null;
    this.last = null;
  }
  enqueue(value) {
    const newNode = new QueueNode(value);
    if (!this.last) {
      this.first = newNode;
      this.last = newNode;
    } else if (this.last === this.first) {
      this.last = newNode;
      this.last.prev = this.first;
      this.first.next = newNode;
    } else {
      newNode.prev = this.last;
      this.last.next = newNode;
      this.last = newNode;
    }
    return true;
  }
  dequeue() {
    if (!this.first)
      return null;
    if (this.first === this.last) {
      const target2 = this.first;
      this.first = null;
      this.last = null;
      return target2.value;
    }
    const target = this.first;
    this.first = target.next;
    return target.value;
  }
};
var JS = class {
  generateSecretKey() {
    return schnorr.utils.randomPrivateKey();
  }
  getPublicKey(secretKey) {
    return bytesToHex2(schnorr.getPublicKey(secretKey));
  }
  finalizeEvent(t, secretKey) {
    const event = t;
    event.pubkey = bytesToHex2(schnorr.getPublicKey(secretKey));
    event.id = getEventHash(event);
    event.sig = bytesToHex2(schnorr.sign(getEventHash(event), secretKey));
    event[verifiedSymbol] = true;
    return event;
  }
  verifyEvent(event) {
    if (typeof event[verifiedSymbol] === "boolean")
      return event[verifiedSymbol];
    const hash3 = getEventHash(event);
    if (hash3 !== event.id) {
      event[verifiedSymbol] = false;
      return false;
    }
    try {
      const valid = schnorr.verify(event.sig, hash3, event.pubkey);
      event[verifiedSymbol] = valid;
      return valid;
    } catch (err) {
      event[verifiedSymbol] = false;
      return false;
    }
  }
};
function serializeEvent(evt) {
  if (!validateEvent(evt))
    throw new Error("can't serialize event with wrong or missing properties");
  return JSON.stringify([0, evt.pubkey, evt.created_at, evt.kind, evt.tags, evt.content]);
}
function getEventHash(event) {
  let eventHash = sha2562(utf8Encoder.encode(serializeEvent(event)));
  return bytesToHex2(eventHash);
}
var i = new JS();
var generateSecretKey = i.generateSecretKey;
var getPublicKey = i.getPublicKey;
var finalizeEvent = i.finalizeEvent;
var verifyEvent = i.verifyEvent;
var kinds_exports = {};
__export2(kinds_exports, {
  Application: () => Application,
  BadgeAward: () => BadgeAward,
  BadgeDefinition: () => BadgeDefinition,
  BlockedRelaysList: () => BlockedRelaysList,
  BookmarkList: () => BookmarkList,
  Bookmarksets: () => Bookmarksets,
  Calendar: () => Calendar,
  CalendarEventRSVP: () => CalendarEventRSVP,
  ChannelCreation: () => ChannelCreation,
  ChannelHideMessage: () => ChannelHideMessage,
  ChannelMessage: () => ChannelMessage,
  ChannelMetadata: () => ChannelMetadata,
  ChannelMuteUser: () => ChannelMuteUser,
  ClassifiedListing: () => ClassifiedListing,
  ClientAuth: () => ClientAuth,
  CommunitiesList: () => CommunitiesList,
  CommunityDefinition: () => CommunityDefinition,
  CommunityPostApproval: () => CommunityPostApproval,
  Contacts: () => Contacts,
  CreateOrUpdateProduct: () => CreateOrUpdateProduct,
  CreateOrUpdateStall: () => CreateOrUpdateStall,
  Curationsets: () => Curationsets,
  Date: () => Date2,
  DraftClassifiedListing: () => DraftClassifiedListing,
  DraftLong: () => DraftLong,
  Emojisets: () => Emojisets,
  EncryptedDirectMessage: () => EncryptedDirectMessage,
  EncryptedDirectMessages: () => EncryptedDirectMessages,
  EventDeletion: () => EventDeletion,
  FileMetadata: () => FileMetadata,
  FileServerPreference: () => FileServerPreference,
  Followsets: () => Followsets,
  GenericRepost: () => GenericRepost,
  Genericlists: () => Genericlists,
  HTTPAuth: () => HTTPAuth,
  Handlerinformation: () => Handlerinformation,
  Handlerrecommendation: () => Handlerrecommendation,
  Highlights: () => Highlights,
  InterestsList: () => InterestsList,
  Interestsets: () => Interestsets,
  JobFeedback: () => JobFeedback,
  JobRequest: () => JobRequest,
  JobResult: () => JobResult,
  Label: () => Label,
  LightningPubRPC: () => LightningPubRPC,
  LiveChatMessage: () => LiveChatMessage,
  LiveEvent: () => LiveEvent,
  LongFormArticle: () => LongFormArticle,
  Metadata: () => Metadata,
  Mutelist: () => Mutelist,
  NWCWalletInfo: () => NWCWalletInfo,
  NWCWalletRequest: () => NWCWalletRequest,
  NWCWalletResponse: () => NWCWalletResponse,
  NostrConnect: () => NostrConnect,
  OpenTimestamps: () => OpenTimestamps,
  Pinlist: () => Pinlist,
  ProblemTracker: () => ProblemTracker,
  ProfileBadges: () => ProfileBadges,
  PublicChatsList: () => PublicChatsList,
  Reaction: () => Reaction,
  RecommendRelay: () => RecommendRelay,
  RelayList: () => RelayList,
  Relaysets: () => Relaysets,
  Report: () => Report,
  Reporting: () => Reporting,
  Repost: () => Repost,
  SearchRelaysList: () => SearchRelaysList,
  ShortTextNote: () => ShortTextNote,
  Time: () => Time,
  UserEmojiList: () => UserEmojiList,
  UserStatuses: () => UserStatuses,
  Zap: () => Zap,
  ZapGoal: () => ZapGoal,
  ZapRequest: () => ZapRequest,
  classifyKind: () => classifyKind,
  isEphemeralKind: () => isEphemeralKind,
  isParameterizedReplaceableKind: () => isParameterizedReplaceableKind,
  isRegularKind: () => isRegularKind,
  isReplaceableKind: () => isReplaceableKind
});
function isRegularKind(kind) {
  return 1e3 <= kind && kind < 1e4 || [1, 2, 4, 5, 6, 7, 8, 16, 40, 41, 42, 43, 44].includes(kind);
}
function isReplaceableKind(kind) {
  return [0, 3].includes(kind) || 1e4 <= kind && kind < 2e4;
}
function isEphemeralKind(kind) {
  return 2e4 <= kind && kind < 3e4;
}
function isParameterizedReplaceableKind(kind) {
  return 3e4 <= kind && kind < 4e4;
}
function classifyKind(kind) {
  if (isRegularKind(kind))
    return "regular";
  if (isReplaceableKind(kind))
    return "replaceable";
  if (isEphemeralKind(kind))
    return "ephemeral";
  if (isParameterizedReplaceableKind(kind))
    return "parameterized";
  return "unknown";
}
var Metadata = 0;
var ShortTextNote = 1;
var RecommendRelay = 2;
var Contacts = 3;
var EncryptedDirectMessage = 4;
var EncryptedDirectMessages = 4;
var EventDeletion = 5;
var Repost = 6;
var Reaction = 7;
var BadgeAward = 8;
var GenericRepost = 16;
var ChannelCreation = 40;
var ChannelMetadata = 41;
var ChannelMessage = 42;
var ChannelHideMessage = 43;
var ChannelMuteUser = 44;
var OpenTimestamps = 1040;
var FileMetadata = 1063;
var LiveChatMessage = 1311;
var ProblemTracker = 1971;
var Report = 1984;
var Reporting = 1984;
var Label = 1985;
var CommunityPostApproval = 4550;
var JobRequest = 5999;
var JobResult = 6999;
var JobFeedback = 7e3;
var ZapGoal = 9041;
var ZapRequest = 9734;
var Zap = 9735;
var Highlights = 9802;
var Mutelist = 1e4;
var Pinlist = 10001;
var RelayList = 10002;
var BookmarkList = 10003;
var CommunitiesList = 10004;
var PublicChatsList = 10005;
var BlockedRelaysList = 10006;
var SearchRelaysList = 10007;
var InterestsList = 10015;
var UserEmojiList = 10030;
var FileServerPreference = 10096;
var NWCWalletInfo = 13194;
var LightningPubRPC = 21e3;
var ClientAuth = 22242;
var NWCWalletRequest = 23194;
var NWCWalletResponse = 23195;
var NostrConnect = 24133;
var HTTPAuth = 27235;
var Followsets = 3e4;
var Genericlists = 30001;
var Relaysets = 30002;
var Bookmarksets = 30003;
var Curationsets = 30004;
var ProfileBadges = 30008;
var BadgeDefinition = 30009;
var Interestsets = 30015;
var CreateOrUpdateStall = 30017;
var CreateOrUpdateProduct = 30018;
var LongFormArticle = 30023;
var DraftLong = 30024;
var Emojisets = 30030;
var Application = 30078;
var LiveEvent = 30311;
var UserStatuses = 30315;
var ClassifiedListing = 30402;
var DraftClassifiedListing = 30403;
var Date2 = 31922;
var Time = 31923;
var Calendar = 31924;
var CalendarEventRSVP = 31925;
var Handlerrecommendation = 31989;
var Handlerinformation = 31990;
var CommunityDefinition = 34550;
var fakejson_exports = {};
__export2(fakejson_exports, {
  getHex64: () => getHex64,
  getInt: () => getInt,
  getSubscriptionId: () => getSubscriptionId,
  matchEventId: () => matchEventId,
  matchEventKind: () => matchEventKind,
  matchEventPubkey: () => matchEventPubkey
});
function getHex64(json, field) {
  let len = field.length + 3;
  let idx = json.indexOf(`"${field}":`) + len;
  let s = json.slice(idx).indexOf(`"`) + idx + 1;
  return json.slice(s, s + 64);
}
function getInt(json, field) {
  let len = field.length;
  let idx = json.indexOf(`"${field}":`) + len + 3;
  let sliced = json.slice(idx);
  let end = Math.min(sliced.indexOf(","), sliced.indexOf("}"));
  return parseInt(sliced.slice(0, end), 10);
}
function getSubscriptionId(json) {
  let idx = json.slice(0, 22).indexOf(`"EVENT"`);
  if (idx === -1)
    return null;
  let pstart = json.slice(idx + 7 + 1).indexOf(`"`);
  if (pstart === -1)
    return null;
  let start = idx + 7 + 1 + pstart;
  let pend = json.slice(start + 1, 80).indexOf(`"`);
  if (pend === -1)
    return null;
  let end = start + 1 + pend;
  return json.slice(start + 1, end);
}
function matchEventId(json, id) {
  return id === getHex64(json, "id");
}
function matchEventPubkey(json, pubkey) {
  return pubkey === getHex64(json, "pubkey");
}
function matchEventKind(json, kind) {
  return kind === getInt(json, "kind");
}
var nip42_exports = {};
__export2(nip42_exports, {
  makeAuthEvent: () => makeAuthEvent
});
function makeAuthEvent(relayURL, challenge2) {
  return {
    kind: ClientAuth,
    created_at: Math.floor(Date.now() / 1e3),
    tags: [
      ["relay", relayURL],
      ["challenge", challenge2]
    ],
    content: ""
  };
}
var _WebSocket;
try {
  _WebSocket = WebSocket;
} catch (e) {
}
var nip19_exports = {};
__export2(nip19_exports, {
  BECH32_REGEX: () => BECH32_REGEX,
  Bech32MaxSize: () => Bech32MaxSize,
  decode: () => decode,
  encodeBytes: () => encodeBytes,
  naddrEncode: () => naddrEncode,
  neventEncode: () => neventEncode,
  noteEncode: () => noteEncode,
  nprofileEncode: () => nprofileEncode,
  npubEncode: () => npubEncode,
  nrelayEncode: () => nrelayEncode,
  nsecEncode: () => nsecEncode
});
var Bech32MaxSize = 5e3;
var BECH32_REGEX = /[\x21-\x7E]{1,83}1[023456789acdefghjklmnpqrstuvwxyz]{6,}/;
function integerToUint8Array(number4) {
  const uint8Array = new Uint8Array(4);
  uint8Array[0] = number4 >> 24 & 255;
  uint8Array[1] = number4 >> 16 & 255;
  uint8Array[2] = number4 >> 8 & 255;
  uint8Array[3] = number4 & 255;
  return uint8Array;
}
function decode(nip19) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  let { prefix, words } = bech32.decode(nip19, Bech32MaxSize);
  let data = new Uint8Array(bech32.fromWords(words));
  switch (prefix) {
    case "nprofile": {
      let tlv = parseTLV(data);
      if (!((_a = tlv[0]) == null ? void 0 : _a[0]))
        throw new Error("missing TLV 0 for nprofile");
      if (tlv[0][0].length !== 32)
        throw new Error("TLV 0 should be 32 bytes");
      return {
        type: "nprofile",
        data: {
          pubkey: bytesToHex2(tlv[0][0]),
          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : []
        }
      };
    }
    case "nevent": {
      let tlv = parseTLV(data);
      if (!((_b = tlv[0]) == null ? void 0 : _b[0]))
        throw new Error("missing TLV 0 for nevent");
      if (tlv[0][0].length !== 32)
        throw new Error("TLV 0 should be 32 bytes");
      if (tlv[2] && tlv[2][0].length !== 32)
        throw new Error("TLV 2 should be 32 bytes");
      if (tlv[3] && tlv[3][0].length !== 4)
        throw new Error("TLV 3 should be 4 bytes");
      return {
        type: "nevent",
        data: {
          id: bytesToHex2(tlv[0][0]),
          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : [],
          author: ((_c = tlv[2]) == null ? void 0 : _c[0]) ? bytesToHex2(tlv[2][0]) : void 0,
          kind: ((_d = tlv[3]) == null ? void 0 : _d[0]) ? parseInt(bytesToHex2(tlv[3][0]), 16) : void 0
        }
      };
    }
    case "naddr": {
      let tlv = parseTLV(data);
      if (!((_e = tlv[0]) == null ? void 0 : _e[0]))
        throw new Error("missing TLV 0 for naddr");
      if (!((_f = tlv[2]) == null ? void 0 : _f[0]))
        throw new Error("missing TLV 2 for naddr");
      if (tlv[2][0].length !== 32)
        throw new Error("TLV 2 should be 32 bytes");
      if (!((_g = tlv[3]) == null ? void 0 : _g[0]))
        throw new Error("missing TLV 3 for naddr");
      if (tlv[3][0].length !== 4)
        throw new Error("TLV 3 should be 4 bytes");
      return {
        type: "naddr",
        data: {
          identifier: utf8Decoder.decode(tlv[0][0]),
          pubkey: bytesToHex2(tlv[2][0]),
          kind: parseInt(bytesToHex2(tlv[3][0]), 16),
          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : []
        }
      };
    }
    case "nrelay": {
      let tlv = parseTLV(data);
      if (!((_h = tlv[0]) == null ? void 0 : _h[0]))
        throw new Error("missing TLV 0 for nrelay");
      return {
        type: "nrelay",
        data: utf8Decoder.decode(tlv[0][0])
      };
    }
    case "nsec":
      return { type: prefix, data };
    case "npub":
    case "note":
      return { type: prefix, data: bytesToHex2(data) };
    default:
      throw new Error(`unknown prefix ${prefix}`);
  }
}
function parseTLV(data) {
  let result = {};
  let rest = data;
  while (rest.length > 0) {
    let t = rest[0];
    let l = rest[1];
    let v = rest.slice(2, 2 + l);
    rest = rest.slice(2 + l);
    if (v.length < l)
      throw new Error(`not enough data to read on TLV ${t}`);
    result[t] = result[t] || [];
    result[t].push(v);
  }
  return result;
}
function nsecEncode(key) {
  return encodeBytes("nsec", key);
}
function npubEncode(hex2) {
  return encodeBytes("npub", hexToBytes2(hex2));
}
function noteEncode(hex2) {
  return encodeBytes("note", hexToBytes2(hex2));
}
function encodeBech32(prefix, data) {
  let words = bech32.toWords(data);
  return bech32.encode(prefix, words, Bech32MaxSize);
}
function encodeBytes(prefix, bytes4) {
  return encodeBech32(prefix, bytes4);
}
function nprofileEncode(profile) {
  let data = encodeTLV({
    0: [hexToBytes2(profile.pubkey)],
    1: (profile.relays || []).map((url) => utf8Encoder.encode(url))
  });
  return encodeBech32("nprofile", data);
}
function neventEncode(event) {
  let kindArray;
  if (event.kind !== void 0) {
    kindArray = integerToUint8Array(event.kind);
  }
  let data = encodeTLV({
    0: [hexToBytes2(event.id)],
    1: (event.relays || []).map((url) => utf8Encoder.encode(url)),
    2: event.author ? [hexToBytes2(event.author)] : [],
    3: kindArray ? [new Uint8Array(kindArray)] : []
  });
  return encodeBech32("nevent", data);
}
function naddrEncode(addr) {
  let kind = new ArrayBuffer(4);
  new DataView(kind).setUint32(0, addr.kind, false);
  let data = encodeTLV({
    0: [utf8Encoder.encode(addr.identifier)],
    1: (addr.relays || []).map((url) => utf8Encoder.encode(url)),
    2: [hexToBytes2(addr.pubkey)],
    3: [new Uint8Array(kind)]
  });
  return encodeBech32("naddr", data);
}
function nrelayEncode(url) {
  let data = encodeTLV({
    0: [utf8Encoder.encode(url)]
  });
  return encodeBech32("nrelay", data);
}
function encodeTLV(tlv) {
  let entries = [];
  Object.entries(tlv).reverse().forEach(([t, vs]) => {
    vs.forEach((v) => {
      let entry = new Uint8Array(v.length + 2);
      entry.set([parseInt(t)], 0);
      entry.set([v.length], 1);
      entry.set(v, 2);
      entries.push(entry);
    });
  });
  return concatBytes3(...entries);
}
var nip04_exports = {};
__export2(nip04_exports, {
  decrypt: () => decrypt2,
  encrypt: () => encrypt2
});
async function encrypt2(secretKey, pubkey, text) {
  const privkey = secretKey instanceof Uint8Array ? bytesToHex2(secretKey) : secretKey;
  const key = secp256k1.getSharedSecret(privkey, "02" + pubkey);
  const normalizedKey = getNormalizedX(key);
  let iv = Uint8Array.from(randomBytes2(16));
  let plaintext = utf8Encoder.encode(text);
  let ciphertext = cbc(normalizedKey, iv).encrypt(plaintext);
  let ctb64 = base64.encode(new Uint8Array(ciphertext));
  let ivb64 = base64.encode(new Uint8Array(iv.buffer));
  return `${ctb64}?iv=${ivb64}`;
}
async function decrypt2(secretKey, pubkey, data) {
  const privkey = secretKey instanceof Uint8Array ? bytesToHex2(secretKey) : secretKey;
  let [ctb64, ivb64] = data.split("?iv=");
  let key = secp256k1.getSharedSecret(privkey, "02" + pubkey);
  let normalizedKey = getNormalizedX(key);
  let iv = base64.decode(ivb64);
  let ciphertext = base64.decode(ctb64);
  let plaintext = cbc(normalizedKey, iv).decrypt(ciphertext);
  return utf8Decoder.decode(plaintext);
}
function getNormalizedX(key) {
  return key.slice(1, 33);
}
var nip05_exports = {};
__export2(nip05_exports, {
  NIP05_REGEX: () => NIP05_REGEX,
  isValid: () => isValid,
  queryProfile: () => queryProfile,
  searchDomain: () => searchDomain,
  useFetchImplementation: () => useFetchImplementation
});
var NIP05_REGEX = /^(?:([\w.+-]+)@)?([\w_-]+(\.[\w_-]+)+)$/;
var _fetch;
try {
  _fetch = fetch;
} catch (e) {
}
function useFetchImplementation(fetchImplementation) {
  _fetch = fetchImplementation;
}
async function searchDomain(domain, query = "") {
  try {
    const url = `https://${domain}/.well-known/nostr.json?name=${query}`;
    const res = await _fetch(url, { redirect: "error" });
    const json = await res.json();
    return json.names;
  } catch (_) {
    return {};
  }
}
async function queryProfile(fullname) {
  var _a;
  const match = fullname.match(NIP05_REGEX);
  if (!match)
    return null;
  const [_, name = "_", domain] = match;
  try {
    const url = `https://${domain}/.well-known/nostr.json?name=${name}`;
    const res = await (await _fetch(url, { redirect: "error" })).json();
    let pubkey = res.names[name];
    return pubkey ? { pubkey, relays: (_a = res.relays) == null ? void 0 : _a[pubkey] } : null;
  } catch (_e) {
    return null;
  }
}
async function isValid(pubkey, nip05) {
  let res = await queryProfile(nip05);
  return res ? res.pubkey === pubkey : false;
}
var nip10_exports = {};
__export2(nip10_exports, {
  parse: () => parse
});
function parse(event) {
  const result = {
    reply: void 0,
    root: void 0,
    mentions: [],
    profiles: []
  };
  const eTags = [];
  for (const tag of event.tags) {
    if (tag[0] === "e" && tag[1]) {
      eTags.push(tag);
    }
    if (tag[0] === "p" && tag[1]) {
      result.profiles.push({
        pubkey: tag[1],
        relays: tag[2] ? [tag[2]] : []
      });
    }
  }
  for (let eTagIndex = 0; eTagIndex < eTags.length; eTagIndex++) {
    const eTag = eTags[eTagIndex];
    const [_, eTagEventId, eTagRelayUrl, eTagMarker] = eTag;
    const eventPointer = {
      id: eTagEventId,
      relays: eTagRelayUrl ? [eTagRelayUrl] : []
    };
    const isFirstETag = eTagIndex === 0;
    const isLastETag = eTagIndex === eTags.length - 1;
    if (eTagMarker === "root") {
      result.root = eventPointer;
      continue;
    }
    if (eTagMarker === "reply") {
      result.reply = eventPointer;
      continue;
    }
    if (eTagMarker === "mention") {
      result.mentions.push(eventPointer);
      continue;
    }
    if (isFirstETag) {
      result.root = eventPointer;
      continue;
    }
    if (isLastETag) {
      result.reply = eventPointer;
      continue;
    }
    result.mentions.push(eventPointer);
  }
  return result;
}
var nip11_exports = {};
__export2(nip11_exports, {
  fetchRelayInformation: () => fetchRelayInformation,
  useFetchImplementation: () => useFetchImplementation2
});
var _fetch2;
try {
  _fetch2 = fetch;
} catch (e) {
}
function useFetchImplementation2(fetchImplementation) {
  _fetch2 = fetchImplementation;
}
async function fetchRelayInformation(url) {
  return await (await fetch(url.replace("ws://", "http://").replace("wss://", "https://"), {
    headers: { Accept: "application/nostr+json" }
  })).json();
}
var nip13_exports = {};
__export2(nip13_exports, {
  getPow: () => getPow,
  minePow: () => minePow
});
function getPow(hex2) {
  let count = 0;
  for (let i22 = 0; i22 < hex2.length; i22++) {
    const nibble = parseInt(hex2[i22], 16);
    if (nibble === 0) {
      count += 4;
    } else {
      count += Math.clz32(nibble) - 28;
      break;
    }
  }
  return count;
}
function minePow(unsigned, difficulty) {
  let count = 0;
  const event = unsigned;
  const tag = ["nonce", count.toString(), difficulty.toString()];
  event.tags.push(tag);
  while (true) {
    const now = Math.floor(new Date().getTime() / 1e3);
    if (now !== event.created_at) {
      count = 0;
      event.created_at = now;
    }
    tag[1] = (++count).toString();
    event.id = getEventHash(event);
    if (getPow(event.id) >= difficulty) {
      break;
    }
  }
  return event;
}
var nip18_exports = {};
__export2(nip18_exports, {
  finishRepostEvent: () => finishRepostEvent,
  getRepostedEvent: () => getRepostedEvent,
  getRepostedEventPointer: () => getRepostedEventPointer
});
function finishRepostEvent(t, reposted, relayUrl, privateKey) {
  var _a;
  return finalizeEvent(
    {
      kind: Repost,
      tags: [...(_a = t.tags) != null ? _a : [], ["e", reposted.id, relayUrl], ["p", reposted.pubkey]],
      content: t.content === "" ? "" : JSON.stringify(reposted),
      created_at: t.created_at
    },
    privateKey
  );
}
function getRepostedEventPointer(event) {
  if (event.kind !== Repost) {
    return void 0;
  }
  let lastETag;
  let lastPTag;
  for (let i22 = event.tags.length - 1; i22 >= 0 && (lastETag === void 0 || lastPTag === void 0); i22--) {
    const tag = event.tags[i22];
    if (tag.length >= 2) {
      if (tag[0] === "e" && lastETag === void 0) {
        lastETag = tag;
      } else if (tag[0] === "p" && lastPTag === void 0) {
        lastPTag = tag;
      }
    }
  }
  if (lastETag === void 0) {
    return void 0;
  }
  return {
    id: lastETag[1],
    relays: [lastETag[2], lastPTag == null ? void 0 : lastPTag[2]].filter((x) => typeof x === "string"),
    author: lastPTag == null ? void 0 : lastPTag[1]
  };
}
function getRepostedEvent(event, { skipVerification } = {}) {
  const pointer = getRepostedEventPointer(event);
  if (pointer === void 0 || event.content === "") {
    return void 0;
  }
  let repostedEvent;
  try {
    repostedEvent = JSON.parse(event.content);
  } catch (error) {
    return void 0;
  }
  if (repostedEvent.id !== pointer.id) {
    return void 0;
  }
  if (!skipVerification && !verifyEvent(repostedEvent)) {
    return void 0;
  }
  return repostedEvent;
}
var nip21_exports = {};
__export2(nip21_exports, {
  NOSTR_URI_REGEX: () => NOSTR_URI_REGEX,
  parse: () => parse2,
  test: () => test
});
var NOSTR_URI_REGEX = new RegExp(`nostr:(${BECH32_REGEX.source})`);
function test(value) {
  return typeof value === "string" && new RegExp(`^${NOSTR_URI_REGEX.source}$`).test(value);
}
function parse2(uri) {
  const match = uri.match(new RegExp(`^${NOSTR_URI_REGEX.source}$`));
  if (!match)
    throw new Error(`Invalid Nostr URI: ${uri}`);
  return {
    uri: match[0],
    value: match[1],
    decoded: decode(match[1])
  };
}
var nip25_exports = {};
__export2(nip25_exports, {
  finishReactionEvent: () => finishReactionEvent,
  getReactedEventPointer: () => getReactedEventPointer
});
function finishReactionEvent(t, reacted, privateKey) {
  var _a, _b;
  const inheritedTags = reacted.tags.filter((tag) => tag.length >= 2 && (tag[0] === "e" || tag[0] === "p"));
  return finalizeEvent(
    {
      ...t,
      kind: Reaction,
      tags: [...(_a = t.tags) != null ? _a : [], ...inheritedTags, ["e", reacted.id], ["p", reacted.pubkey]],
      content: (_b = t.content) != null ? _b : "+"
    },
    privateKey
  );
}
function getReactedEventPointer(event) {
  if (event.kind !== Reaction) {
    return void 0;
  }
  let lastETag;
  let lastPTag;
  for (let i22 = event.tags.length - 1; i22 >= 0 && (lastETag === void 0 || lastPTag === void 0); i22--) {
    const tag = event.tags[i22];
    if (tag.length >= 2) {
      if (tag[0] === "e" && lastETag === void 0) {
        lastETag = tag;
      } else if (tag[0] === "p" && lastPTag === void 0) {
        lastPTag = tag;
      }
    }
  }
  if (lastETag === void 0 || lastPTag === void 0) {
    return void 0;
  }
  return {
    id: lastETag[1],
    relays: [lastETag[2], lastPTag[2]].filter((x) => x !== void 0),
    author: lastPTag[1]
  };
}
var nip27_exports = {};
__export2(nip27_exports, {
  matchAll: () => matchAll,
  regex: () => regex,
  replaceAll: () => replaceAll
});
var regex = () => new RegExp(`\\b${NOSTR_URI_REGEX.source}\\b`, "g");
function* matchAll(content) {
  const matches = content.matchAll(regex());
  for (const match of matches) {
    try {
      const [uri, value] = match;
      yield {
        uri,
        value,
        decoded: decode(value),
        start: match.index,
        end: match.index + uri.length
      };
    } catch (_e) {
    }
  }
}
function replaceAll(content, replacer) {
  return content.replaceAll(regex(), (uri, value) => {
    return replacer({
      uri,
      value,
      decoded: decode(value)
    });
  });
}
var nip28_exports = {};
__export2(nip28_exports, {
  channelCreateEvent: () => channelCreateEvent,
  channelHideMessageEvent: () => channelHideMessageEvent,
  channelMessageEvent: () => channelMessageEvent,
  channelMetadataEvent: () => channelMetadataEvent,
  channelMuteUserEvent: () => channelMuteUserEvent
});
var channelCreateEvent = (t, privateKey) => {
  var _a;
  let content;
  if (typeof t.content === "object") {
    content = JSON.stringify(t.content);
  } else if (typeof t.content === "string") {
    content = t.content;
  } else {
    return void 0;
  }
  return finalizeEvent(
    {
      kind: ChannelCreation,
      tags: [...(_a = t.tags) != null ? _a : []],
      content,
      created_at: t.created_at
    },
    privateKey
  );
};
var channelMetadataEvent = (t, privateKey) => {
  var _a;
  let content;
  if (typeof t.content === "object") {
    content = JSON.stringify(t.content);
  } else if (typeof t.content === "string") {
    content = t.content;
  } else {
    return void 0;
  }
  return finalizeEvent(
    {
      kind: ChannelMetadata,
      tags: [["e", t.channel_create_event_id], ...(_a = t.tags) != null ? _a : []],
      content,
      created_at: t.created_at
    },
    privateKey
  );
};
var channelMessageEvent = (t, privateKey) => {
  var _a;
  const tags = [["e", t.channel_create_event_id, t.relay_url, "root"]];
  if (t.reply_to_channel_message_event_id) {
    tags.push(["e", t.reply_to_channel_message_event_id, t.relay_url, "reply"]);
  }
  return finalizeEvent(
    {
      kind: ChannelMessage,
      tags: [...tags, ...(_a = t.tags) != null ? _a : []],
      content: t.content,
      created_at: t.created_at
    },
    privateKey
  );
};
var channelHideMessageEvent = (t, privateKey) => {
  var _a;
  let content;
  if (typeof t.content === "object") {
    content = JSON.stringify(t.content);
  } else if (typeof t.content === "string") {
    content = t.content;
  } else {
    return void 0;
  }
  return finalizeEvent(
    {
      kind: ChannelHideMessage,
      tags: [["e", t.channel_message_event_id], ...(_a = t.tags) != null ? _a : []],
      content,
      created_at: t.created_at
    },
    privateKey
  );
};
var channelMuteUserEvent = (t, privateKey) => {
  var _a;
  let content;
  if (typeof t.content === "object") {
    content = JSON.stringify(t.content);
  } else if (typeof t.content === "string") {
    content = t.content;
  } else {
    return void 0;
  }
  return finalizeEvent(
    {
      kind: ChannelMuteUser,
      tags: [["p", t.pubkey_to_mute], ...(_a = t.tags) != null ? _a : []],
      content,
      created_at: t.created_at
    },
    privateKey
  );
};
var nip30_exports = {};
__export2(nip30_exports, {
  EMOJI_SHORTCODE_REGEX: () => EMOJI_SHORTCODE_REGEX,
  matchAll: () => matchAll2,
  regex: () => regex2,
  replaceAll: () => replaceAll2
});
var EMOJI_SHORTCODE_REGEX = /:(\w+):/;
var regex2 = () => new RegExp(`\\B${EMOJI_SHORTCODE_REGEX.source}\\B`, "g");
function* matchAll2(content) {
  const matches = content.matchAll(regex2());
  for (const match of matches) {
    try {
      const [shortcode, name] = match;
      yield {
        shortcode,
        name,
        start: match.index,
        end: match.index + shortcode.length
      };
    } catch (_e) {
    }
  }
}
function replaceAll2(content, replacer) {
  return content.replaceAll(regex2(), (shortcode, name) => {
    return replacer({
      shortcode,
      name
    });
  });
}
var nip39_exports = {};
__export2(nip39_exports, {
  useFetchImplementation: () => useFetchImplementation3,
  validateGithub: () => validateGithub
});
var _fetch3;
try {
  _fetch3 = fetch;
} catch (e) {
}
function useFetchImplementation3(fetchImplementation) {
  _fetch3 = fetchImplementation;
}
async function validateGithub(pubkey, username, proof) {
  try {
    let res = await (await _fetch3(`https://gist.github.com/${username}/${proof}/raw`)).text();
    return res === `Verifying that I control the following Nostr public key: ${pubkey}`;
  } catch (_) {
    return false;
  }
}
var nip44_exports = {};
__export2(nip44_exports, {
  default: () => nip44_default,
  v2: () => v2
});
var decoder = new TextDecoder();
var u = {
  minPlaintextSize: 1,
  maxPlaintextSize: 65535,
  utf8Encode: utf8ToBytes3,
  utf8Decode(bytes4) {
    return decoder.decode(bytes4);
  },
  getConversationKey(privkeyA, pubkeyB) {
    const sharedX = secp256k1.getSharedSecret(privkeyA, "02" + pubkeyB).subarray(1, 33);
    return extract(sha2562, sharedX, "nip44-v2");
  },
  getMessageKeys(conversationKey, nonce) {
    const keys = expand(sha2562, conversationKey, nonce, 76);
    return {
      chacha_key: keys.subarray(0, 32),
      chacha_nonce: keys.subarray(32, 44),
      hmac_key: keys.subarray(44, 76)
    };
  },
  calcPaddedLen(len) {
    if (!Number.isSafeInteger(len) || len < 1)
      throw new Error("expected positive integer");
    if (len <= 32)
      return 32;
    const nextPower = 1 << Math.floor(Math.log2(len - 1)) + 1;
    const chunk = nextPower <= 256 ? 32 : nextPower / 8;
    return chunk * (Math.floor((len - 1) / chunk) + 1);
  },
  writeU16BE(num) {
    if (!Number.isSafeInteger(num) || num < u.minPlaintextSize || num > u.maxPlaintextSize)
      throw new Error("invalid plaintext size: must be between 1 and 65535 bytes");
    const arr = new Uint8Array(2);
    new DataView(arr.buffer).setUint16(0, num, false);
    return arr;
  },
  pad(plaintext) {
    const unpadded = u.utf8Encode(plaintext);
    const unpaddedLen = unpadded.length;
    const prefix = u.writeU16BE(unpaddedLen);
    const suffix = new Uint8Array(u.calcPaddedLen(unpaddedLen) - unpaddedLen);
    return concatBytes3(prefix, unpadded, suffix);
  },
  unpad(padded) {
    const unpaddedLen = new DataView(padded.buffer).getUint16(0);
    const unpadded = padded.subarray(2, 2 + unpaddedLen);
    if (unpaddedLen < u.minPlaintextSize || unpaddedLen > u.maxPlaintextSize || unpadded.length !== unpaddedLen || padded.length !== 2 + u.calcPaddedLen(unpaddedLen))
      throw new Error("invalid padding");
    return u.utf8Decode(unpadded);
  },
  hmacAad(key, message, aad) {
    if (aad.length !== 32)
      throw new Error("AAD associated data must be 32 bytes");
    const combined = concatBytes3(aad, message);
    return hmac2(sha2562, key, combined);
  },
  decodePayload(payload) {
    if (typeof payload !== "string")
      throw new Error("payload must be a valid string");
    const plen = payload.length;
    if (plen < 132 || plen > 87472)
      throw new Error("invalid payload length: " + plen);
    if (payload[0] === "#")
      throw new Error("unknown encryption version");
    let data;
    try {
      data = base64.decode(payload);
    } catch (error) {
      throw new Error("invalid base64: " + error.message);
    }
    const dlen = data.length;
    if (dlen < 99 || dlen > 65603)
      throw new Error("invalid data length: " + dlen);
    const vers = data[0];
    if (vers !== 2)
      throw new Error("unknown encryption version " + vers);
    return {
      nonce: data.subarray(1, 33),
      ciphertext: data.subarray(33, -32),
      mac: data.subarray(-32)
    };
  }
};
function encrypt22(plaintext, conversationKey, nonce = randomBytes2(32)) {
  const { chacha_key, chacha_nonce, hmac_key } = u.getMessageKeys(conversationKey, nonce);
  const padded = u.pad(plaintext);
  const ciphertext = chacha20(chacha_key, chacha_nonce, padded);
  const mac = u.hmacAad(hmac_key, ciphertext, nonce);
  return base64.encode(concatBytes3(new Uint8Array([2]), nonce, ciphertext, mac));
}
function decrypt22(payload, conversationKey) {
  const { nonce, ciphertext, mac } = u.decodePayload(payload);
  const { chacha_key, chacha_nonce, hmac_key } = u.getMessageKeys(conversationKey, nonce);
  const calculatedMac = u.hmacAad(hmac_key, ciphertext, nonce);
  if (!equalBytes2(calculatedMac, mac))
    throw new Error("invalid MAC");
  const padded = chacha20(chacha_key, chacha_nonce, ciphertext);
  return u.unpad(padded);
}
var v2 = {
  utils: u,
  encrypt: encrypt22,
  decrypt: decrypt22
};
var nip44_default = { v2 };
var nip47_exports = {};
__export2(nip47_exports, {
  makeNwcRequestEvent: () => makeNwcRequestEvent,
  parseConnectionString: () => parseConnectionString
});
function parseConnectionString(connectionString) {
  const { pathname, searchParams } = new URL(connectionString);
  const pubkey = pathname;
  const relay = searchParams.get("relay");
  const secret = searchParams.get("secret");
  if (!pubkey || !relay || !secret) {
    throw new Error("invalid connection string");
  }
  return { pubkey, relay, secret };
}
async function makeNwcRequestEvent(pubkey, secretKey, invoice) {
  const content = {
    method: "pay_invoice",
    params: {
      invoice
    }
  };
  const encryptedContent = await encrypt2(secretKey, pubkey, JSON.stringify(content));
  const eventTemplate = {
    kind: NWCWalletRequest,
    created_at: Math.round(Date.now() / 1e3),
    content: encryptedContent,
    tags: [["p", pubkey]]
  };
  return finalizeEvent(eventTemplate, secretKey);
}
var nip57_exports = {};
__export2(nip57_exports, {
  getZapEndpoint: () => getZapEndpoint,
  makeZapReceipt: () => makeZapReceipt,
  makeZapRequest: () => makeZapRequest,
  useFetchImplementation: () => useFetchImplementation4,
  validateZapRequest: () => validateZapRequest
});
var _fetch4;
try {
  _fetch4 = fetch;
} catch (e) {
}
function useFetchImplementation4(fetchImplementation) {
  _fetch4 = fetchImplementation;
}
async function getZapEndpoint(metadata) {
  try {
    let lnurl = "";
    let { lud06, lud16 } = JSON.parse(metadata.content);
    if (lud06) {
      let { words } = bech32.decode(lud06, 1e3);
      let data = bech32.fromWords(words);
      lnurl = utf8Decoder.decode(data);
    } else if (lud16) {
      let [name, domain] = lud16.split("@");
      lnurl = new URL(`/.well-known/lnurlp/${name}`, `https://${domain}`).toString();
    } else {
      return null;
    }
    let res = await _fetch4(lnurl);
    let body = await res.json();
    if (body.allowsNostr && body.nostrPubkey) {
      return body.callback;
    }
  } catch (err) {
  }
  return null;
}
function makeZapRequest({
  profile,
  event,
  amount,
  relays,
  comment = ""
}) {
  if (!amount)
    throw new Error("amount not given");
  if (!profile)
    throw new Error("profile not given");
  let zr = {
    kind: 9734,
    created_at: Math.round(Date.now() / 1e3),
    content: comment,
    tags: [
      ["p", profile],
      ["amount", amount.toString()],
      ["relays", ...relays]
    ]
  };
  if (event) {
    zr.tags.push(["e", event]);
  }
  return zr;
}
function validateZapRequest(zapRequestString) {
  let zapRequest;
  try {
    zapRequest = JSON.parse(zapRequestString);
  } catch (err) {
    return "Invalid zap request JSON.";
  }
  if (!validateEvent(zapRequest))
    return "Zap request is not a valid Nostr event.";
  if (!verifyEvent(zapRequest))
    return "Invalid signature on zap request.";
  let p = zapRequest.tags.find(([t, v]) => t === "p" && v);
  if (!p)
    return "Zap request doesn't have a 'p' tag.";
  if (!p[1].match(/^[a-f0-9]{64}$/))
    return "Zap request 'p' tag is not valid hex.";
  let e = zapRequest.tags.find(([t, v]) => t === "e" && v);
  if (e && !e[1].match(/^[a-f0-9]{64}$/))
    return "Zap request 'e' tag is not valid hex.";
  let relays = zapRequest.tags.find(([t, v]) => t === "relays" && v);
  if (!relays)
    return "Zap request doesn't have a 'relays' tag.";
  return null;
}
function makeZapReceipt({
  zapRequest,
  preimage,
  bolt11,
  paidAt
}) {
  let zr = JSON.parse(zapRequest);
  let tagsFromZapRequest = zr.tags.filter(([t]) => t === "e" || t === "p" || t === "a");
  let zap = {
    kind: 9735,
    created_at: Math.round(paidAt.getTime() / 1e3),
    content: "",
    tags: [...tagsFromZapRequest, ["P", zr.pubkey], ["bolt11", bolt11], ["description", zapRequest]]
  };
  if (preimage) {
    zap.tags.push(["preimage", preimage]);
  }
  return zap;
}
var nip98_exports = {};
__export2(nip98_exports, {
  getToken: () => getToken,
  hashPayload: () => hashPayload,
  unpackEventFromToken: () => unpackEventFromToken,
  validateEvent: () => validateEvent2,
  validateEventKind: () => validateEventKind,
  validateEventMethodTag: () => validateEventMethodTag,
  validateEventPayloadTag: () => validateEventPayloadTag,
  validateEventTimestamp: () => validateEventTimestamp,
  validateEventUrlTag: () => validateEventUrlTag,
  validateToken: () => validateToken
});
var _authorizationScheme = "Nostr ";
async function getToken(loginUrl, httpMethod, sign, includeAuthorizationScheme = false, payload) {
  const event = {
    kind: HTTPAuth,
    tags: [
      ["u", loginUrl],
      ["method", httpMethod]
    ],
    created_at: Math.round(new Date().getTime() / 1e3),
    content: ""
  };
  if (payload) {
    event.tags.push(["payload", hashPayload(payload)]);
  }
  const signedEvent = await sign(event);
  const authorizationScheme = includeAuthorizationScheme ? _authorizationScheme : "";
  return authorizationScheme + base64.encode(utf8Encoder.encode(JSON.stringify(signedEvent)));
}
async function validateToken(token, url, method) {
  const event = await unpackEventFromToken(token).catch((error) => {
    throw error;
  });
  const valid = await validateEvent2(event, url, method).catch((error) => {
    throw error;
  });
  return valid;
}
async function unpackEventFromToken(token) {
  if (!token) {
    throw new Error("Missing token");
  }
  token = token.replace(_authorizationScheme, "");
  const eventB64 = utf8Decoder.decode(base64.decode(token));
  if (!eventB64 || eventB64.length === 0 || !eventB64.startsWith("{")) {
    throw new Error("Invalid token");
  }
  const event = JSON.parse(eventB64);
  return event;
}
function validateEventTimestamp(event) {
  if (!event.created_at) {
    return false;
  }
  return Math.round(new Date().getTime() / 1e3) - event.created_at < 60;
}
function validateEventKind(event) {
  return event.kind === HTTPAuth;
}
function validateEventUrlTag(event, url) {
  const urlTag = event.tags.find((t) => t[0] === "u");
  if (!urlTag) {
    return false;
  }
  return urlTag.length > 0 && urlTag[1] === url;
}
function validateEventMethodTag(event, method) {
  const methodTag = event.tags.find((t) => t[0] === "method");
  if (!methodTag) {
    return false;
  }
  return methodTag.length > 0 && methodTag[1].toLowerCase() === method.toLowerCase();
}
function hashPayload(payload) {
  const hash3 = sha2562(utf8Encoder.encode(JSON.stringify(payload)));
  return bytesToHex2(hash3);
}
function validateEventPayloadTag(event, payload) {
  const payloadTag = event.tags.find((t) => t[0] === "payload");
  if (!payloadTag) {
    return false;
  }
  const payloadHash = hashPayload(payload);
  return payloadTag.length > 0 && payloadTag[1] === payloadHash;
}
async function validateEvent2(event, url, method, body) {
  if (!verifyEvent(event)) {
    throw new Error("Invalid nostr event, signature invalid");
  }
  if (!validateEventKind(event)) {
    throw new Error("Invalid nostr event, kind invalid");
  }
  if (!validateEventTimestamp(event)) {
    throw new Error("Invalid nostr event, created_at timestamp invalid");
  }
  if (!validateEventUrlTag(event, url)) {
    throw new Error("Invalid nostr event, url tag invalid");
  }
  if (!validateEventMethodTag(event, method)) {
    throw new Error("Invalid nostr event, method tag invalid");
  }
  if (Boolean(body) && typeof body === "object" && Object.keys(body).length > 0) {
    if (!validateEventPayloadTag(event, body)) {
      throw new Error("Invalid nostr event, payload tag does not match request body hash");
    }
  }
  return true;
}

// node_modules/nostr-tools/lib/esm/pool.js
var verifiedSymbol2 = Symbol("verified");
var isRecord2 = (obj) => obj instanceof Object;
function validateEvent3(event) {
  if (!isRecord2(event))
    return false;
  if (typeof event.kind !== "number")
    return false;
  if (typeof event.content !== "string")
    return false;
  if (typeof event.created_at !== "number")
    return false;
  if (typeof event.pubkey !== "string")
    return false;
  if (!event.pubkey.match(/^[a-f0-9]{64}$/))
    return false;
  if (!Array.isArray(event.tags))
    return false;
  for (let i22 = 0; i22 < event.tags.length; i22++) {
    let tag = event.tags[i22];
    if (!Array.isArray(tag))
      return false;
    for (let j = 0; j < tag.length; j++) {
      if (typeof tag[j] === "object")
        return false;
    }
  }
  return true;
}
var utf8Decoder2 = new TextDecoder("utf-8");
var utf8Encoder2 = new TextEncoder();
function normalizeURL2(url) {
  if (url.indexOf("://") === -1)
    url = "wss://" + url;
  let p = new URL(url);
  p.pathname = p.pathname.replace(/\/+/g, "/");
  if (p.pathname.endsWith("/"))
    p.pathname = p.pathname.slice(0, -1);
  if (p.port === "80" && p.protocol === "ws:" || p.port === "443" && p.protocol === "wss:")
    p.port = "";
  p.searchParams.sort();
  p.hash = "";
  return p.toString();
}
var QueueNode2 = class {
  constructor(message) {
    __publicField(this, "value");
    __publicField(this, "next", null);
    __publicField(this, "prev", null);
    this.value = message;
  }
};
var Queue2 = class {
  constructor() {
    __publicField(this, "first");
    __publicField(this, "last");
    this.first = null;
    this.last = null;
  }
  enqueue(value) {
    const newNode = new QueueNode2(value);
    if (!this.last) {
      this.first = newNode;
      this.last = newNode;
    } else if (this.last === this.first) {
      this.last = newNode;
      this.last.prev = this.first;
      this.first.next = newNode;
    } else {
      newNode.prev = this.last;
      this.last.next = newNode;
      this.last = newNode;
    }
    return true;
  }
  dequeue() {
    if (!this.first)
      return null;
    if (this.first === this.last) {
      const target2 = this.first;
      this.first = null;
      this.last = null;
      return target2.value;
    }
    const target = this.first;
    this.first = target.next;
    return target.value;
  }
};
var JS2 = class {
  generateSecretKey() {
    return schnorr.utils.randomPrivateKey();
  }
  getPublicKey(secretKey) {
    return bytesToHex2(schnorr.getPublicKey(secretKey));
  }
  finalizeEvent(t, secretKey) {
    const event = t;
    event.pubkey = bytesToHex2(schnorr.getPublicKey(secretKey));
    event.id = getEventHash2(event);
    event.sig = bytesToHex2(schnorr.sign(getEventHash2(event), secretKey));
    event[verifiedSymbol2] = true;
    return event;
  }
  verifyEvent(event) {
    if (typeof event[verifiedSymbol2] === "boolean")
      return event[verifiedSymbol2];
    const hash3 = getEventHash2(event);
    if (hash3 !== event.id) {
      event[verifiedSymbol2] = false;
      return false;
    }
    try {
      const valid = schnorr.verify(event.sig, hash3, event.pubkey);
      event[verifiedSymbol2] = valid;
      return valid;
    } catch (err) {
      event[verifiedSymbol2] = false;
      return false;
    }
  }
};
function serializeEvent2(evt) {
  if (!validateEvent3(evt))
    throw new Error("can't serialize event with wrong or missing properties");
  return JSON.stringify([0, evt.pubkey, evt.created_at, evt.kind, evt.tags, evt.content]);
}
function getEventHash2(event) {
  let eventHash = sha2562(utf8Encoder2.encode(serializeEvent2(event)));
  return bytesToHex2(eventHash);
}
var i2 = new JS2();
var generateSecretKey2 = i2.generateSecretKey;
var getPublicKey2 = i2.getPublicKey;
var finalizeEvent2 = i2.finalizeEvent;
var verifyEvent2 = i2.verifyEvent;
var ClientAuth2 = 22242;
function matchFilter(filter2, event) {
  if (filter2.ids && filter2.ids.indexOf(event.id) === -1) {
    if (!filter2.ids.some((prefix) => event.id.startsWith(prefix))) {
      return false;
    }
  }
  if (filter2.kinds && filter2.kinds.indexOf(event.kind) === -1)
    return false;
  if (filter2.authors && filter2.authors.indexOf(event.pubkey) === -1) {
    if (!filter2.authors.some((prefix) => event.pubkey.startsWith(prefix))) {
      return false;
    }
  }
  for (let f in filter2) {
    if (f[0] === "#") {
      let tagName = f.slice(1);
      let values = filter2[`#${tagName}`];
      if (values && !event.tags.find(([t, v]) => t === f.slice(1) && values.indexOf(v) !== -1))
        return false;
    }
  }
  if (filter2.since && event.created_at < filter2.since)
    return false;
  if (filter2.until && event.created_at > filter2.until)
    return false;
  return true;
}
function matchFilters(filters, event) {
  for (let i22 = 0; i22 < filters.length; i22++) {
    if (matchFilter(filters[i22], event))
      return true;
  }
  return false;
}
function getHex642(json, field) {
  let len = field.length + 3;
  let idx = json.indexOf(`"${field}":`) + len;
  let s = json.slice(idx).indexOf(`"`) + idx + 1;
  return json.slice(s, s + 64);
}
function getSubscriptionId2(json) {
  let idx = json.slice(0, 22).indexOf(`"EVENT"`);
  if (idx === -1)
    return null;
  let pstart = json.slice(idx + 7 + 1).indexOf(`"`);
  if (pstart === -1)
    return null;
  let start = idx + 7 + 1 + pstart;
  let pend = json.slice(start + 1, 80).indexOf(`"`);
  if (pend === -1)
    return null;
  let end = start + 1 + pend;
  return json.slice(start + 1, end);
}
function makeAuthEvent2(relayURL, challenge2) {
  return {
    kind: ClientAuth2,
    created_at: Math.floor(Date.now() / 1e3),
    tags: [
      ["relay", relayURL],
      ["challenge", challenge2]
    ],
    content: ""
  };
}
async function yieldThread() {
  return new Promise((resolve) => {
    const ch = new MessageChannel();
    const handler = () => {
      ch.port1.removeEventListener("message", handler);
      resolve();
    };
    ch.port1.addEventListener("message", handler);
    ch.port2.postMessage(0);
    ch.port1.start();
  });
}
var alwaysTrue = (t) => {
  t[verifiedSymbol2] = true;
  return true;
};
var _WebSocket2;
try {
  _WebSocket2 = WebSocket;
} catch (e) {
}
var AbstractRelay = class {
  constructor(url, opts) {
    __publicField(this, "url");
    __publicField(this, "_connected", false);
    __publicField(this, "onclose", null);
    __publicField(this, "onnotice", (msg) => console.debug(`NOTICE from ${this.url}: ${msg}`));
    __publicField(this, "baseEoseTimeout", 4400);
    __publicField(this, "connectionTimeout", 4400);
    __publicField(this, "openSubs", /* @__PURE__ */ new Map());
    __publicField(this, "connectionTimeoutHandle");
    __publicField(this, "connectionPromise");
    __publicField(this, "openCountRequests", /* @__PURE__ */ new Map());
    __publicField(this, "openEventPublishes", /* @__PURE__ */ new Map());
    __publicField(this, "ws");
    __publicField(this, "incomingMessageQueue", new Queue2());
    __publicField(this, "queueRunning", false);
    __publicField(this, "challenge");
    __publicField(this, "serial", 0);
    __publicField(this, "verifyEvent");
    this.url = normalizeURL2(url);
    this.verifyEvent = opts.verifyEvent;
  }
  static async connect(url, opts) {
    const relay = new AbstractRelay(url, opts);
    await relay.connect();
    return relay;
  }
  closeAllSubscriptions(reason) {
    for (let [_, sub] of this.openSubs) {
      sub.close(reason);
    }
    this.openSubs.clear();
    for (let [_, ep] of this.openEventPublishes) {
      ep.reject(new Error(reason));
    }
    this.openEventPublishes.clear();
    for (let [_, cr] of this.openCountRequests) {
      cr.reject(new Error(reason));
    }
    this.openCountRequests.clear();
  }
  get connected() {
    return this._connected;
  }
  async connect() {
    if (this.connectionPromise)
      return this.connectionPromise;
    this.challenge = void 0;
    this.connectionPromise = new Promise((resolve, reject) => {
      this.connectionTimeoutHandle = setTimeout(() => {
        var _a;
        reject("connection timed out");
        this.connectionPromise = void 0;
        (_a = this.onclose) == null ? void 0 : _a.call(this);
        this.closeAllSubscriptions("relay connection timed out");
      }, this.connectionTimeout);
      try {
        this.ws = new _WebSocket2(this.url);
      } catch (err) {
        reject(err);
        return;
      }
      this.ws.onopen = () => {
        clearTimeout(this.connectionTimeoutHandle);
        this._connected = true;
        resolve();
      };
      this.ws.onerror = (ev) => {
        var _a;
        reject(ev.message);
        if (this._connected) {
          (_a = this.onclose) == null ? void 0 : _a.call(this);
          this.closeAllSubscriptions("relay connection errored");
          this._connected = false;
        }
      };
      this.ws.onclose = async () => {
        var _a;
        this.connectionPromise = void 0;
        (_a = this.onclose) == null ? void 0 : _a.call(this);
        this.closeAllSubscriptions("relay connection closed");
        this._connected = false;
      };
      this.ws.onmessage = this._onmessage.bind(this);
    });
    return this.connectionPromise;
  }
  async runQueue() {
    this.queueRunning = true;
    while (true) {
      if (false === this.handleNext()) {
        break;
      }
      await yieldThread();
    }
    this.queueRunning = false;
  }
  handleNext() {
    var _a, _b;
    const json = this.incomingMessageQueue.dequeue();
    if (!json) {
      return false;
    }
    const subid = getSubscriptionId2(json);
    if (subid) {
      const so = this.openSubs.get(subid);
      if (!so) {
        return;
      }
      const id = getHex642(json, "id");
      const alreadyHave = (_a = so.alreadyHaveEvent) == null ? void 0 : _a.call(so, id);
      (_b = so.receivedEvent) == null ? void 0 : _b.call(so, this, id);
      if (alreadyHave) {
        return;
      }
    }
    try {
      let data = JSON.parse(json);
      switch (data[0]) {
        case "EVENT": {
          const so = this.openSubs.get(data[1]);
          const event = data[2];
          if (this.verifyEvent(event) && matchFilters(so.filters, event)) {
            so.onevent(event);
          }
          return;
        }
        case "COUNT": {
          const id = data[1];
          const payload = data[2];
          const cr = this.openCountRequests.get(id);
          if (cr) {
            cr.resolve(payload.count);
            this.openCountRequests.delete(id);
          }
          return;
        }
        case "EOSE": {
          const so = this.openSubs.get(data[1]);
          if (!so)
            return;
          so.receivedEose();
          return;
        }
        case "OK": {
          const id = data[1];
          const ok = data[2];
          const reason = data[3];
          const ep = this.openEventPublishes.get(id);
          if (ok)
            ep.resolve(reason);
          else
            ep.reject(new Error(reason));
          this.openEventPublishes.delete(id);
          return;
        }
        case "CLOSED": {
          const id = data[1];
          const so = this.openSubs.get(id);
          if (!so)
            return;
          so.closed = true;
          so.close(data[2]);
          return;
        }
        case "NOTICE":
          this.onnotice(data[1]);
          return;
        case "AUTH": {
          this.challenge = data[1];
          return;
        }
      }
    } catch (err) {
      return;
    }
  }
  async send(message) {
    if (!this.connectionPromise)
      throw new Error("sending on closed connection");
    this.connectionPromise.then(() => {
      var _a;
      (_a = this.ws) == null ? void 0 : _a.send(message);
    });
  }
  async auth(signAuthEvent) {
    if (!this.challenge)
      throw new Error("can't perform auth, no challenge was received");
    const evt = await signAuthEvent(makeAuthEvent2(this.url, this.challenge));
    const ret = new Promise((resolve, reject) => {
      this.openEventPublishes.set(evt.id, { resolve, reject });
    });
    this.send('["AUTH",' + JSON.stringify(evt) + "]");
    return ret;
  }
  async publish(event) {
    const ret = new Promise((resolve, reject) => {
      this.openEventPublishes.set(event.id, { resolve, reject });
    });
    this.send('["EVENT",' + JSON.stringify(event) + "]");
    return ret;
  }
  async count(filters, params) {
    this.serial++;
    const id = (params == null ? void 0 : params.id) || "count:" + this.serial;
    const ret = new Promise((resolve, reject) => {
      this.openCountRequests.set(id, { resolve, reject });
    });
    this.send('["COUNT","' + id + '",' + JSON.stringify(filters) + "]");
    return ret;
  }
  subscribe(filters, params) {
    const subscription = this.prepareSubscription(filters, params);
    subscription.fire();
    return subscription;
  }
  prepareSubscription(filters, params) {
    this.serial++;
    const id = params.id || "sub:" + this.serial;
    const subscription = new Subscription(this, id, filters, params);
    this.openSubs.set(id, subscription);
    return subscription;
  }
  close() {
    var _a;
    this.closeAllSubscriptions("relay connection closed by us");
    this._connected = false;
    (_a = this.ws) == null ? void 0 : _a.close();
  }
  _onmessage(ev) {
    this.incomingMessageQueue.enqueue(ev.data);
    if (!this.queueRunning) {
      this.runQueue();
    }
  }
};
var Subscription = class {
  constructor(relay, id, filters, params) {
    __publicField(this, "relay");
    __publicField(this, "id");
    __publicField(this, "closed", false);
    __publicField(this, "eosed", false);
    __publicField(this, "filters");
    __publicField(this, "alreadyHaveEvent");
    __publicField(this, "receivedEvent");
    __publicField(this, "onevent");
    __publicField(this, "oneose");
    __publicField(this, "onclose");
    __publicField(this, "eoseTimeout");
    __publicField(this, "eoseTimeoutHandle");
    this.relay = relay;
    this.filters = filters;
    this.id = id;
    this.alreadyHaveEvent = params.alreadyHaveEvent;
    this.receivedEvent = params.receivedEvent;
    this.eoseTimeout = params.eoseTimeout || relay.baseEoseTimeout;
    this.oneose = params.oneose;
    this.onclose = params.onclose;
    this.onevent = params.onevent || ((event) => {
      console.warn(
        `onevent() callback not defined for subscription '${this.id}' in relay ${this.relay.url}. event received:`,
        event
      );
    });
  }
  fire() {
    this.relay.send('["REQ","' + this.id + '",' + JSON.stringify(this.filters).substring(1));
    this.eoseTimeoutHandle = setTimeout(this.receivedEose.bind(this), this.eoseTimeout);
  }
  receivedEose() {
    var _a;
    if (this.eosed)
      return;
    clearTimeout(this.eoseTimeoutHandle);
    this.eosed = true;
    (_a = this.oneose) == null ? void 0 : _a.call(this);
  }
  close(reason = "closed by caller") {
    var _a;
    if (!this.closed) {
      this.relay.send('["CLOSE",' + JSON.stringify(this.id) + "]");
      this.closed = true;
    }
    this.relay.openSubs.delete(this.id);
    (_a = this.onclose) == null ? void 0 : _a.call(this, reason);
  }
};
var AbstractSimplePool = class {
  constructor(opts) {
    __publicField(this, "relays", /* @__PURE__ */ new Map());
    __publicField(this, "seenOn", /* @__PURE__ */ new Map());
    __publicField(this, "trackRelays", false);
    __publicField(this, "verifyEvent");
    __publicField(this, "trustedRelayURLs", /* @__PURE__ */ new Set());
    this.verifyEvent = opts.verifyEvent;
  }
  async ensureRelay(url, params) {
    url = normalizeURL2(url);
    let relay = this.relays.get(url);
    if (!relay) {
      relay = new AbstractRelay(url, {
        verifyEvent: this.trustedRelayURLs.has(url) ? alwaysTrue : this.verifyEvent
      });
      if (params == null ? void 0 : params.connectionTimeout)
        relay.connectionTimeout = params.connectionTimeout;
      this.relays.set(url, relay);
    }
    await relay.connect();
    return relay;
  }
  close(relays) {
    relays.map(normalizeURL2).forEach((url) => {
      var _a;
      (_a = this.relays.get(url)) == null ? void 0 : _a.close();
    });
  }
  subscribeMany(relays, filters, params) {
    if (this.trackRelays) {
      params.receivedEvent = (relay, id) => {
        let set = this.seenOn.get(id);
        if (!set) {
          set = /* @__PURE__ */ new Set();
          this.seenOn.set(id, set);
        }
        set.add(relay);
      };
    }
    const _knownIds = /* @__PURE__ */ new Set();
    const subs = [];
    const eosesReceived = [];
    let handleEose = (i22) => {
      var _a;
      eosesReceived[i22] = true;
      if (eosesReceived.filter((a) => a).length === relays.length) {
        (_a = params.oneose) == null ? void 0 : _a.call(params);
        handleEose = () => {
        };
      }
    };
    const closesReceived = [];
    let handleClose = (i22, reason) => {
      var _a;
      handleEose(i22);
      closesReceived[i22] = reason;
      if (closesReceived.filter((a) => a).length === relays.length) {
        (_a = params.onclose) == null ? void 0 : _a.call(params, closesReceived);
        handleClose = () => {
        };
      }
    };
    const localAlreadyHaveEventHandler = (id) => {
      var _a;
      if ((_a = params.alreadyHaveEvent) == null ? void 0 : _a.call(params, id)) {
        return true;
      }
      const have = _knownIds.has(id);
      _knownIds.add(id);
      return have;
    };
    const allOpened = Promise.all(
      relays.map(normalizeURL2).map(async (url, i22, arr) => {
        if (arr.indexOf(url) !== i22) {
          handleClose(i22, "duplicate url");
          return;
        }
        let relay;
        try {
          relay = await this.ensureRelay(url, {
            connectionTimeout: params.maxWait ? Math.max(params.maxWait * 0.8, params.maxWait - 1e3) : void 0
          });
        } catch (err) {
          handleClose(i22, (err == null ? void 0 : err.message) || String(err));
          return;
        }
        let subscription = relay.subscribe(filters, {
          ...params,
          oneose: () => handleEose(i22),
          onclose: (reason) => handleClose(i22, reason),
          alreadyHaveEvent: localAlreadyHaveEventHandler,
          eoseTimeout: params.maxWait
        });
        subs.push(subscription);
      })
    );
    return {
      async close() {
        await allOpened;
        subs.forEach((sub) => {
          sub.close();
        });
      }
    };
  }
  subscribeManyEose(relays, filters, params) {
    const subcloser = this.subscribeMany(relays, filters, {
      ...params,
      oneose() {
        subcloser.close();
      }
    });
    return subcloser;
  }
  async querySync(relays, filter2, params) {
    return new Promise(async (resolve) => {
      const events = [];
      this.subscribeManyEose(relays, [filter2], {
        ...params,
        onevent(event) {
          events.push(event);
        },
        onclose(_) {
          resolve(events);
        }
      });
    });
  }
  async get(relays, filter2, params) {
    filter2.limit = 1;
    const events = await this.querySync(relays, filter2, params);
    events.sort((a, b) => b.created_at - a.created_at);
    return events[0] || null;
  }
  publish(relays, event) {
    return relays.map(normalizeURL2).map(async (url, i22, arr) => {
      if (arr.indexOf(url) !== i22) {
        return Promise.reject("duplicate url");
      }
      let r = await this.ensureRelay(url);
      return r.publish(event);
    });
  }
};
var SimplePool = class extends AbstractSimplePool {
  constructor() {
    super({ verifyEvent: verifyEvent2 });
  }
};

// node_modules/nostr-tools/lib/esm/pure.js
var verifiedSymbol3 = Symbol("verified");
var isRecord3 = (obj) => obj instanceof Object;
function validateEvent4(event) {
  if (!isRecord3(event))
    return false;
  if (typeof event.kind !== "number")
    return false;
  if (typeof event.content !== "string")
    return false;
  if (typeof event.created_at !== "number")
    return false;
  if (typeof event.pubkey !== "string")
    return false;
  if (!event.pubkey.match(/^[a-f0-9]{64}$/))
    return false;
  if (!Array.isArray(event.tags))
    return false;
  for (let i22 = 0; i22 < event.tags.length; i22++) {
    let tag = event.tags[i22];
    if (!Array.isArray(tag))
      return false;
    for (let j = 0; j < tag.length; j++) {
      if (typeof tag[j] === "object")
        return false;
    }
  }
  return true;
}
var utf8Decoder3 = new TextDecoder("utf-8");
var utf8Encoder3 = new TextEncoder();
var JS3 = class {
  generateSecretKey() {
    return schnorr.utils.randomPrivateKey();
  }
  getPublicKey(secretKey) {
    return bytesToHex2(schnorr.getPublicKey(secretKey));
  }
  finalizeEvent(t, secretKey) {
    const event = t;
    event.pubkey = bytesToHex2(schnorr.getPublicKey(secretKey));
    event.id = getEventHash3(event);
    event.sig = bytesToHex2(schnorr.sign(getEventHash3(event), secretKey));
    event[verifiedSymbol3] = true;
    return event;
  }
  verifyEvent(event) {
    if (typeof event[verifiedSymbol3] === "boolean")
      return event[verifiedSymbol3];
    const hash3 = getEventHash3(event);
    if (hash3 !== event.id) {
      event[verifiedSymbol3] = false;
      return false;
    }
    try {
      const valid = schnorr.verify(event.sig, hash3, event.pubkey);
      event[verifiedSymbol3] = valid;
      return valid;
    } catch (err) {
      event[verifiedSymbol3] = false;
      return false;
    }
  }
};
function serializeEvent3(evt) {
  if (!validateEvent4(evt))
    throw new Error("can't serialize event with wrong or missing properties");
  return JSON.stringify([0, evt.pubkey, evt.created_at, evt.kind, evt.tags, evt.content]);
}
function getEventHash3(event) {
  let eventHash = sha2562(utf8Encoder3.encode(serializeEvent3(event)));
  return bytesToHex2(eventHash);
}
var i3 = new JS3();
var generateSecretKey3 = i3.generateSecretKey;
var getPublicKey3 = i3.getPublicKey;
var finalizeEvent3 = i3.finalizeEvent;
var verifyEvent3 = i3.verifyEvent;

// node_modules/nostr-tools/lib/esm/relay.js
var verifiedSymbol4 = Symbol("verified");
var isRecord4 = (obj) => obj instanceof Object;
function validateEvent5(event) {
  if (!isRecord4(event))
    return false;
  if (typeof event.kind !== "number")
    return false;
  if (typeof event.content !== "string")
    return false;
  if (typeof event.created_at !== "number")
    return false;
  if (typeof event.pubkey !== "string")
    return false;
  if (!event.pubkey.match(/^[a-f0-9]{64}$/))
    return false;
  if (!Array.isArray(event.tags))
    return false;
  for (let i22 = 0; i22 < event.tags.length; i22++) {
    let tag = event.tags[i22];
    if (!Array.isArray(tag))
      return false;
    for (let j = 0; j < tag.length; j++) {
      if (typeof tag[j] === "object")
        return false;
    }
  }
  return true;
}
var utf8Decoder4 = new TextDecoder("utf-8");
var utf8Encoder4 = new TextEncoder();
function normalizeURL3(url) {
  if (url.indexOf("://") === -1)
    url = "wss://" + url;
  let p = new URL(url);
  p.pathname = p.pathname.replace(/\/+/g, "/");
  if (p.pathname.endsWith("/"))
    p.pathname = p.pathname.slice(0, -1);
  if (p.port === "80" && p.protocol === "ws:" || p.port === "443" && p.protocol === "wss:")
    p.port = "";
  p.searchParams.sort();
  p.hash = "";
  return p.toString();
}
var QueueNode3 = class {
  constructor(message) {
    __publicField(this, "value");
    __publicField(this, "next", null);
    __publicField(this, "prev", null);
    this.value = message;
  }
};
var Queue3 = class {
  constructor() {
    __publicField(this, "first");
    __publicField(this, "last");
    this.first = null;
    this.last = null;
  }
  enqueue(value) {
    const newNode = new QueueNode3(value);
    if (!this.last) {
      this.first = newNode;
      this.last = newNode;
    } else if (this.last === this.first) {
      this.last = newNode;
      this.last.prev = this.first;
      this.first.next = newNode;
    } else {
      newNode.prev = this.last;
      this.last.next = newNode;
      this.last = newNode;
    }
    return true;
  }
  dequeue() {
    if (!this.first)
      return null;
    if (this.first === this.last) {
      const target2 = this.first;
      this.first = null;
      this.last = null;
      return target2.value;
    }
    const target = this.first;
    this.first = target.next;
    return target.value;
  }
};
var JS4 = class {
  generateSecretKey() {
    return schnorr.utils.randomPrivateKey();
  }
  getPublicKey(secretKey) {
    return bytesToHex2(schnorr.getPublicKey(secretKey));
  }
  finalizeEvent(t, secretKey) {
    const event = t;
    event.pubkey = bytesToHex2(schnorr.getPublicKey(secretKey));
    event.id = getEventHash4(event);
    event.sig = bytesToHex2(schnorr.sign(getEventHash4(event), secretKey));
    event[verifiedSymbol4] = true;
    return event;
  }
  verifyEvent(event) {
    if (typeof event[verifiedSymbol4] === "boolean")
      return event[verifiedSymbol4];
    const hash3 = getEventHash4(event);
    if (hash3 !== event.id) {
      event[verifiedSymbol4] = false;
      return false;
    }
    try {
      const valid = schnorr.verify(event.sig, hash3, event.pubkey);
      event[verifiedSymbol4] = valid;
      return valid;
    } catch (err) {
      event[verifiedSymbol4] = false;
      return false;
    }
  }
};
function serializeEvent4(evt) {
  if (!validateEvent5(evt))
    throw new Error("can't serialize event with wrong or missing properties");
  return JSON.stringify([0, evt.pubkey, evt.created_at, evt.kind, evt.tags, evt.content]);
}
function getEventHash4(event) {
  let eventHash = sha2562(utf8Encoder4.encode(serializeEvent4(event)));
  return bytesToHex2(eventHash);
}
var i4 = new JS4();
var generateSecretKey4 = i4.generateSecretKey;
var getPublicKey4 = i4.getPublicKey;
var finalizeEvent4 = i4.finalizeEvent;
var verifyEvent4 = i4.verifyEvent;
var ClientAuth3 = 22242;
function matchFilter2(filter2, event) {
  if (filter2.ids && filter2.ids.indexOf(event.id) === -1) {
    if (!filter2.ids.some((prefix) => event.id.startsWith(prefix))) {
      return false;
    }
  }
  if (filter2.kinds && filter2.kinds.indexOf(event.kind) === -1)
    return false;
  if (filter2.authors && filter2.authors.indexOf(event.pubkey) === -1) {
    if (!filter2.authors.some((prefix) => event.pubkey.startsWith(prefix))) {
      return false;
    }
  }
  for (let f in filter2) {
    if (f[0] === "#") {
      let tagName = f.slice(1);
      let values = filter2[`#${tagName}`];
      if (values && !event.tags.find(([t, v]) => t === f.slice(1) && values.indexOf(v) !== -1))
        return false;
    }
  }
  if (filter2.since && event.created_at < filter2.since)
    return false;
  if (filter2.until && event.created_at > filter2.until)
    return false;
  return true;
}
function matchFilters2(filters, event) {
  for (let i22 = 0; i22 < filters.length; i22++) {
    if (matchFilter2(filters[i22], event))
      return true;
  }
  return false;
}
function getHex643(json, field) {
  let len = field.length + 3;
  let idx = json.indexOf(`"${field}":`) + len;
  let s = json.slice(idx).indexOf(`"`) + idx + 1;
  return json.slice(s, s + 64);
}
function getSubscriptionId3(json) {
  let idx = json.slice(0, 22).indexOf(`"EVENT"`);
  if (idx === -1)
    return null;
  let pstart = json.slice(idx + 7 + 1).indexOf(`"`);
  if (pstart === -1)
    return null;
  let start = idx + 7 + 1 + pstart;
  let pend = json.slice(start + 1, 80).indexOf(`"`);
  if (pend === -1)
    return null;
  let end = start + 1 + pend;
  return json.slice(start + 1, end);
}
function makeAuthEvent3(relayURL, challenge2) {
  return {
    kind: ClientAuth3,
    created_at: Math.floor(Date.now() / 1e3),
    tags: [
      ["relay", relayURL],
      ["challenge", challenge2]
    ],
    content: ""
  };
}
async function yieldThread2() {
  return new Promise((resolve) => {
    const ch = new MessageChannel();
    const handler = () => {
      ch.port1.removeEventListener("message", handler);
      resolve();
    };
    ch.port1.addEventListener("message", handler);
    ch.port2.postMessage(0);
    ch.port1.start();
  });
}
var _WebSocket3;
try {
  _WebSocket3 = WebSocket;
} catch (e) {
}
var AbstractRelay2 = class {
  constructor(url, opts) {
    __publicField(this, "url");
    __publicField(this, "_connected", false);
    __publicField(this, "onclose", null);
    __publicField(this, "onnotice", (msg) => console.debug(`NOTICE from ${this.url}: ${msg}`));
    __publicField(this, "baseEoseTimeout", 4400);
    __publicField(this, "connectionTimeout", 4400);
    __publicField(this, "openSubs", /* @__PURE__ */ new Map());
    __publicField(this, "connectionTimeoutHandle");
    __publicField(this, "connectionPromise");
    __publicField(this, "openCountRequests", /* @__PURE__ */ new Map());
    __publicField(this, "openEventPublishes", /* @__PURE__ */ new Map());
    __publicField(this, "ws");
    __publicField(this, "incomingMessageQueue", new Queue3());
    __publicField(this, "queueRunning", false);
    __publicField(this, "challenge");
    __publicField(this, "serial", 0);
    __publicField(this, "verifyEvent");
    this.url = normalizeURL3(url);
    this.verifyEvent = opts.verifyEvent;
  }
  static async connect(url, opts) {
    const relay = new AbstractRelay2(url, opts);
    await relay.connect();
    return relay;
  }
  closeAllSubscriptions(reason) {
    for (let [_, sub] of this.openSubs) {
      sub.close(reason);
    }
    this.openSubs.clear();
    for (let [_, ep] of this.openEventPublishes) {
      ep.reject(new Error(reason));
    }
    this.openEventPublishes.clear();
    for (let [_, cr] of this.openCountRequests) {
      cr.reject(new Error(reason));
    }
    this.openCountRequests.clear();
  }
  get connected() {
    return this._connected;
  }
  async connect() {
    if (this.connectionPromise)
      return this.connectionPromise;
    this.challenge = void 0;
    this.connectionPromise = new Promise((resolve, reject) => {
      this.connectionTimeoutHandle = setTimeout(() => {
        var _a;
        reject("connection timed out");
        this.connectionPromise = void 0;
        (_a = this.onclose) == null ? void 0 : _a.call(this);
        this.closeAllSubscriptions("relay connection timed out");
      }, this.connectionTimeout);
      try {
        this.ws = new _WebSocket3(this.url);
      } catch (err) {
        reject(err);
        return;
      }
      this.ws.onopen = () => {
        clearTimeout(this.connectionTimeoutHandle);
        this._connected = true;
        resolve();
      };
      this.ws.onerror = (ev) => {
        var _a;
        reject(ev.message);
        if (this._connected) {
          (_a = this.onclose) == null ? void 0 : _a.call(this);
          this.closeAllSubscriptions("relay connection errored");
          this._connected = false;
        }
      };
      this.ws.onclose = async () => {
        var _a;
        this.connectionPromise = void 0;
        (_a = this.onclose) == null ? void 0 : _a.call(this);
        this.closeAllSubscriptions("relay connection closed");
        this._connected = false;
      };
      this.ws.onmessage = this._onmessage.bind(this);
    });
    return this.connectionPromise;
  }
  async runQueue() {
    this.queueRunning = true;
    while (true) {
      if (false === this.handleNext()) {
        break;
      }
      await yieldThread2();
    }
    this.queueRunning = false;
  }
  handleNext() {
    var _a, _b;
    const json = this.incomingMessageQueue.dequeue();
    if (!json) {
      return false;
    }
    const subid = getSubscriptionId3(json);
    if (subid) {
      const so = this.openSubs.get(subid);
      if (!so) {
        return;
      }
      const id = getHex643(json, "id");
      const alreadyHave = (_a = so.alreadyHaveEvent) == null ? void 0 : _a.call(so, id);
      (_b = so.receivedEvent) == null ? void 0 : _b.call(so, this, id);
      if (alreadyHave) {
        return;
      }
    }
    try {
      let data = JSON.parse(json);
      switch (data[0]) {
        case "EVENT": {
          const so = this.openSubs.get(data[1]);
          const event = data[2];
          if (this.verifyEvent(event) && matchFilters2(so.filters, event)) {
            so.onevent(event);
          }
          return;
        }
        case "COUNT": {
          const id = data[1];
          const payload = data[2];
          const cr = this.openCountRequests.get(id);
          if (cr) {
            cr.resolve(payload.count);
            this.openCountRequests.delete(id);
          }
          return;
        }
        case "EOSE": {
          const so = this.openSubs.get(data[1]);
          if (!so)
            return;
          so.receivedEose();
          return;
        }
        case "OK": {
          const id = data[1];
          const ok = data[2];
          const reason = data[3];
          const ep = this.openEventPublishes.get(id);
          if (ok)
            ep.resolve(reason);
          else
            ep.reject(new Error(reason));
          this.openEventPublishes.delete(id);
          return;
        }
        case "CLOSED": {
          const id = data[1];
          const so = this.openSubs.get(id);
          if (!so)
            return;
          so.closed = true;
          so.close(data[2]);
          return;
        }
        case "NOTICE":
          this.onnotice(data[1]);
          return;
        case "AUTH": {
          this.challenge = data[1];
          return;
        }
      }
    } catch (err) {
      return;
    }
  }
  async send(message) {
    if (!this.connectionPromise)
      throw new Error("sending on closed connection");
    this.connectionPromise.then(() => {
      var _a;
      (_a = this.ws) == null ? void 0 : _a.send(message);
    });
  }
  async auth(signAuthEvent) {
    if (!this.challenge)
      throw new Error("can't perform auth, no challenge was received");
    const evt = await signAuthEvent(makeAuthEvent3(this.url, this.challenge));
    const ret = new Promise((resolve, reject) => {
      this.openEventPublishes.set(evt.id, { resolve, reject });
    });
    this.send('["AUTH",' + JSON.stringify(evt) + "]");
    return ret;
  }
  async publish(event) {
    const ret = new Promise((resolve, reject) => {
      this.openEventPublishes.set(event.id, { resolve, reject });
    });
    this.send('["EVENT",' + JSON.stringify(event) + "]");
    return ret;
  }
  async count(filters, params) {
    this.serial++;
    const id = (params == null ? void 0 : params.id) || "count:" + this.serial;
    const ret = new Promise((resolve, reject) => {
      this.openCountRequests.set(id, { resolve, reject });
    });
    this.send('["COUNT","' + id + '",' + JSON.stringify(filters) + "]");
    return ret;
  }
  subscribe(filters, params) {
    const subscription = this.prepareSubscription(filters, params);
    subscription.fire();
    return subscription;
  }
  prepareSubscription(filters, params) {
    this.serial++;
    const id = params.id || "sub:" + this.serial;
    const subscription = new Subscription2(this, id, filters, params);
    this.openSubs.set(id, subscription);
    return subscription;
  }
  close() {
    var _a;
    this.closeAllSubscriptions("relay connection closed by us");
    this._connected = false;
    (_a = this.ws) == null ? void 0 : _a.close();
  }
  _onmessage(ev) {
    this.incomingMessageQueue.enqueue(ev.data);
    if (!this.queueRunning) {
      this.runQueue();
    }
  }
};
var Subscription2 = class {
  constructor(relay, id, filters, params) {
    __publicField(this, "relay");
    __publicField(this, "id");
    __publicField(this, "closed", false);
    __publicField(this, "eosed", false);
    __publicField(this, "filters");
    __publicField(this, "alreadyHaveEvent");
    __publicField(this, "receivedEvent");
    __publicField(this, "onevent");
    __publicField(this, "oneose");
    __publicField(this, "onclose");
    __publicField(this, "eoseTimeout");
    __publicField(this, "eoseTimeoutHandle");
    this.relay = relay;
    this.filters = filters;
    this.id = id;
    this.alreadyHaveEvent = params.alreadyHaveEvent;
    this.receivedEvent = params.receivedEvent;
    this.eoseTimeout = params.eoseTimeout || relay.baseEoseTimeout;
    this.oneose = params.oneose;
    this.onclose = params.onclose;
    this.onevent = params.onevent || ((event) => {
      console.warn(
        `onevent() callback not defined for subscription '${this.id}' in relay ${this.relay.url}. event received:`,
        event
      );
    });
  }
  fire() {
    this.relay.send('["REQ","' + this.id + '",' + JSON.stringify(this.filters).substring(1));
    this.eoseTimeoutHandle = setTimeout(this.receivedEose.bind(this), this.eoseTimeout);
  }
  receivedEose() {
    var _a;
    if (this.eosed)
      return;
    clearTimeout(this.eoseTimeoutHandle);
    this.eosed = true;
    (_a = this.oneose) == null ? void 0 : _a.call(this);
  }
  close(reason = "closed by caller") {
    var _a;
    if (!this.closed) {
      this.relay.send('["CLOSE",' + JSON.stringify(this.id) + "]");
      this.closed = true;
    }
    this.relay.openSubs.delete(this.id);
    (_a = this.onclose) == null ? void 0 : _a.call(this, reason);
  }
};
var Relay = class extends AbstractRelay2 {
  constructor(url) {
    super(url, { verifyEvent: verifyEvent4 });
  }
  static async connect(url) {
    const relay = new Relay(url);
    await relay.connect();
    return relay;
  }
};

// src/service/NostrService.ts
var import_obsidian4 = require("obsidian");

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i5 = 0; i5 < 256; ++i5) {
  byteToHex.push((i5 + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i5 = 0; i5 < 16; ++i5) {
      buf[offset + i5] = rnds[i5];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// node_modules/axios/lib/helpers/bind.js
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

// node_modules/axios/lib/utils.js
var { toString } = Object.prototype;
var { getPrototypeOf } = Object;
var kindOf = ((cache) => (thing) => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
var typeOfTest = (type) => (thing) => typeof thing === type;
var { isArray } = Array;
var isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
var isString = typeOfTest("string");
var isFunction = typeOfTest("function");
var isNumber = typeOfTest("number");
var isObject = (thing) => thing !== null && typeof thing === "object";
var isBoolean = (thing) => thing === true || thing === false;
var isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype3 = getPrototypeOf(val);
  return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
var isDate = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
var isStream = (val) => isObject(val) && isFunction(val.pipe);
var isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
var isURLSearchParams = kindOfTest("URLSearchParams");
var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i5;
  let l;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i5 = 0, l = obj.length; i5 < l; i5++) {
      fn.call(null, obj[i5], i5, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i5 = 0; i5 < len; i5++) {
      key = keys[i5];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i5 = keys.length;
  let _key;
  while (i5-- > 0) {
    _key = keys[i5];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
var _global = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
var isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i5 = 0, l = arguments.length; i5 < l; i5++) {
    arguments[i5] && forEach(arguments[i5], assignValue);
  }
  return result;
}
var extend = (a, b, thisArg, { allOwnKeys } = {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
};
var stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
var inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
var toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i5;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i5 = props.length;
    while (i5-- > 0) {
      prop = props[i5];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
var endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
var toArray = (thing) => {
  if (!thing)
    return null;
  if (isArray(thing))
    return thing;
  let i5 = thing.length;
  if (!isNumber(i5))
    return null;
  const arr = new Array(i5);
  while (i5-- > 0) {
    arr[i5] = thing[i5];
  }
  return arr;
};
var isTypedArray = ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
var forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
var matchAll3 = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
var freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
var toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
var noop = () => {
};
var toFiniteNumber = (value, defaultValue) => {
  value = +value;
  return Number.isFinite(value) ? value : defaultValue;
};
var ALPHA = "abcdefghijklmnopqrstuvwxyz";
var DIGIT = "0123456789";
var ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
var generateString = (size = 16, alphabet2 = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length } = alphabet2;
  while (size--) {
    str += alphabet2[Math.random() * length | 0];
  }
  return str;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
var toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i5) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i5] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i5 + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i5] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
var isAsyncFn = kindOfTest("AsyncFunction");
var isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
var utils_default = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll: matchAll3,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable
};

// node_modules/axios/lib/core/AxiosError.js
function AxiosError(message, code, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}
utils_default.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils_default.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
var prototype = AxiosError.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype);
  utils_default.toFlatObject(error, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code, config, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_default = AxiosError;

// node_modules/axios/lib/helpers/null.js
var null_default = null;

// node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key) {
  return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path2, key, dots) {
  if (!path2)
    return key;
  return path2.concat(key).map(function each(token, i5) {
    token = removeBrackets(token);
    return !dots && i5 ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
}
var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils_default.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (null_default || FormData)();
  options = utils_default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils_default.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils_default.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils_default.isBlob(value)) {
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path2) {
    let arr = value;
    if (value && !path2 && typeof value === "object") {
      if (utils_default.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index) {
          !(utils_default.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path2, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path2) {
    if (utils_default.isUndefined(value))
      return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path2.join("."));
    }
    stack.push(value);
    utils_default.forEach(value, function each(el, key) {
      const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils_default.isString(key) ? key.trim() : key,
        path2,
        exposedHelpers
      );
      if (result === true) {
        build(el, path2 ? path2.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils_default.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
var toFormData_default = toFormData;

// node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData_default(params, this, options);
}
var prototype2 = AxiosURLSearchParams.prototype;
prototype2.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype2.toString = function toString2(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode);
  } : encode;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;

// node_modules/axios/lib/helpers/buildURL.js
function encode2(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode2;
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}

// node_modules/axios/lib/core/InterceptorManager.js
var InterceptorManager = class {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils_default.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
};
var InterceptorManager_default = InterceptorManager;

// node_modules/axios/lib/defaults/transitional.js
var transitional_default = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

// node_modules/axios/lib/platform/browser/classes/URLSearchParams.js
var URLSearchParams_default = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams_default;

// node_modules/axios/lib/platform/browser/classes/FormData.js
var FormData_default = typeof FormData !== "undefined" ? FormData : null;

// node_modules/axios/lib/platform/browser/classes/Blob.js
var Blob_default = typeof Blob !== "undefined" ? Blob : null;

// node_modules/axios/lib/platform/browser/index.js
var browser_default = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams_default,
    FormData: FormData_default,
    Blob: Blob_default
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};

// node_modules/axios/lib/platform/common/utils.js
var utils_exports3 = {};
__export(utils_exports3, {
  hasBrowserEnv: () => hasBrowserEnv,
  hasStandardBrowserEnv: () => hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv: () => hasStandardBrowserWebWorkerEnv
});
var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
var hasStandardBrowserEnv = ((product) => {
  return hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(product) < 0;
})(typeof navigator !== "undefined" && navigator.product);
var hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();

// node_modules/axios/lib/platform/index.js
var platform_default = {
  ...utils_exports3,
  ...browser_default
};

// node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new platform_default.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path2, helpers) {
      if (platform_default.isNode && utils_default.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

// node_modules/axios/lib/helpers/formDataToJSON.js
function parsePropPath(name) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i5;
  const len = keys.length;
  let key;
  for (i5 = 0; i5 < len; i5++) {
    key = keys[i5];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path2, value, target, index) {
    let name = path2[index++];
    if (name === "__proto__")
      return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path2.length;
    name = !name && utils_default.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils_default.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path2, value, target[name], index);
    if (result && utils_default.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj = {};
    utils_default.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
var formDataToJSON_default = formDataToJSON;

// node_modules/axios/lib/defaults/index.js
function stringifySafely(rawValue, parser, encoder) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults = {
  transitional: transitional_default,
  adapter: ["xhr", "http"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils_default.isObject(data);
    if (isObjectPayload && utils_default.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils_default.isFormData(data);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
    }
    if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data)) {
      return data;
    }
    if (utils_default.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils_default.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData_default(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw AxiosError_default.from(e, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform_default.classes.FormData,
    Blob: platform_default.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils_default.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
var defaults_default = defaults;

// node_modules/axios/lib/helpers/parseHeaders.js
var ignoreDuplicateOf = utils_default.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders_default = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i5;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i5 = line.indexOf(":");
    key = line.substring(0, i5).trim().toLowerCase();
    val = line.substring(i5 + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};

// node_modules/axios/lib/core/AxiosHeaders.js
var $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils_default.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils_default.isString(value))
    return;
  if (utils_default.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils_default.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
var AxiosHeaders = class {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils_default.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders_default(header), valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils_default.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils_default.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils_default.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils_default.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i5 = keys.length;
    let deleted = false;
    while (i5--) {
      const key = keys[i5];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils_default.forEach(this, (value, header) => {
      const key = utils_default.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils_default.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype3 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype3, _header);
        accessors[lHeader] = true;
      }
    }
    utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils_default.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;

// node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
  const config = this || defaults_default;
  const context = response || config;
  const headers = AxiosHeaders_default.from(context.headers);
  let data = context.data;
  utils_default.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}

// node_modules/axios/lib/cancel/isCancel.js
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

// node_modules/axios/lib/cancel/CanceledError.js
function CanceledError(message, config, request) {
  AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
utils_default.inherits(CanceledError, AxiosError_default, {
  __CANCEL__: true
});
var CanceledError_default = CanceledError;

// node_modules/axios/lib/core/settle.js
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError_default(
      "Request failed with status code " + response.status,
      [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

// node_modules/axios/lib/helpers/cookies.js
var cookies_default = platform_default.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path2, domain, secure) {
      const cookie = [name + "=" + encodeURIComponent(value)];
      utils_default.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils_default.isString(path2) && cookie.push("path=" + path2);
      utils_default.isString(domain) && cookie.push("domain=" + domain);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name) {
      const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);

// node_modules/axios/lib/helpers/isAbsoluteURL.js
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

// node_modules/axios/lib/helpers/combineURLs.js
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

// node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var isURLSameOrigin_default = platform_default.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function standardBrowserEnv() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement("a");
    let originURL;
    function resolveURL(url) {
      let href = url;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin(requestURL) {
      const parsed = utils_default.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  }()
);

// node_modules/axios/lib/helpers/parseProtocol.js
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || "";
}

// node_modules/axios/lib/helpers/speedometer.js
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes4 = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes4[head] = chunkLength;
    timestamps[head] = now;
    let i5 = tail;
    let bytesCount = 0;
    while (i5 !== head) {
      bytesCount += bytes4[i5++];
      i5 = i5 % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
var speedometer_default = speedometer;

// node_modules/axios/lib/adapters/xhr.js
function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = speedometer_default(50, 250);
  return (e) => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e
    };
    data[isDownloadStream ? "download" : "upload"] = true;
    listener(data);
  };
}
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhr_default = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    let requestData = config.data;
    const requestHeaders = AxiosHeaders_default.from(config.headers).normalize();
    let { responseType, withXSRFToken } = config;
    let onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }
      if (config.signal) {
        config.signal.removeEventListener("abort", onCanceled);
      }
    }
    let contentType;
    if (utils_default.isFormData(requestData)) {
      if (platform_default.hasStandardBrowserEnv || platform_default.hasStandardBrowserWebWorkerEnv) {
        requestHeaders.setContentType(false);
      } else if ((contentType = requestHeaders.getContentType()) !== false) {
        const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
        requestHeaders.setContentType([type || "multipart/form-data", ...tokens].join("; "));
      }
    }
    let request = new XMLHttpRequest();
    if (config.auth) {
      const username = config.auth.username || "";
      const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
      requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
    }
    const fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
    request.timeout = config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders_default.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config, request));
      request = null;
    };
    request.onerror = function handleError() {
      reject(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = config.transitional || transitional_default;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new AxiosError_default(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
        config,
        request
      ));
      request = null;
    };
    if (platform_default.hasStandardBrowserEnv) {
      withXSRFToken && utils_default.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config));
      if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin_default(fullPath)) {
        const xsrfValue = config.xsrfHeaderName && config.xsrfCookieName && cookies_default.read(config.xsrfCookieName);
        if (xsrfValue) {
          requestHeaders.set(config.xsrfHeaderName, xsrfValue);
        }
      }
    }
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils_default.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = config.responseType;
    }
    if (typeof config.onDownloadProgress === "function") {
      request.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
    }
    if (typeof config.onUploadProgress === "function" && request.upload) {
      request.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
    }
    if (config.cancelToken || config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError_default(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(fullPath);
    if (protocol && platform_default.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};

// node_modules/axios/lib/adapters/adapters.js
var knownAdapters = {
  http: null_default,
  xhr: xhr_default
};
utils_default.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
var renderReason = (reason) => `- ${reason}`;
var isResolvedHandle = (adapter) => utils_default.isFunction(adapter) || adapter === null || adapter === false;
var adapters_default = {
  getAdapter: (adapters) => {
    adapters = utils_default.isArray(adapters) ? adapters : [adapters];
    const { length } = adapters;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i5 = 0; i5 < length; i5++) {
      nameOrAdapter = adapters[i5];
      let id;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError_default(`Unknown adapter '${id}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id || "#" + i5] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError_default(
        `There is no suitable adapter to dispatch the request ` + s,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  },
  adapters: knownAdapters
};

// node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError_default(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders_default.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters_default.getAdapter(config.adapter || defaults_default.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders_default.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}

// node_modules/axios/lib/core/mergeConfig.js
var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? { ...thing } : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, caseless) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
      return utils_default.merge.call({ caseless }, target, source);
    } else if (utils_default.isPlainObject(source)) {
      return utils_default.merge({}, source);
    } else if (utils_default.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a, b, caseless) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(a, b, caseless);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a, caseless);
    }
  }
  function valueFromConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    }
  }
  function defaultToConfig2(a, b) {
    if (!utils_default.isUndefined(b)) {
      return getMergedValue(void 0, b);
    } else if (!utils_default.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(void 0, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
  };
  utils_default.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils_default.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}

// node_modules/axios/lib/env/data.js
var VERSION = "1.6.8";

// node_modules/axios/lib/helpers/validator.js
var validators = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i5) => {
  validators[type] = function validator(thing) {
    return typeof thing === type || "a" + (i5 < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError_default(
        formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
        AxiosError_default.ERR_DEPRECATED
      );
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version + " and will be removed in the near future"
        )
      );
    }
    return validator ? validator(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i5 = keys.length;
  while (i5-- > 0) {
    const opt = keys[i5];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === void 0 || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
}
var validator_default = {
  assertOptions,
  validators
};

// node_modules/axios/lib/core/Axios.js
var validators2 = validator_default.validators;
var Axios = class {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager_default(),
      response: new InterceptorManager_default()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy;
        Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : dummy = new Error();
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        if (!err.stack) {
          err.stack = stack;
        } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
          err.stack += "\n" + stack;
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== void 0) {
      validator_default.assertOptions(transitional2, {
        silentJSONParsing: validators2.transitional(validators2.boolean),
        forcedJSONParsing: validators2.transitional(validators2.boolean),
        clarifyTimeoutError: validators2.transitional(validators2.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils_default.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator_default.assertOptions(paramsSerializer, {
          encode: validators2.function,
          serialize: validators2.function
        }, true);
      }
    }
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils_default.merge(
      headers.common,
      headers[config.method]
    );
    headers && utils_default.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config.headers = AxiosHeaders_default.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i5 = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain2 = [dispatchRequest.bind(this), void 0];
      chain2.unshift.apply(chain2, requestInterceptorChain);
      chain2.push.apply(chain2, responseInterceptorChain);
      len = chain2.length;
      promise = Promise.resolve(config);
      while (i5 < len) {
        promise = promise.then(chain2[i5++], chain2[i5++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i5 = 0;
    while (i5 < len) {
      const onFulfilled = requestInterceptorChain[i5++];
      const onRejected = requestInterceptorChain[i5++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i5 = 0;
    len = responseInterceptorChain.length;
    while (i5 < len) {
      promise = promise.then(responseInterceptorChain[i5++], responseInterceptorChain[i5++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
};
utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_default = Axios;

// node_modules/axios/lib/cancel/CancelToken.js
var CancelToken = class {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners)
        return;
      let i5 = token._listeners.length;
      while (i5-- > 0) {
        token._listeners[i5](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError_default(message, config, request);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
};
var CancelToken_default = CancelToken;

// node_modules/axios/lib/helpers/spread.js
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

// node_modules/axios/lib/helpers/isAxiosError.js
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}

// node_modules/axios/lib/helpers/HttpStatusCode.js
var HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
var HttpStatusCode_default = HttpStatusCode;

// node_modules/axios/lib/axios.js
function createInstance(defaultConfig) {
  const context = new Axios_default(defaultConfig);
  const instance = bind(Axios_default.prototype.request, context);
  utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
  utils_default.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters_default.getAdapter;
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios;

// node_modules/axios/index.js
var {
  Axios: Axios2,
  AxiosError: AxiosError2,
  CanceledError: CanceledError2,
  isCancel: isCancel2,
  CancelToken: CancelToken2,
  VERSION: VERSION2,
  all: all2,
  Cancel,
  isAxiosError: isAxiosError2,
  spread: spread2,
  toFormData: toFormData2,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode: HttpStatusCode2,
  formToJSON,
  getAdapter,
  mergeConfig: mergeConfig2
} = axios_default;

// src/service/ImageUploadService.ts
var import_obsidian3 = require("obsidian");
var _ImageUploadService = class {
  constructor(plugin, app, settings) {
    this.targetProvider = settings.selectedImageStorageProvider;
    this.premiumNIP98User = settings.premiumStorageEnabled;
    this.plugin = plugin;
    this.privateKey = this.convertKeyToHex(settings.privateKey);
    this.app = app;
  }
  async uploadArticleBannerImage(imageFilePath) {
    let result = null;
    try {
      let path2 = (0, import_obsidian3.normalizePath)(imageFilePath);
      let imageBuffer = await import_obsidian3.FileSystemAdapter.readLocalFile(path2);
      if (imageBuffer) {
        const formData = new FormData();
        formData.append("file", new Blob([imageBuffer]));
        let headers = {
          "Content-Type": "multipart/form-data"
        };
        if (this.premiumNIP98User) {
          let base64encodedEventString = await nip98_exports.getToken(
            _ImageUploadService.UPLOAD_ENDPOINT,
            "post",
            (authEvent) => finalizeEvent(authEvent, Buffer.from(this.privateKey)),
            true
          );
          headers["Authorization"] = base64encodedEventString;
          new import_obsidian3.Notice("\u23F3 Uploading as premium user.");
        }
        const response = await axios_default.post("https://nostr.build/api/v2/upload/files", formData, {
          headers
        });
        const { data } = response;
        if (Array.isArray(data.data) && data.data.length > 0) {
          result = data.data[0].url;
        }
      }
    } catch (error) {
      console.error(`Problem with image file reading : ${error}`);
    }
    return result;
  }
  async uploadImagesToStorageProvider(imageFilePaths) {
    let uploadResults = [];
    let success = true;
    for (let imagePath of imageFilePaths) {
      try {
        let imageFile = this.app.vault.getAbstractFileByPath(imagePath);
        if (imageFile instanceof import_obsidian3.TFile) {
          let imageBinary = await this.app.vault.readBinary(imageFile);
          if (this.isFileSizeOverLimit(imageBinary)) {
            continue;
          }
          const formData = new FormData();
          formData.append("file", new Blob([imageBinary]), imageFile.name);
          let headers = {
            "Content-Type": "multipart/form-data"
          };
          if (this.premiumNIP98User) {
            let base64encodedEventString = await nip98_exports.getToken(
              _ImageUploadService.UPLOAD_ENDPOINT,
              "post",
              (authEvent) => finalizeEvent(authEvent, Buffer.from(this.privateKey)),
              true
            );
            headers["Authorization"] = base64encodedEventString;
            new import_obsidian3.Notice("\u23F3 Uploading as premium user.");
          }
          const response = await axios_default.post("https://nostr.build/api/v2/upload/files", formData, {
            headers
          });
          const { data } = response;
          if (Array.isArray(data.data) && data.data.length > 0) {
            const result = {
              filePath: imagePath,
              stringToReplace: `![[${imageFile.name}]]`,
              replacementStringURL: data.data[0].url,
              uploadMetadata: data.data[0]
            };
            uploadResults.push(result);
            new import_obsidian3.Notice(`\u2705 Uploaded ${imageFile.name}`);
          } else {
            new import_obsidian3.Notice(`\u274C Problem uploading ${imageFile.name}`);
          }
        }
      } catch (error) {
        new import_obsidian3.Notice(`\u274C Problem uploading `);
        console.error(`Problem with image file reading : ${error}`);
        success = false;
      }
    }
    return { success, results: uploadResults };
  }
  isFileSizeOverLimit(file) {
    let maxSizeInBytes = 10 * 1024 * 1024;
    if (this.premiumNIP98User) {
      maxSizeInBytes = 50 * 1024 * 1024;
    }
    if (file.byteLength > maxSizeInBytes) {
      if (this.premiumNIP98User) {
        new import_obsidian3.Notice("\u274C 50 MB inline image limit. Will not upload.");
        return true;
      }
      new import_obsidian3.Notice("\u274C Inline image size exceeds the limit. Will not upload.");
      return true;
    }
    return false;
  }
  convertKeyToHex(value) {
    if (value && value.startsWith("nsec")) {
      let decodedPrivateKey = nip19_exports.decode(value);
      return decodedPrivateKey.data;
    }
    if (value && value.startsWith("npub")) {
      let decodedPublicKey = nip19_exports.decode(value);
      return decodedPublicKey.data;
    }
    return value;
  }
};
var ImageUploadService = _ImageUploadService;
ImageUploadService.UPLOAD_ENDPOINT = "https://nostr.build/api/v2/upload/files";

// src/service/NostrService.ts
var NostrService = class {
  constructor(plugin, app, settings) {
    this.setConnectionPool = () => {
      this.pool = new SimplePool();
      this.poolUrls = [];
      for (const relay of this.connectedRelays) {
        this.poolUrls.push(relay.url);
      }
    };
    this.updateStatusBar = () => {
      var _a, _b;
      if (this.connectedRelays.length === 0) {
        (_a = this.plugin.statusBar) == null ? void 0 : _a.setText("Nostr \u{1F31A}");
        this.isConnected = false;
      } else {
        (_b = this.plugin.statusBar) == null ? void 0 : _b.setText(
          `Nostr \u{1F7E3} ${this.connectedRelays.length} / ${this.relayURLs.length} relays.`
        );
      }
    };
    if (!settings.privateKey) {
      console.error(
        "YourPlugin requires a private key to be set in the settings."
      );
      return;
    }
    if (settings.multipleProfilesEnabled) {
      console.log("multiple profiles enabled");
      this.profiles = settings.profiles;
      this.multipleProfilesEnabled = true;
    }
    this.plugin = plugin;
    this.app = app;
    this.imageUploadService = new ImageUploadService(this.plugin, this.app, settings);
    this.privateKey = this.convertKeyToHex(settings.privateKey);
    this.publicKey = getPublicKey3(this.privateKey);
    this.relayURLs = [];
    if (!settings.relayURLs) {
      console.error(
        "YourPlugin requires a list of relay urls to be set in the settings, defaulting."
      );
      this.relayURLs = [
        "wss://nos.lol ",
        "wss://relay.damus.io",
        "wss://relay.nostr.band",
        "wss://relayable.org",
        "wss://nostr.rocks",
        "wss://nostr.fmt.wiz.biz"
      ];
    } else {
      for (let url of settings.relayURLs) {
        if (this.isValidURL(url)) {
          this.relayURLs.push(url);
        }
      }
    }
    this.connectToRelays();
  }
  reloadMultipleAccounts() {
    console.log("reloading multiple accounts...");
    this.profiles = this.plugin.settings.profiles;
    this.multipleProfilesEnabled = true;
  }
  async connectToRelays() {
    this.refreshRelayUrls();
    this.connectedRelays = [];
    let connectionPromises = this.relayURLs.map((url) => {
      return new Promise(async (resolve) => {
        console.log(`Initializing NostrService with relay: ${url}`);
        try {
          const relayAttempt = await Relay.connect(url);
          relayAttempt.onclose = () => {
            handleFailure();
          };
          const handleFailure = () => {
            console.log(`Disconnected from ${url}, updating status bar.`);
            this.connectedRelays.remove(relayAttempt);
            this.updateStatusBar();
            resolve(null);
          };
          console.log(`Connected to ${relayAttempt.url}`);
          this.connectedRelays.push(relayAttempt);
          resolve(relayAttempt);
        } catch (error) {
          console.error(`Failed to connect to ${url}: ${error}`);
          resolve(null);
        }
      });
    });
    Promise.all(connectionPromises).then(() => {
      console.log(
        `Connected to ${this.connectedRelays.length} / ${this.relayURLs.length} relays`
      );
      this.updateStatusBar();
      if (this.connectedRelays.length > 0) {
        this.setConnectionPool();
        this.isConnected = true;
      }
    });
  }
  refreshRelayUrls() {
    this.relayURLs = [];
    if (!this.plugin.settings.relayURLs || this.plugin.settings.relayURLs.length === 0) {
      console.error(
        "YourPlugin requires a list of relay urls to be set in the settings, defaulting to Damus."
      );
      this.relayURLs = [
        "wss://nos.lol ",
        "wss://relay.damus.io",
        "wss://relay.nostr.band",
        "wss://relayable.org",
        "wss://nostr.fmt.wiz.biz"
      ];
    } else {
      for (let url of this.plugin.settings.relayURLs) {
        if (this.isValidURL(url)) {
          this.relayURLs.push(url);
        }
      }
    }
  }
  getRelayInfo(relayUrl) {
    let connected = false;
    for (let r of this.connectedRelays) {
      if (r.url == relayUrl + "/") {
        return r.connected;
      }
    }
    return connected;
  }
  getConnectionStatus() {
    return this.isConnected;
  }
  getPublicKey() {
    return this.publicKey;
  }
  async publishShortFormNote(message, profileNickname) {
    console.log(`Sending a short form note to Nostr...`);
    let profilePrivateKey = this.privateKey;
    let profilePublicKey = this.publicKey;
    if (profileNickname !== "default" && this.multipleProfilesEnabled) {
      console.log("recieved non-default profile: " + profileNickname);
      for (const { profileNickname: nickname, profilePrivateKey: key } of this.profiles) {
        if (profileNickname === nickname) {
          profilePrivateKey = this.convertKeyToHex(key);
          profilePublicKey = getPublicKey3(profilePrivateKey);
        }
      }
    }
    if (message) {
      let uuid = v4_default().substr(0, 8);
      let tags = [["d", uuid]];
      let eventTemplate = {
        kind: 1,
        created_at: Math.floor(Date.now() / 1e3),
        tags,
        content: message
      };
      const signedEvent = finalizeEvent3(eventTemplate, Buffer.from(profilePrivateKey));
      return this.publishToRelays(signedEvent, "", "");
    } else {
      console.error("No message to publish");
      return { success: false, publishedRelays: [] };
    }
  }
  async publishNote(fileContent, activeFile, summary, imageBannerFilePath, title, userSelectedTags, profileNickname, publishAsDraft) {
    if (!publishAsDraft) {
      new import_obsidian4.Notice(`\u23F3 Publishing your note ${activeFile.name} to nostr...`);
    } else {
      new import_obsidian4.Notice(`\u23F3 Publishing your note ${activeFile.name} as a draft to nostr...`);
    }
    let profilePrivateKey = this.privateKey;
    let profilePublicKey = this.publicKey;
    if (profileNickname !== "default" && this.multipleProfilesEnabled) {
      console.log("recieved non-default profile: " + profileNickname);
      for (const { profileNickname: nickname, profilePrivateKey: key } of this.profiles) {
        if (profileNickname === nickname) {
          profilePrivateKey = this.convertKeyToHex(key);
          profilePublicKey = getPublicKey3(Buffer.from(profilePrivateKey));
        }
      }
    }
    if (fileContent) {
      let uuid = v4_default().substr(0, 8);
      let tags = [["d", uuid]];
      if (summary) {
        tags.push(["summary", summary]);
      }
      if (imageBannerFilePath !== null) {
        new import_obsidian4.Notice("\u{1F5BC}\uFE0F Uploading Banner Image");
        let imageUploadResult = await this.imageUploadService.uploadArticleBannerImage(imageBannerFilePath);
        if (imageUploadResult !== null) {
          tags.push(["image", imageUploadResult]);
          new import_obsidian4.Notice("\u2705 Uploaded Banner Image");
        } else {
          new import_obsidian4.Notice("\u274C Problem Uploading Banner Image..");
        }
      } else {
        console.info("No banner image...");
      }
      let timestamp = Math.floor(Date.now() / 1e3);
      tags.push(["published_at", timestamp.toString()]);
      if (userSelectedTags.length > 0) {
        for (const tag of userSelectedTags) {
          tags.push(["t", tag]);
        }
      }
      if (title) {
        tags.push(["title", title]);
      } else {
        const noteTitle = activeFile.basename;
        tags.push(["title", noteTitle]);
      }
      const imagePaths = [];
      try {
        let vaultResolvedLinks = this.app.metadataCache.resolvedLinks;
        if (vaultResolvedLinks[activeFile.path]) {
          const fileContents = vaultResolvedLinks[activeFile.path];
          for (const filePath of Object.keys(fileContents)) {
            if (this.isImagePath(filePath)) {
              imagePaths.push(filePath);
            }
          }
        }
        if (imagePaths.length > 0) {
          new import_obsidian4.Notice("\u2705 Found inline images - uploading with article.");
          let imageUploadResult = await this.imageUploadService.uploadImagesToStorageProvider(imagePaths);
          if (imageUploadResult.success && imageUploadResult.results && imageUploadResult.results.length > 0) {
            for (const imageTarget of imageUploadResult.results) {
              if (imageTarget.replacementStringURL !== null && imageTarget.uploadMetadata !== null) {
                fileContent = fileContent.replace(imageTarget.stringToReplace, imageTarget.replacementStringURL);
                let imetaTag = this.getImetaTagForImage(imageTarget.uploadMetadata);
                if (imetaTag !== null) {
                  tags.push(imetaTag);
                }
              }
            }
          } else {
            console.error("Problem with the image upload, some or all images may not have successfully uploaded...");
          }
        } else {
          console.error("No images found in vault for this file..");
        }
      } catch (e) {
        console.error("Bigger Problem with the image upload, some or all images may not have successfully uploaded...", e);
        new import_obsidian4.Notice("\u274C Problem uploading inline images.");
      }
      let eventTemplate = {
        kind: publishAsDraft ? 30024 : 30023,
        created_at: timestamp,
        tags,
        content: fileContent
      };
      const finalEvent = finalizeEvent3(eventTemplate, Buffer.from(profilePrivateKey));
      return this.publishToRelays(
        finalEvent,
        activeFile.path,
        profileNickname
      );
    } else {
      console.error("No message to publish");
      return { success: false, publishedRelays: [] };
    }
  }
  getImetaTagForImage(uploadData) {
    let inlineTag = [];
    let url = uploadData.url ? uploadData.url : null;
    let mimeType = uploadData.mime ? uploadData.mime : null;
    let ox = uploadData.original_sha256 ? uploadData.original_sha256 : null;
    let size = uploadData.size ? uploadData.size : null;
    let dim = uploadData.dimensionsString ? uploadData.dimensionsString : null;
    let blurhash = uploadData.blurhash ? uploadData.blurhash : null;
    let thumbnail = uploadData.thumbnail ? uploadData.thumbnail : null;
    if (url !== null) {
      inlineTag.push("imeta");
      let urlString = `url ${url}`;
      inlineTag.push(urlString);
    } else {
      console.error("No upload URL in metadata, so not adding imeta tag");
      return null;
    }
    if (mimeType !== null) {
      let mimeString = `m ${mimeType}`;
      inlineTag.push(mimeString);
    }
    if (ox !== null) {
      let oxString = `ox ${ox}`;
      inlineTag.push(oxString);
    }
    if (size !== null) {
      let sizeString = `size ${size}`;
      inlineTag.push(sizeString);
    }
    if (dim !== null) {
      let dimString = `dim ${dim}`;
      inlineTag.push(dimString);
    }
    if (blurhash !== null) {
      let blurhashString = `blurhash ${blurhash}`;
      inlineTag.push(blurhashString);
    }
    if (thumbnail !== null) {
      let thumbnailString = `thumb ${thumbnail}`;
      inlineTag.push(thumbnailString);
    }
    return inlineTag;
  }
  isImagePath(filePath) {
    const imageExtensions = [".png", ".jpg", ".jpeg", ".gif", ".bmp", ".svg"];
    const ext = path.extname(filePath).toLowerCase();
    return imageExtensions.includes(ext);
  }
  async getUserBookmarkIDs() {
    const bookmark_event_ids = [];
    const longform_event_ids = [];
    try {
      if (this.pool === void 0 || this.poolUrls.length === 0) {
        console.error("No pool...");
        this.setConnectionPool();
      }
      let events = await this.pool.querySync(this.poolUrls, { kinds: [10003], authors: [this.publicKey] });
      if (events.length > 0) {
        for (let event of events) {
          for (const tag of event.tags) {
            if (tag[0] === "e") {
              bookmark_event_ids.push(tag[1]);
            }
            if (tag[0] === "a") {
              longform_event_ids.push(tag[1]);
            }
          }
        }
        return { success: true, bookmark_event_ids, longform_event_ids };
      }
      return events;
    } catch (error) {
      console.error("Error occurred while fetching bookmarks ids:", error);
      return { success: false, bookmark_event_ids, longform_event_ids };
    }
  }
  async loadUserBookmarks() {
    let events = [];
    try {
      let res = await this.getUserBookmarkIDs();
      if (res.success) {
        if (this.pool === void 0 || this.poolUrls.length === 0) {
          this.setConnectionPool();
        }
        if (res.longform_event_ids.length > 0) {
          for (let atag of res.longform_event_ids) {
            let author = "";
            let eTag = "";
            let parts = atag.split(":");
            if (parts.length >= 2) {
              author = parts[1];
              eTag = parts[2];
            }
            let articles = await this.pool.querySync(this.poolUrls, { authors: [author], kinds: [30023] });
            for (let articleItem of articles) {
              if (articleItem.tags.some((tag) => tag[0] === "d" && tag[1] === eTag)) {
                events.push(articleItem);
              }
            }
          }
        }
        let newEvents = await this.pool.querySync(this.poolUrls, { ids: res.bookmark_event_ids, kinds: [1, 30023] });
        events.push(...newEvents);
        return events;
      } else {
        console.error("No bookmark IDs returned");
        return [];
      }
    } catch (err) {
      console.error("Error occurred while fetching bookmarks:", err);
      return [];
    }
  }
  async loadUserHighlights() {
    let events = [];
    try {
      if (this.pool === void 0 || this.poolUrls.length === 0) {
        this.setConnectionPool();
      }
      let highlights = await this.pool.querySync(this.poolUrls, { authors: [this.publicKey], kinds: [9802] });
      if (highlights.length > 0) {
        for (let event of highlights) {
          events.push(event);
        }
      }
      return events;
    } catch (err) {
      console.error("Error occurred while fetching bookmarks:", err);
      return [];
    }
  }
  async getUserProfile(userHexPubKey) {
    try {
      if (this.pool === void 0 || this.poolUrls.length === 0) {
        this.setConnectionPool();
      }
      let profileEvent = await this.pool.querySync(this.poolUrls, { kinds: [0], authors: [userHexPubKey] });
      return profileEvent;
    } catch (err) {
      console.error("Error occurred while fetching bookmarks:", err);
      return null;
    }
  }
  //	The a tag, used to refer to a (maybe parameterized) replaceable event
  //for a parameterized replaceable event: ["a", <kind integer>:<32-bytes lowercase hex of a pubkey>:<d tag value>, <recommended relay URL, optional>]
  //for a non-parameterized replaceable event: ["a", <kind integer>:<32-bytes lowercase hex of a pubkey>:, <recommended relay URL, optional>]
  async getEventFromATag(tagValue) {
    let events = [];
    try {
      if (this.pool === void 0 || this.poolUrls.length === 0) {
        this.setConnectionPool();
      }
      let eventParts = tagValue.split(":");
      let articles = await this.pool.querySync(this.poolUrls, { kinds: [parseInt(eventParts[0], 10)], authors: [eventParts[1]] });
      for (let articleItem of articles) {
        if (articleItem.tags.some((tag) => tag[0] === "d" && tag[1] === eventParts[2])) {
          events.push(articleItem);
        }
      }
      return events[0];
    } catch (err) {
      console.error("Error occurred while fetching bookmarks:", err);
      return null;
    }
  }
  async publishToRelays(finalEvent, filePath, profileNickname) {
    try {
      let publishingPromises = this.connectedRelays.map(async (relay) => {
        try {
          if (relay.connected) {
            console.log(`Publishing to ${relay.url}`);
            await relay.publish(finalEvent);
            console.log(`Event published successfully to ${relay.url}`);
            return { success: true, url: relay.url };
          } else {
            console.log(`Skipping disconnected relay: ${relay.url}`);
            return { success: false };
          }
        } catch (error) {
          console.error(`Failed to publish event to ${relay.url}: ${error}`);
          return { success: false };
        }
      });
      let results = await Promise.all(publishingPromises);
      let publishedRelays = results.filter((result) => result.success).map((result) => result.url);
      console.log(
        `Published to ${publishedRelays.length} / ${this.connectedRelays.length} relays.`
      );
      if (publishedRelays.length === 0) {
        console.log("Didn't send to any relays");
        return { success: false, publishedRelays: [] };
      } else {
        if (finalEvent.kind === 30023) {
          this.savePublishedEvent(
            finalEvent,
            filePath,
            publishedRelays,
            profileNickname
          );
        }
        return { success: true, publishedRelays };
      }
    } catch (error) {
      console.error("An error occurred while publishing to relays", error);
      return { success: false, publishedRelays: [] };
    }
  }
  shutdownRelays() {
    console.log("Shutting down Nostr service");
    if (this.connectedRelays.length > 0) {
      for (let r of this.connectedRelays) {
        r.close();
      }
      this.pool.close();
    }
  }
  convertKeyToHex(value) {
    if (value && value.startsWith("nsec")) {
      let decodedPrivateKey = nip19_exports.decode(value);
      return decodedPrivateKey.data;
    }
    if (value && value.startsWith("npub")) {
      let decodedPublicKey = nip19_exports.decode(value);
      return decodedPublicKey.data;
    }
    return value;
  }
  async savePublishedEvent(finalEvent, publishedFilePath, relays, profileNickname) {
    const publishedDataPath = `${this.plugin.manifest.dir}/published.json`;
    let publishedEvents;
    try {
      const fileContent = await this.app.vault.adapter.read(
        publishedDataPath
      );
      publishedEvents = JSON.parse(fileContent);
    } catch (e) {
      publishedEvents = [];
    }
    const eventWithMetaData = {
      ...finalEvent,
      filepath: publishedFilePath,
      publishedToRelays: relays,
      profileNickname
    };
    publishedEvents.push(eventWithMetaData);
    await this.app.vault.adapter.write(
      publishedDataPath,
      JSON.stringify(publishedEvents)
    );
  }
  isValidURL(url) {
    try {
      new URL(url);
      return true;
    } catch (error) {
      console.log(error);
      return false;
    }
  }
};

// src/settings.ts
var import_obsidian5 = require("obsidian");
var NostrWriterSettingTab = class extends import_obsidian5.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.refreshDisplay = () => this.display();
  }
  display() {
    let { containerEl } = this;
    containerEl.empty();
    let privateKeyField;
    let privateKeyInput;
    new import_obsidian5.Setting(containerEl).setName("Nostr private key").setDesc("Default profile to publish from.").addText((text) => {
      privateKeyInput = text;
      text.setPlaceholder("nsec...").setValue(this.plugin.settings.privateKey).onChange(async (value) => {
        if (isValidPrivateKey(value)) {
          this.plugin.settings.privateKey = value;
          await this.plugin.saveSettings();
          this.plugin.startupNostrService();
          new import_obsidian5.Notice("Private key saved!");
        } else {
          new import_obsidian5.Notice("Invalid private key", 5e3);
        }
      });
      privateKeyField = text.inputEl;
      privateKeyField.type = "password";
      privateKeyField.style.width = "400px";
    }).addButton(
      (button) => button.setTooltip("Copy private key").setIcon("copy").onClick(() => {
        if (privateKeyField) {
          navigator.clipboard.writeText(
            privateKeyField.value
          );
          new import_obsidian5.Notice("Private Key Copied - Be Careful \u{1F510}");
        }
      })
    ).addButton(
      (button) => button.setButtonText("Delete").setWarning().setTooltip("Delete the private key from memory").onClick(async () => {
        if (confirm(
          "Are you sure you want to delete your private key? This cannot be undone."
        )) {
          this.plugin.settings.privateKey = "";
          await this.plugin.saveSettings();
          privateKeyInput.setValue("");
          this.plugin.startupNostrService();
          new import_obsidian5.Notice("Private key deleted!\u{1F5D1}");
        }
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Show private key").setDesc("Toggle to show/hide the private key.").addToggle(
      (toggle) => toggle.setValue(false).onChange((value) => {
        if (privateKeyField) {
          privateKeyField.type = value ? "text" : "password";
        }
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Premium Storage User").setDesc(
      `Turn on if you have a premium account with nostr.build storage service.`
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.premiumStorageEnabled).onChange(async (value) => {
        this.plugin.settings.premiumStorageEnabled = value;
        new import_obsidian5.Notice(`\u2705 Premium image user mode ${value ? "enabled" : "disabled"}`);
        await this.plugin.saveSettings();
        this.refreshDisplay();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Enable multiple Nostr profiles").setDesc(
      "Enable & add multiple Nostr profiles to publish from."
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.multipleProfilesEnabled).onChange(async (value) => {
        this.plugin.settings.multipleProfilesEnabled = value;
        await this.plugin.saveSettings();
        this.refreshDisplay();
      })
    );
    if (this.plugin.settings.multipleProfilesEnabled) {
      let newProfilePrivateKeyField;
      let newProfileNicknameField;
      let multiplePrivateKeyField;
      containerEl.createEl("h5", { text: "Additional Nostr Profiles" });
      new import_obsidian5.Setting(this.containerEl).setDesc("Add a new Nostr profile to publish from.").setName("Add Profile").addText((newAccountNicknameInput) => {
        newAccountNicknameInput.setPlaceholder("Profile Nickname");
        newAccountNicknameInput.onChange((value) => {
          if (value.toLowerCase() !== "default") {
            newProfileNicknameField = value;
          } else {
            new import_obsidian5.Notice("\u274C Can't call an additional profile default");
          }
        });
      }).addText((newAccountNsecInput) => {
        newAccountNsecInput.setPlaceholder("nsec");
        newAccountNsecInput.onChange(async (value) => {
          if (isValidPrivateKey(value)) {
            newProfilePrivateKeyField = value;
            new import_obsidian5.Notice("\u2705 Private key OK!");
          } else {
            new import_obsidian5.Notice("\u274C Invalid private key", 5e3);
          }
        });
        multiplePrivateKeyField = newAccountNsecInput.inputEl;
        multiplePrivateKeyField.type = "password";
        multiplePrivateKeyField.style.width = "200px";
      }).addButton((btn) => {
        btn.setIcon("plus");
        btn.setCta();
        btn.setTooltip("Add this profile");
        btn.onClick(async () => {
          if (newProfilePrivateKeyField && newProfileNicknameField && this.isValidNickname(newProfileNicknameField)) {
            this.plugin.settings.profiles.push({
              profileNickname: newProfileNicknameField,
              profilePrivateKey: newProfilePrivateKeyField
            });
            await this.plugin.saveSettings();
            this.refreshDisplay();
            this.plugin.nostrService.reloadMultipleAccounts();
          } else {
            new import_obsidian5.Notice("Add a profile nickname & a valid nsec");
            if (!this.isValidNickname(newProfileNicknameField)) {
              new import_obsidian5.Notice("\u274C Invalid nickname - already in use");
            }
          }
        });
      });
      for (const [i5, { profileNickname }] of this.plugin.settings.profiles.entries()) {
        new import_obsidian5.Setting(this.containerEl).setName(`\u{1F464} - ${profileNickname}`).addButton((btn) => {
          btn.setIcon("trash");
          btn.setWarning();
          btn.setTooltip("Remove this profile");
          btn.onClick(async () => {
            if (confirm(
              "Are you sure you want to delete this profile? This cannot be undone."
            )) {
              this.plugin.settings.profiles.splice(i5, 1);
              await this.plugin.saveSettings();
              this.refreshDisplay();
              this.plugin.nostrService.reloadMultipleAccounts();
              new import_obsidian5.Notice("\u{1F5D1}\uFE0F Profile successfully deleted.");
            }
          });
        });
      }
      containerEl.createEl("br");
    }
    new import_obsidian5.Setting(containerEl).setName("Clear local published history").setDesc("This does not delete your notes from the Nostr network.").addButton(
      (button) => button.setButtonText("Clear").setIcon("trash").setTooltip("Delete the local published history").onClick(async () => {
        if (confirm(
          "Are you sure you want to delete your local history? This cannot be undone."
        )) {
          clearLocalPublishedFile();
          new import_obsidian5.Notice("\u{1F5D1}\uFE0F Published History deleted!");
        }
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Short form mode").setDesc("Add short form writing button to your menu.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.shortFormEnabled).onChange(async (value) => {
        this.plugin.settings.shortFormEnabled = value;
        await this.plugin.saveSettings();
        this.plugin.updateRibbonIcon();
        new import_obsidian5.Notice(
          `\u2705 Short form mode ${value ? "enabled" : "disabled"}`
        );
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Configure relays").setDesc("Edit the default configuration & see details.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.relayConfigEnabled).onChange(async (value) => {
        this.plugin.settings.relayConfigEnabled = value;
        await this.plugin.saveSettings();
        this.refreshDisplay();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Reconnect to relays ").setDesc(
      "Refresh connection to relays - check status bar for details."
    ).addButton((btn) => {
      btn.setIcon("reset");
      btn.setCta();
      btn.setTooltip("Re-connect");
      btn.onClick(async () => {
        new import_obsidian5.Notice(`Re-connecting to Nostr...`);
        this.refreshDisplay();
        await this.plugin.nostrService.connectToRelays();
      });
    });
    if (this.plugin.settings.relayConfigEnabled) {
      containerEl.createEl("h5", { text: "Relay Configuration" });
      new import_obsidian5.Setting(this.containerEl).setDesc("Add a relay URL to settings").setName("Add Relay").addText((relayUrlInput) => {
        relayUrlInput.setPlaceholder("wss://fav.relay.com");
        relayUrlInput.onChange(() => {
          this.relayUrlInput = relayUrlInput;
        });
      }).addButton((btn) => {
        btn.setIcon("plus");
        btn.setCta();
        btn.setTooltip("Add this relay");
        btn.onClick(async () => {
          try {
            let addedRelayUrl = this.relayUrlInput.getValue();
            if (this.isValidUrl(addedRelayUrl)) {
              this.plugin.settings.relayURLs.push(
                addedRelayUrl
              );
              await this.plugin.saveSettings();
              new import_obsidian5.Notice(
                `Added ${addedRelayUrl} to relay configuration.`
              );
              new import_obsidian5.Notice(`Re-connecting to Nostr...`);
              this.refreshDisplay();
              await this.plugin.nostrService.connectToRelays();
              this.relayUrlInput.setValue("");
            } else {
              new import_obsidian5.Notice("Invalid URL added");
            }
          } catch (e) {
            new import_obsidian5.Notice("No URL added");
          }
        });
      });
      for (const [i5, url] of this.plugin.settings.relayURLs.entries()) {
        new import_obsidian5.Setting(this.containerEl).setDesc(
          `${url} is ${this.plugin.nostrService.getRelayInfo(url) ? "connected" : "disconnected"}`
        ).setName(
          `${this.plugin.nostrService.getRelayInfo(url) ? "\u{1F7E2}" : "\u{1F480}"} - Relay ${i5 + 1} `
        ).addButton((btn) => {
          btn.setIcon("trash");
          btn.setTooltip("Remove this relay");
          btn.onClick(async () => {
            if (confirm(
              "Are you sure you want to delete this relay? This cannot be undone."
            )) {
              this.plugin.settings.relayURLs.splice(i5, 1);
              await this.plugin.saveSettings();
              this.refreshDisplay();
              new import_obsidian5.Notice("Relay successfully deleted.");
              new import_obsidian5.Notice(`Re-connecting to Nostr...`);
              this.plugin.nostrService.connectToRelays();
            }
          });
        });
      }
    }
    containerEl.createEl("h5", { text: "Support" });
    new import_obsidian5.Setting(this.containerEl).setDesc(
      "Has this plugin enhanced your workflow? Say thanks as a one-time payment and zap/buy me a coffee."
    ).addButton((bt) => {
      bt.setTooltip("Copy 20k sats lightning invoice").setIcon("zap").setCta().onClick(() => {
        if (privateKeyField) {
          navigator.clipboard.writeText(
            "lnbc200u1pjvu03dpp5x20p0q5tdwylg5hsqw3av6qxufah0y64efldazmgad2rsffgda8qdpdfehhxarjypthy6t5v4ezqnmzwd5kg6tpdcs9qmr4va5kucqzzsxqyz5vqsp5w55p4tzawyfz5fasflmsvdfnnappd6hqnw9p7y2p0nl974f0mtkq9qyyssqq6gvpnvvuftqsdqyxzn9wrre3qfkpefzz6kqwssa3pz8l9mzczyq4u7qdc09jpatw9ekln9gh47vxrvx6zg6vlsqw7pq4a7kvj4ku4qpdrflwj"
          );
          new import_obsidian5.Notice("Lightning Invoice Address Copied!\u26A1\uFE0F");
          setTimeout(() => {
            new import_obsidian5.Notice("Thank You \u{1F91D}");
          }, 500);
          setTimeout(() => {
            new import_obsidian5.Notice("Stay Humble \u2696\uFE0F");
          }, 1e3);
          setTimeout(() => {
            new import_obsidian5.Notice("Stack Sats \u26A1\uFE0F");
          }, 1500);
        }
      });
    }).addButton((button) => {
      button.setTooltip("Sponsor on GitHub").setIcon("github").onClick(
        () => window.open(
          "https://github.com/sponsors/jamesmagoo",
          "_blank"
        )
      );
      button.buttonEl.style.height = "35px";
    }).addButton((bt) => {
      const anchor = document.createElement("a");
      anchor.href = "https://www.buymeacoffee.com/jamesmagoo";
      anchor.target = "_blank";
      const img = document.createElement("img");
      img.style.height = "35px";
      img.src = "https://cdn.buymeacoffee.com/buttons/v2/default-yellow.png";
      img.alt = "Buy Me A Coffee";
      anchor.appendChild(img);
      bt.buttonEl.replaceWith(anchor);
    });
  }
  isValidUrl(url) {
    try {
      new URL(url);
      return true;
    } catch (error) {
      console.log(error);
      return false;
    }
  }
  isValidNickname(nickname) {
    let isValid2 = true;
    let profilesToCheck = this.plugin.settings.profiles;
    if (profilesToCheck && profilesToCheck.length > 0) {
      for (const profile of profilesToCheck) {
        if (profile.profileNickname == nickname) {
          console.log("found a match");
          isValid2 = false;
        }
      }
    }
    return isValid2;
  }
};
function isValidPrivateKey(key) {
  return typeof key === "string" && key.length === 63 && key.startsWith("nsec");
}
async function clearLocalPublishedFile() {
  const pathToPlugin = this.app.vault.configDir + "/plugins/nostr-writer";
  const publishedFilePath = `${pathToPlugin}/published.json`;
  try {
    await this.app.vault.adapter.remove(publishedFilePath);
  } catch (error) {
    console.log(error);
  }
}

// src/PublishedView.ts
var import_obsidian6 = require("obsidian");
var PUBLISHED_VIEW = "published-view";
var PublishedView = class extends import_obsidian6.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.focusFile = (path2, shouldSplit = false) => {
      const targetFile = this.app.vault.getAbstractFileByPath(path2);
      if (targetFile && targetFile instanceof import_obsidian6.TFile) {
        let leaf = this.app.workspace.getLeaf();
        const createLeaf = shouldSplit || (leaf == null ? void 0 : leaf.getViewState().pinned);
        if (createLeaf) {
          leaf = this.app.workspace.getLeaf("tab");
        }
        leaf == null ? void 0 : leaf.openFile(targetFile);
      } else {
        new import_obsidian6.Notice("Cannot find a file with that name");
      }
    };
    this.plugin = plugin;
    this.refreshDisplay = () => this.onOpen();
  }
  getViewType() {
    return PUBLISHED_VIEW;
  }
  getDisplayText() {
    return "Published To Nostr";
  }
  getIcon() {
    return "scroll";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    let banner = container.createEl("div", {
      cls: "published-banner-div"
    });
    banner.createEl("h4", { text: "Published" });
    new import_obsidian6.ButtonComponent(banner).setIcon("refresh-cw").setCta().setTooltip("Refresh view").onClick(() => {
      this.refreshDisplay();
      new import_obsidian6.Notice("View refreshed");
    });
    const publishedFilePath = `${this.plugin.manifest.dir}/published.json`;
    try {
      const file = await this.app.vault.adapter.read(publishedFilePath);
      const publishedNotes = JSON.parse(file);
      if (publishedNotes) {
        container.createEl("p", { text: `Total: ${publishedNotes.length} \u2705` });
        publishedNotes.reverse().forEach((note) => {
          const titleTag = note.tags.find(
            (tag) => tag[0] === "title"
          );
          const publishedAtTag = note.tags.find(
            (tag) => tag[0] === "published_at"
          );
          const title = titleTag ? titleTag[1] : "No Title";
          const publishedDate = publishedAtTag ? new Date(Number(publishedAtTag[1]) * 1e3).toLocaleString("en-US", {
            year: "numeric",
            month: "long",
            day: "numeric",
            weekday: "long",
            hour: "2-digit",
            minute: "2-digit"
          }) : "No Published Date";
          const cardDiv = container.createEl("div", {
            cls: "published-card"
          });
          cardDiv.createEl("span", { text: `\u{1F4DC} ${title}` });
          if (this.plugin.settings.multipleProfilesEnabled) {
            if (note.profileNickname) {
              let displayNickname = note.profileNickname;
              if (note.profileNickname == "default") {
                displayNickname = "Default Profile";
              }
              cardDiv.createEl("div", {
                text: `\u{1F464} - ${displayNickname}`,
                cls: "published-profile"
              });
            }
          }
          let detailsDiv = cardDiv.createEl("div", {
            cls: "published-details-div"
          });
          detailsDiv.createEl("p", {
            text: `${publishedDate}.`
          });
          let noteDiv = cardDiv.createEl("div", {
            cls: "published-id"
          });
          let target = {
            id: note.id,
            author: note.pubkey,
            relays: note.publishedToRelays
          };
          let nevent = nip19_exports.neventEncode(target);
          new import_obsidian6.ButtonComponent(detailsDiv).setIcon("popup-open").setCta().setTooltip("View Online").onClick(() => {
            const url = `https://njump.me/${nevent}`;
            window.open(url, "_blank");
          });
          new import_obsidian6.ButtonComponent(detailsDiv).setIcon("go-to-file").setCta().setTooltip("Go to file in Obsidian").onClick(() => {
            if (note.filepath == null) {
              const openFile = this.app.workspace.getActiveFile();
              console.log(openFile == null ? void 0 : openFile.path);
              new import_obsidian6.Notice("File path not available");
            } else {
              this.focusFile(note.filepath);
            }
          });
        });
      } else {
        const noPostsDiv = container.createEl("div", { cls: "published-card" });
        noPostsDiv.createEl("h6", { text: "No Posts \u{1F4DD}" });
      }
    } catch (err) {
      console.error("Error reading published.json:", err);
      const noPostsDiv = container.createEl("div", { cls: "no-posts" });
      noPostsDiv.createEl("h6", { text: "No Posts \u{1F4DD}" });
    }
  }
};

// src/ReaderView.ts
var import_obsidian7 = require("obsidian");

// node_modules/nostr-tools/lib/esm/references.js
var utf8Decoder5 = new TextDecoder("utf-8");
var utf8Encoder5 = new TextEncoder();
var Bech32MaxSize2 = 5e3;
function decode2(nip19) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  let { prefix, words } = bech32.decode(nip19, Bech32MaxSize2);
  let data = new Uint8Array(bech32.fromWords(words));
  switch (prefix) {
    case "nprofile": {
      let tlv = parseTLV2(data);
      if (!((_a = tlv[0]) == null ? void 0 : _a[0]))
        throw new Error("missing TLV 0 for nprofile");
      if (tlv[0][0].length !== 32)
        throw new Error("TLV 0 should be 32 bytes");
      return {
        type: "nprofile",
        data: {
          pubkey: bytesToHex2(tlv[0][0]),
          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder5.decode(d)) : []
        }
      };
    }
    case "nevent": {
      let tlv = parseTLV2(data);
      if (!((_b = tlv[0]) == null ? void 0 : _b[0]))
        throw new Error("missing TLV 0 for nevent");
      if (tlv[0][0].length !== 32)
        throw new Error("TLV 0 should be 32 bytes");
      if (tlv[2] && tlv[2][0].length !== 32)
        throw new Error("TLV 2 should be 32 bytes");
      if (tlv[3] && tlv[3][0].length !== 4)
        throw new Error("TLV 3 should be 4 bytes");
      return {
        type: "nevent",
        data: {
          id: bytesToHex2(tlv[0][0]),
          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder5.decode(d)) : [],
          author: ((_c = tlv[2]) == null ? void 0 : _c[0]) ? bytesToHex2(tlv[2][0]) : void 0,
          kind: ((_d = tlv[3]) == null ? void 0 : _d[0]) ? parseInt(bytesToHex2(tlv[3][0]), 16) : void 0
        }
      };
    }
    case "naddr": {
      let tlv = parseTLV2(data);
      if (!((_e = tlv[0]) == null ? void 0 : _e[0]))
        throw new Error("missing TLV 0 for naddr");
      if (!((_f = tlv[2]) == null ? void 0 : _f[0]))
        throw new Error("missing TLV 2 for naddr");
      if (tlv[2][0].length !== 32)
        throw new Error("TLV 2 should be 32 bytes");
      if (!((_g = tlv[3]) == null ? void 0 : _g[0]))
        throw new Error("missing TLV 3 for naddr");
      if (tlv[3][0].length !== 4)
        throw new Error("TLV 3 should be 4 bytes");
      return {
        type: "naddr",
        data: {
          identifier: utf8Decoder5.decode(tlv[0][0]),
          pubkey: bytesToHex2(tlv[2][0]),
          kind: parseInt(bytesToHex2(tlv[3][0]), 16),
          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder5.decode(d)) : []
        }
      };
    }
    case "nrelay": {
      let tlv = parseTLV2(data);
      if (!((_h = tlv[0]) == null ? void 0 : _h[0]))
        throw new Error("missing TLV 0 for nrelay");
      return {
        type: "nrelay",
        data: utf8Decoder5.decode(tlv[0][0])
      };
    }
    case "nsec":
      return { type: prefix, data };
    case "npub":
    case "note":
      return { type: prefix, data: bytesToHex2(data) };
    default:
      throw new Error(`unknown prefix ${prefix}`);
  }
}
function parseTLV2(data) {
  let result = {};
  let rest = data;
  while (rest.length > 0) {
    let t = rest[0];
    let l = rest[1];
    let v = rest.slice(2, 2 + l);
    rest = rest.slice(2 + l);
    if (v.length < l)
      throw new Error(`not enough data to read on TLV ${t}`);
    result[t] = result[t] || [];
    result[t].push(v);
  }
  return result;
}
var mentionRegex = /\bnostr:((note|npub|naddr|nevent|nprofile)1\w+)\b|#\[(\d+)\]/g;
function parseReferences(evt) {
  let references = [];
  for (let ref of evt.content.matchAll(mentionRegex)) {
    if (ref[2]) {
      try {
        let { type, data } = decode2(ref[1]);
        switch (type) {
          case "npub": {
            references.push({
              text: ref[0],
              profile: { pubkey: data, relays: [] }
            });
            break;
          }
          case "nprofile": {
            references.push({
              text: ref[0],
              profile: data
            });
            break;
          }
          case "note": {
            references.push({
              text: ref[0],
              event: { id: data, relays: [] }
            });
            break;
          }
          case "nevent": {
            references.push({
              text: ref[0],
              event: data
            });
            break;
          }
          case "naddr": {
            references.push({
              text: ref[0],
              address: data
            });
            break;
          }
        }
      } catch (err) {
      }
    } else if (ref[3]) {
      let idx = parseInt(ref[3], 10);
      let tag = evt.tags[idx];
      if (!tag)
        continue;
      switch (tag[0]) {
        case "p": {
          references.push({
            text: ref[0],
            profile: { pubkey: tag[1], relays: tag[2] ? [tag[2]] : [] }
          });
          break;
        }
        case "e": {
          references.push({
            text: ref[0],
            event: { id: tag[1], relays: tag[2] ? [tag[2]] : [] }
          });
          break;
        }
        case "a": {
          try {
            let [kind, pubkey, identifier] = tag[1].split(":");
            references.push({
              text: ref[0],
              address: {
                identifier,
                pubkey,
                kind: parseInt(kind, 10),
                relays: tag[2] ? [tag[2]] : []
              }
            });
          } catch (err) {
          }
          break;
        }
      }
    }
  }
  return references;
}

// src/ReaderView.ts
var READER_VIEW = "reader-view";
var ReaderView = class extends import_obsidian7.ItemView {
  constructor(leaf, plugin, nostrService) {
    super(leaf);
    this.focusFile = (path2, shouldSplit = false) => {
      const targetFile = this.app.vault.getAbstractFileByPath(path2);
      if (targetFile && targetFile instanceof import_obsidian7.TFile) {
        let leaf = this.app.workspace.getLeaf();
        const createLeaf = shouldSplit || (leaf == null ? void 0 : leaf.getViewState().pinned);
        if (createLeaf) {
          leaf = this.app.workspace.getLeaf("tab");
        }
        leaf == null ? void 0 : leaf.openFile(targetFile);
      } else {
        new import_obsidian7.Notice("Cannot find a file with that name");
      }
    };
    this.plugin = plugin;
    this.nostrService = nostrService;
    this.refreshDisplay = () => this.onOpen();
  }
  getViewType() {
    return READER_VIEW;
  }
  getDisplayText() {
    return "Your Nostr Bookmarks";
  }
  getIcon() {
    return "star-list";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    let banner = container.createEl("div", {
      cls: "published-banner-div"
    });
    banner.createEl("h4", { text: "Bookmarks" });
    new import_obsidian7.ButtonComponent(banner).setIcon("refresh-cw").setCta().setTooltip("Refresh bookmarks").onClick(() => {
      this.refreshDisplay();
      new import_obsidian7.Notice("View refreshed");
    });
    try {
      let bookmarks = await this.nostrService.loadUserBookmarks();
      if (this.nostrService.connectedRelays.length === 0) {
        new import_obsidian7.Notice("Re-connect to relays...");
      }
      if (bookmarks.length > 0) {
        container.createEl("p", { text: `Total: ${bookmarks.length} \u2705` });
        bookmarks.reverse().forEach(async (bookmark) => {
          let bookmarkProfile = await this.nostrService.getUserProfile(bookmark.pubkey);
          let profileName = "";
          let profilePicURL = "";
          try {
            const profileObject = JSON.parse(bookmarkProfile[0].content);
            const { name, picture } = profileObject;
            profileName = name;
            if (picture == void 0) {
              for (const tag of bookmarkProfile.tags) {
                if (tag[0] === "image") {
                  const pictureUrl = tag[1];
                  profilePicURL = pictureUrl;
                  break;
                }
              }
            } else {
              profilePicURL = picture;
            }
          } catch (err) {
            console.error("Problem Parsing Profile...setting defaults...", err);
          }
          const cardDiv = container.createEl("div", {
            cls: "bookmark-card"
          });
          if (bookmark.kind === 30023) {
            const titleTag = bookmark.tags.find((tag) => tag[0] === "title");
            if (titleTag) {
              const title = titleTag[1];
              cardDiv.createEl("h3", { text: title });
            }
          }
          const contentDiv = cardDiv.createDiv({
            cls: "bookmark-content"
          });
          let references = parseReferences(bookmark);
          let linkedEvent = false;
          let linkedEventURL = "";
          let simpleAugmentedContent = bookmark.content;
          for (let i5 = 0; i5 < references.length; i5++) {
            let { text, profile, event, address } = references[i5];
            let augmentedReference;
            if (profile) {
              const taggedProfile = await this.nostrService.getUserProfile(profile.pubkey);
              const { name } = JSON.parse(taggedProfile[0].content);
              augmentedReference = `<strong>@${name}</strong>`;
            } else if (event) {
              let linkedEventPointer = {
                id: event.id
              };
              let x = nip19_exports.neventEncode(linkedEventPointer);
              augmentedReference = "";
              linkedEvent = true;
              linkedEventURL = `https://njump.me/${x}`;
            } else if (address) {
              augmentedReference = `<a href="${text}">Referenced Event</a>`;
            } else {
              augmentedReference = text;
            }
            simpleAugmentedContent = simpleAugmentedContent.replaceAll(text, augmentedReference);
          }
          if (bookmark.kind === 30023) {
            const summaryTag = bookmark.tags.find((tag) => tag[0] === "summary");
            if (summaryTag) {
              const summary = summaryTag[1];
              simpleAugmentedContent = `<em>${summary}</em>`;
            } else {
              const firstLineIndex = simpleAugmentedContent.indexOf("\n");
              if (firstLineIndex !== -1) {
                simpleAugmentedContent = simpleAugmentedContent.substring(0, firstLineIndex);
              } else {
                simpleAugmentedContent = simpleAugmentedContent.substring(0, 140) + "...";
              }
            }
          }
          contentDiv.innerHTML = simpleAugmentedContent.replace(/\bhttps?:\/\/\S+/gi, "");
          const imageUrls = this.extractImageUrls(bookmark.content);
          imageUrls.forEach((imageUrl) => {
            cardDiv.createEl("img", {
              attr: {
                src: imageUrl
              },
              cls: "bookmark-image"
            });
          });
          const imageTag = bookmark.tags.find((tag) => tag[0] === "image");
          if (imageTag) {
            const imageURL = imageTag[1];
            cardDiv.createEl("img", {
              attr: {
                src: imageURL
              },
              cls: "bookmark-image"
            });
          }
          const publicKeyDiv = cardDiv.createEl("div", {
            cls: "bookmark-pubkey"
          });
          publicKeyDiv.createEl("img", {
            attr: {
              src: `${profilePicURL}`,
              alt: "Profile Pic"
            },
            cls: "bookmark-profile-pic"
          });
          const displayName = profileName ? profileName : "Unknown";
          publicKeyDiv.createEl("span", { text: displayName });
          const createdAt = new Date(bookmark.created_at * 1e3).toLocaleString();
          cardDiv.createEl("div", {
            text: `Bookmarked On: ${createdAt}`,
            cls: "bookmark-created-at"
          });
          let detailsDiv = cardDiv.createEl("div", {
            cls: "bookmark-view-online-btn"
          });
          let target = {
            id: bookmark.id,
            author: bookmark.pubkey
          };
          let nevent = nip19_exports.neventEncode(target);
          new import_obsidian7.ButtonComponent(detailsDiv).setIcon("popup-open").setCta().setTooltip("View Online").onClick(() => {
            const url = `https://njump.me/${nevent}`;
            window.open(url, "_blank");
          });
          new import_obsidian7.ButtonComponent(detailsDiv).setIcon("download").setClass("bookmark-btn").setCta().setTooltip("Download & Open in Obsidian").onClick(() => {
            this.downloadBookmark(bookmark);
          });
          if (linkedEvent) {
            new import_obsidian7.ButtonComponent(detailsDiv).setIcon("link").setCta().setTooltip("View Linked Event").onClick(() => {
              window.open(linkedEventURL, "_blank");
            });
          }
        });
      } else {
        const noBookmarksDiv = container.createEl("div", { cls: "nobookmarks-card" });
        noBookmarksDiv.createEl("h6", { text: "No Bookmarks Found \u{1F4DA}" });
        noBookmarksDiv.createEl("p", { text: "Use listr.lol to edit & manage your bookmarks" });
        const linkEl = noBookmarksDiv.createEl("a", { text: "listr.lol" });
        linkEl.href = "https://listr.lol";
        linkEl.target = "_blank";
      }
    } catch (err) {
      console.error("Error reading bookmarks:", err);
      new import_obsidian7.Notice("Problem reading bookmarks - re-connect & check you list.");
      const noBookmarksDiv = container.createEl("div", { cls: "nobookmarks-card" });
      noBookmarksDiv.createEl("h6", { text: "No Bookmarks Found \u{1F4DA}" });
      noBookmarksDiv.createEl("p", { text: "Use listr.lol to edit & manage your bookmarks" });
      const linkEl = noBookmarksDiv.createEl("a", { text: "listr.lol" });
      linkEl.href = "https://listr.lol";
      linkEl.target = "_blank";
    }
  }
  openLink(url) {
    console.log(url);
    window.open(url, "_blank");
  }
  async downloadBookmark(bookmark) {
    try {
      let filename;
      const titleTag = bookmark.tags.find((tag) => tag[0] === "title");
      if (titleTag) {
        filename = `${titleTag[1]}.md`;
      } else {
        filename = `bookmark_${bookmark.id.substring(0, 8)}.md`;
      }
      const content = this.generateMarkdownContent(bookmark);
      const file = await this.createMarkdownFile(filename, content);
      if (file !== null) {
        await this.app.workspace.openLinkText(filename, file.path, true);
      } else {
        new import_obsidian7.Notice("Failed to create file. File may already exist.");
      }
    } catch (error) {
      console.error("Error downloading bookmark:", error);
      new import_obsidian7.Notice("Failed to create file. File may already exist.");
    }
  }
  async createMarkdownFile(filename, content) {
    try {
      const file = this.app.vault.create(filename, content);
      return file;
    } catch (error) {
      if (error.message.includes("File already exists")) {
        new import_obsidian7.Notice("File already exists");
      } else {
        console.error("Error creating file:", error);
      }
      return null;
    }
  }
  generateMarkdownContent(bookmark) {
    const createdAt = new Date(bookmark.created_at * 1e3).toLocaleString();
    let source = {
      pubkey: bookmark.pubkey
    };
    let y = nip19_exports.nprofileEncode(source);
    const url = `https://njump.me/${y}`;
    const markdownContent = `
# Nostr Bookmark

**Content:** 

 
${bookmark.content}


***
**Created At:** ${createdAt}
**Source:** ${url}
		`;
    return markdownContent;
  }
  extractImageUrls(content) {
    const urlRegex = /(https?:\/\/[^\s]+\.(?:jpg|jpeg|png|gif))/gi;
    const urls = [];
    let match;
    while ((match = urlRegex.exec(content)) !== null) {
      urls.push(match[0]);
    }
    return urls;
  }
};

// src/HighlightsView.ts
var import_obsidian8 = require("obsidian");
var HIGHLIGHTS_VIEW = "highlights-view";
var HighlightsView = class extends import_obsidian8.ItemView {
  constructor(leaf, plugin, nostrService) {
    super(leaf);
    this.focusFile = (path2, shouldSplit = false) => {
      const targetFile = this.app.vault.getAbstractFileByPath(path2);
      if (targetFile && targetFile instanceof import_obsidian8.TFile) {
        let leaf = this.app.workspace.getLeaf();
        const createLeaf = shouldSplit || (leaf == null ? void 0 : leaf.getViewState().pinned);
        if (createLeaf) {
          leaf = this.app.workspace.getLeaf("tab");
        }
        leaf == null ? void 0 : leaf.openFile(targetFile);
      } else {
        new import_obsidian8.Notice("Cannot find a file with that name");
      }
    };
    this.plugin = plugin;
    this.nostrService = nostrService;
    this.refreshDisplay = () => this.onOpen();
  }
  getViewType() {
    return HIGHLIGHTS_VIEW;
  }
  getDisplayText() {
    return "Your Nostr Highlights";
  }
  getIcon() {
    return "edit";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    let banner = container.createEl("div", {
      cls: "published-banner-div"
    });
    banner.createEl("h4", { text: "Highlights" });
    new import_obsidian8.ButtonComponent(banner).setIcon("refresh-cw").setCta().setTooltip("Refresh highlights").onClick(() => {
      this.refreshDisplay();
      new import_obsidian8.Notice("View refreshed");
    });
    try {
      let highlights = await this.nostrService.loadUserHighlights();
      if (this.nostrService.connectedRelays.length === 0) {
        new import_obsidian8.Notice("Re-connect to relays...");
      }
      if (highlights.length > 0) {
        container.createEl("p", { text: `Total: ${highlights.length} \u2705` });
        highlights.reverse().forEach(async (highlight) => {
          const cardDiv = container.createEl("div", {
            cls: "bookmark-card"
          });
          const contentDiv = cardDiv.createDiv({
            cls: "highlight-content"
          });
          let references = parseReferences(highlight);
          let linkedEvent = false;
          let linkedEventURL = "";
          let simpleAugmentedContent = highlight.content;
          for (let i5 = 0; i5 < references.length; i5++) {
            let { text, profile, event, address } = references[i5];
            let augmentedReference;
            if (profile) {
              const taggedProfile = await this.nostrService.getUserProfile(profile.pubkey);
              const { name } = JSON.parse(taggedProfile[0].content);
              augmentedReference = `<strong>@${name}</strong>`;
            } else if (event) {
              let linkedEventPointer = {
                id: event.id
              };
              let x = nip19_exports.neventEncode(linkedEventPointer);
              augmentedReference = "";
              linkedEvent = true;
              linkedEventURL = `https://njump.me/${x}`;
            } else if (address) {
              augmentedReference = `<a href="${text}">Referenced Event</a>`;
            } else {
              augmentedReference = text;
            }
            simpleAugmentedContent = simpleAugmentedContent.replaceAll(text, augmentedReference);
          }
          contentDiv.innerHTML = simpleAugmentedContent.replace(/\bhttps?:\/\/\S+/gi, "");
          contentDiv.addEventListener("click", function() {
            const textToCopy = contentDiv.textContent;
            navigator.clipboard.writeText(textToCopy).then(() => {
              new import_obsidian8.Notice("\u{1F4CB} Copied to clipboard \u2705.");
            }).catch((error) => {
              console.error("Failed to copy text: ", error);
            });
          });
          const authorTag = highlight.tags.find((tag) => tag[0] === "p");
          let sourceTag = highlight.tags.find((tag) => tag[0] === "a");
          if (sourceTag == void 0) {
            sourceTag = highlight.tags.find((tag) => tag[0] === "e");
          }
          const externalSourceTag = highlight.tags.find((tag) => tag[0] === "r");
          let highlightSource = null;
          if (sourceTag !== void 0) {
            highlightSource = await this.nostrService.getEventFromATag(sourceTag[1]);
          }
          if (authorTag !== void 0) {
            let highlightProfile = await this.nostrService.getUserProfile(authorTag[1]);
            let profileName = "";
            let profilePicURL = "";
            try {
              const profileObject = JSON.parse(highlightProfile[0].content);
              const { name, picture } = profileObject;
              profileName = name;
              if (picture == void 0) {
                for (const tag of highlightProfile.tags) {
                  if (tag[0] === "image") {
                    const pictureUrl = tag[1];
                    profilePicURL = pictureUrl;
                    break;
                  }
                }
              } else {
                profilePicURL = picture;
              }
            } catch (err) {
              console.error("Problem Parsing Profile...setting defaults...", err);
            }
            if (sourceTag !== void 0) {
              if (highlightSource !== null) {
                let sourceTitle = "Unknown...";
                for (const tag of highlightSource.tags) {
                  if (tag[0] === "title") {
                    sourceTitle = tag[1];
                    break;
                  }
                }
                let target = {
                  id: highlightSource.id,
                  author: highlightSource.pubkey
                };
                let nevent = nip19_exports.neventEncode(target);
                const url = `https://njump.me/${nevent}`;
                const contentSourceDiv = cardDiv.createEl("div", {
                  cls: "highlight-content-source"
                });
                contentSourceDiv.createEl("img", {
                  attr: {
                    src: `${profilePicURL}`,
                    alt: "Profile Pic"
                  },
                  cls: "bookmark-profile-pic"
                });
                const displayName = profileName ? profileName : "Unknown";
                contentSourceDiv.createEl("a", {
                  attr: {
                    href: url,
                    target: "_blank"
                  },
                  text: `${sourceTitle}`,
                  cls: "source-article-link"
                });
                contentSourceDiv.createEl("span", { text: "  " });
                contentSourceDiv.createEl("span", { text: " | " });
                contentSourceDiv.createEl("span", { text: displayName });
              }
            }
          } else {
            if (externalSourceTag !== void 0) {
              let externalSourceDiv = cardDiv.createEl("div", {
                cls: "highlight-content-source"
              });
              externalSourceDiv.createEl("a", {
                attr: {
                  href: externalSourceTag[1],
                  target: "_blank"
                },
                text: externalSourceTag[1],
                cls: "source-article-link"
              });
            }
          }
          const createdAt = new Date(highlight.created_at * 1e3).toLocaleString();
          let bottomDiv = cardDiv.createEl("div", {
            text: `Highlighted on: ${createdAt}`,
            cls: "highlight-created-at"
          });
          if (highlightSource !== null) {
            new import_obsidian8.ButtonComponent(bottomDiv).setIcon("download").setClass("highlight-btn").setTooltip("Download full source article.").onClick(() => {
              this.downloadBookmark(highlightSource);
            });
          }
        });
      } else {
        const noBookmarksDiv = container.createEl("div", { cls: "nobookmarks-card" });
        noBookmarksDiv.createEl("h6", { text: "No Highlights Found \u{1F4DA}" });
        noBookmarksDiv.createEl("p", { text: "Use highlighter.com to read and highlight." });
        const linkEl = noBookmarksDiv.createEl("a", { text: "highlighter.com" });
        linkEl.href = "https://highlighter.com";
        linkEl.target = "_blank";
      }
    } catch (err) {
      console.error("Error reading highlights:", err);
      new import_obsidian8.Notice("Problem reading highlights - re-connect & check you list.");
      const noBookmarksDiv = container.createEl("div", { cls: "nobookmarks-card" });
      noBookmarksDiv.createEl("h6", { text: "No Highlights Found \u{1F4DA}" });
      noBookmarksDiv.createEl("p", { text: "Use highlighter.com to read and highlight." });
      const linkEl = noBookmarksDiv.createEl("a", { text: "highlighter.com" });
      linkEl.href = "https://highlighter.com";
      linkEl.target = "_blank";
    }
  }
  openLink(url) {
    console.log(url);
    window.open(url, "_blank");
  }
  async downloadBookmark(bookmark) {
    try {
      let filename;
      const titleTag = bookmark.tags.find((tag) => tag[0] === "title");
      if (titleTag) {
        filename = `${titleTag[1]}.md`;
      } else {
        filename = `bookmark_${bookmark.id.substring(0, 8)}.md`;
      }
      const content = this.generateMarkdownContent(bookmark);
      const file = await this.createMarkdownFile(filename, content);
      if (file !== null) {
        await this.app.workspace.openLinkText(filename, file.path, true);
      } else {
        new import_obsidian8.Notice("Failed to create file. File may already exist.");
      }
    } catch (error) {
      console.error("Error downloading bookmark:", error);
      new import_obsidian8.Notice("Failed to create file. File may already exist.");
    }
  }
  async createMarkdownFile(filename, content) {
    try {
      const file = this.app.vault.create(filename, content);
      return file;
    } catch (error) {
      if (error.message.includes("File already exists")) {
        new import_obsidian8.Notice("File already exists");
      } else {
        console.error("Error creating file:", error);
      }
      return null;
    }
  }
  generateMarkdownContent(bookmark) {
    const createdAt = new Date(bookmark.created_at * 1e3).toLocaleString();
    let source = {
      pubkey: bookmark.pubkey
    };
    let y = nip19_exports.nprofileEncode(source);
    const url = `https://njump.me/${y}`;
    const markdownContent = `
# Nostr Highlight Source

**Content:** 

 
${bookmark.content}


***
**Created At:** ${createdAt}
**Source:** ${url}
		`;
    return markdownContent;
  }
  extractImageUrls(content) {
    const urlRegex = /(https?:\/\/[^\s]+\.(?:jpg|jpeg|png|gif))/gi;
    const urls = [];
    let match;
    while ((match = urlRegex.exec(content)) !== null) {
      urls.push(match[0]);
    }
    return urls;
  }
};

// main.ts
var NostrWriterPlugin = class extends import_obsidian9.Plugin {
  constructor() {
    super(...arguments);
    this.togglePublishedView = async () => {
      const existing = this.app.workspace.getLeavesOfType(PUBLISHED_VIEW);
      if (existing.length) {
        this.app.workspace.revealLeaf(existing[0]);
        return;
      }
      await this.app.workspace.getRightLeaf(false).setViewState({
        type: PUBLISHED_VIEW,
        active: true
      });
      this.app.workspace.revealLeaf(
        this.app.workspace.getLeavesOfType(PUBLISHED_VIEW)[0]
      );
    };
    this.toggleReaderView = async () => {
      const existing = this.app.workspace.getLeavesOfType(READER_VIEW);
      if (existing.length) {
        this.app.workspace.revealLeaf(existing[0]);
        return;
      }
      await this.app.workspace.getRightLeaf(false).setViewState({
        type: READER_VIEW,
        active: true
      });
      this.app.workspace.revealLeaf(
        this.app.workspace.getLeavesOfType(READER_VIEW)[0]
      );
    };
    this.toggleHighlightsView = async () => {
      const existing = this.app.workspace.getLeavesOfType(HIGHLIGHTS_VIEW);
      if (existing.length) {
        this.app.workspace.revealLeaf(existing[0]);
        return;
      }
      await this.app.workspace.getRightLeaf(false).setViewState({
        type: HIGHLIGHTS_VIEW,
        active: true
      });
      this.app.workspace.revealLeaf(
        this.app.workspace.getLeavesOfType(HIGHLIGHTS_VIEW)[0]
      );
    };
  }
  async onload() {
    await this.loadSettings();
    this.updateStatusBar();
    this.startupNostrService();
    this.addSettingTab(new NostrWriterSettingTab(this.app, this));
    this.updateRibbonIcon();
    this.registerView(
      PUBLISHED_VIEW,
      (leaf) => new PublishedView(leaf, this)
    );
    this.registerView(
      READER_VIEW,
      (leaf) => new ReaderView(leaf, this, this.nostrService)
    );
    this.registerView(
      HIGHLIGHTS_VIEW,
      (leaf) => new HighlightsView(leaf, this, this.nostrService)
    );
    this.addRibbonIcon("blocks", "See notes published to Nostr", () => {
      this.togglePublishedView();
    });
    this.addRibbonIcon("star-list", "See your Nostr Bookmarks", () => {
      this.toggleReaderView();
    });
    this.addRibbonIcon("lines-of-text", "See your Nostr Highlights", () => {
      this.toggleHighlightsView();
    });
    this.addRibbonIcon(
      "file-up",
      "Publish this note to Nostr",
      async (evt) => {
        await this.checkAndPublish();
      }
    );
    this.addCommand({
      id: "publish-note-to-nostr",
      name: "Publish",
      callback: async () => {
        await this.checkAndPublish();
      }
    });
    this.addCommand({
      id: "test-print",
      name: "Show connected relays",
      callback: async () => {
        for (let r of this.nostrService.connectedRelays) {
          new import_obsidian9.Notice(`Connected to ${r.url}`);
        }
      }
    });
    this.addCommand({
      id: "get-pub",
      name: "See your public key",
      callback: async () => {
        let pubKey = this.nostrService.getPublicKey();
        new import_obsidian9.Notice(`Public Key: ${pubKey}`);
      }
    });
    this.addCommand({
      id: "re-connect",
      name: "Re-connect to relays",
      callback: async () => {
        this.nostrService.connectToRelays();
        new import_obsidian9.Notice(`Attempting re-connect, see status bar.`);
      }
    });
    this.addCommand({
      id: "get-pub-clipboard",
      name: "Copy public key to clipboard",
      callback: async () => {
        let pubKey = this.nostrService.getPublicKey();
        navigator.clipboard.writeText(pubKey).then(() => {
          new import_obsidian9.Notice(`Public Key copied to clipboard: ${pubKey}`);
        }).catch((err) => {
          new import_obsidian9.Notice(`Failed to copy Public Key: ${err}`);
        });
      }
    });
  }
  onunload() {
    this.nostrService.shutdownRelays();
    this.app.workspace.getLeavesOfType(PUBLISHED_VIEW).forEach((leaf) => leaf.detach());
    this.app.workspace.getLeavesOfType(READER_VIEW).forEach((leaf) => leaf.detach());
    this.app.workspace.getLeavesOfType(HIGHLIGHTS_VIEW).forEach((leaf) => leaf.detach());
  }
  startupNostrService() {
    this.nostrService = new NostrService(this, this.app, this.settings);
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      {
        privateKey: "",
        shortFormEnabled: false,
        statusBarEnabled: true,
        relayConfigEnabled: false,
        relayURLs: [
          "wss://nos.lol",
          "wss://relay.damus.io",
          "wss://relay.nostr.band",
          "wss://relayable.org",
          "wss://nostr.rocks",
          "wss://nostr.fmt.wiz.biz"
        ],
        imageStorageProviders: [
          "www.nostr.build",
          "www.another.build"
        ],
        selectedImageStorageProvider: "www.nostr.build",
        premiumStorageEnabled: false,
        multipleProfilesEnabled: false,
        profiles: []
      },
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  isEmptyContent(content) {
    return content.trim() === "";
  }
  async checkAndPublish() {
    if (!this.settings.privateKey) {
      new import_obsidian9.Notice(
        `\u{1F511} Please set your private key in the Nostr Writer Plugin settings before publishing.`
      );
      return;
    }
    const activeFile = this.app.workspace.getActiveFile();
    if (activeFile) {
      const fileContent = await this.app.vault.read(activeFile);
      if (this.isEmptyContent(fileContent)) {
        new import_obsidian9.Notice("\u274C The note is empty and cannot be published.");
        return;
      }
      if (this.nostrService.getConnectionStatus()) {
        new ConfirmPublishModal(
          this.app,
          this.nostrService,
          activeFile,
          this
        ).open();
      } else {
        new import_obsidian9.Notice(`\u2757\uFE0F Please connect to Nostr before publishing.`);
      }
    } else {
      new import_obsidian9.Notice("\u2757\uFE0F No note is currently active. Click into a note.");
    }
  }
  updateRibbonIcon() {
    if (this.settings.shortFormEnabled) {
      if (!this.ribbonIconElShortForm) {
        this.ribbonIconElShortForm = this.addRibbonIcon(
          "pencil",
          "Write to Nostr (short form)",
          (evt) => {
            if (!this.settings.privateKey) {
              new import_obsidian9.Notice(
                `\u{1F511} Please set your private key in the Nostr Writer Plugin settings before publishing.`
              );
              return;
            }
            if (this.nostrService.getConnectionStatus()) {
              new ShortFormModal(
                this.app,
                this.nostrService,
                this
              ).open();
              return;
            } else {
              new import_obsidian9.Notice(
                `\u2757\uFE0F Please connect to Nostr before publishing.`
              );
            }
          }
        );
      }
    } else if (this.ribbonIconElShortForm) {
      this.ribbonIconElShortForm.remove();
      this.ribbonIconElShortForm = null;
    }
  }
  updateStatusBar() {
    if (this.settings.statusBarEnabled) {
      if (!this.statusBar) {
        this.statusBar = this.addStatusBarItem();
        this.statusBar.addClass("mod-clickable");
        setAttributes(this.statusBar, {
          "aria-label": "Re-connect to Nostr",
          "aria-label-position": "top"
        });
        this.statusBar.addEventListener("click", () => {
          this.nostrService.connectToRelays();
          new import_obsidian9.Notice("\u26A1\uFE0F Re-connecting to Nostr..");
        });
      }
    } else if (this.statusBar) {
      this.statusBar.remove();
      this.statusBar = null;
    }
  }
};
function setAttributes(element, attributes) {
  for (let key in attributes) {
    element.setAttribute(key, attributes[key]);
  }
}
/*! Bundled license information:

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/base/lib/esm/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/ciphers/esm/utils.js:
  (*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyIsICJzcmMvU2hvcnRGb3JtTW9kYWwudHMiLCAic3JjL0NvbmZpcm1QdWJsaXNoTW9kYWwudHMiLCAic3JjL3NlcnZpY2UvTm9zdHJTZXJ2aWNlLnRzIiwgIm5vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9zcmMvX2Fzc2VydC50cyIsICJub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvc3JjL2NyeXB0by50cyIsICJub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvc3JjL3V0aWxzLnRzIiwgIm5vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9zcmMvX3NoYTIudHMiLCAibm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3NyYy9zaGEyNTYudHMiLCAibm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL3NyYy9hYnN0cmFjdC91dGlscy50cyIsICJub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvc3JjL2Fic3RyYWN0L21vZHVsYXIudHMiLCAibm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL3NyYy9hYnN0cmFjdC9jdXJ2ZS50cyIsICJub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvc3JjL2Fic3RyYWN0L3dlaWVyc3RyYXNzLnRzIiwgIm5vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9zcmMvaG1hYy50cyIsICJub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvc3JjL19zaG9ydHdfdXRpbHMudHMiLCAibm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL3NyYy9zZWNwMjU2azEudHMiLCAibm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvc3JjL2NyeXB0by50cyIsICJub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9zcmMvdXRpbHMudHMiLCAibm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvc3JjL19hc3NlcnQudHMiLCAibm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvc3JjL19zaGEyLnRzIiwgIm5vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3NyYy9zaGEyNTYudHMiLCAibm9kZV9tb2R1bGVzL0BzY3VyZS9iYXNlL2xpYi9lc20vaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0Bub2JsZS9jaXBoZXJzL3NyYy9fYXNzZXJ0LnRzIiwgIm5vZGVfbW9kdWxlcy9Abm9ibGUvY2lwaGVycy9zcmMvdXRpbHMudHMiLCAibm9kZV9tb2R1bGVzL0Bub2JsZS9jaXBoZXJzL3NyYy9fcG9seXZhbC50cyIsICJub2RlX21vZHVsZXMvQG5vYmxlL2NpcGhlcnMvc3JjL2Flcy50cyIsICJub2RlX21vZHVsZXMvQG5vYmxlL2NpcGhlcnMvc3JjL19wb2x5MTMwNS50cyIsICJub2RlX21vZHVsZXMvQG5vYmxlL2NpcGhlcnMvc3JjL19hcngudHMiLCAibm9kZV9tb2R1bGVzL0Bub2JsZS9jaXBoZXJzL3NyYy9jaGFjaGEudHMiLCAibm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvc3JjL2htYWMudHMiLCAibm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvc3JjL2hrZGYudHMiLCAibm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL2xpYi9lc20vaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL2xpYi9lc20vcG9vbC5qcyIsICJub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbGliL2VzbS9wdXJlLmpzIiwgIm5vZGVfbW9kdWxlcy9ub3N0ci10b29scy9saWIvZXNtL3JlbGF5LmpzIiwgIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvcm5nLmpzIiwgIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvc3RyaW5naWZ5LmpzIiwgIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvbmF0aXZlLmpzIiwgIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjQuanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2JpbmQuanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi91dGlscy5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvQXhpb3NFcnJvci5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvbnVsbC5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvdG9Gb3JtRGF0YS5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvQXhpb3NVUkxTZWFyY2hQYXJhbXMuanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2J1aWxkVVJMLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9JbnRlcmNlcHRvck1hbmFnZXIuanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9kZWZhdWx0cy90cmFuc2l0aW9uYWwuanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9wbGF0Zm9ybS9icm93c2VyL2NsYXNzZXMvVVJMU2VhcmNoUGFyYW1zLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvcGxhdGZvcm0vYnJvd3Nlci9jbGFzc2VzL0Zvcm1EYXRhLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvcGxhdGZvcm0vYnJvd3Nlci9jbGFzc2VzL0Jsb2IuanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9wbGF0Zm9ybS9icm93c2VyL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvcGxhdGZvcm0vY29tbW9uL3V0aWxzLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvcGxhdGZvcm0vaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3RvVVJMRW5jb2RlZEZvcm0uanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2Zvcm1EYXRhVG9KU09OLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvZGVmYXVsdHMvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3BhcnNlSGVhZGVycy5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvQXhpb3NIZWFkZXJzLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS90cmFuc2Zvcm1EYXRhLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL2lzQ2FuY2VsLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbGVkRXJyb3IuanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3NldHRsZS5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29va2llcy5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTC5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29tYmluZVVSTHMuanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2J1aWxkRnVsbFBhdGguanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbi5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvcGFyc2VQcm90b2NvbC5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvc3BlZWRvbWV0ZXIuanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9hZGFwdGVycy94aHIuanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9hZGFwdGVycy9hZGFwdGVycy5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZGlzcGF0Y2hSZXF1ZXN0LmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9tZXJnZUNvbmZpZy5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2Vudi9kYXRhLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy92YWxpZGF0b3IuanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0F4aW9zLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbFRva2VuLmpzIiwgIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9zcHJlYWQuanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQXhpb3NFcnJvci5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvSHR0cFN0YXR1c0NvZGUuanMiLCAibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9heGlvcy5qcyIsICJub2RlX21vZHVsZXMvYXhpb3MvaW5kZXguanMiLCAic3JjL3NlcnZpY2UvSW1hZ2VVcGxvYWRTZXJ2aWNlLnRzIiwgInNyYy9zZXR0aW5ncy50cyIsICJzcmMvUHVibGlzaGVkVmlldy50cyIsICJzcmMvUmVhZGVyVmlldy50cyIsICJub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbGliL2VzbS9yZWZlcmVuY2VzLmpzIiwgInNyYy9IaWdobGlnaHRzVmlldy50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgTm90aWNlLCBQbHVnaW4gfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCBTaG9ydEZvcm1Nb2RhbCBmcm9tIFwic3JjL1Nob3J0Rm9ybU1vZGFsXCI7XG5pbXBvcnQgQ29uZmlybVB1Ymxpc2hNb2RhbCBmcm9tIFwiLi9zcmMvQ29uZmlybVB1Ymxpc2hNb2RhbFwiO1xuaW1wb3J0IE5vc3RyU2VydmljZSBmcm9tIFwiLi9zcmMvc2VydmljZS9Ob3N0clNlcnZpY2VcIjtcbmltcG9ydCB7XG5cdE5vc3RyV3JpdGVyUGx1Z2luU2V0dGluZ3MsXG5cdE5vc3RyV3JpdGVyU2V0dGluZ1RhYixcbn0gZnJvbSBcIi4vc3JjL3NldHRpbmdzXCI7XG5pbXBvcnQgeyBQdWJsaXNoZWRWaWV3LCBQVUJMSVNIRURfVklFVyB9IGZyb20gXCIuL3NyYy9QdWJsaXNoZWRWaWV3XCI7XG5pbXBvcnQgeyBSZWFkZXJWaWV3LCBSRUFERVJfVklFVyB9IGZyb20gXCIuL3NyYy9SZWFkZXJWaWV3XCI7XG5pbXBvcnQgeyBIaWdobGlnaHRzVmlldyAsIEhJR0hMSUdIVFNfVklFVyB9IGZyb20gXCIuL3NyYy9IaWdobGlnaHRzVmlld1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOb3N0cldyaXRlclBsdWdpbiBleHRlbmRzIFBsdWdpbiB7XG5cdG5vc3RyU2VydmljZTogTm9zdHJTZXJ2aWNlO1xuXHRzZXR0aW5nczogTm9zdHJXcml0ZXJQbHVnaW5TZXR0aW5ncztcblx0cHJpdmF0ZSByaWJib25JY29uRWxTaG9ydEZvcm06IEhUTUxFbGVtZW50IHwgbnVsbDtcblx0c3RhdHVzQmFyOiBhbnk7XG5cblx0YXN5bmMgb25sb2FkKCkge1xuXHRcdGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XG5cdFx0dGhpcy51cGRhdGVTdGF0dXNCYXIoKTtcblx0XHR0aGlzLnN0YXJ0dXBOb3N0clNlcnZpY2UoKTtcblx0XHR0aGlzLmFkZFNldHRpbmdUYWIobmV3IE5vc3RyV3JpdGVyU2V0dGluZ1RhYih0aGlzLmFwcCwgdGhpcykpO1xuXHRcdHRoaXMudXBkYXRlUmliYm9uSWNvbigpO1xuXHRcdHRoaXMucmVnaXN0ZXJWaWV3KFxuXHRcdFx0UFVCTElTSEVEX1ZJRVcsXG5cdFx0XHQobGVhZikgPT4gbmV3IFB1Ymxpc2hlZFZpZXcobGVhZiwgdGhpcylcblx0XHQpO1xuXG5cdFx0dGhpcy5yZWdpc3RlclZpZXcoXG5cdFx0XHRSRUFERVJfVklFVyxcblx0XHRcdChsZWFmKSA9PiBuZXcgUmVhZGVyVmlldyhsZWFmLCB0aGlzLCB0aGlzLm5vc3RyU2VydmljZSlcblx0XHQpO1xuXG5cdFx0dGhpcy5yZWdpc3RlclZpZXcoXG5cdFx0XHRISUdITElHSFRTX1ZJRVcsXG5cdFx0XHQobGVhZikgPT4gbmV3IEhpZ2hsaWdodHNWaWV3KGxlYWYsIHRoaXMsIHRoaXMubm9zdHJTZXJ2aWNlKVxuXHRcdCk7XG5cblx0XHQvLyBpY29uIGNhbmRpZGF0ZXMgOiAnY2hlY2ttYXJrJywgJ2Jsb2NrcycsICdzY3JvbGwnLCAncGluJ1xuXHRcdHRoaXMuYWRkUmliYm9uSWNvbihcImJsb2Nrc1wiLCBcIlNlZSBub3RlcyBwdWJsaXNoZWQgdG8gTm9zdHJcIiwgKCkgPT4ge1xuXHRcdFx0dGhpcy50b2dnbGVQdWJsaXNoZWRWaWV3KCk7XG5cdFx0fSk7XG5cblx0XHQvLyBpY29uIGNhbmRpZGF0ZXM6ICdib29rbWFyaycsICdtYWduaWZ5aW5nLWdsYXNzJywgJ3N0YXItbGlzdCcsICdibG9ja3MnLCAnc2hlZXRzLWluLWJveCdcblx0XHR0aGlzLmFkZFJpYmJvbkljb24oXCJzdGFyLWxpc3RcIiwgXCJTZWUgeW91ciBOb3N0ciBCb29rbWFya3NcIiwgKCkgPT4ge1xuXHRcdFx0dGhpcy50b2dnbGVSZWFkZXJWaWV3KCk7XG5cdFx0fSk7XG5cblx0XHQvLyBpY29uIGNhbmRpZGF0ZXM6IFwibGluZXMtb2YtdGV4dFwiLCdxdW90ZS1nbHlwaCdcblx0XHR0aGlzLmFkZFJpYmJvbkljb24oXCJsaW5lcy1vZi10ZXh0XCIsIFwiU2VlIHlvdXIgTm9zdHIgSGlnaGxpZ2h0c1wiLCAoKSA9PiB7XG5cdFx0XHR0aGlzLnRvZ2dsZUhpZ2hsaWdodHNWaWV3KCk7XG5cdFx0fSk7XG5cblx0XHR0aGlzLmFkZFJpYmJvbkljb24oXG5cdFx0XHRcImZpbGUtdXBcIixcblx0XHRcdFwiUHVibGlzaCB0aGlzIG5vdGUgdG8gTm9zdHJcIixcblx0XHRcdGFzeW5jIChldnQ6IE1vdXNlRXZlbnQpID0+IHtcblx0XHRcdFx0YXdhaXQgdGhpcy5jaGVja0FuZFB1Ymxpc2goKTtcblx0XHRcdH1cblx0XHQpO1xuXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcInB1Ymxpc2gtbm90ZS10by1ub3N0clwiLFxuXHRcdFx0bmFtZTogXCJQdWJsaXNoXCIsXG5cdFx0XHRjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRhd2FpdCB0aGlzLmNoZWNrQW5kUHVibGlzaCgpO1xuXHRcdFx0fSxcblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJ0ZXN0LXByaW50XCIsXG5cdFx0XHRuYW1lOiBcIlNob3cgY29ubmVjdGVkIHJlbGF5c1wiLFxuXHRcdFx0Y2FsbGJhY2s6IGFzeW5jICgpID0+IHtcblx0XHRcdFx0Zm9yIChsZXQgciBvZiB0aGlzLm5vc3RyU2VydmljZS5jb25uZWN0ZWRSZWxheXMpIHtcblx0XHRcdFx0XHRuZXcgTm90aWNlKGBDb25uZWN0ZWQgdG8gJHtyLnVybH1gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJnZXQtcHViXCIsXG5cdFx0XHRuYW1lOiBcIlNlZSB5b3VyIHB1YmxpYyBrZXlcIixcblx0XHRcdGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG5cdFx0XHRcdGxldCBwdWJLZXkgPSB0aGlzLm5vc3RyU2VydmljZS5nZXRQdWJsaWNLZXkoKTtcblx0XHRcdFx0Ly8gVE9ETyBtYWtlIHRoaXMgYW4gbnB1YlxuXHRcdFx0XHRuZXcgTm90aWNlKGBQdWJsaWMgS2V5OiAke3B1YktleX1gKTtcblx0XHRcdH0sXG5cdFx0fSk7XG5cblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwicmUtY29ubmVjdFwiLFxuXHRcdFx0bmFtZTogXCJSZS1jb25uZWN0IHRvIHJlbGF5c1wiLFxuXHRcdFx0Y2FsbGJhY2s6IGFzeW5jICgpID0+IHtcblx0XHRcdFx0dGhpcy5ub3N0clNlcnZpY2UuY29ubmVjdFRvUmVsYXlzKCk7XG5cdFx0XHRcdG5ldyBOb3RpY2UoYEF0dGVtcHRpbmcgcmUtY29ubmVjdCwgc2VlIHN0YXR1cyBiYXIuYCk7XG5cdFx0XHR9LFxuXHRcdH0pO1xuXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcImdldC1wdWItY2xpcGJvYXJkXCIsXG5cdFx0XHRuYW1lOiBcIkNvcHkgcHVibGljIGtleSB0byBjbGlwYm9hcmRcIixcblx0XHRcdGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG5cdFx0XHRcdC8vIFRPRE8gbWFrZSB0aGlzIGFuIG5wdWJcblx0XHRcdFx0bGV0IHB1YktleSA9IHRoaXMubm9zdHJTZXJ2aWNlLmdldFB1YmxpY0tleSgpO1xuXHRcdFx0XHRuYXZpZ2F0b3IuY2xpcGJvYXJkXG5cdFx0XHRcdFx0LndyaXRlVGV4dChwdWJLZXkpXG5cdFx0XHRcdFx0LnRoZW4oKCkgPT4ge1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZShgUHVibGljIEtleSBjb3BpZWQgdG8gY2xpcGJvYXJkOiAke3B1YktleX1gKTtcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC5jYXRjaCgoZXJyKSA9PiB7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKGBGYWlsZWQgdG8gY29weSBQdWJsaWMgS2V5OiAke2Vycn1gKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cdFx0fSk7XG5cdH1cblxuXHR0b2dnbGVQdWJsaXNoZWRWaWV3ID0gYXN5bmMgKCk6IFByb21pc2U8dm9pZD4gPT4ge1xuXHRcdGNvbnN0IGV4aXN0aW5nID0gdGhpcy5hcHAud29ya3NwYWNlLmdldExlYXZlc09mVHlwZShQVUJMSVNIRURfVklFVyk7XG5cdFx0aWYgKGV4aXN0aW5nLmxlbmd0aCkge1xuXHRcdFx0dGhpcy5hcHAud29ya3NwYWNlLnJldmVhbExlYWYoZXhpc3RpbmdbMF0pO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGF3YWl0IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRSaWdodExlYWYoZmFsc2UpLnNldFZpZXdTdGF0ZSh7XG5cdFx0XHR0eXBlOiBQVUJMSVNIRURfVklFVyxcblx0XHRcdGFjdGl2ZTogdHJ1ZSxcblx0XHR9KTtcblxuXHRcdHRoaXMuYXBwLndvcmtzcGFjZS5yZXZlYWxMZWFmKFxuXHRcdFx0dGhpcy5hcHAud29ya3NwYWNlLmdldExlYXZlc09mVHlwZShQVUJMSVNIRURfVklFVylbMF1cblx0XHQpO1xuXHR9O1xuXG5cdHRvZ2dsZVJlYWRlclZpZXcgPSBhc3luYyAoKTogUHJvbWlzZTx2b2lkPiA9PiB7XG5cdFx0Y29uc3QgZXhpc3RpbmcgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0TGVhdmVzT2ZUeXBlKFJFQURFUl9WSUVXKTtcblx0XHRpZiAoZXhpc3RpbmcubGVuZ3RoKSB7XG5cdFx0XHR0aGlzLmFwcC53b3Jrc3BhY2UucmV2ZWFsTGVhZihleGlzdGluZ1swXSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0YXdhaXQgdGhpcy5hcHAud29ya3NwYWNlLmdldFJpZ2h0TGVhZihmYWxzZSkuc2V0Vmlld1N0YXRlKHtcblx0XHRcdHR5cGU6IFJFQURFUl9WSUVXLFxuXHRcdFx0YWN0aXZlOiB0cnVlLFxuXHRcdH0pO1xuXG5cdFx0dGhpcy5hcHAud29ya3NwYWNlLnJldmVhbExlYWYoXG5cdFx0XHR0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0TGVhdmVzT2ZUeXBlKFJFQURFUl9WSUVXKVswXVxuXHRcdCk7XG5cdH07XG5cblx0dG9nZ2xlSGlnaGxpZ2h0c1ZpZXcgPSBhc3luYyAoKTogUHJvbWlzZTx2b2lkPiA9PiB7XG5cdFx0Y29uc3QgZXhpc3RpbmcgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0TGVhdmVzT2ZUeXBlKEhJR0hMSUdIVFNfVklFVyk7XG5cdFx0aWYgKGV4aXN0aW5nLmxlbmd0aCkge1xuXHRcdFx0dGhpcy5hcHAud29ya3NwYWNlLnJldmVhbExlYWYoZXhpc3RpbmdbMF0pO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGF3YWl0IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRSaWdodExlYWYoZmFsc2UpLnNldFZpZXdTdGF0ZSh7XG5cdFx0XHR0eXBlOiBISUdITElHSFRTX1ZJRVcsXG5cdFx0XHRhY3RpdmU6IHRydWUsXG5cdFx0fSk7XG5cblx0XHR0aGlzLmFwcC53b3Jrc3BhY2UucmV2ZWFsTGVhZihcblx0XHRcdHRoaXMuYXBwLndvcmtzcGFjZS5nZXRMZWF2ZXNPZlR5cGUoSElHSExJR0hUU19WSUVXKVswXVxuXHRcdCk7XG5cdH07XG5cblxuXHRvbnVubG9hZCgpOiB2b2lkIHtcblx0XHR0aGlzLm5vc3RyU2VydmljZS5zaHV0ZG93blJlbGF5cygpO1xuXHRcdHRoaXMuYXBwLndvcmtzcGFjZVxuXHRcdFx0LmdldExlYXZlc09mVHlwZShQVUJMSVNIRURfVklFVylcblx0XHRcdC5mb3JFYWNoKChsZWFmKSA9PiBsZWFmLmRldGFjaCgpKTtcblx0XHR0aGlzLmFwcC53b3Jrc3BhY2Vcblx0XHRcdC5nZXRMZWF2ZXNPZlR5cGUoUkVBREVSX1ZJRVcpXG5cdFx0XHQuZm9yRWFjaCgobGVhZikgPT4gbGVhZi5kZXRhY2goKSk7XG5cdFx0dGhpcy5hcHAud29ya3NwYWNlXG5cdFx0XHQuZ2V0TGVhdmVzT2ZUeXBlKEhJR0hMSUdIVFNfVklFVylcblx0XHRcdC5mb3JFYWNoKChsZWFmKSA9PiBsZWFmLmRldGFjaCgpKTtcblx0fVxuXG5cdHN0YXJ0dXBOb3N0clNlcnZpY2UoKSB7XG5cdFx0dGhpcy5ub3N0clNlcnZpY2UgPSBuZXcgTm9zdHJTZXJ2aWNlKHRoaXMsIHRoaXMuYXBwLCB0aGlzLnNldHRpbmdzKTtcblx0fVxuXG5cdGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcblx0XHR0aGlzLnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbihcblx0XHRcdHt9LFxuXHRcdFx0e1xuXHRcdFx0XHRwcml2YXRlS2V5OiBcIlwiLFxuXHRcdFx0XHRzaG9ydEZvcm1FbmFibGVkOiBmYWxzZSxcblx0XHRcdFx0c3RhdHVzQmFyRW5hYmxlZDogdHJ1ZSxcblx0XHRcdFx0cmVsYXlDb25maWdFbmFibGVkOiBmYWxzZSxcblx0XHRcdFx0cmVsYXlVUkxzOiBbXG5cdFx0XHRcdFx0XCJ3c3M6Ly9ub3MubG9sXCIsXG5cdFx0XHRcdFx0XCJ3c3M6Ly9yZWxheS5kYW11cy5pb1wiLFxuXHRcdFx0XHRcdFwid3NzOi8vcmVsYXkubm9zdHIuYmFuZFwiLFxuXHRcdFx0XHRcdFwid3NzOi8vcmVsYXlhYmxlLm9yZ1wiLFxuXHRcdFx0XHRcdFwid3NzOi8vbm9zdHIucm9ja3NcIixcblx0XHRcdFx0XHRcIndzczovL25vc3RyLmZtdC53aXouYml6XCIsXG5cdFx0XHRcdF0sXG5cdFx0XHRcdGltYWdlU3RvcmFnZVByb3ZpZGVycyA6IFtcblx0XHRcdFx0XHRcInd3dy5ub3N0ci5idWlsZFwiLFxuXHRcdFx0XHRcdFwid3d3LmFub3RoZXIuYnVpbGRcIixcblx0XHRcdFx0XSxcblx0XHRcdFx0c2VsZWN0ZWRJbWFnZVN0b3JhZ2VQcm92aWRlcjogXCJ3d3cubm9zdHIuYnVpbGRcIixcblx0XHRcdFx0cHJlbWl1bVN0b3JhZ2VFbmFibGVkOiBmYWxzZSxcblx0XHRcdFx0bXVsdGlwbGVQcm9maWxlc0VuYWJsZWQ6IGZhbHNlLFxuXHRcdFx0XHRwcm9maWxlczogW10sXG5cdFx0XHR9LFxuXHRcdFx0YXdhaXQgdGhpcy5sb2FkRGF0YSgpXG5cdFx0KTtcblx0fVxuXG5cdGFzeW5jIHNhdmVTZXR0aW5ncygpIHtcblx0XHRhd2FpdCB0aGlzLnNhdmVEYXRhKHRoaXMuc2V0dGluZ3MpO1xuXHR9XG5cblx0aXNFbXB0eUNvbnRlbnQoY29udGVudDogc3RyaW5nKTogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIGNvbnRlbnQudHJpbSgpID09PSBcIlwiO1xuXHR9XG5cblx0YXN5bmMgY2hlY2tBbmRQdWJsaXNoKCkge1xuXHRcdGlmICghdGhpcy5zZXR0aW5ncy5wcml2YXRlS2V5KSB7XG5cdFx0XHRuZXcgTm90aWNlKFxuXHRcdFx0XHRgXHVEODNEXHVERDExIFBsZWFzZSBzZXQgeW91ciBwcml2YXRlIGtleSBpbiB0aGUgTm9zdHIgV3JpdGVyIFBsdWdpbiBzZXR0aW5ncyBiZWZvcmUgcHVibGlzaGluZy5gXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRjb25zdCBhY3RpdmVGaWxlID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKTtcblx0XHRpZiAoYWN0aXZlRmlsZSkge1xuXHRcdFx0Y29uc3QgZmlsZUNvbnRlbnQ6IHN0cmluZyA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQoYWN0aXZlRmlsZSk7XG5cdFx0XHRpZiAodGhpcy5pc0VtcHR5Q29udGVudChmaWxlQ29udGVudCkpIHtcblx0XHRcdFx0bmV3IE5vdGljZShcIlx1Mjc0QyBUaGUgbm90ZSBpcyBlbXB0eSBhbmQgY2Fubm90IGJlIHB1Ymxpc2hlZC5cIik7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLm5vc3RyU2VydmljZS5nZXRDb25uZWN0aW9uU3RhdHVzKCkpIHtcblx0XHRcdFx0bmV3IENvbmZpcm1QdWJsaXNoTW9kYWwoXG5cdFx0XHRcdFx0dGhpcy5hcHAsXG5cdFx0XHRcdFx0dGhpcy5ub3N0clNlcnZpY2UsXG5cdFx0XHRcdFx0YWN0aXZlRmlsZSxcblx0XHRcdFx0XHR0aGlzXG5cdFx0XHRcdCkub3BlbigpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bmV3IE5vdGljZShgXHUyNzU3XHVGRTBGIFBsZWFzZSBjb25uZWN0IHRvIE5vc3RyIGJlZm9yZSBwdWJsaXNoaW5nLmApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRuZXcgTm90aWNlKFwiXHUyNzU3XHVGRTBGIE5vIG5vdGUgaXMgY3VycmVudGx5IGFjdGl2ZS4gQ2xpY2sgaW50byBhIG5vdGUuXCIpO1xuXHRcdH1cblx0fVxuXG5cdHVwZGF0ZVJpYmJvbkljb24oKSB7XG5cdFx0aWYgKHRoaXMuc2V0dGluZ3Muc2hvcnRGb3JtRW5hYmxlZCkge1xuXHRcdFx0aWYgKCF0aGlzLnJpYmJvbkljb25FbFNob3J0Rm9ybSkge1xuXHRcdFx0XHR0aGlzLnJpYmJvbkljb25FbFNob3J0Rm9ybSA9IHRoaXMuYWRkUmliYm9uSWNvbihcblx0XHRcdFx0XHRcInBlbmNpbFwiLFxuXHRcdFx0XHRcdFwiV3JpdGUgdG8gTm9zdHIgKHNob3J0IGZvcm0pXCIsXG5cdFx0XHRcdFx0KGV2dDogTW91c2VFdmVudCkgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKCF0aGlzLnNldHRpbmdzLnByaXZhdGVLZXkpIHtcblx0XHRcdFx0XHRcdFx0bmV3IE5vdGljZShcblx0XHRcdFx0XHRcdFx0XHRgXHVEODNEXHVERDExIFBsZWFzZSBzZXQgeW91ciBwcml2YXRlIGtleSBpbiB0aGUgTm9zdHIgV3JpdGVyIFBsdWdpbiBzZXR0aW5ncyBiZWZvcmUgcHVibGlzaGluZy5gXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICh0aGlzLm5vc3RyU2VydmljZS5nZXRDb25uZWN0aW9uU3RhdHVzKCkpIHtcblx0XHRcdFx0XHRcdFx0bmV3IFNob3J0Rm9ybU1vZGFsKFxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuYXBwLFxuXHRcdFx0XHRcdFx0XHRcdHRoaXMubm9zdHJTZXJ2aWNlLFxuXHRcdFx0XHRcdFx0XHRcdHRoaXNcblx0XHRcdFx0XHRcdFx0KS5vcGVuKCk7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoXG5cdFx0XHRcdFx0XHRcdFx0YFx1Mjc1N1x1RkUwRiBQbGVhc2UgY29ubmVjdCB0byBOb3N0ciBiZWZvcmUgcHVibGlzaGluZy5gXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAodGhpcy5yaWJib25JY29uRWxTaG9ydEZvcm0pIHtcblx0XHRcdHRoaXMucmliYm9uSWNvbkVsU2hvcnRGb3JtLnJlbW92ZSgpO1xuXHRcdFx0dGhpcy5yaWJib25JY29uRWxTaG9ydEZvcm0gPSBudWxsO1xuXHRcdH1cblx0fVxuXG5cdHVwZGF0ZVN0YXR1c0JhcigpIHtcblx0XHRpZiAodGhpcy5zZXR0aW5ncy5zdGF0dXNCYXJFbmFibGVkKSB7XG5cdFx0XHRpZiAoIXRoaXMuc3RhdHVzQmFyKSB7XG5cdFx0XHRcdHRoaXMuc3RhdHVzQmFyID0gdGhpcy5hZGRTdGF0dXNCYXJJdGVtKCk7XG5cdFx0XHRcdHRoaXMuc3RhdHVzQmFyLmFkZENsYXNzKFwibW9kLWNsaWNrYWJsZVwiKTtcblx0XHRcdFx0c2V0QXR0cmlidXRlcyh0aGlzLnN0YXR1c0Jhciwge1xuXHRcdFx0XHRcdFwiYXJpYS1sYWJlbFwiOiBcIlJlLWNvbm5lY3QgdG8gTm9zdHJcIixcblx0XHRcdFx0XHRcImFyaWEtbGFiZWwtcG9zaXRpb25cIjogXCJ0b3BcIixcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHRoaXMuc3RhdHVzQmFyLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB7XG5cdFx0XHRcdFx0dGhpcy5ub3N0clNlcnZpY2UuY29ubmVjdFRvUmVsYXlzKCk7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShcIlx1MjZBMVx1RkUwRiBSZS1jb25uZWN0aW5nIHRvIE5vc3RyLi5cIik7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAodGhpcy5zdGF0dXNCYXIpIHtcblx0XHRcdHRoaXMuc3RhdHVzQmFyLnJlbW92ZSgpO1xuXHRcdFx0dGhpcy5zdGF0dXNCYXIgPSBudWxsO1xuXHRcdH1cblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0QXR0cmlidXRlcyhlbGVtZW50OiBhbnksIGF0dHJpYnV0ZXM6IGFueSkge1xuXHRmb3IgKGxldCBrZXkgaW4gYXR0cmlidXRlcykge1xuXHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgYXR0cmlidXRlc1trZXldKTtcblx0fVxufVxuIiwgImltcG9ydCB7XG5cdEFwcCxcblx0QnV0dG9uQ29tcG9uZW50LFxuXHRNb2RhbCxcblx0Tm90aWNlLFxuXHRUZXh0QXJlYUNvbXBvbmVudCxcblx0U2V0dGluZyxcbn0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgTm9zdHJTZXJ2aWNlIGZyb20gXCIuL3NlcnZpY2UvTm9zdHJTZXJ2aWNlXCI7XG5pbXBvcnQgTm9zdHJXcml0ZXJQbHVnaW4gZnJvbSBcIi4uL21haW5cIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2hvcnRGb3JtTW9kYWwgZXh0ZW5kcyBNb2RhbCB7XG5cdHBsdWdpbjogTm9zdHJXcml0ZXJQbHVnaW47XG5cblx0Y29uc3RydWN0b3IoXG5cdFx0YXBwOiBBcHAsXG5cdFx0cHJpdmF0ZSBub3N0clNlcnZpY2U6IE5vc3RyU2VydmljZSxcblx0XHRwbHVnaW46IE5vc3RyV3JpdGVyUGx1Z2luXG5cdCkge1xuXHRcdHN1cGVyKGFwcCk7XG5cdFx0dGhpcy5wbHVnaW4gPSBwbHVnaW47XG5cdH1cblxuXHRhc3luYyBvbk9wZW4oKSB7XG5cdFx0bGV0IHsgY29udGVudEVsIH0gPSB0aGlzO1xuXHRcdGNvbnRlbnRFbC5jcmVhdGVFbChcImgyXCIsIHsgdGV4dDogYFdyaXRlIEEgU2hvcnQgTm90ZWAgfSk7XG5cdFx0bGV0IHN1bW1hcnlUZXh0ID0gbmV3IFRleHRBcmVhQ29tcG9uZW50KGNvbnRlbnRFbClcblx0XHRcdC5zZXRQbGFjZWhvbGRlcihcIldyaXRlIGEgTm9zdHIgbWVzc2FnZSBoZXJlLi4uXCIpXG5cdFx0XHQuc2V0VmFsdWUoXCJcIik7XG5cblx0XHRzdW1tYXJ5VGV4dC5pbnB1dEVsLnNldENzc1N0eWxlcyh7XG5cdFx0XHR3aWR0aDogXCIxMDAlXCIsXG5cdFx0XHRoZWlnaHQ6IFwiMzAwcHhcIixcblx0XHRcdG1hcmdpbkJvdHRvbTogXCIxMHB4XCIsXG5cdFx0XHRtYXJnaW5Ub3A6IFwiMTBweFwiLFxuXHRcdFx0ZmxleDogXCJyb3dcIixcblx0XHR9KTtcblx0XHRcblx0XHRsZXQgc2VsZWN0ZWRQcm9maWxlS2V5ID0gXCJkZWZhdWx0XCI7XG5cdFx0aWYodGhpcy5wbHVnaW4uc2V0dGluZ3MucHJvZmlsZXMubGVuZ3RoID4gMCAmJiB0aGlzLnBsdWdpbi5zZXR0aW5ncy5tdWx0aXBsZVByb2ZpbGVzRW5hYmxlZCl7XG5cdFx0XHRuZXcgU2V0dGluZyhjb250ZW50RWwpXG5cdFx0XHQuc2V0TmFtZShcIlNlbGVjdCBQcm9maWxlXCIpXG5cdFx0XHQuc2V0RGVzYyhcIlNlbGVjdCBhIHByb2ZpbGUgdG8gc2VuZCB0aGlzIG5vdGUgZnJvbS5cIilcblx0XHRcdC5hZGREcm9wZG93bigoZHJvcGRvd24pID0+IHtcblx0XHRcdFx0ZHJvcGRvd24uYWRkT3B0aW9uKFwiZGVmYXVsdFwiLCBcIkRlZmF1bHRcIik7XG5cdFx0XHRcdGZvciAoY29uc3QgeyBwcm9maWxlTmlja25hbWUgfSBvZiB0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcm9maWxlcykge1xuXHRcdFx0XHRcdGRyb3Bkb3duLmFkZE9wdGlvbihwcm9maWxlTmlja25hbWUsIHByb2ZpbGVOaWNrbmFtZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZHJvcGRvd24uc2V0VmFsdWUoXCJkZWZhdWx0XCIpO1xuXHRcdFx0XHRkcm9wZG93bi5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHRzZWxlY3RlZFByb2ZpbGVLZXkgPSB2YWx1ZTtcblx0XHRcdFx0XHRuZXcgTm90aWNlKGAke3NlbGVjdGVkUHJvZmlsZUtleX0gc2VsZWN0ZWRgKTtcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhzZWxlY3RlZFByb2ZpbGVLZXkpXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdGNvbnRlbnRFbC5jcmVhdGVFbChcImhyXCIpO1xuXHRcdGNvbnRlbnRFbC5jcmVhdGVFbChcInBcIiwge1xuXHRcdFx0dGV4dDogYEFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBzZW5kIHRoaXMgbWVzc2FnZSB0byBOb3N0cj9gLFxuXHRcdH0pLmFkZENsYXNzKFwicHVibGlzaC1tb2RhbC1pbmZvXCIpO1xuXG5cdFx0bGV0IHB1Ymxpc2hCdXR0b24gPSBuZXcgQnV0dG9uQ29tcG9uZW50KGNvbnRlbnRFbClcblx0XHRcdHB1Ymxpc2hCdXR0b25cblx0XHRcdC5zZXRCdXR0b25UZXh0KHRoaXMucGx1Z2luLnNldHRpbmdzLm11bHRpcGxlUHJvZmlsZXNFbmFibGVkID8gYENvbmZpcm0gYW5kIFNlbmQgd2l0aCBTZWxlY3RlZCBQcm9maWxlYCA6IGBDb25maXJtIGFuZCBTZW5kYClcblx0XHRcdC5zZXRDdGEoKVxuXHRcdFx0Lm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHQvLyBEaXNhYmxlIHRoZSBidXR0b24gYW5kIGNoYW5nZSB0aGUgdGV4dCB0byBzaG93IGEgbG9hZGluZyBzdGF0ZVxuXHRcdFx0XHRpZiAoc3VtbWFyeVRleHQuZ2V0VmFsdWUoKS5sZW5ndGggPiAxICkge1xuXHRcdFx0XHRcdHB1Ymxpc2hCdXR0b24uc2V0QnV0dG9uVGV4dChcIlNlbmRpbmcuLi5cIikuc2V0RGlzYWJsZWQodHJ1ZSk7XG5cdFx0XHRcdFx0c2V0VGltZW91dChhc3luYyAoKSA9PiB7XG5cdFx0XHRcdFx0XHRjb25zdCBzdW1tYXJ5ID0gc3VtbWFyeVRleHQuZ2V0VmFsdWUoKTtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdGxldCByZXMgPVxuXHRcdFx0XHRcdFx0XHRcdGF3YWl0IHRoaXMubm9zdHJTZXJ2aWNlLnB1Ymxpc2hTaG9ydEZvcm1Ob3RlKFxuXHRcdFx0XHRcdFx0XHRcdFx0c3VtbWFyeSxcblx0XHRcdFx0XHRcdFx0XHRcdHNlbGVjdGVkUHJvZmlsZUtleVxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdGlmIChyZXMuc3VjY2Vzcykge1xuXHRcdFx0XHRcdFx0XHRcdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmV3IE5vdGljZShcblx0XHRcdFx0XHRcdFx0XHRcdFx0YFN1Y2Nlc3NmdWxseSBzZW50IG5vdGUgdG8gTm9zdHIuYFxuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9LCA1MDApO1xuXHRcdFx0XHRcdFx0XHRcdGZvciAobGV0IHJlbGF5IG9mIHJlcy5wdWJsaXNoZWRSZWxheXMpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRuZXcgTm90aWNlKGBcdTI3MDUgLSBTZW50IHRvICR7cmVsYXl9YCk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9LCA1MDApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRuZXcgTm90aWNlKGBcdTI3NEMgRmFpbGVkIHRvIHNlbmQgbm90ZSB0byBOb3N0ci5gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBjYXRjaCB7XG5cdFx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoYFx1Mjc0QyBGYWlsZWQgdG8gc2VuZCBub3RlIHRvIE5vc3RyLmApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0c3VtbWFyeVRleHQuc2V0VmFsdWUoXCJcIik7XG5cdFx0XHRcdFx0XHRwdWJsaXNoQnV0dG9uXG5cdFx0XHRcdFx0XHRcdC5zZXRCdXR0b25UZXh0KFwiQ29uZmlybSBhbmQgUHVibGlzaFwiKVxuXHRcdFx0XHRcdFx0XHQuc2V0RGlzYWJsZWQoZmFsc2UpO1xuXG5cdFx0XHRcdFx0XHR0aGlzLmNsb3NlKCk7XG5cdFx0XHRcdFx0fSwgMzAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShgUGxlYXNlIGVudGVyIHRleHQgdG8gcHVibGlzaCB0byBOb3N0cmApO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdGNvbnRlbnRFbC5jbGFzc0xpc3QuYWRkKFwic2hvcnQtZm9ybS1tb2RhbC1jb250ZW50XCIpO1xuXHRcdHB1Ymxpc2hCdXR0b24uYnV0dG9uRWwuY2xhc3NMaXN0LmFkZChcInNob3J0LWZvcm0tbW9kYWwtYnV0dG9uXCIpO1xuXHRcdHN1bW1hcnlUZXh0LmlucHV0RWwuY2xhc3NMaXN0LmFkZChcInNob3J0LWZvcm0tbW9kYWwtaW5wdXRcIik7XG5cdH1cbn1cbiIsICJpbXBvcnQge1xuXHRCdXR0b25Db21wb25lbnQsXG5cdE1vZGFsLFxuXHROb3RpY2UsXG5cdFRGaWxlLFxuXHRBcHAsXG5cdFNldHRpbmcsXG5cdFRleHRBcmVhQ29tcG9uZW50LFxuXHRUZXh0Q29tcG9uZW50LFxufSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCBOb3N0clNlcnZpY2UgZnJvbSBcIi4vc2VydmljZS9Ob3N0clNlcnZpY2VcIjtcbmltcG9ydCBOb3N0cldyaXRlclBsdWdpbiBmcm9tIFwiLi4vbWFpblwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb25maXJtUHVibGlzaE1vZGFsIGV4dGVuZHMgTW9kYWwge1xuXG5cdHBsdWdpbjogTm9zdHJXcml0ZXJQbHVnaW47XG5cblx0Y29uc3RydWN0b3IoXG5cdFx0YXBwOiBBcHAsXG5cdFx0cHJpdmF0ZSBub3N0clNlcnZpY2U6IE5vc3RyU2VydmljZSxcblx0XHRwcml2YXRlIGZpbGU6IFRGaWxlLFxuXHRcdHBsdWdpbjogTm9zdHJXcml0ZXJQbHVnaW5cblx0KSB7XG5cdFx0c3VwZXIoYXBwKTtcblx0XHR0aGlzLnBsdWdpbiA9IHBsdWdpbjtcblx0fVxuXG5cdGFzeW5jIG9uT3BlbigpIHtcblx0XHRsZXQgeyBjb250ZW50RWwgfSA9IHRoaXM7XG5cblx0XHRjb25zdCBmcm9udG1hdHRlciA9IHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKHRoaXMuZmlsZSk/LmZyb250bWF0dGVyO1xuXG5cdFx0Ly8gVE9ETyBjaGVjayBvdXQgUHJvZ3Jlc3MgQmFyIENvbXBvbmVudC4uLlxuXG5cdFx0aWYodGhpcy5maWxlLmV4dGVuc2lvbiAhPT0gXCJtZFwiKXtcblx0XHRcdG5ldyBOb3RpY2UoXCJcdTI3NEMgT25seSBtYXJrZG93biBmaWxlcyBjYW4gYmUgcHVibGlzaGVkLlwiKVxuXHRcdFx0dGhpcy5jbG9zZSgpXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29uc3QgZnJvbnRtYXR0ZXJSZWdleCA9IC8tLS1cXHMqW1xcc1xcU10qP1xccyotLS0vZztcblx0XHRjb25zdCBjb250ZW50ID0gKGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQodGhpcy5maWxlKSkucmVwbGFjZShmcm9udG1hdHRlclJlZ2V4LCBcIlwiKS50cmltKCk7XG5cblx0XHRjb25zdCBub3RlV29yZENvdW50ID0gY29udGVudC5zcGxpdChcIiBcIikubGVuZ3RoO1xuXG5cdFx0bGV0IG5vdGVDYXRlZ29yeVRhZ3M6IHN0cmluZ1tdID0gW107XG5cblx0XHRjb25zdCByZWdleCA9IC8jXFx3Ky9nO1xuXHRcdGNvbnN0IG1hdGNoZXMgPSBjb250ZW50Lm1hdGNoKHJlZ2V4KSB8fCBbXTtcblx0XHRjb25zdCBoYXNodGFncyA9IG1hdGNoZXMubWFwKChtYXRjaDogc3RyaW5nKSA9PiBtYXRjaC5zbGljZSgxKSk7XG5cblx0XHRjb25zdCBwcm9wZXJ0aWVzID0ge1xuXHRcdFx0dGl0bGU6IGZyb250bWF0dGVyPy50aXRsZSB8fCB0aGlzLmZpbGUuYmFzZW5hbWUsXG5cdFx0XHRzdW1tYXJ5OiBmcm9udG1hdHRlcj8uc3VtbWFyeSB8fCBcIlwiLFxuXHRcdFx0aW1hZ2U6IGlzVmFsaWRVUkwoZnJvbnRtYXR0ZXI/LmltYWdlKSA/IGZyb250bWF0dGVyPy5pbWFnZSA6IFwiXCIsXG5cdFx0XHR0YWdzOiBmcm9udG1hdHRlcj8udGFncyB8fCBoYXNodGFncyxcblx0XHR9XG5cblx0XHRmb3IgKGNvbnN0IHRhZyBvZiBwcm9wZXJ0aWVzLnRhZ3MpIHtcblx0XHRcdG5vdGVDYXRlZ29yeVRhZ3MucHVzaCh0YWcpO1xuXHRcdH1cblxuXHRcdGNvbnRlbnRFbC5jcmVhdGVFbChcImgyXCIsIHsgdGV4dDogYFB1Ymxpc2hgIH0pO1xuXHRcdGNvbnN0IHRpdGxlQ29udGFpbmVyID0gY29udGVudEVsLmNyZWF0ZUVsKFwiZGl2XCIpO1xuXHRcdHRpdGxlQ29udGFpbmVyLmFkZENsYXNzKFwicHVibGlzaC10aXRsZS1jb250YWluZXJcIik7XG5cblx0XHR0aXRsZUNvbnRhaW5lci5jcmVhdGVFbChcInBcIiwgeyB0ZXh0OiBgJHtub3RlV29yZENvdW50fSB3b3Jkc2AgfSk7XG5cblx0XHRjb250ZW50RWwuY3JlYXRlRWwoXCJoNlwiLCB7IHRleHQ6IGBUaXRsZWAgfSk7XG5cdFx0bGV0IHRpdGxlVGV4dCA9IG5ldyBUZXh0Q29tcG9uZW50KGNvbnRlbnRFbClcblx0XHRcdC5zZXRQbGFjZWhvbGRlcihgJHtwcm9wZXJ0aWVzLnRpdGxlfWApXG5cdFx0XHQuc2V0VmFsdWUoYCR7cHJvcGVydGllcy50aXRsZX1gKTtcblxuXHRcdGNvbnRlbnRFbC5jcmVhdGVFbChcImg2XCIsIHsgdGV4dDogYFRhZ3NgIH0pO1xuXHRcdGNvbnN0IHRhZ0NvbnRhaW5lciA9IGNvbnRlbnRFbC5jcmVhdGVFbChcImRpdlwiKTtcblx0XHR0YWdDb250YWluZXIuYWRkQ2xhc3MoXCJwdWJsaXNoLXRpdGxlLWNvbnRhaW5lclwiKTtcblxuXHRcdHRhZ0NvbnRhaW5lci5jcmVhdGVFbChcInBcIiwge1xuXHRcdFx0dGV4dDogYFRhZ3MgKCN0YWdzKSBmcm9tIHlvdXIgZmlsZSBhcmUgYXV0b21hdGljYWxseSBhZGRlZCBiZWxvdy4gQWRkIG1vcmUgdG8gaGVscCBwZW9wbGUgZGlzY292ZXIgeW91ciB3b3JrLiBSZW1vdmUgYW55IGJ5IGNsaWNraW5nIHRoZSBYLiBgLFxuXHRcdH0pO1xuXG5cdFx0bGV0IHRhZ3NUZXh0ID0gbmV3IFRleHRDb21wb25lbnQoY29udGVudEVsKS5zZXRQbGFjZWhvbGRlcihcblx0XHRcdGBBZGQgYSB0YWcgaGVyZSBhbmQgcHJlc3MgZW50ZXJgXG5cdFx0KTtcblxuXHRcdHRhZ3NUZXh0LmlucHV0RWwuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgKGV2ZW50KSA9PiB7XG5cdFx0XHRpZiAoZXZlbnQua2V5ID09PSBcIkVudGVyXCIpIHtcblx0XHRcdFx0YWRkVGFnQXNQaWxsKHRhZ3NUZXh0LmdldFZhbHVlKCkpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dGFnc1RleHQuaW5wdXRFbC5zZXRDc3NTdHlsZXMoe1xuXHRcdFx0d2lkdGg6IFwiMTAwJVwiLFxuXHRcdFx0bWFyZ2luQm90dG9tOiBcIjEwcHhcIixcblx0XHR9KTtcblxuXHRcdGNvbnN0IHBpbGxzQ29udGFpbmVyID0gY29udGVudEVsLmNyZWF0ZUVsKFwiZGl2XCIpO1xuXHRcdHBpbGxzQ29udGFpbmVyLmFkZENsYXNzKFwicGlsbHMtY29udGFpbmVyXCIpO1xuXHRcdG5vdGVDYXRlZ29yeVRhZ3MuZm9yRWFjaCgodGFnKSA9PiB7XG5cdFx0XHRjb25zdCBwaWxsRWxlbWVudCA9IGNyZWF0ZVBpbGxFbGVtZW50KHRhZyk7XG5cdFx0XHRwaWxsc0NvbnRhaW5lci5hcHBlbmRDaGlsZChwaWxsRWxlbWVudCk7XG5cdFx0fSk7XG5cblx0XHRjb250ZW50RWwuY3JlYXRlRWwoXCJoNlwiLCB7IHRleHQ6IGBTdW1tYXJ5YCB9KTtcblx0XHRsZXQgc3VtbWFyeVRleHQgPSBuZXcgVGV4dEFyZWFDb21wb25lbnQoY29udGVudEVsKVxuXHRcdFx0LnNldFBsYWNlaG9sZGVyKFwiT3B0aW9uYWwgYnJpZWYgc3VtbWFyeSBvZiB5b3VyIGFydGljbGUuLi5cIilcblx0XHRcdC5zZXRWYWx1ZShwcm9wZXJ0aWVzLnN1bW1hcnkpO1xuXG5cdFx0bGV0IHNlbGVjdGVkQmFubmVySW1hZ2U6IGFueSB8IG51bGwgPSBudWxsO1xuXG5cdFx0bmV3IFNldHRpbmcoY29udGVudEVsKVxuXHRcdFx0LnNldE5hbWUoXCJVcGxvYWQgQmFubmVyIEltYWdlXCIpXG5cdFx0XHQuc2V0RGVzYyhcIk9wdGlvbmFsIGltYWdlIHRvIGJlIHNob3duIGFsb25nc2lkZSB5b3VyIGFydGljbGVzIHRpdGxlLlwiKVxuXHRcdFx0LmFkZEJ1dHRvbigoYnV0dG9uKSA9PlxuXHRcdFx0XHRidXR0b25cblx0XHRcdFx0XHQuc2V0QnV0dG9uVGV4dChcIlVwbG9hZFwiKVxuXHRcdFx0XHRcdC5zZXRJY29uKFwidXBsb2FkXCIpXG5cdFx0XHRcdFx0LnNldFRvb2x0aXAoXCJVcGxvYWQgYW4gaW1hZ2UgZmlsZSBmb3IgeW91ciBhcnRpY2xlIGJhbm5lci5cIilcblx0XHRcdFx0XHQub25DbGljayhhc3luYyAoKSA9PiB7XG5cdFx0XHRcdFx0XHRjb25zdCBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG5cdFx0XHRcdFx0XHRpbnB1dC50eXBlID0gJ2ZpbGUnO1xuXHRcdFx0XHRcdFx0aW5wdXQubXVsdGlwbGUgPSBmYWxzZTtcblxuXHRcdFx0XHRcdFx0aW5wdXQuY2xpY2soKTtcblxuXHRcdFx0XHRcdFx0aW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRpZiAoaW5wdXQuZmlsZXMgIT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0XHRjb25zdCBmaWxlID0gaW5wdXQuZmlsZXNbMF07XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGZpbGUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICghZmlsZS50eXBlLnN0YXJ0c1dpdGgoJ2ltYWdlLycpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoJ1x1Mjc0QyBJbnZhbGlkIGZpbGUgdHlwZS4gUGxlYXNlIHVwbG9hZCBhbiBpbWFnZS4nKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRsZXQgbWF4U2l6ZUluQnl0ZXMgPSAxMCAqIDEwMjQgKiAxMDI0OyAvLyAxMCBNQlxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKHRoaXMucGx1Z2luLnNldHRpbmdzLnByZW1pdW1TdG9yYWdlRW5hYmxlZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRtYXhTaXplSW5CeXRlcyA9IDEwMCAqIDEwMjQgKiAxMDI0O1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKGZpbGUuc2l6ZSA+IG1heFNpemVJbkJ5dGVzKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoJ1x1Mjc0QyBGaWxlIHNpemUgZXhjZWVkcyB0aGUgbGltaXQuIFBsZWFzZSB1cGxvYWQgYSBzbWFsbGVyIGltYWdlLicpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRzZWxlY3RlZEJhbm5lckltYWdlID0gZmlsZTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0aW1hZ2VQcmV2aWV3LnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwoc2VsZWN0ZWRCYW5uZXJJbWFnZSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRpbWFnZVByZXZpZXcuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcblx0XHRcdFx0XHRcdFx0XHRcdGNsZWFySW1hZ2VCdXR0b24uc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG5cblxuXHRcdFx0XHRcdFx0XHRcdFx0aW1hZ2VOYW1lRGl2LnRleHRDb250ZW50ID0gc2VsZWN0ZWRCYW5uZXJJbWFnZS5uYW1lO1xuXHRcdFx0XHRcdFx0XHRcdFx0bmV3IE5vdGljZShgXHUyNzA1IFNlbGVjdGVkIGltYWdlIDogJHtmaWxlLm5hbWV9YCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoYFx1Mjc1N1x1RkUwRiBObyBmaWxlIHNlbGVjdGVkLmApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdH0pXG5cdFx0XHQpO1xuXG5cdFx0bGV0IGltYWdlUHJldmlldyA9IGNvbnRlbnRFbC5jcmVhdGVFbChcImltZ1wiKTtcblx0XHRpbWFnZVByZXZpZXcuc2V0Q3NzU3R5bGVzKHtcblx0XHRcdG1heFdpZHRoOiBcIjEwMCVcIixcblx0XHRcdGRpc3BsYXk6IFwibm9uZVwiLFxuXHRcdH0pO1xuXG5cdFx0Y29uc3QgaW1hZ2VOYW1lRGl2ID0gY29udGVudEVsLmNyZWF0ZUVsKFwiZGl2XCIpO1xuXHRcdGltYWdlTmFtZURpdi5zZXRDc3NTdHlsZXMoe1xuXHRcdFx0ZGlzcGxheTogXCJub25lXCIsXG5cdFx0fSk7XG5cblx0XHRjb25zdCBjbGVhckltYWdlQnV0dG9uID0gY29udGVudEVsLmNyZWF0ZUVsKFwiZGl2XCIpO1xuXHRcdGNsZWFySW1hZ2VCdXR0b24uc2V0Q3NzU3R5bGVzKHtcblx0XHRcdGRpc3BsYXk6IFwibm9uZVwiLFxuXHRcdFx0YmFja2dyb3VuZDogXCJub25lXCIsXG5cdFx0XHRib3JkZXI6IFwibm9uZVwiLFxuXHRcdFx0Y3Vyc29yOiBcInBvaW50ZXJcIixcblx0XHRcdGZvbnRTaXplOiBcIjE0cHhcIixcblx0XHRcdGNvbG9yOiBcInJlZFwiLFxuXHRcdH0pO1xuXG5cdFx0Y2xlYXJJbWFnZUJ1dHRvbi50ZXh0Q29udGVudCA9IFwiXHUyNzRDIFJlbW92ZSBpbWFnZS5cIjtcblxuXHRcdGZ1bmN0aW9uIGNsZWFyU2VsZWN0ZWRJbWFnZSgpIHtcblx0XHRcdHNlbGVjdGVkQmFubmVySW1hZ2UgPSBudWxsO1xuXHRcdFx0aW1hZ2VQcmV2aWV3LnNyYyA9IFwiXCI7XG5cdFx0XHRpbWFnZVByZXZpZXcuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuXHRcdFx0aW1hZ2VOYW1lRGl2LnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdGltYWdlTmFtZURpdi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG5cdFx0XHRjbGVhckltYWdlQnV0dG9uLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcblx0XHR9XG5cblx0XHRjbGVhckltYWdlQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBjbGVhclNlbGVjdGVkSW1hZ2UpO1xuXG5cblx0XHR0aXRsZVRleHQuaW5wdXRFbC5zZXRDc3NTdHlsZXMoe1xuXHRcdFx0d2lkdGg6IFwiMTAwJVwiLFxuXHRcdFx0bWFyZ2luQm90dG9tOiBcIjEwcHhcIixcblx0XHR9KTtcblxuXHRcdHN1bW1hcnlUZXh0LmlucHV0RWwuc2V0Q3NzU3R5bGVzKHtcblx0XHRcdHdpZHRoOiBcIjEwMCVcIixcblx0XHRcdGhlaWdodDogXCI3NXB4XCIsXG5cdFx0XHRtYXJnaW5Cb3R0b206IFwiMTBweFwiLFxuXHRcdH0pO1xuXG5cdFx0dGFnc1RleHQuaW5wdXRFbC5zZXRDc3NTdHlsZXMoe1xuXHRcdFx0d2lkdGg6IFwiMTAwJVwiLFxuXHRcdH0pO1xuXG5cdFx0dGFnc1RleHQuaW5wdXRFbC5hZGRDbGFzcyhcImZlYXR1cmVzXCIpO1xuXG5cdFx0bGV0IHNlbGVjdGVkUHJvZmlsZUtleSA9IFwiZGVmYXVsdFwiO1xuXHRcdGlmICh0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcm9maWxlcy5sZW5ndGggPiAwICYmIHRoaXMucGx1Z2luLnNldHRpbmdzLm11bHRpcGxlUHJvZmlsZXNFbmFibGVkKSB7XG5cdFx0XHRsZXQgeCA9IG5ldyBTZXR0aW5nKGNvbnRlbnRFbClcblx0XHRcdFx0LnNldE5hbWUoXCJTZWxlY3QgUHJvZmlsZVwiKVxuXHRcdFx0XHQuc2V0RGVzYyhcIlNlbGVjdCBhIHByb2ZpbGUgdG8gc2VuZCB0aGlzIG5vdGUgZnJvbS5cIilcblx0XHRcdFx0LmFkZERyb3Bkb3duKChkcm9wZG93bikgPT4ge1xuXHRcdFx0XHRcdGRyb3Bkb3duLmFkZE9wdGlvbihcImRlZmF1bHRcIiwgXCJEZWZhdWx0XCIpO1xuXHRcdFx0XHRcdGZvciAoY29uc3QgeyBwcm9maWxlTmlja25hbWUgfSBvZiB0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcm9maWxlcykge1xuXHRcdFx0XHRcdFx0ZHJvcGRvd24uYWRkT3B0aW9uKHByb2ZpbGVOaWNrbmFtZSwgcHJvZmlsZU5pY2tuYW1lKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZHJvcGRvd24uc2V0VmFsdWUoXCJkZWZhdWx0XCIpO1xuXHRcdFx0XHRcdGRyb3Bkb3duLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdFx0c2VsZWN0ZWRQcm9maWxlS2V5ID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKGAke3NlbGVjdGVkUHJvZmlsZUtleX0gc2VsZWN0ZWRgKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0bGV0IHB1Ymxpc2hBc0RyYWZ0ID0gZmFsc2U7XG5cdFx0bmV3IFNldHRpbmcoY29udGVudEVsKVxuXHRcdFx0LnNldE5hbWUoXCJQdWJsaXNoIGFzIGEgZHJhZnRcIilcblx0XHRcdC5zZXREZXNjKFwiTm9zdHIgY2xpZW50cyBhbGxvdyB5b3UgdG8gZWRpdCB5b3VyIGRyYWZ0cyBsYXRlci5cIilcblx0XHRcdC5hZGRUb2dnbGUoKHRvZ2dsZSkgPT5cblx0XHRcdFx0dG9nZ2xlLnNldFZhbHVlKGZhbHNlKS5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHRwdWJsaXNoQXNEcmFmdCA9IHZhbHVlO1xuXHRcdFx0XHRcdGlmIChwdWJsaXNoQXNEcmFmdCkge1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZShgXHVEODNEXHVEREQyXHVGRTBGIFB1Ymxpc2hpbmcgYXMgYSBkcmFmdC5gKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZShgXHVEODNEXHVEQ0RDIFB1Ymxpc2hpbmcgYXMgZmluYWwuYCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KVxuXHRcdFx0KTtcblxuXHRcdGNvbnRlbnRFbC5jcmVhdGVFbChcImhyXCIpO1xuXG5cdFx0bGV0IGluZm8gPSBjb250ZW50RWwuY3JlYXRlRWwoXCJwXCIsIHtcblx0XHRcdHRleHQ6IGBBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gcHVibGlzaCB0aGlzIG5vdGUgdG8gTm9zdHI/YCxcblx0XHR9KTtcblx0XHRpbmZvLmFkZENsYXNzKFwicHVibGlzaC1tb2RhbC1pbmZvXCIpO1xuXG5cdFx0bGV0IHB1Ymxpc2hCdXR0b24gPSBuZXcgQnV0dG9uQ29tcG9uZW50KGNvbnRlbnRFbClcblx0XHRcdC5zZXRCdXR0b25UZXh0KFwiQ29uZmlybSBhbmQgUHVibGlzaFwiKVxuXHRcdFx0LnNldEN0YSgpXG5cdFx0XHQub25DbGljayhhc3luYyAoKSA9PiB7XG5cdFx0XHRcdGlmIChjb25maXJtKGBBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gcHVibGlzaCB0aGlzIG5vdGUgJHtwdWJsaXNoQXNEcmFmdCA/IFwiYXMgYSBkcmFmdFwiIDogXCJwdWJsaWNhbGx5XCJ9IHRvIE5vc3RyP2ApKSB7XG5cdFx0XHRcdFx0Ly8gRGlzYWJsZSB0aGUgYnV0dG9uIGFuZCBjaGFuZ2UgdGhlIHRleHQgdG8gc2hvdyBhIGxvYWRpbmcgc3RhdGVcblx0XHRcdFx0XHRwdWJsaXNoQnV0dG9uLnNldEJ1dHRvblRleHQoXCJQdWJsaXNoaW5nLi4uXCIpLnNldERpc2FibGVkKHRydWUpO1xuXHRcdFx0XHRcdHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgZmlsZUNvbnRlbnQgPSBjb250ZW50O1xuXHRcdFx0XHRcdFx0XHRjb25zdCB0aXRsZSA9IHRpdGxlVGV4dC5nZXRWYWx1ZSgpO1xuXHRcdFx0XHRcdFx0XHRjb25zdCBzdW1tYXJ5ID0gc3VtbWFyeVRleHQuZ2V0VmFsdWUoKTtcblx0XHRcdFx0XHRcdFx0bGV0IHJlcyA9IGF3YWl0IHRoaXMubm9zdHJTZXJ2aWNlLnB1Ymxpc2hOb3RlKFxuXHRcdFx0XHRcdFx0XHRcdGZpbGVDb250ZW50LFxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuZmlsZSxcblx0XHRcdFx0XHRcdFx0XHRzdW1tYXJ5LFxuXHRcdFx0XHRcdFx0XHRcdHNlbGVjdGVkQmFubmVySW1hZ2UgJiYgc2VsZWN0ZWRCYW5uZXJJbWFnZS5wYXRoID8gc2VsZWN0ZWRCYW5uZXJJbWFnZS5wYXRoIDogbnVsbCxcblx0XHRcdFx0XHRcdFx0XHR0aXRsZSxcblx0XHRcdFx0XHRcdFx0XHRub3RlQ2F0ZWdvcnlUYWdzLFxuXHRcdFx0XHRcdFx0XHRcdHNlbGVjdGVkUHJvZmlsZUtleSxcblx0XHRcdFx0XHRcdFx0XHRwdWJsaXNoQXNEcmFmdFxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRpZiAocmVzLnN1Y2Nlc3MpIHtcblx0XHRcdFx0XHRcdFx0XHRzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoYFx1MjcwNSBTdWNjZXNzZnVsbHkgc2VudCBub3RlIHRvIE5vc3RyLmApO1xuXHRcdFx0XHRcdFx0XHRcdH0sIDUwMCk7XG5cdFx0XHRcdFx0XHRcdFx0Zm9yIChsZXQgcmVsYXkgb2YgcmVzLnB1Ymxpc2hlZFJlbGF5cykge1xuXHRcdFx0XHRcdFx0XHRcdFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoYFx1MjcwNSAtIFNlbnQgdG8gJHtyZWxheX1gKTtcblx0XHRcdFx0XHRcdFx0XHRcdH0sIDUwMCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoYFx1Mjc0QyBGYWlsZWQgdG8gc2VuZCBub3RlIHRvIE5vc3RyLmApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKGVycm9yKTtcblx0XHRcdFx0XHRcdFx0bmV3IE5vdGljZShgXHUyNzRDIEZhaWxlZCB0byBwdWJsaXNoIG5vdGUgdG8gTm9zdHIuYCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRwdWJsaXNoQnV0dG9uXG5cdFx0XHRcdFx0XHRcdC5zZXRCdXR0b25UZXh0KFwiQ29uZmlybSBhbmQgUHVibGlzaFwiKVxuXHRcdFx0XHRcdFx0XHQuc2V0RGlzYWJsZWQoZmFsc2UpO1xuXHRcdFx0XHRcdFx0dGhpcy5jbG9zZSgpO1xuXHRcdFx0XHRcdH0sIDMwMDApO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdGNvbnRlbnRFbC5jbGFzc0xpc3QuYWRkKFwicHVibGlzaC1tb2RhbC1jb250ZW50XCIpO1xuXHRcdHB1Ymxpc2hCdXR0b24uYnV0dG9uRWwuY2xhc3NMaXN0LmFkZChcInB1Ymxpc2gtbW9kYWwtYnV0dG9uXCIpO1xuXHRcdHN1bW1hcnlUZXh0LmlucHV0RWwuY2xhc3NMaXN0LmFkZChcInB1Ymxpc2gtbW9kYWwtaW5wdXRcIik7XG5cblx0XHRmdW5jdGlvbiBjcmVhdGVQaWxsRWxlbWVudCh0YWc6IHN0cmluZykge1xuXHRcdFx0Y29uc3QgcGlsbEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHRcdFx0cGlsbEVsZW1lbnQuY2xhc3NOYW1lID0gXCJwaWxsXCI7XG5cdFx0XHRwaWxsRWxlbWVudC50ZXh0Q29udGVudCA9IHRhZztcblxuXHRcdFx0Y29uc3QgZGVsZXRlQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblx0XHRcdGRlbGV0ZUJ1dHRvbi5jbGFzc05hbWUgPSBcImRlbGV0ZS1idXR0b25cIjtcblx0XHRcdGRlbGV0ZUJ1dHRvbi50ZXh0Q29udGVudCA9IFwieFwiO1xuXG5cdFx0XHRkZWxldGVCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHtcblx0XHRcdFx0bm90ZUNhdGVnb3J5VGFncyA9IG5vdGVDYXRlZ29yeVRhZ3MuZmlsdGVyKCh0KSA9PiB0ICE9PSB0YWcpO1xuXHRcdFx0XHRwaWxsRWxlbWVudC5yZW1vdmUoKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRwaWxsRWxlbWVudC5hcHBlbmRDaGlsZChkZWxldGVCdXR0b24pO1xuXHRcdFx0cmV0dXJuIHBpbGxFbGVtZW50O1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGFkZFRhZ0FzUGlsbCh0YWc6IHN0cmluZykge1xuXHRcdFx0aWYgKHRhZy50cmltKCkgPT09IFwiXCIpIHJldHVybjtcblx0XHRcdG5vdGVDYXRlZ29yeVRhZ3MucHVzaCh0YWcudHJpbSgpKTtcblx0XHRcdGNvbnN0IHBpbGxFbGVtZW50ID0gY3JlYXRlUGlsbEVsZW1lbnQodGFnLnRyaW0oKSk7XG5cdFx0XHRwaWxsc0NvbnRhaW5lci5hcHBlbmRDaGlsZChwaWxsRWxlbWVudCk7XG5cdFx0XHR0YWdzVGV4dC5zZXRWYWx1ZShcIlwiKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gaXNWYWxpZFVSTCh1cmw6IHN0cmluZykge1xuXHR0cnkge1xuXHRcdG5ldyBVUkwodXJsKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoXykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuIiwgImltcG9ydCBOb3N0cldyaXRlclBsdWdpbiBmcm9tIFwibWFpblwiO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IG5pcDE5IH0gZnJvbSBcIm5vc3RyLXRvb2xzXCI7XG5pbXBvcnQgeyBTaW1wbGVQb29sIH0gZnJvbSAnbm9zdHItdG9vbHMvcG9vbCc7XG5pbXBvcnQgeyBFdmVudCB9IGZyb20gXCJub3N0ci10b29scy9jb3JlXCJcbmltcG9ydCB7IGZpbmFsaXplRXZlbnQsIGdldFB1YmxpY0tleSB9IGZyb20gXCJub3N0ci10b29scy9wdXJlXCI7XG5pbXBvcnQgeyBSZWxheSB9IGZyb20gXCJub3N0ci10b29scy9yZWxheVwiO1xuaW1wb3J0IHsgQXBwLCBOb3RpY2UsIFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgeyBOb3N0cldyaXRlclBsdWdpblNldHRpbmdzIH0gZnJvbSBcInNyYy9zZXR0aW5nc1wiO1xuaW1wb3J0IHsgdjQgYXMgdXVpZHY0IH0gZnJvbSBcInV1aWRcIjtcbmltcG9ydCBJbWFnZVVwbG9hZFNlcnZpY2UgZnJvbSBcIi4vSW1hZ2VVcGxvYWRTZXJ2aWNlXCI7XG5cbmludGVyZmFjZSBQcm9maWxlIHtcblx0cHJvZmlsZU5pY2tuYW1lOiBzdHJpbmc7XG5cdHByb2ZpbGVQcml2YXRlS2V5OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vc3RyU2VydmljZSB7XG5cdHByaXZhdGUgcHJpdmF0ZUtleTogc3RyaW5nO1xuXHRwcml2YXRlIHByb2ZpbGVzOiBQcm9maWxlW107XG5cdHByaXZhdGUgbXVsdGlwbGVQcm9maWxlc0VuYWJsZWQ6IGJvb2xlYW47XG5cdHByaXZhdGUgcHVibGljS2V5OiBzdHJpbmc7XG5cdHByaXZhdGUgcGx1Z2luOiBOb3N0cldyaXRlclBsdWdpbjtcblx0cHJpdmF0ZSBhcHA6IEFwcDtcblx0cHJpdmF0ZSBpc0Nvbm5lY3RlZDogYm9vbGVhbjtcblx0cHJpdmF0ZSByZWxheVVSTHM6IHN0cmluZ1tdO1xuXHRjb25uZWN0ZWRSZWxheXM6IFJlbGF5W107XG5cdHByaXZhdGUgcG9vbDogU2ltcGxlUG9vbDtcblx0cHJpdmF0ZSBwb29sVXJsczogc3RyaW5nW107XG5cdHByaXZhdGUgaW1hZ2VVcGxvYWRTZXJ2aWNlOiBJbWFnZVVwbG9hZFNlcnZpY2U7XG5cblxuXHRjb25zdHJ1Y3Rvcihcblx0XHRwbHVnaW46IE5vc3RyV3JpdGVyUGx1Z2luLFxuXHRcdGFwcDogQXBwLFxuXHRcdHNldHRpbmdzOiBOb3N0cldyaXRlclBsdWdpblNldHRpbmdzXG5cdCkge1xuXHRcdGlmICghc2V0dGluZ3MucHJpdmF0ZUtleSkge1xuXHRcdFx0Y29uc29sZS5lcnJvcihcblx0XHRcdFx0XCJZb3VyUGx1Z2luIHJlcXVpcmVzIGEgcHJpdmF0ZSBrZXkgdG8gYmUgc2V0IGluIHRoZSBzZXR0aW5ncy5cIlxuXHRcdFx0KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoc2V0dGluZ3MubXVsdGlwbGVQcm9maWxlc0VuYWJsZWQpIHtcblx0XHRcdGNvbnNvbGUubG9nKFwibXVsdGlwbGUgcHJvZmlsZXMgZW5hYmxlZFwiKVxuXHRcdFx0dGhpcy5wcm9maWxlcyA9IHNldHRpbmdzLnByb2ZpbGVzO1xuXHRcdFx0dGhpcy5tdWx0aXBsZVByb2ZpbGVzRW5hYmxlZCA9IHRydWU7XG5cdFx0fVxuXHRcdHRoaXMucGx1Z2luID0gcGx1Z2luO1xuXHRcdHRoaXMuYXBwID0gYXBwO1xuXHRcdHRoaXMuaW1hZ2VVcGxvYWRTZXJ2aWNlID0gbmV3IEltYWdlVXBsb2FkU2VydmljZSh0aGlzLnBsdWdpbiwgdGhpcy5hcHAsIHNldHRpbmdzKTtcblx0XHR0aGlzLnByaXZhdGVLZXkgPSB0aGlzLmNvbnZlcnRLZXlUb0hleChzZXR0aW5ncy5wcml2YXRlS2V5KTtcblx0XHR0aGlzLnB1YmxpY0tleSA9IGdldFB1YmxpY0tleSh0aGlzLnByaXZhdGVLZXkpO1xuXHRcdHRoaXMucmVsYXlVUkxzID0gW107XG5cdFx0aWYgKCFzZXR0aW5ncy5yZWxheVVSTHMpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoXG5cdFx0XHRcdFwiWW91clBsdWdpbiByZXF1aXJlcyBhIGxpc3Qgb2YgcmVsYXkgdXJscyB0byBiZSBzZXQgaW4gdGhlIHNldHRpbmdzLCBkZWZhdWx0aW5nLlwiXG5cdFx0XHQpO1xuXHRcdFx0dGhpcy5yZWxheVVSTHMgPSBbXG5cdFx0XHRcdFwid3NzOi8vbm9zLmxvbCBcIixcblx0XHRcdFx0XCJ3c3M6Ly9yZWxheS5kYW11cy5pb1wiLFxuXHRcdFx0XHRcIndzczovL3JlbGF5Lm5vc3RyLmJhbmRcIixcblx0XHRcdFx0XCJ3c3M6Ly9yZWxheWFibGUub3JnXCIsXG5cdFx0XHRcdFwid3NzOi8vbm9zdHIucm9ja3NcIixcblx0XHRcdFx0XCJ3c3M6Ly9ub3N0ci5mbXQud2l6LmJpelwiLFxuXHRcdFx0XTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yIChsZXQgdXJsIG9mIHNldHRpbmdzLnJlbGF5VVJMcykge1xuXHRcdFx0XHRpZiAodGhpcy5pc1ZhbGlkVVJMKHVybCkpIHtcblx0XHRcdFx0XHR0aGlzLnJlbGF5VVJMcy5wdXNoKHVybCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5jb25uZWN0VG9SZWxheXMoKTtcblx0fVxuXG5cdHJlbG9hZE11bHRpcGxlQWNjb3VudHMoKSB7XG5cdFx0Y29uc29sZS5sb2coXCJyZWxvYWRpbmcgbXVsdGlwbGUgYWNjb3VudHMuLi5cIilcblx0XHR0aGlzLnByb2ZpbGVzID0gdGhpcy5wbHVnaW4uc2V0dGluZ3MucHJvZmlsZXM7XG5cdFx0dGhpcy5tdWx0aXBsZVByb2ZpbGVzRW5hYmxlZCA9IHRydWU7XG5cdH1cblxuXG5cdGFzeW5jIGNvbm5lY3RUb1JlbGF5cygpIHtcblx0XHR0aGlzLnJlZnJlc2hSZWxheVVybHMoKTtcblx0XHR0aGlzLmNvbm5lY3RlZFJlbGF5cyA9IFtdO1xuXG5cdFx0bGV0IGNvbm5lY3Rpb25Qcm9taXNlcyA9IHRoaXMucmVsYXlVUkxzLm1hcCgodXJsKSA9PiB7XG5cdFx0XHRyZXR1cm4gbmV3IFByb21pc2U8UmVsYXkgfCBudWxsPihhc3luYyAocmVzb2x2ZSkgPT4ge1xuXHRcdFx0XHRjb25zb2xlLmxvZyhgSW5pdGlhbGl6aW5nIE5vc3RyU2VydmljZSB3aXRoIHJlbGF5OiAke3VybH1gKTtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRjb25zdCByZWxheUF0dGVtcHQgPSBhd2FpdCBSZWxheS5jb25uZWN0KHVybCk7XG5cblx0XHRcdFx0XHRyZWxheUF0dGVtcHQub25jbG9zZSA9ICgpID0+IHtcblx0XHRcdFx0XHRcdGhhbmRsZUZhaWx1cmUoKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjb25zdCBoYW5kbGVGYWlsdXJlID0gKCkgPT4ge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coYERpc2Nvbm5lY3RlZCBmcm9tICR7dXJsfSwgdXBkYXRpbmcgc3RhdHVzIGJhci5gKTtcblx0XHRcdFx0XHRcdHRoaXMuY29ubmVjdGVkUmVsYXlzLnJlbW92ZShyZWxheUF0dGVtcHQpO1xuXHRcdFx0XHRcdFx0dGhpcy51cGRhdGVTdGF0dXNCYXIoKTtcblx0XHRcdFx0XHRcdHJlc29sdmUobnVsbCk7XG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKGBDb25uZWN0ZWQgdG8gJHtyZWxheUF0dGVtcHQudXJsfWApO1xuXHRcdFx0XHRcdHRoaXMuY29ubmVjdGVkUmVsYXlzLnB1c2gocmVsYXlBdHRlbXB0KTtcblx0XHRcdFx0XHRyZXNvbHZlKHJlbGF5QXR0ZW1wdCk7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGNvbm5lY3QgdG8gJHt1cmx9OiAke2Vycm9yfWApO1xuXHRcdFx0XHRcdHJlc29sdmUobnVsbCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0pO1xuXG5cdFx0UHJvbWlzZS5hbGwoY29ubmVjdGlvblByb21pc2VzKS50aGVuKCgpID0+IHtcblx0XHRcdGNvbnNvbGUubG9nKFxuXHRcdFx0XHRgQ29ubmVjdGVkIHRvICR7dGhpcy5jb25uZWN0ZWRSZWxheXMubGVuZ3RofSAvICR7dGhpcy5yZWxheVVSTHMubGVuZ3RofSByZWxheXNgXG5cdFx0XHQpO1xuXHRcdFx0dGhpcy51cGRhdGVTdGF0dXNCYXIoKTtcblx0XHRcdGlmICh0aGlzLmNvbm5lY3RlZFJlbGF5cy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdHRoaXMuc2V0Q29ubmVjdGlvblBvb2woKTtcblx0XHRcdFx0dGhpcy5pc0Nvbm5lY3RlZCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHRzZXRDb25uZWN0aW9uUG9vbCA9ICgpID0+IHtcblx0XHR0aGlzLnBvb2wgPSBuZXcgU2ltcGxlUG9vbCgpXG5cdFx0dGhpcy5wb29sVXJscyA9IFtdO1xuXHRcdGZvciAoY29uc3QgcmVsYXkgb2YgdGhpcy5jb25uZWN0ZWRSZWxheXMpIHtcblx0XHRcdHRoaXMucG9vbFVybHMucHVzaChyZWxheS51cmwpO1xuXHRcdH1cblx0fVxuXG5cdHVwZGF0ZVN0YXR1c0JhciA9ICgpID0+IHtcblx0XHRpZiAodGhpcy5jb25uZWN0ZWRSZWxheXMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHR0aGlzLnBsdWdpbi5zdGF0dXNCYXI/LnNldFRleHQoXCJOb3N0ciBcdUQ4M0NcdURGMUFcIik7XG5cdFx0XHR0aGlzLmlzQ29ubmVjdGVkID0gZmFsc2U7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucGx1Z2luLnN0YXR1c0Jhcj8uc2V0VGV4dChcblx0XHRcdFx0YE5vc3RyIFx1RDgzRFx1REZFMyAke3RoaXMuY29ubmVjdGVkUmVsYXlzLmxlbmd0aH0gLyAke3RoaXMucmVsYXlVUkxzLmxlbmd0aH0gcmVsYXlzLmBcblx0XHRcdCk7XG5cdFx0fVxuXHR9O1xuXG5cdHJlZnJlc2hSZWxheVVybHMoKSB7XG5cdFx0dGhpcy5yZWxheVVSTHMgPSBbXTtcblx0XHRpZiAoIXRoaXMucGx1Z2luLnNldHRpbmdzLnJlbGF5VVJMcyB8fCB0aGlzLnBsdWdpbi5zZXR0aW5ncy5yZWxheVVSTHMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKFxuXHRcdFx0XHRcIllvdXJQbHVnaW4gcmVxdWlyZXMgYSBsaXN0IG9mIHJlbGF5IHVybHMgdG8gYmUgc2V0IGluIHRoZSBzZXR0aW5ncywgZGVmYXVsdGluZyB0byBEYW11cy5cIlxuXHRcdFx0KTtcblx0XHRcdHRoaXMucmVsYXlVUkxzID0gW1xuXHRcdFx0XHRcIndzczovL25vcy5sb2wgXCIsXG5cdFx0XHRcdFwid3NzOi8vcmVsYXkuZGFtdXMuaW9cIixcblx0XHRcdFx0XCJ3c3M6Ly9yZWxheS5ub3N0ci5iYW5kXCIsXG5cdFx0XHRcdFwid3NzOi8vcmVsYXlhYmxlLm9yZ1wiLFxuXHRcdFx0XHRcIndzczovL25vc3RyLmZtdC53aXouYml6XCIsXG5cdFx0XHRdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKGxldCB1cmwgb2YgdGhpcy5wbHVnaW4uc2V0dGluZ3MucmVsYXlVUkxzKSB7XG5cdFx0XHRcdGlmICh0aGlzLmlzVmFsaWRVUkwodXJsKSkge1xuXHRcdFx0XHRcdHRoaXMucmVsYXlVUkxzLnB1c2godXJsKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGdldFJlbGF5SW5mbyhyZWxheVVybDogc3RyaW5nKTogYm9vbGVhbiB7XG5cdFx0bGV0IGNvbm5lY3RlZDogYm9vbGVhbiA9IGZhbHNlO1xuXHRcdGZvciAobGV0IHIgb2YgdGhpcy5jb25uZWN0ZWRSZWxheXMpIHtcblx0XHRcdGlmIChyLnVybCA9PSByZWxheVVybCArIFwiL1wiKSB7XG5cdFx0XHRcdHJldHVybiByLmNvbm5lY3RlZDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNvbm5lY3RlZDtcblx0fVxuXG5cdHB1YmxpYyBnZXRDb25uZWN0aW9uU3RhdHVzKCk6IGJvb2xlYW4ge1xuXHRcdHJldHVybiB0aGlzLmlzQ29ubmVjdGVkO1xuXHR9XG5cblx0cHVibGljIGdldFB1YmxpY0tleSgpOiBzdHJpbmcge1xuXHRcdHJldHVybiB0aGlzLnB1YmxpY0tleTtcblx0fVxuXG5cdGFzeW5jIHB1Ymxpc2hTaG9ydEZvcm1Ob3RlKG1lc3NhZ2U6IHN0cmluZywgcHJvZmlsZU5pY2tuYW1lOiBzdHJpbmcpOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbjsgcHVibGlzaGVkUmVsYXlzOiBzdHJpbmdbXSB9PiB7XG5cdFx0Y29uc29sZS5sb2coYFNlbmRpbmcgYSBzaG9ydCBmb3JtIG5vdGUgdG8gTm9zdHIuLi5gKTtcblx0XHRsZXQgcHJvZmlsZVByaXZhdGVLZXkgPSB0aGlzLnByaXZhdGVLZXk7XG5cdFx0bGV0IHByb2ZpbGVQdWJsaWNLZXkgPSB0aGlzLnB1YmxpY0tleTtcblx0XHRpZiAocHJvZmlsZU5pY2tuYW1lICE9PSBcImRlZmF1bHRcIiAmJiB0aGlzLm11bHRpcGxlUHJvZmlsZXNFbmFibGVkKSB7XG5cdFx0XHRjb25zb2xlLmxvZyhcInJlY2lldmVkIG5vbi1kZWZhdWx0IHByb2ZpbGU6IFwiICsgcHJvZmlsZU5pY2tuYW1lKTtcblx0XHRcdGZvciAoY29uc3QgeyBwcm9maWxlTmlja25hbWU6IG5pY2tuYW1lLCBwcm9maWxlUHJpdmF0ZUtleToga2V5IH0gb2YgdGhpcy5wcm9maWxlcykge1xuXHRcdFx0XHRpZiAocHJvZmlsZU5pY2tuYW1lID09PSBuaWNrbmFtZSkge1xuXHRcdFx0XHRcdHByb2ZpbGVQcml2YXRlS2V5ID0gdGhpcy5jb252ZXJ0S2V5VG9IZXgoa2V5KTtcblx0XHRcdFx0XHRwcm9maWxlUHVibGljS2V5ID0gZ2V0UHVibGljS2V5KHByb2ZpbGVQcml2YXRlS2V5KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAobWVzc2FnZSkge1xuXHRcdFx0bGV0IHV1aWQ6IGFueSA9IHV1aWR2NCgpLnN1YnN0cigwLCA4KTtcblx0XHRcdGxldCB0YWdzOiBhbnkgPSBbW1wiZFwiLCB1dWlkXV07XG5cblx0XHRcdGxldCBldmVudFRlbXBsYXRlID0ge1xuXHRcdFx0XHRraW5kOiAxLFxuXHRcdFx0XHRjcmVhdGVkX2F0OiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSxcblx0XHRcdFx0dGFnczogdGFncyxcblx0XHRcdFx0Y29udGVudDogbWVzc2FnZSxcblx0XHRcdH07XG5cblx0XHRcdC8vIHRoaXMgYXNzaWducyB0aGUgcHVia2V5LCBjYWxjdWxhdGVzIHRoZSBldmVudCBpZCBhbmQgc2lnbnMgdGhlIGV2ZW50IGluIGEgc2luZ2xlIHN0ZXBcblx0XHRcdGNvbnN0IHNpZ25lZEV2ZW50ID0gZmluYWxpemVFdmVudChldmVudFRlbXBsYXRlLCBCdWZmZXIuZnJvbShwcm9maWxlUHJpdmF0ZUtleSkpXG5cdFx0XHRyZXR1cm4gdGhpcy5wdWJsaXNoVG9SZWxheXMoc2lnbmVkRXZlbnQsIFwiXCIsIFwiXCIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKFwiTm8gbWVzc2FnZSB0byBwdWJsaXNoXCIpO1xuXHRcdFx0cmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIHB1Ymxpc2hlZFJlbGF5czogW10gfTtcblx0XHR9XG5cdH1cblxuXHRhc3luYyBwdWJsaXNoTm90ZShcblx0XHRmaWxlQ29udGVudDogc3RyaW5nLFxuXHRcdGFjdGl2ZUZpbGU6IFRGaWxlLFxuXHRcdHN1bW1hcnk6IHN0cmluZyxcblx0XHRpbWFnZUJhbm5lckZpbGVQYXRoOiBzdHJpbmcgfCBudWxsLFxuXHRcdHRpdGxlOiBzdHJpbmcsXG5cdFx0dXNlclNlbGVjdGVkVGFnczogc3RyaW5nW10sXG5cdFx0cHJvZmlsZU5pY2tuYW1lOiBzdHJpbmcsXG5cdFx0cHVibGlzaEFzRHJhZnQ6IGJvb2xlYW5cblx0KTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW47IHB1Ymxpc2hlZFJlbGF5czogc3RyaW5nW10gfT4ge1xuXHRcdGlmICghcHVibGlzaEFzRHJhZnQpIHtcblx0XHRcdG5ldyBOb3RpY2UoYFx1MjNGMyBQdWJsaXNoaW5nIHlvdXIgbm90ZSAke2FjdGl2ZUZpbGUubmFtZX0gdG8gbm9zdHIuLi5gKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRuZXcgTm90aWNlKGBcdTIzRjMgUHVibGlzaGluZyB5b3VyIG5vdGUgJHthY3RpdmVGaWxlLm5hbWV9IGFzIGEgZHJhZnQgdG8gbm9zdHIuLi5gKVxuXHRcdH1cblxuXHRcdGxldCBwcm9maWxlUHJpdmF0ZUtleSA9IHRoaXMucHJpdmF0ZUtleTtcblx0XHRsZXQgcHJvZmlsZVB1YmxpY0tleSA9IHRoaXMucHVibGljS2V5O1xuXHRcdGlmIChwcm9maWxlTmlja25hbWUgIT09IFwiZGVmYXVsdFwiICYmIHRoaXMubXVsdGlwbGVQcm9maWxlc0VuYWJsZWQpIHtcblx0XHRcdGNvbnNvbGUubG9nKFwicmVjaWV2ZWQgbm9uLWRlZmF1bHQgcHJvZmlsZTogXCIgKyBwcm9maWxlTmlja25hbWUpO1xuXHRcdFx0Zm9yIChjb25zdCB7IHByb2ZpbGVOaWNrbmFtZTogbmlja25hbWUsIHByb2ZpbGVQcml2YXRlS2V5OiBrZXkgfSBvZiB0aGlzLnByb2ZpbGVzKSB7XG5cdFx0XHRcdGlmIChwcm9maWxlTmlja25hbWUgPT09IG5pY2tuYW1lKSB7XG5cdFx0XHRcdFx0cHJvZmlsZVByaXZhdGVLZXkgPSB0aGlzLmNvbnZlcnRLZXlUb0hleChrZXkpO1xuXHRcdFx0XHRcdHByb2ZpbGVQdWJsaWNLZXkgPSBnZXRQdWJsaWNLZXkoQnVmZmVyLmZyb20ocHJvZmlsZVByaXZhdGVLZXkpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoZmlsZUNvbnRlbnQpIHtcblx0XHRcdGxldCB1dWlkOiBhbnkgPSB1dWlkdjQoKS5zdWJzdHIoMCwgOCk7XG5cdFx0XHRsZXQgdGFnczogYW55ID0gW1tcImRcIiwgdXVpZF1dO1xuXG5cdFx0XHRpZiAoc3VtbWFyeSkge1xuXHRcdFx0XHR0YWdzLnB1c2goW1wic3VtbWFyeVwiLCBzdW1tYXJ5XSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChpbWFnZUJhbm5lckZpbGVQYXRoICE9PSBudWxsKSB7XG5cdFx0XHRcdG5ldyBOb3RpY2UoXCJcdUQ4M0RcdUREQkNcdUZFMEYgVXBsb2FkaW5nIEJhbm5lciBJbWFnZVwiKVxuXHRcdFx0XHRsZXQgaW1hZ2VVcGxvYWRSZXN1bHQgPSBhd2FpdCB0aGlzLmltYWdlVXBsb2FkU2VydmljZS51cGxvYWRBcnRpY2xlQmFubmVySW1hZ2UoaW1hZ2VCYW5uZXJGaWxlUGF0aCk7XG5cdFx0XHRcdGlmIChpbWFnZVVwbG9hZFJlc3VsdCAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdHRhZ3MucHVzaChbXCJpbWFnZVwiLCBpbWFnZVVwbG9hZFJlc3VsdF0pO1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoXCJcdTI3MDUgVXBsb2FkZWQgQmFubmVyIEltYWdlXCIpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShcIlx1Mjc0QyBQcm9ibGVtIFVwbG9hZGluZyBCYW5uZXIgSW1hZ2UuLlwiKVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zb2xlLmluZm8oXCJObyBiYW5uZXIgaW1hZ2UuLi5cIilcblx0XHRcdH1cblxuXHRcdFx0bGV0IHRpbWVzdGFtcCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xuXHRcdFx0dGFncy5wdXNoKFtcInB1Ymxpc2hlZF9hdFwiLCB0aW1lc3RhbXAudG9TdHJpbmcoKV0pO1xuXG5cdFx0XHRpZiAodXNlclNlbGVjdGVkVGFncy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdGZvciAoY29uc3QgdGFnIG9mIHVzZXJTZWxlY3RlZFRhZ3MpIHtcblx0XHRcdFx0XHR0YWdzLnB1c2goW1widFwiLCB0YWddKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGl0bGUpIHtcblx0XHRcdFx0dGFncy5wdXNoKFtcInRpdGxlXCIsIHRpdGxlXSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zdCBub3RlVGl0bGUgPSBhY3RpdmVGaWxlLmJhc2VuYW1lO1xuXHRcdFx0XHR0YWdzLnB1c2goW1widGl0bGVcIiwgbm90ZVRpdGxlXSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhhbmRsZSBpbmxpbmUgaW1hZ2VzLCB1cGxvYWQgaWYgcG9zc2libGUsIGFuZCByZXBsYWNlIHRoZWlyIHN0cmluZ3Mgd2l0aCB1cmxzIGluIHRoZSAubWQgY29udGVudFxuXHRcdFx0Y29uc3QgaW1hZ2VQYXRoczogc3RyaW5nW10gPSBbXTtcblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0bGV0IHZhdWx0UmVzb2x2ZWRMaW5rcyA9IHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUucmVzb2x2ZWRMaW5rcztcblx0XHRcdFx0aWYgKHZhdWx0UmVzb2x2ZWRMaW5rc1thY3RpdmVGaWxlLnBhdGhdKSB7XG5cdFx0XHRcdFx0Y29uc3QgZmlsZUNvbnRlbnRzID0gdmF1bHRSZXNvbHZlZExpbmtzW2FjdGl2ZUZpbGUucGF0aF07XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBmaWxlUGF0aCBvZiBPYmplY3Qua2V5cyhmaWxlQ29udGVudHMpKSB7XG5cdFx0XHRcdFx0XHRpZiAodGhpcy5pc0ltYWdlUGF0aChmaWxlUGF0aCkpIHtcblx0XHRcdFx0XHRcdFx0aW1hZ2VQYXRocy5wdXNoKGZpbGVQYXRoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGltYWdlUGF0aHMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoXCJcdTI3MDUgRm91bmQgaW5saW5lIGltYWdlcyAtIHVwbG9hZGluZyB3aXRoIGFydGljbGUuXCIpXG5cdFx0XHRcdFx0bGV0IGltYWdlVXBsb2FkUmVzdWx0ID0gYXdhaXQgdGhpcy5pbWFnZVVwbG9hZFNlcnZpY2UudXBsb2FkSW1hZ2VzVG9TdG9yYWdlUHJvdmlkZXIoaW1hZ2VQYXRocylcblx0XHRcdFx0XHRpZiAoaW1hZ2VVcGxvYWRSZXN1bHQuc3VjY2VzcyAmJiBpbWFnZVVwbG9hZFJlc3VsdC5yZXN1bHRzICYmIGltYWdlVXBsb2FkUmVzdWx0LnJlc3VsdHMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdFx0Zm9yIChjb25zdCBpbWFnZVRhcmdldCBvZiBpbWFnZVVwbG9hZFJlc3VsdC5yZXN1bHRzKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChpbWFnZVRhcmdldC5yZXBsYWNlbWVudFN0cmluZ1VSTCAhPT0gbnVsbCAmJiBpbWFnZVRhcmdldC51cGxvYWRNZXRhZGF0YSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRcdGZpbGVDb250ZW50ID0gZmlsZUNvbnRlbnQucmVwbGFjZShpbWFnZVRhcmdldC5zdHJpbmdUb1JlcGxhY2UsIGltYWdlVGFyZ2V0LnJlcGxhY2VtZW50U3RyaW5nVVJMKTtcblx0XHRcdFx0XHRcdFx0XHRsZXQgaW1ldGFUYWcgPSB0aGlzLmdldEltZXRhVGFnRm9ySW1hZ2UoaW1hZ2VUYXJnZXQudXBsb2FkTWV0YWRhdGEpO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChpbWV0YVRhZyAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGFncy5wdXNoKGltZXRhVGFnKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvcihcIlByb2JsZW0gd2l0aCB0aGUgaW1hZ2UgdXBsb2FkLCBzb21lIG9yIGFsbCBpbWFnZXMgbWF5IG5vdCBoYXZlIHN1Y2Nlc3NmdWxseSB1cGxvYWRlZC4uLlwiKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKFwiTm8gaW1hZ2VzIGZvdW5kIGluIHZhdWx0IGZvciB0aGlzIGZpbGUuLlwiKVxuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoXCJCaWdnZXIgUHJvYmxlbSB3aXRoIHRoZSBpbWFnZSB1cGxvYWQsIHNvbWUgb3IgYWxsIGltYWdlcyBtYXkgbm90IGhhdmUgc3VjY2Vzc2Z1bGx5IHVwbG9hZGVkLi4uXCIsIGUpXG5cdFx0XHRcdG5ldyBOb3RpY2UoXCJcdTI3NEMgUHJvYmxlbSB1cGxvYWRpbmcgaW5saW5lIGltYWdlcy5cIilcblx0XHRcdH1cblxuXHRcdFx0bGV0IGV2ZW50VGVtcGxhdGUgPSB7XG5cdFx0XHRcdGtpbmQ6IHB1Ymxpc2hBc0RyYWZ0ID8gMzAwMjQgOiAzMDAyMyxcblx0XHRcdFx0Y3JlYXRlZF9hdDogdGltZXN0YW1wLFxuXHRcdFx0XHR0YWdzOiB0YWdzLFxuXHRcdFx0XHRjb250ZW50OiBmaWxlQ29udGVudCxcblx0XHRcdH07XG5cblx0XHRcdGNvbnN0IGZpbmFsRXZlbnQgPSBmaW5hbGl6ZUV2ZW50KGV2ZW50VGVtcGxhdGUsIEJ1ZmZlci5mcm9tKHByb2ZpbGVQcml2YXRlS2V5KSlcblxuXHRcdFx0cmV0dXJuIHRoaXMucHVibGlzaFRvUmVsYXlzKFxuXHRcdFx0XHRmaW5hbEV2ZW50LFxuXHRcdFx0XHRhY3RpdmVGaWxlLnBhdGgsXG5cdFx0XHRcdHByb2ZpbGVOaWNrbmFtZVxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc29sZS5lcnJvcihcIk5vIG1lc3NhZ2UgdG8gcHVibGlzaFwiKTtcblx0XHRcdHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBwdWJsaXNoZWRSZWxheXM6IFtdIH07XG5cdFx0fVxuXHR9XG5cblx0Z2V0SW1ldGFUYWdGb3JJbWFnZSh1cGxvYWREYXRhOiBhbnkpOiBzdHJpbmdbXSB8IG51bGwge1xuXHRcdGxldCBpbmxpbmVUYWc6IHN0cmluZ1tdID0gW107XG5cdFx0bGV0IHVybCA9IHVwbG9hZERhdGEudXJsID8gdXBsb2FkRGF0YS51cmwgOiBudWxsO1xuXHRcdGxldCBtaW1lVHlwZSA9IHVwbG9hZERhdGEubWltZSA/IHVwbG9hZERhdGEubWltZSA6IG51bGw7XG5cdFx0bGV0IG94ID0gdXBsb2FkRGF0YS5vcmlnaW5hbF9zaGEyNTYgPyB1cGxvYWREYXRhLm9yaWdpbmFsX3NoYTI1NiA6IG51bGw7XG5cdFx0bGV0IHNpemUgPSB1cGxvYWREYXRhLnNpemUgPyB1cGxvYWREYXRhLnNpemUgOiBudWxsO1xuXHRcdGxldCBkaW0gPSB1cGxvYWREYXRhLmRpbWVuc2lvbnNTdHJpbmcgPyB1cGxvYWREYXRhLmRpbWVuc2lvbnNTdHJpbmcgOiBudWxsO1xuXHRcdGxldCBibHVyaGFzaCA9IHVwbG9hZERhdGEuYmx1cmhhc2ggPyB1cGxvYWREYXRhLmJsdXJoYXNoIDogbnVsbDtcblx0XHRsZXQgdGh1bWJuYWlsID0gdXBsb2FkRGF0YS50aHVtYm5haWwgPyB1cGxvYWREYXRhLnRodW1ibmFpbCA6IG51bGw7XG5cblx0XHRpZiAodXJsICE9PSBudWxsKSB7XG5cdFx0XHRpbmxpbmVUYWcucHVzaChcImltZXRhXCIpXG5cdFx0XHRsZXQgdXJsU3RyaW5nID0gYHVybCAke3VybH1gXG5cdFx0XHRpbmxpbmVUYWcucHVzaCh1cmxTdHJpbmcpXG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoXCJObyB1cGxvYWQgVVJMIGluIG1ldGFkYXRhLCBzbyBub3QgYWRkaW5nIGltZXRhIHRhZ1wiKVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0aWYgKG1pbWVUeXBlICE9PSBudWxsKSB7XG5cdFx0XHRsZXQgbWltZVN0cmluZyA9IGBtICR7bWltZVR5cGV9YFxuXHRcdFx0aW5saW5lVGFnLnB1c2gobWltZVN0cmluZylcblx0XHR9XG5cdFx0aWYgKG94ICE9PSBudWxsKSB7XG5cdFx0XHRsZXQgb3hTdHJpbmcgPSBgb3ggJHtveH1gXG5cdFx0XHRpbmxpbmVUYWcucHVzaChveFN0cmluZylcblx0XHR9XG5cdFx0aWYgKHNpemUgIT09IG51bGwpIHtcblx0XHRcdGxldCBzaXplU3RyaW5nID0gYHNpemUgJHtzaXplfWBcblx0XHRcdGlubGluZVRhZy5wdXNoKHNpemVTdHJpbmcpXG5cdFx0fVxuXHRcdGlmIChkaW0gIT09IG51bGwpIHtcblx0XHRcdGxldCBkaW1TdHJpbmcgPSBgZGltICR7ZGltfWBcblx0XHRcdGlubGluZVRhZy5wdXNoKGRpbVN0cmluZylcblx0XHR9XG5cdFx0aWYgKGJsdXJoYXNoICE9PSBudWxsKSB7XG5cdFx0XHRsZXQgYmx1cmhhc2hTdHJpbmcgPSBgYmx1cmhhc2ggJHtibHVyaGFzaH1gXG5cdFx0XHRpbmxpbmVUYWcucHVzaChibHVyaGFzaFN0cmluZylcblx0XHR9XG5cblx0XHRpZiAodGh1bWJuYWlsICE9PSBudWxsKSB7XG5cdFx0XHRsZXQgdGh1bWJuYWlsU3RyaW5nID0gYHRodW1iICR7dGh1bWJuYWlsfWBcblx0XHRcdGlubGluZVRhZy5wdXNoKHRodW1ibmFpbFN0cmluZylcblx0XHR9XG5cblx0XHRyZXR1cm4gaW5saW5lVGFnO1xuXHR9XG5cblx0aXNJbWFnZVBhdGgoZmlsZVBhdGg6IHN0cmluZyk6IGJvb2xlYW4ge1xuXHRcdGNvbnN0IGltYWdlRXh0ZW5zaW9ucyA9IFsnLnBuZycsICcuanBnJywgJy5qcGVnJywgJy5naWYnLCAnLmJtcCcsICcuc3ZnJ107XG5cdFx0Y29uc3QgZXh0ID0gcGF0aC5leHRuYW1lKGZpbGVQYXRoKS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiBpbWFnZUV4dGVuc2lvbnMuaW5jbHVkZXMoZXh0KTtcblx0fVxuXG5cdGFzeW5jIGdldFVzZXJCb29rbWFya0lEcygpOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbjsgYm9va21hcmtfZXZlbnRfaWRzOiBzdHJpbmdbXSwgbG9uZ2Zvcm1fZXZlbnRfaWRzOiBzdHJpbmdbXSB9PiB7XG5cdFx0Y29uc3QgYm9va21hcmtfZXZlbnRfaWRzOiBzdHJpbmdbXSA9IFtdO1xuXHRcdGNvbnN0IGxvbmdmb3JtX2V2ZW50X2lkczogc3RyaW5nW10gPSBbXTtcblx0XHR0cnkge1xuXHRcdFx0aWYgKHRoaXMucG9vbCA9PT0gdW5kZWZpbmVkIHx8IHRoaXMucG9vbFVybHMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoXCJObyBwb29sLi4uXCIpXG5cdFx0XHRcdHRoaXMuc2V0Q29ubmVjdGlvblBvb2woKTtcblx0XHRcdH1cblx0XHRcdGxldCBldmVudHMgPSBhd2FpdCB0aGlzLnBvb2wucXVlcnlTeW5jKHRoaXMucG9vbFVybHMsIHsga2luZHM6IFsxMDAwM10sIGF1dGhvcnM6IFt0aGlzLnB1YmxpY0tleV0gfSlcblx0XHRcdGlmIChldmVudHMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRmb3IgKGxldCBldmVudCBvZiBldmVudHMpIHtcblx0XHRcdFx0XHRmb3IgKGNvbnN0IHRhZyBvZiBldmVudC50YWdzKSB7XG5cdFx0XHRcdFx0XHRpZiAodGFnWzBdID09PSAnZScpIHtcblx0XHRcdFx0XHRcdFx0Ym9va21hcmtfZXZlbnRfaWRzLnB1c2godGFnWzFdKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIGhhbmRsZSBraW5kIDMwMDIzIGxvbmctZm9ybSBldmVudHNcblx0XHRcdFx0XHRcdGlmICh0YWdbMF0gPT09ICdhJykge1xuXHRcdFx0XHRcdFx0XHRsb25nZm9ybV9ldmVudF9pZHMucHVzaCh0YWdbMV0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBib29rbWFya19ldmVudF9pZHMsIGxvbmdmb3JtX2V2ZW50X2lkcyB9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZXZlbnRzO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdFcnJvciBvY2N1cnJlZCB3aGlsZSBmZXRjaGluZyBib29rbWFya3MgaWRzOicsIGVycm9yKTtcblx0XHRcdHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBib29rbWFya19ldmVudF9pZHMsIGxvbmdmb3JtX2V2ZW50X2lkcyB9O1xuXHRcdH1cblx0fVxuXG5cdGFzeW5jIGxvYWRVc2VyQm9va21hcmtzKCk6IFByb21pc2U8RXZlbnRbXT4ge1xuXHRcdGxldCBldmVudHM6IEV2ZW50W10gPSBbXTtcblx0XHR0cnkge1xuXHRcdFx0bGV0IHJlcyA9IGF3YWl0IHRoaXMuZ2V0VXNlckJvb2ttYXJrSURzKCk7XG5cdFx0XHRpZiAocmVzLnN1Y2Nlc3MpIHtcblx0XHRcdFx0aWYgKHRoaXMucG9vbCA9PT0gdW5kZWZpbmVkIHx8IHRoaXMucG9vbFVybHMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXRDb25uZWN0aW9uUG9vbCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChyZXMubG9uZ2Zvcm1fZXZlbnRfaWRzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRmb3IgKGxldCBhdGFnIG9mIHJlcy5sb25nZm9ybV9ldmVudF9pZHMpIHtcblx0XHRcdFx0XHRcdGxldCBhdXRob3IgPSBcIlwiXG5cdFx0XHRcdFx0XHRsZXQgZVRhZyA9IFwiXCJcblx0XHRcdFx0XHRcdGxldCBwYXJ0cyA9IGF0YWcuc3BsaXQoJzonKTtcblx0XHRcdFx0XHRcdGlmIChwYXJ0cy5sZW5ndGggPj0gMikge1xuXHRcdFx0XHRcdFx0XHRhdXRob3IgPSBwYXJ0c1sxXTtcblx0XHRcdFx0XHRcdFx0ZVRhZyA9IHBhcnRzWzJdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bGV0IGFydGljbGVzID0gYXdhaXQgdGhpcy5wb29sLnF1ZXJ5U3luYyh0aGlzLnBvb2xVcmxzLCB7IGF1dGhvcnM6IFthdXRob3JdLCBraW5kczogWzMwMDIzXSB9KTtcblx0XHRcdFx0XHRcdGZvciAobGV0IGFydGljbGVJdGVtIG9mIGFydGljbGVzKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChhcnRpY2xlSXRlbS50YWdzLnNvbWUodGFnID0+IHRhZ1swXSA9PT0gXCJkXCIgJiYgdGFnWzFdID09PSBlVGFnKSkge1xuXHRcdFx0XHRcdFx0XHRcdGV2ZW50cy5wdXNoKGFydGljbGVJdGVtKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGxldCBuZXdFdmVudHMgPSBhd2FpdCB0aGlzLnBvb2wucXVlcnlTeW5jKHRoaXMucG9vbFVybHMsIHsgaWRzOiByZXMuYm9va21hcmtfZXZlbnRfaWRzLCBraW5kczogWzEsIDMwMDIzXSB9KTtcblx0XHRcdFx0ZXZlbnRzLnB1c2goLi4ubmV3RXZlbnRzKTtcblx0XHRcdFx0cmV0dXJuIGV2ZW50cztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ05vIGJvb2ttYXJrIElEcyByZXR1cm5lZCcpO1xuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHR9XG5cblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0Vycm9yIG9jY3VycmVkIHdoaWxlIGZldGNoaW5nIGJvb2ttYXJrczonLCBlcnIpO1xuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdH1cblx0fVxuXG5cdGFzeW5jIGxvYWRVc2VySGlnaGxpZ2h0cygpOiBQcm9taXNlPEV2ZW50W10+IHtcblx0XHRsZXQgZXZlbnRzOiBFdmVudFtdID0gW107XG5cdFx0dHJ5IHtcblx0XHRcdGlmICh0aGlzLnBvb2wgPT09IHVuZGVmaW5lZCB8fCB0aGlzLnBvb2xVcmxzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHR0aGlzLnNldENvbm5lY3Rpb25Qb29sKCk7XG5cdFx0XHR9XG5cdFx0XHRsZXQgaGlnaGxpZ2h0cyA9IGF3YWl0IHRoaXMucG9vbC5xdWVyeVN5bmModGhpcy5wb29sVXJscywgeyBhdXRob3JzOiBbdGhpcy5wdWJsaWNLZXldLCBraW5kczogWzk4MDJdIH0pO1xuXHRcdFx0aWYgKGhpZ2hsaWdodHMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRmb3IgKGxldCBldmVudCBvZiBoaWdobGlnaHRzKSB7XG5cdFx0XHRcdFx0ZXZlbnRzLnB1c2goZXZlbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZXZlbnRzO1xuXG5cdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdFcnJvciBvY2N1cnJlZCB3aGlsZSBmZXRjaGluZyBib29rbWFya3M6JywgZXJyKTtcblx0XHRcdHJldHVybiBbXTtcblx0XHR9XG5cdH1cblxuXG5cdGFzeW5jIGdldFVzZXJQcm9maWxlKHVzZXJIZXhQdWJLZXk6IHN0cmluZyk6IFByb21pc2U8RXZlbnQ+IHtcblx0XHR0cnkge1xuXHRcdFx0aWYgKHRoaXMucG9vbCA9PT0gdW5kZWZpbmVkIHx8IHRoaXMucG9vbFVybHMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdHRoaXMuc2V0Q29ubmVjdGlvblBvb2woKTtcblx0XHRcdH1cblx0XHRcdGxldCBwcm9maWxlRXZlbnQgPSBhd2FpdCB0aGlzLnBvb2wucXVlcnlTeW5jKHRoaXMucG9vbFVybHMsIHsga2luZHM6IFswXSwgYXV0aG9yczogW3VzZXJIZXhQdWJLZXldIH0pXG5cdFx0XHRyZXR1cm4gcHJvZmlsZUV2ZW50O1xuXHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignRXJyb3Igb2NjdXJyZWQgd2hpbGUgZmV0Y2hpbmcgYm9va21hcmtzOicsIGVycik7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdH1cblxuXHQvL1x0VGhlIGEgdGFnLCB1c2VkIHRvIHJlZmVyIHRvIGEgKG1heWJlIHBhcmFtZXRlcml6ZWQpIHJlcGxhY2VhYmxlIGV2ZW50XG5cdC8vZm9yIGEgcGFyYW1ldGVyaXplZCByZXBsYWNlYWJsZSBldmVudDogW1wiYVwiLCA8a2luZCBpbnRlZ2VyPjo8MzItYnl0ZXMgbG93ZXJjYXNlIGhleCBvZiBhIHB1YmtleT46PGQgdGFnIHZhbHVlPiwgPHJlY29tbWVuZGVkIHJlbGF5IFVSTCwgb3B0aW9uYWw+XVxuXHQvL2ZvciBhIG5vbi1wYXJhbWV0ZXJpemVkIHJlcGxhY2VhYmxlIGV2ZW50OiBbXCJhXCIsIDxraW5kIGludGVnZXI+OjwzMi1ieXRlcyBsb3dlcmNhc2UgaGV4IG9mIGEgcHVia2V5PjosIDxyZWNvbW1lbmRlZCByZWxheSBVUkwsIG9wdGlvbmFsPl1cblx0YXN5bmMgZ2V0RXZlbnRGcm9tQVRhZyh0YWdWYWx1ZTogc3RyaW5nKTogUHJvbWlzZTxFdmVudD4ge1xuXHRcdGxldCBldmVudHMgPSBbXTtcblx0XHR0cnkge1xuXHRcdFx0aWYgKHRoaXMucG9vbCA9PT0gdW5kZWZpbmVkIHx8IHRoaXMucG9vbFVybHMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdHRoaXMuc2V0Q29ubmVjdGlvblBvb2woKTtcblx0XHRcdH1cblx0XHRcdGxldCBldmVudFBhcnRzID0gdGFnVmFsdWUuc3BsaXQoXCI6XCIpO1xuXHRcdFx0bGV0IGFydGljbGVzID0gYXdhaXQgdGhpcy5wb29sLnF1ZXJ5U3luYyh0aGlzLnBvb2xVcmxzLCB7IGtpbmRzOiBbcGFyc2VJbnQoZXZlbnRQYXJ0c1swXSwgMTApXSwgYXV0aG9yczogW2V2ZW50UGFydHNbMV1dIH0pXG5cdFx0XHRmb3IgKGxldCBhcnRpY2xlSXRlbSBvZiBhcnRpY2xlcykge1xuXHRcdFx0XHRpZiAoYXJ0aWNsZUl0ZW0udGFncy5zb21lKHRhZyA9PiB0YWdbMF0gPT09IFwiZFwiICYmIHRhZ1sxXSA9PT0gZXZlbnRQYXJ0c1syXSkpIHtcblx0XHRcdFx0XHRldmVudHMucHVzaChhcnRpY2xlSXRlbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBldmVudHNbMF07XG5cdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdFcnJvciBvY2N1cnJlZCB3aGlsZSBmZXRjaGluZyBib29rbWFya3M6JywgZXJyKTtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0fVxuXG5cdGFzeW5jIHB1Ymxpc2hUb1JlbGF5cyhcblx0XHRmaW5hbEV2ZW50OiBFdmVudCxcblx0XHRmaWxlUGF0aDogc3RyaW5nLFxuXHRcdHByb2ZpbGVOaWNrbmFtZTogc3RyaW5nXG5cdCk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuOyBwdWJsaXNoZWRSZWxheXM6IHN0cmluZ1tdIH0+IHtcblx0XHR0cnkge1xuXHRcdFx0bGV0IHB1Ymxpc2hpbmdQcm9taXNlcyA9IHRoaXMuY29ubmVjdGVkUmVsYXlzLm1hcChhc3luYyAocmVsYXkpID0+IHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRpZiAocmVsYXkuY29ubmVjdGVkKSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhgUHVibGlzaGluZyB0byAke3JlbGF5LnVybH1gKTtcblx0XHRcdFx0XHRcdGF3YWl0IHJlbGF5LnB1Ymxpc2goZmluYWxFdmVudCk7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhgRXZlbnQgcHVibGlzaGVkIHN1Y2Nlc3NmdWxseSB0byAke3JlbGF5LnVybH1gKTtcblx0XHRcdFx0XHRcdHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIHVybDogcmVsYXkudXJsIH07XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKGBTa2lwcGluZyBkaXNjb25uZWN0ZWQgcmVsYXk6ICR7cmVsYXkudXJsfWApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHsgc3VjY2VzczogZmFsc2UgfTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcihgRmFpbGVkIHRvIHB1Ymxpc2ggZXZlbnQgdG8gJHtyZWxheS51cmx9OiAke2Vycm9yfWApO1xuXHRcdFx0XHRcdHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlIH07XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRsZXQgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKHB1Ymxpc2hpbmdQcm9taXNlcyk7XG5cdFx0XHRsZXQgcHVibGlzaGVkUmVsYXlzID0gcmVzdWx0c1xuXHRcdFx0XHQuZmlsdGVyKChyZXN1bHQpID0+IHJlc3VsdC5zdWNjZXNzKVxuXHRcdFx0XHQubWFwKChyZXN1bHQpID0+IHJlc3VsdC51cmwhKTtcblxuXHRcdFx0Y29uc29sZS5sb2coXG5cdFx0XHRcdGBQdWJsaXNoZWQgdG8gJHtwdWJsaXNoZWRSZWxheXMubGVuZ3RofSAvICR7dGhpcy5jb25uZWN0ZWRSZWxheXMubGVuZ3RofSByZWxheXMuYFxuXHRcdFx0KTtcblxuXHRcdFx0aWYgKHB1Ymxpc2hlZFJlbGF5cy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0Y29uc29sZS5sb2coXCJEaWRuJ3Qgc2VuZCB0byBhbnkgcmVsYXlzXCIpO1xuXHRcdFx0XHRyZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgcHVibGlzaGVkUmVsYXlzOiBbXSB9O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKGZpbmFsRXZlbnQua2luZCA9PT0gMzAwMjMpIHtcblx0XHRcdFx0XHR0aGlzLnNhdmVQdWJsaXNoZWRFdmVudChcblx0XHRcdFx0XHRcdGZpbmFsRXZlbnQsXG5cdFx0XHRcdFx0XHRmaWxlUGF0aCxcblx0XHRcdFx0XHRcdHB1Ymxpc2hlZFJlbGF5cyxcblx0XHRcdFx0XHRcdHByb2ZpbGVOaWNrbmFtZVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgcHVibGlzaGVkUmVsYXlzIH07XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoXCJBbiBlcnJvciBvY2N1cnJlZCB3aGlsZSBwdWJsaXNoaW5nIHRvIHJlbGF5c1wiLCBlcnJvcik7XG5cdFx0XHRyZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgcHVibGlzaGVkUmVsYXlzOiBbXSB9O1xuXHRcdH1cblx0fVxuXG5cblx0c2h1dGRvd25SZWxheXMoKSB7XG5cdFx0Y29uc29sZS5sb2coXCJTaHV0dGluZyBkb3duIE5vc3RyIHNlcnZpY2VcIik7XG5cdFx0aWYgKHRoaXMuY29ubmVjdGVkUmVsYXlzLmxlbmd0aCA+IDApIHtcblx0XHRcdGZvciAobGV0IHIgb2YgdGhpcy5jb25uZWN0ZWRSZWxheXMpIHtcblx0XHRcdFx0ci5jbG9zZSgpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5wb29sLmNsb3NlKCk7XG5cdFx0fVxuXHR9XG5cblx0Y29udmVydEtleVRvSGV4KHZhbHVlOiBzdHJpbmcpOiBzdHJpbmcge1xuXHRcdGlmICh2YWx1ZSAmJiB2YWx1ZS5zdGFydHNXaXRoKFwibnNlY1wiKSkge1xuXHRcdFx0bGV0IGRlY29kZWRQcml2YXRlS2V5ID0gbmlwMTkuZGVjb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBkZWNvZGVkUHJpdmF0ZUtleS5kYXRhIGFzIHN0cmluZztcblx0XHR9XG5cdFx0aWYgKHZhbHVlICYmIHZhbHVlLnN0YXJ0c1dpdGgoXCJucHViXCIpKSB7XG5cdFx0XHRsZXQgZGVjb2RlZFB1YmxpY0tleSA9IG5pcDE5LmRlY29kZSh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gZGVjb2RlZFB1YmxpY0tleS5kYXRhIGFzIHN0cmluZztcblx0XHR9XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cblx0YXN5bmMgc2F2ZVB1Ymxpc2hlZEV2ZW50KFxuXHRcdGZpbmFsRXZlbnQ6IEV2ZW50LFxuXHRcdHB1Ymxpc2hlZEZpbGVQYXRoOiBzdHJpbmcsXG5cdFx0cmVsYXlzOiBzdHJpbmdbXSxcblx0XHRwcm9maWxlTmlja25hbWU6IHN0cmluZ1xuXHQpIHtcblx0XHRjb25zdCBwdWJsaXNoZWREYXRhUGF0aCA9IGAke3RoaXMucGx1Z2luLm1hbmlmZXN0LmRpcn0vcHVibGlzaGVkLmpzb25gO1xuXHRcdGxldCBwdWJsaXNoZWRFdmVudHM7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IGZpbGVDb250ZW50ID0gYXdhaXQgdGhpcy5hcHAudmF1bHQuYWRhcHRlci5yZWFkKFxuXHRcdFx0XHRwdWJsaXNoZWREYXRhUGF0aFxuXHRcdFx0KTtcblx0XHRcdHB1Ymxpc2hlZEV2ZW50cyA9IEpTT04ucGFyc2UoZmlsZUNvbnRlbnQpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHB1Ymxpc2hlZEV2ZW50cyA9IFtdO1xuXHRcdH1cblxuXHRcdGNvbnN0IGV2ZW50V2l0aE1ldGFEYXRhID0ge1xuXHRcdFx0Li4uZmluYWxFdmVudCxcblx0XHRcdGZpbGVwYXRoOiBwdWJsaXNoZWRGaWxlUGF0aCxcblx0XHRcdHB1Ymxpc2hlZFRvUmVsYXlzOiByZWxheXMsXG5cdFx0XHRwcm9maWxlTmlja25hbWU6IHByb2ZpbGVOaWNrbmFtZSxcblx0XHR9O1xuXHRcdHB1Ymxpc2hlZEV2ZW50cy5wdXNoKGV2ZW50V2l0aE1ldGFEYXRhKTtcblx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC5hZGFwdGVyLndyaXRlKFxuXHRcdFx0cHVibGlzaGVkRGF0YVBhdGgsXG5cdFx0XHRKU09OLnN0cmluZ2lmeShwdWJsaXNoZWRFdmVudHMpXG5cdFx0KTtcblx0fVxuXG5cdGlzVmFsaWRVUkwodXJsOiBzdHJpbmcpIHtcblx0XHR0cnkge1xuXHRcdFx0bmV3IFVSTCh1cmwpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUubG9nKGVycm9yKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cbn1cbiIsICJmdW5jdGlvbiBudW1iZXIobjogbnVtYmVyKSB7XG4gIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikgfHwgbiA8IDApIHRocm93IG5ldyBFcnJvcihgV3JvbmcgcG9zaXRpdmUgaW50ZWdlcjogJHtufWApO1xufVxuXG5mdW5jdGlvbiBib29sKGI6IGJvb2xlYW4pIHtcbiAgaWYgKHR5cGVvZiBiICE9PSAnYm9vbGVhbicpIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYm9vbGVhbiwgbm90ICR7Yn1gKTtcbn1cblxuZnVuY3Rpb24gYnl0ZXMoYjogVWludDhBcnJheSB8IHVuZGVmaW5lZCwgLi4ubGVuZ3RoczogbnVtYmVyW10pIHtcbiAgaWYgKCEoYiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIFVpbnQ4QXJyYXknKTtcbiAgaWYgKGxlbmd0aHMubGVuZ3RoID4gMCAmJiAhbGVuZ3Rocy5pbmNsdWRlcyhiLmxlbmd0aCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBVaW50OEFycmF5IG9mIGxlbmd0aCAke2xlbmd0aHN9LCBub3Qgb2YgbGVuZ3RoPSR7Yi5sZW5ndGh9YCk7XG59XG5cbnR5cGUgSGFzaCA9IHtcbiAgKGRhdGE6IFVpbnQ4QXJyYXkpOiBVaW50OEFycmF5O1xuICBibG9ja0xlbjogbnVtYmVyO1xuICBvdXRwdXRMZW46IG51bWJlcjtcbiAgY3JlYXRlOiBhbnk7XG59O1xuZnVuY3Rpb24gaGFzaChoYXNoOiBIYXNoKSB7XG4gIGlmICh0eXBlb2YgaGFzaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaGFzaC5jcmVhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIHNob3VsZCBiZSB3cmFwcGVkIGJ5IHV0aWxzLndyYXBDb25zdHJ1Y3RvcicpO1xuICBudW1iZXIoaGFzaC5vdXRwdXRMZW4pO1xuICBudW1iZXIoaGFzaC5ibG9ja0xlbik7XG59XG5cbmZ1bmN0aW9uIGV4aXN0cyhpbnN0YW5jZTogYW55LCBjaGVja0ZpbmlzaGVkID0gdHJ1ZSkge1xuICBpZiAoaW5zdGFuY2UuZGVzdHJveWVkKSB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkJyk7XG4gIGlmIChjaGVja0ZpbmlzaGVkICYmIGluc3RhbmNlLmZpbmlzaGVkKSB0aHJvdyBuZXcgRXJyb3IoJ0hhc2gjZGlnZXN0KCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQnKTtcbn1cbmZ1bmN0aW9uIG91dHB1dChvdXQ6IGFueSwgaW5zdGFuY2U6IGFueSkge1xuICBieXRlcyhvdXQpO1xuICBjb25zdCBtaW4gPSBpbnN0YW5jZS5vdXRwdXRMZW47XG4gIGlmIChvdXQubGVuZ3RoIDwgbWluKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBkaWdlc3RJbnRvKCkgZXhwZWN0cyBvdXRwdXQgYnVmZmVyIG9mIGxlbmd0aCBhdCBsZWFzdCAke21pbn1gKTtcbiAgfVxufVxuXG5leHBvcnQgeyBudW1iZXIsIGJvb2wsIGJ5dGVzLCBoYXNoLCBleGlzdHMsIG91dHB1dCB9O1xuXG5jb25zdCBhc3NlcnQgPSB7IG51bWJlciwgYm9vbCwgYnl0ZXMsIGhhc2gsIGV4aXN0cywgb3V0cHV0IH07XG5leHBvcnQgZGVmYXVsdCBhc3NlcnQ7XG4iLCAiLy8gV2UgdXNlIFdlYkNyeXB0byBha2EgZ2xvYmFsVGhpcy5jcnlwdG8sIHdoaWNoIGV4aXN0cyBpbiBicm93c2VycyBhbmQgbm9kZS5qcyAxNisuXG4vLyBTZWUgdXRpbHMudHMgZm9yIGRldGFpbHMuXG5kZWNsYXJlIGNvbnN0IGdsb2JhbFRoaXM6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQ7XG5leHBvcnQgY29uc3QgY3J5cHRvID1cbiAgdHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnICYmICdjcnlwdG8nIGluIGdsb2JhbFRoaXMgPyBnbG9iYWxUaGlzLmNyeXB0byA6IHVuZGVmaW5lZDtcbiIsICIvKiEgbm9ibGUtaGFzaGVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5cbi8vIFdlIHVzZSBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gYnJvd3NlcnMgYW5kIG5vZGUuanMgMTYrLlxuLy8gbm9kZS5qcyB2ZXJzaW9ucyBlYXJsaWVyIHRoYW4gdjE5IGRvbid0IGRlY2xhcmUgaXQgaW4gZ2xvYmFsIHNjb3BlLlxuLy8gRm9yIG5vZGUuanMsIHBhY2thZ2UuanNvbiNleHBvcnRzIGZpZWxkIG1hcHBpbmcgcmV3cml0ZXMgaW1wb3J0XG4vLyBmcm9tIGBjcnlwdG9gIHRvIGBjcnlwdG9Ob2RlYCwgd2hpY2ggaW1wb3J0cyBuYXRpdmUgbW9kdWxlLlxuLy8gTWFrZXMgdGhlIHV0aWxzIHVuLWltcG9ydGFibGUgaW4gYnJvd3NlcnMgd2l0aG91dCBhIGJ1bmRsZXIuXG4vLyBPbmNlIG5vZGUuanMgMTggaXMgZGVwcmVjYXRlZCwgd2UgY2FuIGp1c3QgZHJvcCB0aGUgaW1wb3J0LlxuaW1wb3J0IHsgY3J5cHRvIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9jcnlwdG8nO1xuXG4vLyBwcmV0dGllci1pZ25vcmVcbmV4cG9ydCB0eXBlIFR5cGVkQXJyYXkgPSBJbnQ4QXJyYXkgfCBVaW50OENsYW1wZWRBcnJheSB8IFVpbnQ4QXJyYXkgfFxuICBVaW50MTZBcnJheSB8IEludDE2QXJyYXkgfCBVaW50MzJBcnJheSB8IEludDMyQXJyYXk7XG5cbmNvbnN0IHU4YSA9IChhOiBhbnkpOiBhIGlzIFVpbnQ4QXJyYXkgPT4gYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG4vLyBDYXN0IGFycmF5IHRvIGRpZmZlcmVudCB0eXBlXG5leHBvcnQgY29uc3QgdTggPSAoYXJyOiBUeXBlZEFycmF5KSA9PiBuZXcgVWludDhBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuZXhwb3J0IGNvbnN0IHUzMiA9IChhcnI6IFR5cGVkQXJyYXkpID0+XG4gIG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDQpKTtcblxuLy8gQ2FzdCBhcnJheSB0byB2aWV3XG5leHBvcnQgY29uc3QgY3JlYXRlVmlldyA9IChhcnI6IFR5cGVkQXJyYXkpID0+XG4gIG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuXG4vLyBUaGUgcm90YXRlIHJpZ2h0IChjaXJjdWxhciByaWdodCBzaGlmdCkgb3BlcmF0aW9uIGZvciB1aW50MzJcbmV4cG9ydCBjb25zdCByb3RyID0gKHdvcmQ6IG51bWJlciwgc2hpZnQ6IG51bWJlcikgPT4gKHdvcmQgPDwgKDMyIC0gc2hpZnQpKSB8ICh3b3JkID4+PiBzaGlmdCk7XG5cbi8vIGJpZy1lbmRpYW4gaGFyZHdhcmUgaXMgcmFyZS4gSnVzdCBpbiBjYXNlIHNvbWVvbmUgc3RpbGwgZGVjaWRlcyB0byBydW4gaGFzaGVzOlxuLy8gZWFybHktdGhyb3cgYW4gZXJyb3IgYmVjYXVzZSB3ZSBkb24ndCBzdXBwb3J0IEJFIHlldC5cbmV4cG9ydCBjb25zdCBpc0xFID0gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQzMkFycmF5KFsweDExMjIzMzQ0XSkuYnVmZmVyKVswXSA9PT0gMHg0NDtcbmlmICghaXNMRSkgdGhyb3cgbmV3IEVycm9yKCdOb24gbGl0dGxlLWVuZGlhbiBoYXJkd2FyZSBpcyBub3Qgc3VwcG9ydGVkJyk7XG5cbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT5cbiAgaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKVxuKTtcbi8qKlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlczogVWludDhBcnJheSk6IHN0cmluZyB7XG4gIGlmICghdThhKGJ5dGVzKSkgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICBsZXQgaGV4ID0gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBoZXggKz0gaGV4ZXNbYnl0ZXNbaV1dO1xuICB9XG4gIHJldHVybiBoZXg7XG59XG5cbi8qKlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXg6IHN0cmluZyk6IFVpbnQ4QXJyYXkge1xuICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgY29uc3QgbGVuID0gaGV4Lmxlbmd0aDtcbiAgaWYgKGxlbiAlIDIpIHRocm93IG5ldyBFcnJvcigncGFkZGVkIGhleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoICcgKyBsZW4pO1xuICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGxlbiAvIDIpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgaiA9IGkgKiAyO1xuICAgIGNvbnN0IGhleEJ5dGUgPSBoZXguc2xpY2UoaiwgaiArIDIpO1xuICAgIGNvbnN0IGJ5dGUgPSBOdW1iZXIucGFyc2VJbnQoaGV4Qnl0ZSwgMTYpO1xuICAgIGlmIChOdW1iZXIuaXNOYU4oYnl0ZSkgfHwgYnl0ZSA8IDApIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBieXRlIHNlcXVlbmNlJyk7XG4gICAgYXJyYXlbaV0gPSBieXRlO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuLy8gVGhlcmUgaXMgbm8gc2V0SW1tZWRpYXRlIGluIGJyb3dzZXIgYW5kIHNldFRpbWVvdXQgaXMgc2xvdy5cbi8vIGNhbGwgb2YgYXN5bmMgZm4gd2lsbCByZXR1cm4gUHJvbWlzZSwgd2hpY2ggd2lsbCBiZSBmdWxsZmlsZWQgb25seSBvblxuLy8gbmV4dCBzY2hlZHVsZXIgcXVldWUgcHJvY2Vzc2luZyBzdGVwIGFuZCB0aGlzIGlzIGV4YWN0bHkgd2hhdCB3ZSBuZWVkLlxuZXhwb3J0IGNvbnN0IG5leHRUaWNrID0gYXN5bmMgKCkgPT4ge307XG5cbi8vIFJldHVybnMgY29udHJvbCB0byB0aHJlYWQgZWFjaCAndGljaycgbXMgdG8gYXZvaWQgYmxvY2tpbmdcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3luY0xvb3AoaXRlcnM6IG51bWJlciwgdGljazogbnVtYmVyLCBjYjogKGk6IG51bWJlcikgPT4gdm9pZCkge1xuICBsZXQgdHMgPSBEYXRlLm5vdygpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJzOyBpKyspIHtcbiAgICBjYihpKTtcbiAgICAvLyBEYXRlLm5vdygpIGlzIG5vdCBtb25vdG9uaWMsIHNvIGluIGNhc2UgaWYgY2xvY2sgZ29lcyBiYWNrd2FyZHMgd2UgcmV0dXJuIHJldHVybiBjb250cm9sIHRvb1xuICAgIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gdHM7XG4gICAgaWYgKGRpZmYgPj0gMCAmJiBkaWZmIDwgdGljaykgY29udGludWU7XG4gICAgYXdhaXQgbmV4dFRpY2soKTtcbiAgICB0cyArPSBkaWZmO1xuICB9XG59XG5cbi8vIEdsb2JhbCBzeW1ib2xzIGluIGJvdGggYnJvd3NlcnMgYW5kIE5vZGUuanMgc2luY2UgdjExXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8zMTUzNVxuZGVjbGFyZSBjb25zdCBUZXh0RW5jb2RlcjogYW55O1xuXG4vKipcbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHI6IHN0cmluZyk6IFVpbnQ4QXJyYXkge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBFcnJvcihgdXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc3RyfWApO1xuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG5cbmV4cG9ydCB0eXBlIElucHV0ID0gVWludDhBcnJheSB8IHN0cmluZztcbi8qKlxuICogTm9ybWFsaXplcyAobm9uLWhleCkgc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gVWludDhBcnJheS5cbiAqIFdhcm5pbmc6IHdoZW4gVWludDhBcnJheSBpcyBwYXNzZWQsIGl0IHdvdWxkIE5PVCBnZXQgY29waWVkLlxuICogS2VlcCBpbiBtaW5kIGZvciBmdXR1cmUgbXV0YWJsZSBvcGVyYXRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CeXRlcyhkYXRhOiBJbnB1dCk6IFVpbnQ4QXJyYXkge1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSBkYXRhID0gdXRmOFRvQnl0ZXMoZGF0YSk7XG4gIGlmICghdThhKGRhdGEpKSB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIFVpbnQ4QXJyYXksIGdvdCAke3R5cGVvZiBkYXRhfWApO1xuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBDb3BpZXMgc2V2ZXJhbCBVaW50OEFycmF5cyBpbnRvIG9uZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5czogVWludDhBcnJheVtdKTogVWludDhBcnJheSB7XG4gIGNvbnN0IHIgPSBuZXcgVWludDhBcnJheShhcnJheXMucmVkdWNlKChzdW0sIGEpID0+IHN1bSArIGEubGVuZ3RoLCAwKSk7XG4gIGxldCBwYWQgPSAwOyAvLyB3YWxrIHRocm91Z2ggZWFjaCBpdGVtLCBlbnN1cmUgdGhleSBoYXZlIHByb3BlciB0eXBlXG4gIGFycmF5cy5mb3JFYWNoKChhKSA9PiB7XG4gICAgaWYgKCF1OGEoYSkpIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIHIuc2V0KGEsIHBhZCk7XG4gICAgcGFkICs9IGEubGVuZ3RoO1xuICB9KTtcbiAgcmV0dXJuIHI7XG59XG5cbi8vIEZvciBydW50aW1lIGNoZWNrIGlmIGNsYXNzIGltcGxlbWVudHMgaW50ZXJmYWNlXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgSGFzaDxUIGV4dGVuZHMgSGFzaDxUPj4ge1xuICBhYnN0cmFjdCBibG9ja0xlbjogbnVtYmVyOyAvLyBCeXRlcyBwZXIgYmxvY2tcbiAgYWJzdHJhY3Qgb3V0cHV0TGVuOiBudW1iZXI7IC8vIEJ5dGVzIGluIG91dHB1dFxuICBhYnN0cmFjdCB1cGRhdGUoYnVmOiBJbnB1dCk6IHRoaXM7XG4gIC8vIFdyaXRlcyBkaWdlc3QgaW50byBidWZcbiAgYWJzdHJhY3QgZGlnZXN0SW50byhidWY6IFVpbnQ4QXJyYXkpOiB2b2lkO1xuICBhYnN0cmFjdCBkaWdlc3QoKTogVWludDhBcnJheTtcbiAgLyoqXG4gICAqIFJlc2V0cyBpbnRlcm5hbCBzdGF0ZS4gTWFrZXMgSGFzaCBpbnN0YW5jZSB1bnVzYWJsZS5cbiAgICogUmVzZXQgaXMgaW1wb3NzaWJsZSBmb3Iga2V5ZWQgaGFzaGVzIGlmIGtleSBpcyBjb25zdW1lZCBpbnRvIHN0YXRlLiBJZiBkaWdlc3QgaXMgbm90IGNvbnN1bWVkXG4gICAqIGJ5IHVzZXIsIHRoZXkgd2lsbCBuZWVkIHRvIG1hbnVhbGx5IGNhbGwgYGRlc3Ryb3koKWAgd2hlbiB6ZXJvaW5nIGlzIG5lY2Vzc2FyeS5cbiAgICovXG4gIGFic3RyYWN0IGRlc3Ryb3koKTogdm9pZDtcbiAgLyoqXG4gICAqIENsb25lcyBoYXNoIGluc3RhbmNlLiBVbnNhZmU6IGRvZXNuJ3QgY2hlY2sgd2hldGhlciBgdG9gIGlzIHZhbGlkLiBDYW4gYmUgdXNlZCBhcyBgY2xvbmUoKWBcbiAgICogd2hlbiBubyBvcHRpb25zIGFyZSBwYXNzZWQuXG4gICAqIFJlYXNvbnMgdG8gdXNlIGBfY2xvbmVJbnRvYCBpbnN0ZWFkIG9mIGNsb25lOiAxKSBwZXJmb3JtYW5jZSAyKSByZXVzZSBpbnN0YW5jZSA9PiBhbGwgaW50ZXJuYWxcbiAgICogYnVmZmVycyBhcmUgb3ZlcndyaXR0ZW4gPT4gY2F1c2VzIGJ1ZmZlciBvdmVyd3JpdGUgd2hpY2ggaXMgdXNlZCBmb3IgZGlnZXN0IGluIHNvbWUgY2FzZXMuXG4gICAqIFRoZXJlIGFyZSBubyBndWFyYW50ZWVzIGZvciBjbGVhbi11cCBiZWNhdXNlIGl0J3MgaW1wb3NzaWJsZSBpbiBKUy5cbiAgICovXG4gIGFic3RyYWN0IF9jbG9uZUludG8odG8/OiBUKTogVDtcbiAgLy8gU2FmZSB2ZXJzaW9uIHRoYXQgY2xvbmVzIGludGVybmFsIHN0YXRlXG4gIGNsb25lKCk6IFQge1xuICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcbiAgfVxufVxuXG4vKipcbiAqIFhPRjogc3RyZWFtaW5nIEFQSSB0byByZWFkIGRpZ2VzdCBpbiBjaHVua3MuXG4gKiBTYW1lIGFzICdzcXVlZXplJyBpbiBrZWNjYWsvazEyIGFuZCAnc2VlaycgaW4gYmxha2UzLCBidXQgbW9yZSBnZW5lcmljIG5hbWUuXG4gKiBXaGVuIGhhc2ggdXNlZCBpbiBYT0YgbW9kZSBpdCBpcyB1cCB0byB1c2VyIHRvIGNhbGwgJy5kZXN0cm95JyBhZnRlcndhcmRzLCBzaW5jZSB3ZSBjYW5ub3RcbiAqIGRlc3Ryb3kgc3RhdGUsIG5leHQgY2FsbCBjYW4gcmVxdWlyZSBtb3JlIGJ5dGVzLlxuICovXG5leHBvcnQgdHlwZSBIYXNoWE9GPFQgZXh0ZW5kcyBIYXNoPFQ+PiA9IEhhc2g8VD4gJiB7XG4gIHhvZihieXRlczogbnVtYmVyKTogVWludDhBcnJheTsgLy8gUmVhZCAnYnl0ZXMnIGJ5dGVzIGZyb20gZGlnZXN0IHN0cmVhbVxuICB4b2ZJbnRvKGJ1ZjogVWludDhBcnJheSk6IFVpbnQ4QXJyYXk7IC8vIHJlYWQgYnVmLmxlbmd0aCBieXRlcyBmcm9tIGRpZ2VzdCBzdHJlYW0gaW50byBidWZcbn07XG5cbmNvbnN0IHRvU3RyID0ge30udG9TdHJpbmc7XG50eXBlIEVtcHR5T2JqID0ge307XG5leHBvcnQgZnVuY3Rpb24gY2hlY2tPcHRzPFQxIGV4dGVuZHMgRW1wdHlPYmosIFQyIGV4dGVuZHMgRW1wdHlPYmo+KFxuICBkZWZhdWx0czogVDEsXG4gIG9wdHM/OiBUMlxuKTogVDEgJiBUMiB7XG4gIGlmIChvcHRzICE9PSB1bmRlZmluZWQgJiYgdG9TdHIuY2FsbChvcHRzKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb25zIHNob3VsZCBiZSBvYmplY3Qgb3IgdW5kZWZpbmVkJyk7XG4gIGNvbnN0IG1lcmdlZCA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdHMsIG9wdHMpO1xuICByZXR1cm4gbWVyZ2VkIGFzIFQxICYgVDI7XG59XG5cbmV4cG9ydCB0eXBlIENIYXNoID0gUmV0dXJuVHlwZTx0eXBlb2Ygd3JhcENvbnN0cnVjdG9yPjtcblxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcjxUIGV4dGVuZHMgSGFzaDxUPj4oaGFzaENvbnM6ICgpID0+IEhhc2g8VD4pIHtcbiAgY29uc3QgaGFzaEMgPSAobXNnOiBJbnB1dCk6IFVpbnQ4QXJyYXkgPT4gaGFzaENvbnMoKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgY29uc3QgdG1wID0gaGFzaENvbnMoKTtcbiAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gIGhhc2hDLmNyZWF0ZSA9ICgpID0+IGhhc2hDb25zKCk7XG4gIHJldHVybiBoYXNoQztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcldpdGhPcHRzPEggZXh0ZW5kcyBIYXNoPEg+LCBUIGV4dGVuZHMgT2JqZWN0PihcbiAgaGFzaENvbnM6IChvcHRzPzogVCkgPT4gSGFzaDxIPlxuKSB7XG4gIGNvbnN0IGhhc2hDID0gKG1zZzogSW5wdXQsIG9wdHM/OiBUKTogVWludDhBcnJheSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgY29uc3QgdG1wID0gaGFzaENvbnMoe30gYXMgVCk7XG4gIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICBoYXNoQy5jcmVhdGUgPSAob3B0czogVCkgPT4gaGFzaENvbnMob3B0cyk7XG4gIHJldHVybiBoYXNoQztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzPEggZXh0ZW5kcyBIYXNoWE9GPEg+LCBUIGV4dGVuZHMgT2JqZWN0PihcbiAgaGFzaENvbnM6IChvcHRzPzogVCkgPT4gSGFzaFhPRjxIPlxuKSB7XG4gIGNvbnN0IGhhc2hDID0gKG1zZzogSW5wdXQsIG9wdHM/OiBUKTogVWludDhBcnJheSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgY29uc3QgdG1wID0gaGFzaENvbnMoe30gYXMgVCk7XG4gIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICBoYXNoQy5jcmVhdGUgPSAob3B0czogVCkgPT4gaGFzaENvbnMob3B0cyk7XG4gIHJldHVybiBoYXNoQztcbn1cblxuLyoqXG4gKiBTZWN1cmUgUFJORy4gVXNlcyBgY3J5cHRvLmdldFJhbmRvbVZhbHVlc2AsIHdoaWNoIGRlZmVycyB0byBPUy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoID0gMzIpOiBVaW50OEFycmF5IHtcbiAgaWYgKGNyeXB0byAmJiB0eXBlb2YgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KGJ5dGVzTGVuZ3RoKSk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIG11c3QgYmUgZGVmaW5lZCcpO1xufVxuIiwgImltcG9ydCB7IGV4aXN0cywgb3V0cHV0IH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IEhhc2gsIGNyZWF0ZVZpZXcsIElucHV0LCB0b0J5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG5cbi8vIFBvbHlmaWxsIGZvciBTYWZhcmkgMTRcbmZ1bmN0aW9uIHNldEJpZ1VpbnQ2NCh2aWV3OiBEYXRhVmlldywgYnl0ZU9mZnNldDogbnVtYmVyLCB2YWx1ZTogYmlnaW50LCBpc0xFOiBib29sZWFuKTogdm9pZCB7XG4gIGlmICh0eXBlb2Ygdmlldy5zZXRCaWdVaW50NjQgPT09ICdmdW5jdGlvbicpIHJldHVybiB2aWV3LnNldEJpZ1VpbnQ2NChieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSk7XG4gIGNvbnN0IF8zMm4gPSBCaWdJbnQoMzIpO1xuICBjb25zdCBfdTMyX21heCA9IEJpZ0ludCgweGZmZmZmZmZmKTtcbiAgY29uc3Qgd2ggPSBOdW1iZXIoKHZhbHVlID4+IF8zMm4pICYgX3UzMl9tYXgpO1xuICBjb25zdCB3bCA9IE51bWJlcih2YWx1ZSAmIF91MzJfbWF4KTtcbiAgY29uc3QgaCA9IGlzTEUgPyA0IDogMDtcbiAgY29uc3QgbCA9IGlzTEUgPyAwIDogNDtcbiAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGgsIHdoLCBpc0xFKTtcbiAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGwsIHdsLCBpc0xFKTtcbn1cblxuLy8gQmFzZSBTSEEyIGNsYXNzIChSRkMgNjIzNClcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTSEEyPFQgZXh0ZW5kcyBTSEEyPFQ+PiBleHRlbmRzIEhhc2g8VD4ge1xuICBwcm90ZWN0ZWQgYWJzdHJhY3QgcHJvY2VzcyhidWY6IERhdGFWaWV3LCBvZmZzZXQ6IG51bWJlcik6IHZvaWQ7XG4gIHByb3RlY3RlZCBhYnN0cmFjdCBnZXQoKTogbnVtYmVyW107XG4gIHByb3RlY3RlZCBhYnN0cmFjdCBzZXQoLi4uYXJnczogbnVtYmVyW10pOiB2b2lkO1xuICBhYnN0cmFjdCBkZXN0cm95KCk6IHZvaWQ7XG4gIHByb3RlY3RlZCBhYnN0cmFjdCByb3VuZENsZWFuKCk6IHZvaWQ7XG4gIC8vIEZvciBwYXJ0aWFsIHVwZGF0ZXMgbGVzcyB0aGFuIGJsb2NrIHNpemVcbiAgcHJvdGVjdGVkIGJ1ZmZlcjogVWludDhBcnJheTtcbiAgcHJvdGVjdGVkIHZpZXc6IERhdGFWaWV3O1xuICBwcm90ZWN0ZWQgZmluaXNoZWQgPSBmYWxzZTtcbiAgcHJvdGVjdGVkIGxlbmd0aCA9IDA7XG4gIHByb3RlY3RlZCBwb3MgPSAwO1xuICBwcm90ZWN0ZWQgZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcmVhZG9ubHkgYmxvY2tMZW46IG51bWJlcixcbiAgICBwdWJsaWMgb3V0cHV0TGVuOiBudW1iZXIsXG4gICAgcmVhZG9ubHkgcGFkT2Zmc2V0OiBudW1iZXIsXG4gICAgcmVhZG9ubHkgaXNMRTogYm9vbGVhblxuICApIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgIHRoaXMudmlldyA9IGNyZWF0ZVZpZXcodGhpcy5idWZmZXIpO1xuICB9XG4gIHVwZGF0ZShkYXRhOiBJbnB1dCk6IHRoaXMge1xuICAgIGV4aXN0cyh0aGlzKTtcbiAgICBjb25zdCB7IHZpZXcsIGJ1ZmZlciwgYmxvY2tMZW4gfSA9IHRoaXM7XG4gICAgZGF0YSA9IHRvQnl0ZXMoZGF0YSk7XG4gICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOyApIHtcbiAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xuICAgICAgLy8gRmFzdCBwYXRoOiB3ZSBoYXZlIGF0IGxlYXN0IG9uZSBibG9jayBpbiBpbnB1dCwgY2FzdCBpdCB0byB2aWV3IGFuZCBwcm9jZXNzXG4gICAgICBpZiAodGFrZSA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgY29uc3QgZGF0YVZpZXcgPSBjcmVhdGVWaWV3KGRhdGEpO1xuICAgICAgICBmb3IgKDsgYmxvY2tMZW4gPD0gbGVuIC0gcG9zOyBwb3MgKz0gYmxvY2tMZW4pIHRoaXMucHJvY2VzcyhkYXRhVmlldywgcG9zKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBidWZmZXIuc2V0KGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyB0YWtlKSwgdGhpcy5wb3MpO1xuICAgICAgdGhpcy5wb3MgKz0gdGFrZTtcbiAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbikge1xuICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5sZW5ndGggKz0gZGF0YS5sZW5ndGg7XG4gICAgdGhpcy5yb3VuZENsZWFuKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZGlnZXN0SW50byhvdXQ6IFVpbnQ4QXJyYXkpIHtcbiAgICBleGlzdHModGhpcyk7XG4gICAgb3V0cHV0KG91dCwgdGhpcyk7XG4gICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgLy8gUGFkZGluZ1xuICAgIC8vIFdlIGNhbiBhdm9pZCBhbGxvY2F0aW9uIG9mIGJ1ZmZlciBmb3IgcGFkZGluZyBjb21wbGV0ZWx5IGlmIGl0XG4gICAgLy8gd2FzIHByZXZpb3VzbHkgbm90IGFsbG9jYXRlZCBoZXJlLiBCdXQgaXQgd29uJ3QgY2hhbmdlIHBlcmZvcm1hbmNlLlxuICAgIGNvbnN0IHsgYnVmZmVyLCB2aWV3LCBibG9ja0xlbiwgaXNMRSB9ID0gdGhpcztcbiAgICBsZXQgeyBwb3MgfSA9IHRoaXM7XG4gICAgLy8gYXBwZW5kIHRoZSBiaXQgJzEnIHRvIHRoZSBtZXNzYWdlXG4gICAgYnVmZmVyW3BvcysrXSA9IDBiMTAwMDAwMDA7XG4gICAgdGhpcy5idWZmZXIuc3ViYXJyYXkocG9zKS5maWxsKDApO1xuICAgIC8vIHdlIGhhdmUgbGVzcyB0aGFuIHBhZE9mZnNldCBsZWZ0IGluIGJ1ZmZlciwgc28gd2UgY2Fubm90IHB1dCBsZW5ndGggaW4gY3VycmVudCBibG9jaywgbmVlZCBwcm9jZXNzIGl0IGFuZCBwYWQgYWdhaW5cbiAgICBpZiAodGhpcy5wYWRPZmZzZXQgPiBibG9ja0xlbiAtIHBvcykge1xuICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgcG9zID0gMDtcbiAgICB9XG4gICAgLy8gUGFkIHVudGlsIGZ1bGwgYmxvY2sgYnl0ZSB3aXRoIHplcm9zXG4gICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGJsb2NrTGVuOyBpKyspIGJ1ZmZlcltpXSA9IDA7XG4gICAgLy8gTm90ZTogc2hhNTEyIHJlcXVpcmVzIGxlbmd0aCB0byBiZSAxMjhiaXQgaW50ZWdlciwgYnV0IGxlbmd0aCBpbiBKUyB3aWxsIG92ZXJmbG93IGJlZm9yZSB0aGF0XG4gICAgLy8gWW91IG5lZWQgdG8gd3JpdGUgYXJvdW5kIDIgZXhhYnl0ZXMgKHU2NF9tYXggLyA4IC8gKDEwMjQqKjYpKSBmb3IgdGhpcyB0byBoYXBwZW4uXG4gICAgLy8gU28gd2UganVzdCB3cml0ZSBsb3dlc3QgNjQgYml0cyBvZiB0aGF0IHZhbHVlLlxuICAgIHNldEJpZ1VpbnQ2NCh2aWV3LCBibG9ja0xlbiAtIDgsIEJpZ0ludCh0aGlzLmxlbmd0aCAqIDgpLCBpc0xFKTtcbiAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgY29uc3Qgb3ZpZXcgPSBjcmVhdGVWaWV3KG91dCk7XG4gICAgY29uc3QgbGVuID0gdGhpcy5vdXRwdXRMZW47XG4gICAgLy8gTk9URTogd2UgZG8gZGl2aXNpb24gYnkgNCBsYXRlciwgd2hpY2ggc2hvdWxkIGJlIGZ1c2VkIGluIHNpbmdsZSBvcCB3aXRoIG1vZHVsbyBieSBKSVRcbiAgICBpZiAobGVuICUgNCkgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIHNob3VsZCBiZSBhbGlnbmVkIHRvIDMyYml0Jyk7XG4gICAgY29uc3Qgb3V0TGVuID0gbGVuIC8gNDtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0KCk7XG4gICAgaWYgKG91dExlbiA+IHN0YXRlLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIGJpZ2dlciB0aGFuIHN0YXRlJyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRMZW47IGkrKykgb3ZpZXcuc2V0VWludDMyKDQgKiBpLCBzdGF0ZVtpXSwgaXNMRSk7XG4gIH1cbiAgZGlnZXN0KCkge1xuICAgIGNvbnN0IHsgYnVmZmVyLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgdGhpcy5kaWdlc3RJbnRvKGJ1ZmZlcik7XG4gICAgY29uc3QgcmVzID0gYnVmZmVyLnNsaWNlKDAsIG91dHB1dExlbik7XG4gICAgdGhpcy5kZXN0cm95KCk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBfY2xvbmVJbnRvKHRvPzogVCk6IFQge1xuICAgIHRvIHx8PSBuZXcgKHRoaXMuY29uc3RydWN0b3IgYXMgYW55KSgpIGFzIFQ7XG4gICAgdG8uc2V0KC4uLnRoaXMuZ2V0KCkpO1xuICAgIGNvbnN0IHsgYmxvY2tMZW4sIGJ1ZmZlciwgbGVuZ3RoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBwb3MgfSA9IHRoaXM7XG4gICAgdG8ubGVuZ3RoID0gbGVuZ3RoO1xuICAgIHRvLnBvcyA9IHBvcztcbiAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICBpZiAobGVuZ3RoICUgYmxvY2tMZW4pIHRvLmJ1ZmZlci5zZXQoYnVmZmVyKTtcbiAgICByZXR1cm4gdG87XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBTSEEyIH0gZnJvbSAnLi9fc2hhMi5qcyc7XG5pbXBvcnQgeyByb3RyLCB3cmFwQ29uc3RydWN0b3IgfSBmcm9tICcuL3V0aWxzLmpzJztcblxuLy8gU0hBMi0yNTYgbmVlZCB0byB0cnkgMl4xMjggaGFzaGVzIHRvIGV4ZWN1dGUgYmlydGhkYXkgYXR0YWNrLlxuLy8gQlRDIG5ldHdvcmsgaXMgZG9pbmcgMl42NyBoYXNoZXMvc2VjIGFzIHBlciBlYXJseSAyMDIzLlxuXG4vLyBDaG9pY2U6IGEgPyBiIDogY1xuY29uc3QgQ2hpID0gKGE6IG51bWJlciwgYjogbnVtYmVyLCBjOiBudW1iZXIpID0+IChhICYgYikgXiAofmEgJiBjKTtcbi8vIE1ham9yaXR5IGZ1bmN0aW9uLCB0cnVlIGlmIGFueSB0d28gaW5wdXN0IGlzIHRydWVcbmNvbnN0IE1haiA9IChhOiBudW1iZXIsIGI6IG51bWJlciwgYzogbnVtYmVyKSA9PiAoYSAmIGIpIF4gKGEgJiBjKSBeIChiICYgYyk7XG5cbi8vIFJvdW5kIGNvbnN0YW50czpcbi8vIGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDY0IHByaW1lcyAyLi4zMTEpXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFNIQTI1Nl9LID0gLyogQF9fUFVSRV9fICovbmV3IFVpbnQzMkFycmF5KFtcbiAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSwgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgMHhkODA3YWE5OCwgMHgxMjgzNWIwMSwgMHgyNDMxODViZSwgMHg1NTBjN2RjMywgMHg3MmJlNWQ3NCwgMHg4MGRlYjFmZSwgMHg5YmRjMDZhNywgMHhjMTliZjE3NCxcbiAgMHhlNDliNjljMSwgMHhlZmJlNDc4NiwgMHgwZmMxOWRjNiwgMHgyNDBjYTFjYywgMHgyZGU5MmM2ZiwgMHg0YTc0ODRhYSwgMHg1Y2IwYTlkYywgMHg3NmY5ODhkYSxcbiAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNywgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgMHgyN2I3MGE4NSwgMHgyZTFiMjEzOCwgMHg0ZDJjNmRmYywgMHg1MzM4MGQxMywgMHg2NTBhNzM1NCwgMHg3NjZhMGFiYiwgMHg4MWMyYzkyZSwgMHg5MjcyMmM4NSxcbiAgMHhhMmJmZThhMSwgMHhhODFhNjY0YiwgMHhjMjRiOGI3MCwgMHhjNzZjNTFhMywgMHhkMTkyZTgxOSwgMHhkNjk5MDYyNCwgMHhmNDBlMzU4NSwgMHgxMDZhYTA3MCxcbiAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgMHg3NDhmODJlZSwgMHg3OGE1NjM2ZiwgMHg4NGM4NzgxNCwgMHg4Y2M3MDIwOCwgMHg5MGJlZmZmYSwgMHhhNDUwNmNlYiwgMHhiZWY5YTNmNywgMHhjNjcxNzhmMlxuXSk7XG5cbi8vIEluaXRpYWwgc3RhdGUgKGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIHNxdWFyZSByb290cyBvZiB0aGUgZmlyc3QgOCBwcmltZXMgMi4uMTkpOlxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBJViA9IC8qIEBfX1BVUkVfXyAqL25ldyBVaW50MzJBcnJheShbXG4gIDB4NmEwOWU2NjcsIDB4YmI2N2FlODUsIDB4M2M2ZWYzNzIsIDB4YTU0ZmY1M2EsIDB4NTEwZTUyN2YsIDB4OWIwNTY4OGMsIDB4MWY4M2Q5YWIsIDB4NWJlMGNkMTlcbl0pO1xuXG4vLyBUZW1wb3JhcnkgYnVmZmVyLCBub3QgdXNlZCB0byBzdG9yZSBhbnl0aGluZyBiZXR3ZWVuIHJ1bnNcbi8vIE5hbWVkIHRoaXMgd2F5IGJlY2F1c2UgaXQgbWF0Y2hlcyBzcGVjaWZpY2F0aW9uLlxuY29uc3QgU0hBMjU2X1cgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDY0KTtcbmNsYXNzIFNIQTI1NiBleHRlbmRzIFNIQTI8U0hBMjU2PiB7XG4gIC8vIFdlIGNhbm5vdCB1c2UgYXJyYXkgaGVyZSBzaW5jZSBhcnJheSBhbGxvd3MgaW5kZXhpbmcgYnkgdmFyaWFibGVcbiAgLy8gd2hpY2ggbWVhbnMgb3B0aW1pemVyL2NvbXBpbGVyIGNhbm5vdCB1c2UgcmVnaXN0ZXJzLlxuICBBID0gSVZbMF0gfCAwO1xuICBCID0gSVZbMV0gfCAwO1xuICBDID0gSVZbMl0gfCAwO1xuICBEID0gSVZbM10gfCAwO1xuICBFID0gSVZbNF0gfCAwO1xuICBGID0gSVZbNV0gfCAwO1xuICBHID0gSVZbNl0gfCAwO1xuICBIID0gSVZbN10gfCAwO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKDY0LCAzMiwgOCwgZmFsc2UpO1xuICB9XG4gIHByb3RlY3RlZCBnZXQoKTogW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyXSB7XG4gICAgY29uc3QgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgIHJldHVybiBbQSwgQiwgQywgRCwgRSwgRiwgRywgSF07XG4gIH1cbiAgLy8gcHJldHRpZXItaWdub3JlXG4gIHByb3RlY3RlZCBzZXQoXG4gICAgQTogbnVtYmVyLCBCOiBudW1iZXIsIEM6IG51bWJlciwgRDogbnVtYmVyLCBFOiBudW1iZXIsIEY6IG51bWJlciwgRzogbnVtYmVyLCBIOiBudW1iZXJcbiAgKSB7XG4gICAgdGhpcy5BID0gQSB8IDA7XG4gICAgdGhpcy5CID0gQiB8IDA7XG4gICAgdGhpcy5DID0gQyB8IDA7XG4gICAgdGhpcy5EID0gRCB8IDA7XG4gICAgdGhpcy5FID0gRSB8IDA7XG4gICAgdGhpcy5GID0gRiB8IDA7XG4gICAgdGhpcy5HID0gRyB8IDA7XG4gICAgdGhpcy5IID0gSCB8IDA7XG4gIH1cbiAgcHJvdGVjdGVkIHByb2Nlc3ModmlldzogRGF0YVZpZXcsIG9mZnNldDogbnVtYmVyKTogdm9pZCB7XG4gICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNDggd29yZHMgd1sxNi4uNjNdIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNCkgU0hBMjU2X1dbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQsIGZhbHNlKTtcbiAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA2NDsgaSsrKSB7XG4gICAgICBjb25zdCBXMTUgPSBTSEEyNTZfV1tpIC0gMTVdO1xuICAgICAgY29uc3QgVzIgPSBTSEEyNTZfV1tpIC0gMl07XG4gICAgICBjb25zdCBzMCA9IHJvdHIoVzE1LCA3KSBeIHJvdHIoVzE1LCAxOCkgXiAoVzE1ID4+PiAzKTtcbiAgICAgIGNvbnN0IHMxID0gcm90cihXMiwgMTcpIF4gcm90cihXMiwgMTkpIF4gKFcyID4+PiAxMCk7XG4gICAgICBTSEEyNTZfV1tpXSA9IChzMSArIFNIQTI1Nl9XW2kgLSA3XSArIHMwICsgU0hBMjU2X1dbaSAtIDE2XSkgfCAwO1xuICAgIH1cbiAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDY0IHJvdW5kc1xuICAgIGxldCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG4gICAgICBjb25zdCBzaWdtYTEgPSByb3RyKEUsIDYpIF4gcm90cihFLCAxMSkgXiByb3RyKEUsIDI1KTtcbiAgICAgIGNvbnN0IFQxID0gKEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEEyNTZfS1tpXSArIFNIQTI1Nl9XW2ldKSB8IDA7XG4gICAgICBjb25zdCBzaWdtYTAgPSByb3RyKEEsIDIpIF4gcm90cihBLCAxMykgXiByb3RyKEEsIDIyKTtcbiAgICAgIGNvbnN0IFQyID0gKHNpZ21hMCArIE1haihBLCBCLCBDKSkgfCAwO1xuICAgICAgSCA9IEc7XG4gICAgICBHID0gRjtcbiAgICAgIEYgPSBFO1xuICAgICAgRSA9IChEICsgVDEpIHwgMDtcbiAgICAgIEQgPSBDO1xuICAgICAgQyA9IEI7XG4gICAgICBCID0gQTtcbiAgICAgIEEgPSAoVDEgKyBUMikgfCAwO1xuICAgIH1cbiAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgIEEgPSAoQSArIHRoaXMuQSkgfCAwO1xuICAgIEIgPSAoQiArIHRoaXMuQikgfCAwO1xuICAgIEMgPSAoQyArIHRoaXMuQykgfCAwO1xuICAgIEQgPSAoRCArIHRoaXMuRCkgfCAwO1xuICAgIEUgPSAoRSArIHRoaXMuRSkgfCAwO1xuICAgIEYgPSAoRiArIHRoaXMuRikgfCAwO1xuICAgIEcgPSAoRyArIHRoaXMuRykgfCAwO1xuICAgIEggPSAoSCArIHRoaXMuSCkgfCAwO1xuICAgIHRoaXMuc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpO1xuICB9XG4gIHByb3RlY3RlZCByb3VuZENsZWFuKCkge1xuICAgIFNIQTI1Nl9XLmZpbGwoMCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICB0aGlzLmJ1ZmZlci5maWxsKDApO1xuICB9XG59XG4vLyBDb25zdGFudHMgZnJvbSBodHRwczovL252bHB1YnMubmlzdC5nb3YvbmlzdHB1YnMvRklQUy9OSVNULkZJUFMuMTgwLTQucGRmXG5jbGFzcyBTSEEyMjQgZXh0ZW5kcyBTSEEyNTYge1xuICBBID0gMHhjMTA1OWVkOCB8IDA7XG4gIEIgPSAweDM2N2NkNTA3IHwgMDtcbiAgQyA9IDB4MzA3MGRkMTcgfCAwO1xuICBEID0gMHhmNzBlNTkzOSB8IDA7XG4gIEUgPSAweGZmYzAwYjMxIHwgMDtcbiAgRiA9IDB4Njg1ODE1MTEgfCAwO1xuICBHID0gMHg2NGY5OGZhNyB8IDA7XG4gIEggPSAweGJlZmE0ZmE0IHwgMDtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm91dHB1dExlbiA9IDI4O1xuICB9XG59XG5cbi8qKlxuICogU0hBMi0yNTYgaGFzaCBmdW5jdGlvblxuICogQHBhcmFtIG1lc3NhZ2UgLSBkYXRhIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydCBjb25zdCBzaGEyNTYgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEEyNTYoKSk7XG5leHBvcnQgY29uc3Qgc2hhMjI0ID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBMjI0KCkpO1xuIiwgIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIDEwMCBsaW5lcyBvZiBjb2RlIGluIHRoZSBmaWxlIGFyZSBkdXBsaWNhdGVkIGZyb20gbm9ibGUtaGFzaGVzICh1dGlscykuXG4vLyBUaGlzIGlzIE9LOiBgYWJzdHJhY3RgIGRpcmVjdG9yeSBkb2VzIG5vdCB1c2Ugbm9ibGUtaGFzaGVzLlxuLy8gVXNlciBtYXkgb3B0LWluIGludG8gdXNpbmcgZGlmZmVyZW50IGhhc2hpbmcgbGlicmFyeS4gVGhpcyB3YXksIG5vYmxlLWhhc2hlc1xuLy8gd29uJ3QgYmUgaW5jbHVkZWQgaW50byB0aGVpciBidW5kbGUuXG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG5jb25zdCBfMm4gPSBCaWdJbnQoMik7XG5jb25zdCB1OGEgPSAoYTogYW55KTogYSBpcyBVaW50OEFycmF5ID0+IGEgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuZXhwb3J0IHR5cGUgSGV4ID0gVWludDhBcnJheSB8IHN0cmluZzsgLy8gaGV4IHN0cmluZ3MgYXJlIGFjY2VwdGVkIGZvciBzaW1wbGljaXR5XG5leHBvcnQgdHlwZSBQcml2S2V5ID0gSGV4IHwgYmlnaW50OyAvLyBiaWdpbnRzIGFyZSBhY2NlcHRlZCB0byBlYXNlIGxlYXJuaW5nIGN1cnZlXG5leHBvcnQgdHlwZSBDSGFzaCA9IHtcbiAgKG1lc3NhZ2U6IFVpbnQ4QXJyYXkgfCBzdHJpbmcpOiBVaW50OEFycmF5O1xuICBibG9ja0xlbjogbnVtYmVyO1xuICBvdXRwdXRMZW46IG51bWJlcjtcbiAgY3JlYXRlKG9wdHM/OiB7IGRrTGVuPzogbnVtYmVyIH0pOiBhbnk7IC8vIEZvciBzaGFrZVxufTtcbmV4cG9ydCB0eXBlIEZIYXNoID0gKG1lc3NhZ2U6IFVpbnQ4QXJyYXkgfCBzdHJpbmcpID0+IFVpbnQ4QXJyYXk7XG5cbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT5cbiAgaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKVxuKTtcbi8qKlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlczogVWludDhBcnJheSk6IHN0cmluZyB7XG4gIGlmICghdThhKGJ5dGVzKSkgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICBsZXQgaGV4ID0gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBoZXggKz0gaGV4ZXNbYnl0ZXNbaV1dO1xuICB9XG4gIHJldHVybiBoZXg7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0hleFVucGFkZGVkKG51bTogbnVtYmVyIHwgYmlnaW50KTogc3RyaW5nIHtcbiAgY29uc3QgaGV4ID0gbnVtLnRvU3RyaW5nKDE2KTtcbiAgcmV0dXJuIGhleC5sZW5ndGggJiAxID8gYDAke2hleH1gIDogaGV4O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9OdW1iZXIoaGV4OiBzdHJpbmcpOiBiaWdpbnQge1xuICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgLy8gQmlnIEVuZGlhblxuICByZXR1cm4gQmlnSW50KGhleCA9PT0gJycgPyAnMCcgOiBgMHgke2hleH1gKTtcbn1cblxuLyoqXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdjYWZlMDEyMycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb0J5dGVzKGhleDogc3RyaW5nKTogVWludDhBcnJheSB7XG4gIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICBjb25zdCBsZW4gPSBoZXgubGVuZ3RoO1xuICBpZiAobGVuICUgMikgdGhyb3cgbmV3IEVycm9yKCdwYWRkZWQgaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGxlbik7XG4gIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkobGVuIC8gMik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBqID0gaSAqIDI7XG4gICAgY29uc3QgaGV4Qnl0ZSA9IGhleC5zbGljZShqLCBqICsgMik7XG4gICAgY29uc3QgYnl0ZSA9IE51bWJlci5wYXJzZUludChoZXhCeXRlLCAxNik7XG4gICAgaWYgKE51bWJlci5pc05hTihieXRlKSB8fCBieXRlIDwgMCkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ5dGUgc2VxdWVuY2UnKTtcbiAgICBhcnJheVtpXSA9IGJ5dGU7XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vLyBCRTogQmlnIEVuZGlhbiwgTEU6IExpdHRsZSBFbmRpYW5cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvTnVtYmVyQkUoYnl0ZXM6IFVpbnQ4QXJyYXkpOiBiaWdpbnQge1xuICByZXR1cm4gaGV4VG9OdW1iZXIoYnl0ZXNUb0hleChieXRlcykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJMRShieXRlczogVWludDhBcnJheSk6IGJpZ2ludCB7XG4gIGlmICghdThhKGJ5dGVzKSkgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gIHJldHVybiBoZXhUb051bWJlcihieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShieXRlcykucmV2ZXJzZSgpKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0J5dGVzQkUobjogbnVtYmVyIHwgYmlnaW50LCBsZW46IG51bWJlcik6IFVpbnQ4QXJyYXkge1xuICByZXR1cm4gaGV4VG9CeXRlcyhuLnRvU3RyaW5nKDE2KS5wYWRTdGFydChsZW4gKiAyLCAnMCcpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0J5dGVzTEUobjogbnVtYmVyIHwgYmlnaW50LCBsZW46IG51bWJlcik6IFVpbnQ4QXJyYXkge1xuICByZXR1cm4gbnVtYmVyVG9CeXRlc0JFKG4sIGxlbikucmV2ZXJzZSgpO1xufVxuLy8gVW5wYWRkZWQsIHJhcmVseSB1c2VkXG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9WYXJCeXRlc0JFKG46IG51bWJlciB8IGJpZ2ludCk6IFVpbnQ4QXJyYXkge1xuICByZXR1cm4gaGV4VG9CeXRlcyhudW1iZXJUb0hleFVucGFkZGVkKG4pKTtcbn1cblxuLyoqXG4gKiBUYWtlcyBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXksIGNvbnZlcnRzIHRvIFVpbnQ4QXJyYXkuXG4gKiBWYWxpZGF0ZXMgb3V0cHV0IGxlbmd0aC5cbiAqIFdpbGwgdGhyb3cgZXJyb3IgZm9yIG90aGVyIHR5cGVzLlxuICogQHBhcmFtIHRpdGxlIGRlc2NyaXB0aXZlIHRpdGxlIGZvciBhbiBlcnJvciBlLmcuICdwcml2YXRlIGtleSdcbiAqIEBwYXJhbSBoZXggaGV4IHN0cmluZyBvciBVaW50OEFycmF5XG4gKiBAcGFyYW0gZXhwZWN0ZWRMZW5ndGggb3B0aW9uYWwsIHdpbGwgY29tcGFyZSB0byByZXN1bHQgYXJyYXkncyBsZW5ndGhcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVCeXRlcyh0aXRsZTogc3RyaW5nLCBoZXg6IEhleCwgZXhwZWN0ZWRMZW5ndGg/OiBudW1iZXIpOiBVaW50OEFycmF5IHtcbiAgbGV0IHJlczogVWludDhBcnJheTtcbiAgaWYgKHR5cGVvZiBoZXggPT09ICdzdHJpbmcnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlcyA9IGhleFRvQnl0ZXMoaGV4KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGl0bGV9IG11c3QgYmUgdmFsaWQgaGV4IHN0cmluZywgZ290IFwiJHtoZXh9XCIuIENhdXNlOiAke2V9YCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHU4YShoZXgpKSB7XG4gICAgLy8gVWludDhBcnJheS5mcm9tKCkgaW5zdGVhZCBvZiBoYXNoLnNsaWNlKCkgYmVjYXVzZSBub2RlLmpzIEJ1ZmZlclxuICAgIC8vIGlzIGluc3RhbmNlIG9mIFVpbnQ4QXJyYXksIGFuZCBpdHMgc2xpY2UoKSBjcmVhdGVzICoqbXV0YWJsZSoqIGNvcHlcbiAgICByZXMgPSBVaW50OEFycmF5LmZyb20oaGV4KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGl0bGV9IG11c3QgYmUgaGV4IHN0cmluZyBvciBVaW50OEFycmF5YCk7XG4gIH1cbiAgY29uc3QgbGVuID0gcmVzLmxlbmd0aDtcbiAgaWYgKHR5cGVvZiBleHBlY3RlZExlbmd0aCA9PT0gJ251bWJlcicgJiYgbGVuICE9PSBleHBlY3RlZExlbmd0aClcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGl0bGV9IGV4cGVjdGVkICR7ZXhwZWN0ZWRMZW5ndGh9IGJ5dGVzLCBnb3QgJHtsZW59YCk7XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogQ29waWVzIHNldmVyYWwgVWludDhBcnJheXMgaW50byBvbmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXM6IFVpbnQ4QXJyYXlbXSk6IFVpbnQ4QXJyYXkge1xuICBjb25zdCByID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlzLnJlZHVjZSgoc3VtLCBhKSA9PiBzdW0gKyBhLmxlbmd0aCwgMCkpO1xuICBsZXQgcGFkID0gMDsgLy8gd2FsayB0aHJvdWdoIGVhY2ggaXRlbSwgZW5zdXJlIHRoZXkgaGF2ZSBwcm9wZXIgdHlwZVxuICBhcnJheXMuZm9yRWFjaCgoYSkgPT4ge1xuICAgIGlmICghdThhKGEpKSB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICByLnNldChhLCBwYWQpO1xuICAgIHBhZCArPSBhLmxlbmd0aDtcbiAgfSk7XG4gIHJldHVybiByO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxCeXRlcyhiMTogVWludDhBcnJheSwgYjI6IFVpbnQ4QXJyYXkpIHtcbiAgLy8gV2UgZG9uJ3QgY2FyZSBhYm91dCB0aW1pbmcgYXR0YWNrcyBoZXJlXG4gIGlmIChiMS5sZW5ndGggIT09IGIyLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGIxLmxlbmd0aDsgaSsrKSBpZiAoYjFbaV0gIT09IGIyW2ldKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBHbG9iYWwgc3ltYm9scyBpbiBib3RoIGJyb3dzZXJzIGFuZCBOb2RlLmpzIHNpbmNlIHYxMVxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMzE1MzVcbmRlY2xhcmUgY29uc3QgVGV4dEVuY29kZXI6IGFueTtcblxuLyoqXG4gKiBAZXhhbXBsZSB1dGY4VG9CeXRlcygnYWJjJykgLy8gbmV3IFVpbnQ4QXJyYXkoWzk3LCA5OCwgOTldKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyOiBzdHJpbmcpOiBVaW50OEFycmF5IHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB0aHJvdyBuZXcgRXJyb3IoYHV0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN0cn1gKTtcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTsgLy8gaHR0cHM6Ly9idWd6aWwubGEvMTY4MTgwOVxufVxuXG4vLyBCaXQgb3BlcmF0aW9uc1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgYW1vdW50IG9mIGJpdHMgaW4gYSBiaWdpbnQuXG4gKiBTYW1lIGFzIGBuLnRvU3RyaW5nKDIpLmxlbmd0aGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpdExlbihuOiBiaWdpbnQpIHtcbiAgbGV0IGxlbjtcbiAgZm9yIChsZW4gPSAwOyBuID4gXzBuOyBuID4+PSBfMW4sIGxlbiArPSAxKTtcbiAgcmV0dXJuIGxlbjtcbn1cblxuLyoqXG4gKiBHZXRzIHNpbmdsZSBiaXQgYXQgcG9zaXRpb24uXG4gKiBOT1RFOiBmaXJzdCBiaXQgcG9zaXRpb24gaXMgMCAoc2FtZSBhcyBhcnJheXMpXG4gKiBTYW1lIGFzIGAhIStBcnJheS5mcm9tKG4udG9TdHJpbmcoMikpLnJldmVyc2UoKVtwb3NdYFxuICovXG5leHBvcnQgZnVuY3Rpb24gYml0R2V0KG46IGJpZ2ludCwgcG9zOiBudW1iZXIpIHtcbiAgcmV0dXJuIChuID4+IEJpZ0ludChwb3MpKSAmIF8xbjtcbn1cblxuLyoqXG4gKiBTZXRzIHNpbmdsZSBiaXQgYXQgcG9zaXRpb24uXG4gKi9cbmV4cG9ydCBjb25zdCBiaXRTZXQgPSAobjogYmlnaW50LCBwb3M6IG51bWJlciwgdmFsdWU6IGJvb2xlYW4pID0+IHtcbiAgcmV0dXJuIG4gfCAoKHZhbHVlID8gXzFuIDogXzBuKSA8PCBCaWdJbnQocG9zKSk7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZSBtYXNrIGZvciBOIGJpdHMuIE5vdCB1c2luZyAqKiBvcGVyYXRvciB3aXRoIGJpZ2ludHMgYmVjYXVzZSBvZiBvbGQgZW5naW5lcy5cbiAqIFNhbWUgYXMgQmlnSW50KGAwYiR7QXJyYXkoaSkuZmlsbCgnMScpLmpvaW4oJycpfWApXG4gKi9cbmV4cG9ydCBjb25zdCBiaXRNYXNrID0gKG46IG51bWJlcikgPT4gKF8ybiA8PCBCaWdJbnQobiAtIDEpKSAtIF8xbjtcblxuLy8gRFJCR1xuXG5jb25zdCB1OG4gPSAoZGF0YT86IGFueSkgPT4gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7IC8vIGNyZWF0ZXMgVWludDhBcnJheVxuY29uc3QgdThmciA9IChhcnI6IGFueSkgPT4gVWludDhBcnJheS5mcm9tKGFycik7IC8vIGFub3RoZXIgc2hvcnRjdXRcbnR5cGUgUHJlZDxUPiA9ICh2OiBVaW50OEFycmF5KSA9PiBUIHwgdW5kZWZpbmVkO1xuLyoqXG4gKiBNaW5pbWFsIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gKiBAcmV0dXJucyBmdW5jdGlvbiB0aGF0IHdpbGwgY2FsbCBEUkJHIHVudGlsIDJuZCBhcmcgcmV0dXJucyBzb21ldGhpbmcgbWVhbmluZ2Z1bFxuICogQGV4YW1wbGVcbiAqICAgY29uc3QgZHJiZyA9IGNyZWF0ZUhtYWNEUkJHPEtleT4oMzIsIDMyLCBobWFjKTtcbiAqICAgZHJiZyhzZWVkLCBieXRlc1RvS2V5KTsgLy8gYnl0ZXNUb0tleSBtdXN0IHJldHVybiBLZXkgb3IgdW5kZWZpbmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIbWFjRHJiZzxUPihcbiAgaGFzaExlbjogbnVtYmVyLFxuICBxQnl0ZUxlbjogbnVtYmVyLFxuICBobWFjRm46IChrZXk6IFVpbnQ4QXJyYXksIC4uLm1lc3NhZ2VzOiBVaW50OEFycmF5W10pID0+IFVpbnQ4QXJyYXlcbik6IChzZWVkOiBVaW50OEFycmF5LCBwcmVkaWNhdGU6IFByZWQ8VD4pID0+IFQge1xuICBpZiAodHlwZW9mIGhhc2hMZW4gIT09ICdudW1iZXInIHx8IGhhc2hMZW4gPCAyKSB0aHJvdyBuZXcgRXJyb3IoJ2hhc2hMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICBpZiAodHlwZW9mIHFCeXRlTGVuICE9PSAnbnVtYmVyJyB8fCBxQnl0ZUxlbiA8IDIpIHRocm93IG5ldyBFcnJvcigncUJ5dGVMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICBpZiAodHlwZW9mIGhtYWNGbiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVycm9yKCdobWFjRm4gbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIC8vIFN0ZXAgQiwgU3RlcCBDOiBzZXQgaGFzaExlbiB0byA4KmNlaWwoaGxlbi84KVxuICBsZXQgdiA9IHU4bihoYXNoTGVuKTsgLy8gTWluaW1hbCBub24tZnVsbC1zcGVjIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gIGxldCBrID0gdThuKGhhc2hMZW4pOyAvLyBTdGVwcyBCIGFuZCBDIG9mIFJGQzY5NzkgMy4yOiBzZXQgaGFzaExlbiwgaW4gb3VyIGNhc2UgYWx3YXlzIHNhbWVcbiAgbGV0IGkgPSAwOyAvLyBJdGVyYXRpb25zIGNvdW50ZXIsIHdpbGwgdGhyb3cgd2hlbiBvdmVyIDEwMDBcbiAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgdi5maWxsKDEpO1xuICAgIGsuZmlsbCgwKTtcbiAgICBpID0gMDtcbiAgfTtcbiAgY29uc3QgaCA9ICguLi5iOiBVaW50OEFycmF5W10pID0+IGhtYWNGbihrLCB2LCAuLi5iKTsgLy8gaG1hYyhrKSh2LCAuLi52YWx1ZXMpXG4gIGNvbnN0IHJlc2VlZCA9IChzZWVkID0gdThuKCkpID0+IHtcbiAgICAvLyBITUFDLURSQkcgcmVzZWVkKCkgZnVuY3Rpb24uIFN0ZXBzIEQtR1xuICAgIGsgPSBoKHU4ZnIoWzB4MDBdKSwgc2VlZCk7IC8vIGsgPSBobWFjKGsgfHwgdiB8fCAweDAwIHx8IHNlZWQpXG4gICAgdiA9IGgoKTsgLy8gdiA9IGhtYWMoayB8fCB2KVxuICAgIGlmIChzZWVkLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIGsgPSBoKHU4ZnIoWzB4MDFdKSwgc2VlZCk7IC8vIGsgPSBobWFjKGsgfHwgdiB8fCAweDAxIHx8IHNlZWQpXG4gICAgdiA9IGgoKTsgLy8gdiA9IGhtYWMoayB8fCB2KVxuICB9O1xuICBjb25zdCBnZW4gPSAoKSA9PiB7XG4gICAgLy8gSE1BQy1EUkJHIGdlbmVyYXRlKCkgZnVuY3Rpb25cbiAgICBpZiAoaSsrID49IDEwMDApIHRocm93IG5ldyBFcnJvcignZHJiZzogdHJpZWQgMTAwMCB2YWx1ZXMnKTtcbiAgICBsZXQgbGVuID0gMDtcbiAgICBjb25zdCBvdXQ6IFVpbnQ4QXJyYXlbXSA9IFtdO1xuICAgIHdoaWxlIChsZW4gPCBxQnl0ZUxlbikge1xuICAgICAgdiA9IGgoKTtcbiAgICAgIGNvbnN0IHNsID0gdi5zbGljZSgpO1xuICAgICAgb3V0LnB1c2goc2wpO1xuICAgICAgbGVuICs9IHYubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gY29uY2F0Qnl0ZXMoLi4ub3V0KTtcbiAgfTtcbiAgY29uc3QgZ2VuVW50aWwgPSAoc2VlZDogVWludDhBcnJheSwgcHJlZDogUHJlZDxUPik6IFQgPT4ge1xuICAgIHJlc2V0KCk7XG4gICAgcmVzZWVkKHNlZWQpOyAvLyBTdGVwcyBELUdcbiAgICBsZXQgcmVzOiBUIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkOyAvLyBTdGVwIEg6IGdyaW5kIHVudGlsIGsgaXMgaW4gWzEuLm4tMV1cbiAgICB3aGlsZSAoIShyZXMgPSBwcmVkKGdlbigpKSkpIHJlc2VlZCgpO1xuICAgIHJlc2V0KCk7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbiAgcmV0dXJuIGdlblVudGlsO1xufVxuXG4vLyBWYWxpZGF0aW5nIGN1cnZlcyBhbmQgZmllbGRzXG5cbmNvbnN0IHZhbGlkYXRvckZucyA9IHtcbiAgYmlnaW50OiAodmFsOiBhbnkpID0+IHR5cGVvZiB2YWwgPT09ICdiaWdpbnQnLFxuICBmdW5jdGlvbjogKHZhbDogYW55KSA9PiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nLFxuICBib29sZWFuOiAodmFsOiBhbnkpID0+IHR5cGVvZiB2YWwgPT09ICdib29sZWFuJyxcbiAgc3RyaW5nOiAodmFsOiBhbnkpID0+IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnLFxuICBzdHJpbmdPclVpbnQ4QXJyYXk6ICh2YWw6IGFueSkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgfHwgdmFsIGluc3RhbmNlb2YgVWludDhBcnJheSxcbiAgaXNTYWZlSW50ZWdlcjogKHZhbDogYW55KSA9PiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWwpLFxuICBhcnJheTogKHZhbDogYW55KSA9PiBBcnJheS5pc0FycmF5KHZhbCksXG4gIGZpZWxkOiAodmFsOiBhbnksIG9iamVjdDogYW55KSA9PiAob2JqZWN0IGFzIGFueSkuRnAuaXNWYWxpZCh2YWwpLFxuICBoYXNoOiAodmFsOiBhbnkpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicgJiYgTnVtYmVyLmlzU2FmZUludGVnZXIodmFsLm91dHB1dExlbiksXG59IGFzIGNvbnN0O1xudHlwZSBWYWxpZGF0b3IgPSBrZXlvZiB0eXBlb2YgdmFsaWRhdG9yRm5zO1xudHlwZSBWYWxNYXA8VCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIGFueT4+ID0geyBbSyBpbiBrZXlvZiBUXT86IFZhbGlkYXRvciB9O1xuLy8gdHlwZSBSZWNvcmQ8SyBleHRlbmRzIHN0cmluZyB8IG51bWJlciB8IHN5bWJvbCwgVD4gPSB7IFtQIGluIEtdOiBUOyB9XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZU9iamVjdDxUIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55Pj4oXG4gIG9iamVjdDogVCxcbiAgdmFsaWRhdG9yczogVmFsTWFwPFQ+LFxuICBvcHRWYWxpZGF0b3JzOiBWYWxNYXA8VD4gPSB7fVxuKSB7XG4gIGNvbnN0IGNoZWNrRmllbGQgPSAoZmllbGROYW1lOiBrZXlvZiBULCB0eXBlOiBWYWxpZGF0b3IsIGlzT3B0aW9uYWw6IGJvb2xlYW4pID0+IHtcbiAgICBjb25zdCBjaGVja1ZhbCA9IHZhbGlkYXRvckZuc1t0eXBlXTtcbiAgICBpZiAodHlwZW9mIGNoZWNrVmFsICE9PSAnZnVuY3Rpb24nKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHZhbGlkYXRvciBcIiR7dHlwZX1cIiwgZXhwZWN0ZWQgZnVuY3Rpb25gKTtcblxuICAgIGNvbnN0IHZhbCA9IG9iamVjdFtmaWVsZE5hbWUgYXMga2V5b2YgdHlwZW9mIG9iamVjdF07XG4gICAgaWYgKGlzT3B0aW9uYWwgJiYgdmFsID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICBpZiAoIWNoZWNrVmFsKHZhbCwgb2JqZWN0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW52YWxpZCBwYXJhbSAke1N0cmluZyhmaWVsZE5hbWUpfT0ke3ZhbH0gKCR7dHlwZW9mIHZhbH0pLCBleHBlY3RlZCAke3R5cGV9YFxuICAgICAgKTtcbiAgICB9XG4gIH07XG4gIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgdHlwZV0gb2YgT2JqZWN0LmVudHJpZXModmFsaWRhdG9ycykpIGNoZWNrRmllbGQoZmllbGROYW1lLCB0eXBlISwgZmFsc2UpO1xuICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIHR5cGVdIG9mIE9iamVjdC5lbnRyaWVzKG9wdFZhbGlkYXRvcnMpKSBjaGVja0ZpZWxkKGZpZWxkTmFtZSwgdHlwZSEsIHRydWUpO1xuICByZXR1cm4gb2JqZWN0O1xufVxuLy8gdmFsaWRhdGUgdHlwZSB0ZXN0c1xuLy8gY29uc3QgbzogeyBhOiBudW1iZXI7IGI6IG51bWJlcjsgYzogbnVtYmVyIH0gPSB7IGE6IDEsIGI6IDUsIGM6IDYgfTtcbi8vIGNvbnN0IHowID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnaXNTYWZlSW50ZWdlcicgfSwgeyBjOiAnYmlnaW50JyB9KTsgLy8gT2shXG4vLyAvLyBTaG91bGQgZmFpbCB0eXBlLWNoZWNrXG4vLyBjb25zdCB6MSA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ3RtcCcgfSwgeyBjOiAnenonIH0pO1xuLy8gY29uc3QgejIgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdpc1NhZmVJbnRlZ2VyJyB9LCB7IGM6ICd6eicgfSk7XG4vLyBjb25zdCB6MyA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgdGVzdDogJ2Jvb2xlYW4nLCB6OiAnYnVnJyB9KTtcbi8vIGNvbnN0IHo0ID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnYm9vbGVhbicsIHo6ICdidWcnIH0pO1xuIiwgIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFV0aWxpdGllcyBmb3IgbW9kdWxhciBhcml0aG1ldGljcyBhbmQgZmluaXRlIGZpZWxkc1xuaW1wb3J0IHtcbiAgYml0TWFzayxcbiAgbnVtYmVyVG9CeXRlc0JFLFxuICBudW1iZXJUb0J5dGVzTEUsXG4gIGJ5dGVzVG9OdW1iZXJCRSxcbiAgYnl0ZXNUb051bWJlckxFLFxuICBlbnN1cmVCeXRlcyxcbiAgdmFsaWRhdGVPYmplY3QsXG59IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfMG4gPSBCaWdJbnQoMCksIF8xbiA9IEJpZ0ludCgxKSwgXzJuID0gQmlnSW50KDIpLCBfM24gPSBCaWdJbnQoMyk7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF80biA9IEJpZ0ludCg0KSwgXzVuID0gQmlnSW50KDUpLCBfOG4gPSBCaWdJbnQoOCk7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF85biA9IEJpZ0ludCg5KSwgXzE2biA9IEJpZ0ludCgxNik7XG5cbi8vIENhbGN1bGF0ZXMgYSBtb2R1bG8gYlxuZXhwb3J0IGZ1bmN0aW9uIG1vZChhOiBiaWdpbnQsIGI6IGJpZ2ludCk6IGJpZ2ludCB7XG4gIGNvbnN0IHJlc3VsdCA9IGEgJSBiO1xuICByZXR1cm4gcmVzdWx0ID49IF8wbiA/IHJlc3VsdCA6IGIgKyByZXN1bHQ7XG59XG4vKipcbiAqIEVmZmljaWVudGx5IHJhaXNlIG51bSB0byBwb3dlciBhbmQgZG8gbW9kdWxhciBkaXZpc2lvbi5cbiAqIFVuc2FmZSBpbiBzb21lIGNvbnRleHRzOiB1c2VzIGxhZGRlciwgc28gY2FuIGV4cG9zZSBiaWdpbnQgYml0cy5cbiAqIEBleGFtcGxlXG4gKiBwb3coMm4sIDZuLCAxMW4pIC8vIDY0biAlIDExbiA9PSA5blxuICovXG4vLyBUT0RPOiB1c2UgZmllbGQgdmVyc2lvbiAmJiByZW1vdmVcbmV4cG9ydCBmdW5jdGlvbiBwb3cobnVtOiBiaWdpbnQsIHBvd2VyOiBiaWdpbnQsIG1vZHVsbzogYmlnaW50KTogYmlnaW50IHtcbiAgaWYgKG1vZHVsbyA8PSBfMG4gfHwgcG93ZXIgPCBfMG4pIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcG93ZXIvbW9kdWxvID4gMCcpO1xuICBpZiAobW9kdWxvID09PSBfMW4pIHJldHVybiBfMG47XG4gIGxldCByZXMgPSBfMW47XG4gIHdoaWxlIChwb3dlciA+IF8wbikge1xuICAgIGlmIChwb3dlciAmIF8xbikgcmVzID0gKHJlcyAqIG51bSkgJSBtb2R1bG87XG4gICAgbnVtID0gKG51bSAqIG51bSkgJSBtb2R1bG87XG4gICAgcG93ZXIgPj49IF8xbjtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vLyBEb2VzIHggXiAoMiBeIHBvd2VyKSBtb2QgcC4gcG93MigzMCwgNCkgPT0gMzAgXiAoMiBeIDQpXG5leHBvcnQgZnVuY3Rpb24gcG93Mih4OiBiaWdpbnQsIHBvd2VyOiBiaWdpbnQsIG1vZHVsbzogYmlnaW50KTogYmlnaW50IHtcbiAgbGV0IHJlcyA9IHg7XG4gIHdoaWxlIChwb3dlci0tID4gXzBuKSB7XG4gICAgcmVzICo9IHJlcztcbiAgICByZXMgJT0gbW9kdWxvO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vIEludmVyc2VzIG51bWJlciBvdmVyIG1vZHVsb1xuZXhwb3J0IGZ1bmN0aW9uIGludmVydChudW1iZXI6IGJpZ2ludCwgbW9kdWxvOiBiaWdpbnQpOiBiaWdpbnQge1xuICBpZiAobnVtYmVyID09PSBfMG4gfHwgbW9kdWxvIDw9IF8wbikge1xuICAgIHRocm93IG5ldyBFcnJvcihgaW52ZXJ0OiBleHBlY3RlZCBwb3NpdGl2ZSBpbnRlZ2VycywgZ290IG49JHtudW1iZXJ9IG1vZD0ke21vZHVsb31gKTtcbiAgfVxuICAvLyBFdWNsaWRlYW4gR0NEIGh0dHBzOi8vYnJpbGxpYW50Lm9yZy93aWtpL2V4dGVuZGVkLWV1Y2xpZGVhbi1hbGdvcml0aG0vXG4gIC8vIEZlcm1hdCdzIGxpdHRsZSB0aGVvcmVtIFwiQ1QtbGlrZVwiIHZlcnNpb24gaW52KG4pID0gbl4obS0yKSBtb2QgbSBpcyAzMHggc2xvd2VyLlxuICBsZXQgYSA9IG1vZChudW1iZXIsIG1vZHVsbyk7XG4gIGxldCBiID0gbW9kdWxvO1xuICAvLyBwcmV0dGllci1pZ25vcmVcbiAgbGV0IHggPSBfMG4sIHkgPSBfMW4sIHUgPSBfMW4sIHYgPSBfMG47XG4gIHdoaWxlIChhICE9PSBfMG4pIHtcbiAgICAvLyBKSVQgYXBwbGllcyBvcHRpbWl6YXRpb24gaWYgdGhvc2UgdHdvIGxpbmVzIGZvbGxvdyBlYWNoIG90aGVyXG4gICAgY29uc3QgcSA9IGIgLyBhO1xuICAgIGNvbnN0IHIgPSBiICUgYTtcbiAgICBjb25zdCBtID0geCAtIHUgKiBxO1xuICAgIGNvbnN0IG4gPSB5IC0gdiAqIHE7XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgYiA9IGEsIGEgPSByLCB4ID0gdSwgeSA9IHYsIHUgPSBtLCB2ID0gbjtcbiAgfVxuICBjb25zdCBnY2QgPSBiO1xuICBpZiAoZ2NkICE9PSBfMW4pIHRocm93IG5ldyBFcnJvcignaW52ZXJ0OiBkb2VzIG5vdCBleGlzdCcpO1xuICByZXR1cm4gbW9kKHgsIG1vZHVsbyk7XG59XG5cbi8qKlxuICogVG9uZWxsaS1TaGFua3Mgc3F1YXJlIHJvb3Qgc2VhcmNoIGFsZ29yaXRobS5cbiAqIDEuIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZiAocGFnZSAxMilcbiAqIDIuIFNxdWFyZSBSb290cyBmcm9tIDE7IDI0LCA1MSwgMTAgdG8gRGFuIFNoYW5rc1xuICogV2lsbCBzdGFydCBhbiBpbmZpbml0ZSBsb29wIGlmIGZpZWxkIG9yZGVyIFAgaXMgbm90IHByaW1lLlxuICogQHBhcmFtIFAgZmllbGQgb3JkZXJcbiAqIEByZXR1cm5zIGZ1bmN0aW9uIHRoYXQgdGFrZXMgZmllbGQgRnAgKGNyZWF0ZWQgZnJvbSBQKSBhbmQgbnVtYmVyIG5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvbmVsbGlTaGFua3MoUDogYmlnaW50KSB7XG4gIC8vIExlZ2VuZHJlIGNvbnN0YW50OiB1c2VkIHRvIGNhbGN1bGF0ZSBMZWdlbmRyZSBzeW1ib2wgKGEgfCBwKSxcbiAgLy8gd2hpY2ggZGVub3RlcyB0aGUgdmFsdWUgb2YgYV4oKHAtMSkvMikgKG1vZCBwKS5cbiAgLy8gKGEgfCBwKSBcdTIyNjEgMSAgICBpZiBhIGlzIGEgc3F1YXJlIChtb2QgcClcbiAgLy8gKGEgfCBwKSBcdTIyNjEgLTEgICBpZiBhIGlzIG5vdCBhIHNxdWFyZSAobW9kIHApXG4gIC8vIChhIHwgcCkgXHUyMjYxIDAgICAgaWYgYSBcdTIyNjEgMCAobW9kIHApXG4gIGNvbnN0IGxlZ2VuZHJlQyA9IChQIC0gXzFuKSAvIF8ybjtcblxuICBsZXQgUTogYmlnaW50LCBTOiBudW1iZXIsIFo6IGJpZ2ludDtcbiAgLy8gU3RlcCAxOiBCeSBmYWN0b3Jpbmcgb3V0IHBvd2VycyBvZiAyIGZyb20gcCAtIDEsXG4gIC8vIGZpbmQgcSBhbmQgcyBzdWNoIHRoYXQgcCAtIDEgPSBxKigyXnMpIHdpdGggcSBvZGRcbiAgZm9yIChRID0gUCAtIF8xbiwgUyA9IDA7IFEgJSBfMm4gPT09IF8wbjsgUSAvPSBfMm4sIFMrKyk7XG5cbiAgLy8gU3RlcCAyOiBTZWxlY3QgYSBub24tc3F1YXJlIHogc3VjaCB0aGF0ICh6IHwgcCkgXHUyMjYxIC0xIGFuZCBzZXQgYyBcdTIyNjEgenFcbiAgZm9yIChaID0gXzJuOyBaIDwgUCAmJiBwb3coWiwgbGVnZW5kcmVDLCBQKSAhPT0gUCAtIF8xbjsgWisrKTtcblxuICAvLyBGYXN0LXBhdGhcbiAgaWYgKFMgPT09IDEpIHtcbiAgICBjb25zdCBwMWRpdjQgPSAoUCArIF8xbikgLyBfNG47XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHRvbmVsbGlGYXN0PFQ+KEZwOiBJRmllbGQ8VD4sIG46IFQpIHtcbiAgICAgIGNvbnN0IHJvb3QgPSBGcC5wb3cobiwgcDFkaXY0KTtcbiAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgIHJldHVybiByb290O1xuICAgIH07XG4gIH1cblxuICAvLyBTbG93LXBhdGhcbiAgY29uc3QgUTFkaXYyID0gKFEgKyBfMW4pIC8gXzJuO1xuICByZXR1cm4gZnVuY3Rpb24gdG9uZWxsaVNsb3c8VD4oRnA6IElGaWVsZDxUPiwgbjogVCk6IFQge1xuICAgIC8vIFN0ZXAgMDogQ2hlY2sgdGhhdCBuIGlzIGluZGVlZCBhIHNxdWFyZTogKG4gfCBwKSBzaG91bGQgbm90IGJlIFx1MjI2MSAtMVxuICAgIGlmIChGcC5wb3cobiwgbGVnZW5kcmVDKSA9PT0gRnAubmVnKEZwLk9ORSkpIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICBsZXQgciA9IFM7XG4gICAgLy8gVE9ETzogd2lsbCBmYWlsIGF0IEZwMi9ldGNcbiAgICBsZXQgZyA9IEZwLnBvdyhGcC5tdWwoRnAuT05FLCBaKSwgUSk7IC8vIHdpbGwgdXBkYXRlIGJvdGggeCBhbmQgYlxuICAgIGxldCB4ID0gRnAucG93KG4sIFExZGl2Mik7IC8vIGZpcnN0IGd1ZXNzIGF0IHRoZSBzcXVhcmUgcm9vdFxuICAgIGxldCBiID0gRnAucG93KG4sIFEpOyAvLyBmaXJzdCBndWVzcyBhdCB0aGUgZnVkZ2UgZmFjdG9yXG5cbiAgICB3aGlsZSAoIUZwLmVxbChiLCBGcC5PTkUpKSB7XG4gICAgICBpZiAoRnAuZXFsKGIsIEZwLlpFUk8pKSByZXR1cm4gRnAuWkVSTzsgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVG9uZWxsaSVFMiU4MCU5M1NoYW5rc19hbGdvcml0aG0gKDQuIElmIHQgPSAwLCByZXR1cm4gciA9IDApXG4gICAgICAvLyBGaW5kIG0gc3VjaCBiXigyXm0pPT0xXG4gICAgICBsZXQgbSA9IDE7XG4gICAgICBmb3IgKGxldCB0MiA9IEZwLnNxcihiKTsgbSA8IHI7IG0rKykge1xuICAgICAgICBpZiAoRnAuZXFsKHQyLCBGcC5PTkUpKSBicmVhaztcbiAgICAgICAgdDIgPSBGcC5zcXIodDIpOyAvLyB0MiAqPSB0MlxuICAgICAgfVxuICAgICAgLy8gTk9URTogci1tLTEgY2FuIGJlIGJpZ2dlciB0aGFuIDMyLCBuZWVkIHRvIGNvbnZlcnQgdG8gYmlnaW50IGJlZm9yZSBzaGlmdCwgb3RoZXJ3aXNlIHRoZXJlIHdpbGwgYmUgb3ZlcmZsb3dcbiAgICAgIGNvbnN0IGdlID0gRnAucG93KGcsIF8xbiA8PCBCaWdJbnQociAtIG0gLSAxKSk7IC8vIGdlID0gMl4oci1tLTEpXG4gICAgICBnID0gRnAuc3FyKGdlKTsgLy8gZyA9IGdlICogZ2VcbiAgICAgIHggPSBGcC5tdWwoeCwgZ2UpOyAvLyB4ICo9IGdlXG4gICAgICBiID0gRnAubXVsKGIsIGcpOyAvLyBiICo9IGdcbiAgICAgIHIgPSBtO1xuICAgIH1cbiAgICByZXR1cm4geDtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEZwU3FydChQOiBiaWdpbnQpIHtcbiAgLy8gTk9URTogZGlmZmVyZW50IGFsZ29yaXRobXMgY2FuIGdpdmUgZGlmZmVyZW50IHJvb3RzLCBpdCBpcyB1cCB0byB1c2VyIHRvIGRlY2lkZSB3aGljaCBvbmUgdGhleSB3YW50LlxuICAvLyBGb3IgZXhhbXBsZSB0aGVyZSBpcyBGcFNxcnRPZGQvRnBTcXJ0RXZlbiB0byBjaG9pY2Ugcm9vdCBiYXNlZCBvbiBvZGRuZXNzICh1c2VkIGZvciBoYXNoLXRvLWN1cnZlKS5cblxuICAvLyBQIFx1MjI2MSAzIChtb2QgNClcbiAgLy8gXHUyMjFBbiA9IG5eKChQKzEpLzQpXG4gIGlmIChQICUgXzRuID09PSBfM24pIHtcbiAgICAvLyBOb3QgYWxsIHJvb3RzIHBvc3NpYmxlIVxuICAgIC8vIGNvbnN0IE9SREVSID1cbiAgICAvLyAgIDB4MWEwMTExZWEzOTdmZTY5YTRiMWJhN2I2NDM0YmFjZDc2NDc3NGI4NGYzODUxMmJmNjczMGQyYTBmNmIwZjYyNDFlYWJmZmZlYjE1M2ZmZmZiOWZlZmZmZmZmZmZhYWFibjtcbiAgICAvLyBjb25zdCBOVU0gPSA3MjA1NzU5NDAzNzkyNzgxNm47XG4gICAgY29uc3QgcDFkaXY0ID0gKFAgKyBfMW4pIC8gXzRuO1xuICAgIHJldHVybiBmdW5jdGlvbiBzcXJ0M21vZDQ8VD4oRnA6IElGaWVsZDxUPiwgbjogVCkge1xuICAgICAgY29uc3Qgcm9vdCA9IEZwLnBvdyhuLCBwMWRpdjQpO1xuICAgICAgLy8gVGhyb3cgaWYgcm9vdCoqMiAhPSBuXG4gICAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICByZXR1cm4gcm9vdDtcbiAgICB9O1xuICB9XG5cbiAgLy8gQXRraW4gYWxnb3JpdGhtIGZvciBxIFx1MjI2MSA1IChtb2QgOCksIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZiAocGFnZSAxMClcbiAgaWYgKFAgJSBfOG4gPT09IF81bikge1xuICAgIGNvbnN0IGMxID0gKFAgLSBfNW4pIC8gXzhuO1xuICAgIHJldHVybiBmdW5jdGlvbiBzcXJ0NW1vZDg8VD4oRnA6IElGaWVsZDxUPiwgbjogVCkge1xuICAgICAgY29uc3QgbjIgPSBGcC5tdWwobiwgXzJuKTtcbiAgICAgIGNvbnN0IHYgPSBGcC5wb3cobjIsIGMxKTtcbiAgICAgIGNvbnN0IG52ID0gRnAubXVsKG4sIHYpO1xuICAgICAgY29uc3QgaSA9IEZwLm11bChGcC5tdWwobnYsIF8ybiksIHYpO1xuICAgICAgY29uc3Qgcm9vdCA9IEZwLm11bChudiwgRnAuc3ViKGksIEZwLk9ORSkpO1xuICAgICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSkgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfTtcbiAgfVxuXG4gIC8vIFAgXHUyMjYxIDkgKG1vZCAxNilcbiAgaWYgKFAgJSBfMTZuID09PSBfOW4pIHtcbiAgICAvLyBOT1RFOiB0b25lbGxpIGlzIHRvbyBzbG93IGZvciBibHMtRnAyIGNhbGN1bGF0aW9ucyBldmVuIG9uIHN0YXJ0XG4gICAgLy8gTWVhbnMgd2UgY2Fubm90IHVzZSBzcXJ0IGZvciBjb25zdGFudHMgYXQgYWxsIVxuICAgIC8vXG4gICAgLy8gY29uc3QgYzEgPSBGcC5zcXJ0KEZwLm5lZ2F0ZShGcC5PTkUpKTsgLy8gIDEuIGMxID0gc3FydCgtMSkgaW4gRiwgaS5lLiwgKGMxXjIpID09IC0xIGluIEZcbiAgICAvLyBjb25zdCBjMiA9IEZwLnNxcnQoYzEpOyAgICAgICAgICAgICAgICAvLyAgMi4gYzIgPSBzcXJ0KGMxKSBpbiBGLCBpLmUuLCAoYzJeMikgPT0gYzEgaW4gRlxuICAgIC8vIGNvbnN0IGMzID0gRnAuc3FydChGcC5uZWdhdGUoYzEpKTsgICAgIC8vICAzLiBjMyA9IHNxcnQoLWMxKSBpbiBGLCBpLmUuLCAoYzNeMikgPT0gLWMxIGluIEZcbiAgICAvLyBjb25zdCBjNCA9IChQICsgXzduKSAvIF8xNm47ICAgICAgICAgICAvLyAgNC4gYzQgPSAocSArIDcpIC8gMTYgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgLy8gc3FydCA9ICh4KSA9PiB7XG4gICAgLy8gICBsZXQgdHYxID0gRnAucG93KHgsIGM0KTsgICAgICAgICAgICAgLy8gIDEuIHR2MSA9IHheYzRcbiAgICAvLyAgIGxldCB0djIgPSBGcC5tdWwoYzEsIHR2MSk7ICAgICAgICAgICAvLyAgMi4gdHYyID0gYzEgKiB0djFcbiAgICAvLyAgIGNvbnN0IHR2MyA9IEZwLm11bChjMiwgdHYxKTsgICAgICAgICAvLyAgMy4gdHYzID0gYzIgKiB0djFcbiAgICAvLyAgIGxldCB0djQgPSBGcC5tdWwoYzMsIHR2MSk7ICAgICAgICAgICAvLyAgNC4gdHY0ID0gYzMgKiB0djFcbiAgICAvLyAgIGNvbnN0IGUxID0gRnAuZXF1YWxzKEZwLnNxdWFyZSh0djIpLCB4KTsgLy8gIDUuICBlMSA9ICh0djJeMikgPT0geFxuICAgIC8vICAgY29uc3QgZTIgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MyksIHgpOyAvLyAgNi4gIGUyID0gKHR2M14yKSA9PSB4XG4gICAgLy8gICB0djEgPSBGcC5jbW92KHR2MSwgdHYyLCBlMSk7IC8vICA3LiB0djEgPSBDTU9WKHR2MSwgdHYyLCBlMSkgICMgU2VsZWN0IHR2MiBpZiAodHYyXjIpID09IHhcbiAgICAvLyAgIHR2MiA9IEZwLmNtb3YodHY0LCB0djMsIGUyKTsgLy8gIDguIHR2MiA9IENNT1YodHY0LCB0djMsIGUyKSAgIyBTZWxlY3QgdHYzIGlmICh0djNeMikgPT0geFxuICAgIC8vICAgY29uc3QgZTMgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MiksIHgpOyAvLyAgOS4gIGUzID0gKHR2Ml4yKSA9PSB4XG4gICAgLy8gICByZXR1cm4gRnAuY21vdih0djEsIHR2MiwgZTMpOyAvLyAgMTAuICB6ID0gQ01PVih0djEsIHR2MiwgZTMpICAjIFNlbGVjdCB0aGUgc3FydCBmcm9tIHR2MSBhbmQgdHYyXG4gICAgLy8gfVxuICB9XG5cbiAgLy8gT3RoZXIgY2FzZXM6IFRvbmVsbGktU2hhbmtzIGFsZ29yaXRobVxuICByZXR1cm4gdG9uZWxsaVNoYW5rcyhQKTtcbn1cblxuLy8gTGl0dGxlLWVuZGlhbiBjaGVjayBmb3IgZmlyc3QgTEUgYml0IChsYXN0IEJFIGJpdCk7XG5leHBvcnQgY29uc3QgaXNOZWdhdGl2ZUxFID0gKG51bTogYmlnaW50LCBtb2R1bG86IGJpZ2ludCkgPT4gKG1vZChudW0sIG1vZHVsbykgJiBfMW4pID09PSBfMW47XG5cbi8vIEZpZWxkIGlzIG5vdCBhbHdheXMgb3ZlciBwcmltZTogZm9yIGV4YW1wbGUsIEZwMiBoYXMgT1JERVIocSk9cF5tXG5leHBvcnQgaW50ZXJmYWNlIElGaWVsZDxUPiB7XG4gIE9SREVSOiBiaWdpbnQ7XG4gIEJZVEVTOiBudW1iZXI7XG4gIEJJVFM6IG51bWJlcjtcbiAgTUFTSzogYmlnaW50O1xuICBaRVJPOiBUO1xuICBPTkU6IFQ7XG4gIC8vIDEtYXJnXG4gIGNyZWF0ZTogKG51bTogVCkgPT4gVDtcbiAgaXNWYWxpZDogKG51bTogVCkgPT4gYm9vbGVhbjtcbiAgaXMwOiAobnVtOiBUKSA9PiBib29sZWFuO1xuICBuZWcobnVtOiBUKTogVDtcbiAgaW52KG51bTogVCk6IFQ7XG4gIHNxcnQobnVtOiBUKTogVDtcbiAgc3FyKG51bTogVCk6IFQ7XG4gIC8vIDItYXJnc1xuICBlcWwobGhzOiBULCByaHM6IFQpOiBib29sZWFuO1xuICBhZGQobGhzOiBULCByaHM6IFQpOiBUO1xuICBzdWIobGhzOiBULCByaHM6IFQpOiBUO1xuICBtdWwobGhzOiBULCByaHM6IFQgfCBiaWdpbnQpOiBUO1xuICBwb3cobGhzOiBULCBwb3dlcjogYmlnaW50KTogVDtcbiAgZGl2KGxoczogVCwgcmhzOiBUIHwgYmlnaW50KTogVDtcbiAgLy8gTiBmb3IgTm9uTm9ybWFsaXplZCAoZm9yIG5vdylcbiAgYWRkTihsaHM6IFQsIHJoczogVCk6IFQ7XG4gIHN1Yk4obGhzOiBULCByaHM6IFQpOiBUO1xuICBtdWxOKGxoczogVCwgcmhzOiBUIHwgYmlnaW50KTogVDtcbiAgc3FyTihudW06IFQpOiBUO1xuXG4gIC8vIE9wdGlvbmFsXG4gIC8vIFNob3VsZCBiZSBzYW1lIGFzIHNnbjAgZnVuY3Rpb24gaW5cbiAgLy8gW1JGQzkzODBdKGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNC4xKS5cbiAgLy8gTk9URTogc2duMCBpcyAnbmVnYXRpdmUgaW4gTEUnLCB3aGljaCBpcyBzYW1lIGFzIG9kZC4gQW5kIG5lZ2F0aXZlIGluIExFIGlzIGtpbmRhIHN0cmFuZ2UgZGVmaW5pdGlvbiBhbnl3YXkuXG4gIGlzT2RkPyhudW06IFQpOiBib29sZWFuOyAvLyBPZGQgaW5zdGVhZCBvZiBldmVuIHNpbmNlIHdlIGhhdmUgaXQgZm9yIEZwMlxuICAvLyBsZWdlbmRyZT8obnVtOiBUKTogVDtcbiAgcG93KGxoczogVCwgcG93ZXI6IGJpZ2ludCk6IFQ7XG4gIGludmVydEJhdGNoOiAobHN0OiBUW10pID0+IFRbXTtcbiAgdG9CeXRlcyhudW06IFQpOiBVaW50OEFycmF5O1xuICBmcm9tQnl0ZXMoYnl0ZXM6IFVpbnQ4QXJyYXkpOiBUO1xuICAvLyBJZiBjIGlzIEZhbHNlLCBDTU9WIHJldHVybnMgYSwgb3RoZXJ3aXNlIGl0IHJldHVybnMgYi5cbiAgY21vdihhOiBULCBiOiBULCBjOiBib29sZWFuKTogVDtcbn1cbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgRklFTERfRklFTERTID0gW1xuICAnY3JlYXRlJywgJ2lzVmFsaWQnLCAnaXMwJywgJ25lZycsICdpbnYnLCAnc3FydCcsICdzcXInLFxuICAnZXFsJywgJ2FkZCcsICdzdWInLCAnbXVsJywgJ3BvdycsICdkaXYnLFxuICAnYWRkTicsICdzdWJOJywgJ211bE4nLCAnc3FyTidcbl0gYXMgY29uc3Q7XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVGaWVsZDxUPihmaWVsZDogSUZpZWxkPFQ+KSB7XG4gIGNvbnN0IGluaXRpYWwgPSB7XG4gICAgT1JERVI6ICdiaWdpbnQnLFxuICAgIE1BU0s6ICdiaWdpbnQnLFxuICAgIEJZVEVTOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgQklUUzogJ2lzU2FmZUludGVnZXInLFxuICB9IGFzIFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gIGNvbnN0IG9wdHMgPSBGSUVMRF9GSUVMRFMucmVkdWNlKChtYXAsIHZhbDogc3RyaW5nKSA9PiB7XG4gICAgbWFwW3ZhbF0gPSAnZnVuY3Rpb24nO1xuICAgIHJldHVybiBtYXA7XG4gIH0sIGluaXRpYWwpO1xuICByZXR1cm4gdmFsaWRhdGVPYmplY3QoZmllbGQsIG9wdHMpO1xufVxuXG4vLyBHZW5lcmljIGZpZWxkIGZ1bmN0aW9uc1xuXG4vKipcbiAqIFNhbWUgYXMgYHBvd2AgYnV0IGZvciBGcDogbm9uLWNvbnN0YW50LXRpbWUuXG4gKiBVbnNhZmUgaW4gc29tZSBjb250ZXh0czogdXNlcyBsYWRkZXIsIHNvIGNhbiBleHBvc2UgYmlnaW50IGJpdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGcFBvdzxUPihmOiBJRmllbGQ8VD4sIG51bTogVCwgcG93ZXI6IGJpZ2ludCk6IFQge1xuICAvLyBTaG91bGQgaGF2ZSBzYW1lIHNwZWVkIGFzIHBvdyBmb3IgYmlnaW50c1xuICAvLyBUT0RPOiBiZW5jaG1hcmshXG4gIGlmIChwb3dlciA8IF8wbikgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwb3dlciA+IDAnKTtcbiAgaWYgKHBvd2VyID09PSBfMG4pIHJldHVybiBmLk9ORTtcbiAgaWYgKHBvd2VyID09PSBfMW4pIHJldHVybiBudW07XG4gIGxldCBwID0gZi5PTkU7XG4gIGxldCBkID0gbnVtO1xuICB3aGlsZSAocG93ZXIgPiBfMG4pIHtcbiAgICBpZiAocG93ZXIgJiBfMW4pIHAgPSBmLm11bChwLCBkKTtcbiAgICBkID0gZi5zcXIoZCk7XG4gICAgcG93ZXIgPj49IF8xbjtcbiAgfVxuICByZXR1cm4gcDtcbn1cblxuLyoqXG4gKiBFZmZpY2llbnRseSBpbnZlcnQgYW4gYXJyYXkgb2YgRmllbGQgZWxlbWVudHMuXG4gKiBgaW52KDApYCB3aWxsIHJldHVybiBgdW5kZWZpbmVkYCBoZXJlOiBtYWtlIHN1cmUgdG8gdGhyb3cgYW4gZXJyb3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGcEludmVydEJhdGNoPFQ+KGY6IElGaWVsZDxUPiwgbnVtczogVFtdKTogVFtdIHtcbiAgY29uc3QgdG1wID0gbmV3IEFycmF5KG51bXMubGVuZ3RoKTtcbiAgLy8gV2FsayBmcm9tIGZpcnN0IHRvIGxhc3QsIG11bHRpcGx5IHRoZW0gYnkgZWFjaCBvdGhlciBNT0QgcFxuICBjb25zdCBsYXN0TXVsdGlwbGllZCA9IG51bXMucmVkdWNlKChhY2MsIG51bSwgaSkgPT4ge1xuICAgIGlmIChmLmlzMChudW0pKSByZXR1cm4gYWNjO1xuICAgIHRtcFtpXSA9IGFjYztcbiAgICByZXR1cm4gZi5tdWwoYWNjLCBudW0pO1xuICB9LCBmLk9ORSk7XG4gIC8vIEludmVydCBsYXN0IGVsZW1lbnRcbiAgY29uc3QgaW52ZXJ0ZWQgPSBmLmludihsYXN0TXVsdGlwbGllZCk7XG4gIC8vIFdhbGsgZnJvbSBsYXN0IHRvIGZpcnN0LCBtdWx0aXBseSB0aGVtIGJ5IGludmVydGVkIGVhY2ggb3RoZXIgTU9EIHBcbiAgbnVtcy5yZWR1Y2VSaWdodCgoYWNjLCBudW0sIGkpID0+IHtcbiAgICBpZiAoZi5pczAobnVtKSkgcmV0dXJuIGFjYztcbiAgICB0bXBbaV0gPSBmLm11bChhY2MsIHRtcFtpXSk7XG4gICAgcmV0dXJuIGYubXVsKGFjYywgbnVtKTtcbiAgfSwgaW52ZXJ0ZWQpO1xuICByZXR1cm4gdG1wO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gRnBEaXY8VD4oZjogSUZpZWxkPFQ+LCBsaHM6IFQsIHJoczogVCB8IGJpZ2ludCk6IFQge1xuICByZXR1cm4gZi5tdWwobGhzLCB0eXBlb2YgcmhzID09PSAnYmlnaW50JyA/IGludmVydChyaHMsIGYuT1JERVIpIDogZi5pbnYocmhzKSk7XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBUcnVlIHdoZW5ldmVyIHRoZSB2YWx1ZSB4IGlzIGEgc3F1YXJlIGluIHRoZSBmaWVsZCBGLlxuZXhwb3J0IGZ1bmN0aW9uIEZwSXNTcXVhcmU8VD4oZjogSUZpZWxkPFQ+KSB7XG4gIGNvbnN0IGxlZ2VuZHJlQ29uc3QgPSAoZi5PUkRFUiAtIF8xbikgLyBfMm47IC8vIEludGVnZXIgYXJpdGhtZXRpY1xuICByZXR1cm4gKHg6IFQpOiBib29sZWFuID0+IHtcbiAgICBjb25zdCBwID0gZi5wb3coeCwgbGVnZW5kcmVDb25zdCk7XG4gICAgcmV0dXJuIGYuZXFsKHAsIGYuWkVSTykgfHwgZi5lcWwocCwgZi5PTkUpO1xuICB9O1xufVxuXG4vLyBDVVJWRS5uIGxlbmd0aHNcbmV4cG9ydCBmdW5jdGlvbiBuTGVuZ3RoKG46IGJpZ2ludCwgbkJpdExlbmd0aD86IG51bWJlcikge1xuICAvLyBCaXQgc2l6ZSwgYnl0ZSBzaXplIG9mIENVUlZFLm5cbiAgY29uc3QgX25CaXRMZW5ndGggPSBuQml0TGVuZ3RoICE9PSB1bmRlZmluZWQgPyBuQml0TGVuZ3RoIDogbi50b1N0cmluZygyKS5sZW5ndGg7XG4gIGNvbnN0IG5CeXRlTGVuZ3RoID0gTWF0aC5jZWlsKF9uQml0TGVuZ3RoIC8gOCk7XG4gIHJldHVybiB7IG5CaXRMZW5ndGg6IF9uQml0TGVuZ3RoLCBuQnl0ZUxlbmd0aCB9O1xufVxuXG50eXBlIEZwRmllbGQgPSBJRmllbGQ8YmlnaW50PiAmIFJlcXVpcmVkPFBpY2s8SUZpZWxkPGJpZ2ludD4sICdpc09kZCc+Pjtcbi8qKlxuICogSW5pdGlhbGl6ZXMgYSBmaW5pdGUgZmllbGQgb3ZlciBwcmltZS4gKipOb24tcHJpbWVzIGFyZSBub3Qgc3VwcG9ydGVkLioqXG4gKiBEbyBub3QgaW5pdCBpbiBsb29wOiBzbG93LiBWZXJ5IGZyYWdpbGU6IGFsd2F5cyBydW4gYSBiZW5jaG1hcmsgb24gYSBjaGFuZ2UuXG4gKiBNYWpvciBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb25zOlxuICogKiBhKSBkZW5vcm1hbGl6ZWQgb3BlcmF0aW9ucyBsaWtlIG11bE4gaW5zdGVhZCBvZiBtdWxcbiAqICogYikgc2FtZSBvYmplY3Qgc2hhcGU6IG5ldmVyIGFkZCBvciByZW1vdmUga2V5c1xuICogKiBjKSBPYmplY3QuZnJlZXplXG4gKiBAcGFyYW0gT1JERVIgcHJpbWUgcG9zaXRpdmUgYmlnaW50XG4gKiBAcGFyYW0gYml0TGVuIGhvdyBtYW55IGJpdHMgdGhlIGZpZWxkIGNvbnN1bWVzXG4gKiBAcGFyYW0gaXNMRSAoZGVmOiBmYWxzZSkgaWYgZW5jb2RpbmcgLyBkZWNvZGluZyBzaG91bGQgYmUgaW4gbGl0dGxlLWVuZGlhblxuICogQHBhcmFtIHJlZGVmIG9wdGlvbmFsIGZhc3RlciByZWRlZmluaXRpb25zIG9mIHNxcnQgYW5kIG90aGVyIG1ldGhvZHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZpZWxkKFxuICBPUkRFUjogYmlnaW50LFxuICBiaXRMZW4/OiBudW1iZXIsXG4gIGlzTEUgPSBmYWxzZSxcbiAgcmVkZWY6IFBhcnRpYWw8SUZpZWxkPGJpZ2ludD4+ID0ge31cbik6IFJlYWRvbmx5PEZwRmllbGQ+IHtcbiAgaWYgKE9SREVSIDw9IF8wbikgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBGaWVsZCBPUkRFUiA+IDAsIGdvdCAke09SREVSfWApO1xuICBjb25zdCB7IG5CaXRMZW5ndGg6IEJJVFMsIG5CeXRlTGVuZ3RoOiBCWVRFUyB9ID0gbkxlbmd0aChPUkRFUiwgYml0TGVuKTtcbiAgaWYgKEJZVEVTID4gMjA0OCkgdGhyb3cgbmV3IEVycm9yKCdGaWVsZCBsZW5ndGhzIG92ZXIgMjA0OCBieXRlcyBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICBjb25zdCBzcXJ0UCA9IEZwU3FydChPUkRFUik7XG4gIGNvbnN0IGY6IFJlYWRvbmx5PEZwRmllbGQ+ID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgT1JERVIsXG4gICAgQklUUyxcbiAgICBCWVRFUyxcbiAgICBNQVNLOiBiaXRNYXNrKEJJVFMpLFxuICAgIFpFUk86IF8wbixcbiAgICBPTkU6IF8xbixcbiAgICBjcmVhdGU6IChudW0pID0+IG1vZChudW0sIE9SREVSKSxcbiAgICBpc1ZhbGlkOiAobnVtKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIG51bSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBmaWVsZCBlbGVtZW50OiBleHBlY3RlZCBiaWdpbnQsIGdvdCAke3R5cGVvZiBudW19YCk7XG4gICAgICByZXR1cm4gXzBuIDw9IG51bSAmJiBudW0gPCBPUkRFUjsgLy8gMCBpcyB2YWxpZCBlbGVtZW50LCBidXQgaXQncyBub3QgaW52ZXJ0aWJsZVxuICAgIH0sXG4gICAgaXMwOiAobnVtKSA9PiBudW0gPT09IF8wbixcbiAgICBpc09kZDogKG51bSkgPT4gKG51bSAmIF8xbikgPT09IF8xbixcbiAgICBuZWc6IChudW0pID0+IG1vZCgtbnVtLCBPUkRFUiksXG4gICAgZXFsOiAobGhzLCByaHMpID0+IGxocyA9PT0gcmhzLFxuXG4gICAgc3FyOiAobnVtKSA9PiBtb2QobnVtICogbnVtLCBPUkRFUiksXG4gICAgYWRkOiAobGhzLCByaHMpID0+IG1vZChsaHMgKyByaHMsIE9SREVSKSxcbiAgICBzdWI6IChsaHMsIHJocykgPT4gbW9kKGxocyAtIHJocywgT1JERVIpLFxuICAgIG11bDogKGxocywgcmhzKSA9PiBtb2QobGhzICogcmhzLCBPUkRFUiksXG4gICAgcG93OiAobnVtLCBwb3dlcikgPT4gRnBQb3coZiwgbnVtLCBwb3dlciksXG4gICAgZGl2OiAobGhzLCByaHMpID0+IG1vZChsaHMgKiBpbnZlcnQocmhzLCBPUkRFUiksIE9SREVSKSxcblxuICAgIC8vIFNhbWUgYXMgYWJvdmUsIGJ1dCBkb2Vzbid0IG5vcm1hbGl6ZVxuICAgIHNxck46IChudW0pID0+IG51bSAqIG51bSxcbiAgICBhZGROOiAobGhzLCByaHMpID0+IGxocyArIHJocyxcbiAgICBzdWJOOiAobGhzLCByaHMpID0+IGxocyAtIHJocyxcbiAgICBtdWxOOiAobGhzLCByaHMpID0+IGxocyAqIHJocyxcblxuICAgIGludjogKG51bSkgPT4gaW52ZXJ0KG51bSwgT1JERVIpLFxuICAgIHNxcnQ6IHJlZGVmLnNxcnQgfHwgKChuKSA9PiBzcXJ0UChmLCBuKSksXG4gICAgaW52ZXJ0QmF0Y2g6IChsc3QpID0+IEZwSW52ZXJ0QmF0Y2goZiwgbHN0KSxcbiAgICAvLyBUT0RPOiBkbyB3ZSByZWFsbHkgbmVlZCBjb25zdGFudCBjbW92P1xuICAgIC8vIFdlIGRvbid0IGhhdmUgY29uc3QtdGltZSBiaWdpbnRzIGFueXdheSwgc28gcHJvYmFibHkgd2lsbCBiZSBub3QgdmVyeSB1c2VmdWxcbiAgICBjbW92OiAoYSwgYiwgYykgPT4gKGMgPyBiIDogYSksXG4gICAgdG9CeXRlczogKG51bSkgPT4gKGlzTEUgPyBudW1iZXJUb0J5dGVzTEUobnVtLCBCWVRFUykgOiBudW1iZXJUb0J5dGVzQkUobnVtLCBCWVRFUykpLFxuICAgIGZyb21CeXRlczogKGJ5dGVzKSA9PiB7XG4gICAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSBCWVRFUylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGcC5mcm9tQnl0ZXM6IGV4cGVjdGVkICR7QllURVN9LCBnb3QgJHtieXRlcy5sZW5ndGh9YCk7XG4gICAgICByZXR1cm4gaXNMRSA/IGJ5dGVzVG9OdW1iZXJMRShieXRlcykgOiBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpO1xuICAgIH0sXG4gIH0gYXMgRnBGaWVsZCk7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKGYpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gRnBTcXJ0T2RkPFQ+KEZwOiBJRmllbGQ8VD4sIGVsbTogVCkge1xuICBpZiAoIUZwLmlzT2RkKSB0aHJvdyBuZXcgRXJyb3IoYEZpZWxkIGRvZXNuJ3QgaGF2ZSBpc09kZGApO1xuICBjb25zdCByb290ID0gRnAuc3FydChlbG0pO1xuICByZXR1cm4gRnAuaXNPZGQocm9vdCkgPyByb290IDogRnAubmVnKHJvb3QpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gRnBTcXJ0RXZlbjxUPihGcDogSUZpZWxkPFQ+LCBlbG06IFQpIHtcbiAgaWYgKCFGcC5pc09kZCkgdGhyb3cgbmV3IEVycm9yKGBGaWVsZCBkb2Vzbid0IGhhdmUgaXNPZGRgKTtcbiAgY29uc3Qgcm9vdCA9IEZwLnNxcnQoZWxtKTtcbiAgcmV0dXJuIEZwLmlzT2RkKHJvb3QpID8gRnAubmVnKHJvb3QpIDogcm9vdDtcbn1cblxuLyoqXG4gKiBcIkNvbnN0YW50LXRpbWVcIiBwcml2YXRlIGtleSBnZW5lcmF0aW9uIHV0aWxpdHkuXG4gKiBTYW1lIGFzIG1hcEtleVRvRmllbGQsIGJ1dCBhY2NlcHRzIGxlc3MgYnl0ZXMgKDQwIGluc3RlYWQgb2YgNDggZm9yIDMyLWJ5dGUgZmllbGQpLlxuICogV2hpY2ggbWFrZXMgaXQgc2xpZ2h0bHkgbW9yZSBiaWFzZWQsIGxlc3Mgc2VjdXJlLlxuICogQGRlcHJlY2F0ZWQgdXNlIG1hcEtleVRvRmllbGQgaW5zdGVhZFxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaFRvUHJpdmF0ZVNjYWxhcihcbiAgaGFzaDogc3RyaW5nIHwgVWludDhBcnJheSxcbiAgZ3JvdXBPcmRlcjogYmlnaW50LFxuICBpc0xFID0gZmFsc2Vcbik6IGJpZ2ludCB7XG4gIGhhc2ggPSBlbnN1cmVCeXRlcygncHJpdmF0ZUhhc2gnLCBoYXNoKTtcbiAgY29uc3QgaGFzaExlbiA9IGhhc2gubGVuZ3RoO1xuICBjb25zdCBtaW5MZW4gPSBuTGVuZ3RoKGdyb3VwT3JkZXIpLm5CeXRlTGVuZ3RoICsgODtcbiAgaWYgKG1pbkxlbiA8IDI0IHx8IGhhc2hMZW4gPCBtaW5MZW4gfHwgaGFzaExlbiA+IDEwMjQpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBoYXNoVG9Qcml2YXRlU2NhbGFyOiBleHBlY3RlZCAke21pbkxlbn0tMTAyNCBieXRlcyBvZiBpbnB1dCwgZ290ICR7aGFzaExlbn1gKTtcbiAgY29uc3QgbnVtID0gaXNMRSA/IGJ5dGVzVG9OdW1iZXJMRShoYXNoKSA6IGJ5dGVzVG9OdW1iZXJCRShoYXNoKTtcbiAgcmV0dXJuIG1vZChudW0sIGdyb3VwT3JkZXIgLSBfMW4pICsgXzFuO1xufVxuXG4vKipcbiAqIFJldHVybnMgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIGNvbnN1bWVkIGJ5IHRoZSBmaWVsZCBlbGVtZW50LlxuICogRm9yIGV4YW1wbGUsIDMyIGJ5dGVzIGZvciB1c3VhbCAyNTYtYml0IHdlaWVyc3RyYXNzIGN1cnZlLlxuICogQHBhcmFtIGZpZWxkT3JkZXIgbnVtYmVyIG9mIGZpZWxkIGVsZW1lbnRzLCB1c3VhbGx5IENVUlZFLm5cbiAqIEByZXR1cm5zIGJ5dGUgbGVuZ3RoIG9mIGZpZWxkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXI6IGJpZ2ludCk6IG51bWJlciB7XG4gIGlmICh0eXBlb2YgZmllbGRPcmRlciAhPT0gJ2JpZ2ludCcpIHRocm93IG5ldyBFcnJvcignZmllbGQgb3JkZXIgbXVzdCBiZSBiaWdpbnQnKTtcbiAgY29uc3QgYml0TGVuZ3RoID0gZmllbGRPcmRlci50b1N0cmluZygyKS5sZW5ndGg7XG4gIHJldHVybiBNYXRoLmNlaWwoYml0TGVuZ3RoIC8gOCk7XG59XG5cbi8qKlxuICogUmV0dXJucyBtaW5pbWFsIGFtb3VudCBvZiBieXRlcyB0aGF0IGNhbiBiZSBzYWZlbHkgcmVkdWNlZFxuICogYnkgZmllbGQgb3JkZXIuXG4gKiBTaG91bGQgYmUgMl4tMTI4IGZvciAxMjgtYml0IGN1cnZlIHN1Y2ggYXMgUDI1Ni5cbiAqIEBwYXJhbSBmaWVsZE9yZGVyIG51bWJlciBvZiBmaWVsZCBlbGVtZW50cywgdXN1YWxseSBDVVJWRS5uXG4gKiBAcmV0dXJucyBieXRlIGxlbmd0aCBvZiB0YXJnZXQgaGFzaFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWluSGFzaExlbmd0aChmaWVsZE9yZGVyOiBiaWdpbnQpOiBudW1iZXIge1xuICBjb25zdCBsZW5ndGggPSBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpO1xuICByZXR1cm4gbGVuZ3RoICsgTWF0aC5jZWlsKGxlbmd0aCAvIDIpO1xufVxuXG4vKipcbiAqIFwiQ29uc3RhbnQtdGltZVwiIHByaXZhdGUga2V5IGdlbmVyYXRpb24gdXRpbGl0eS5cbiAqIENhbiB0YWtlIChuICsgbi8yKSBvciBtb3JlIGJ5dGVzIG9mIHVuaWZvcm0gaW5wdXQgZS5nLiBmcm9tIENTUFJORyBvciBLREZcbiAqIGFuZCBjb252ZXJ0IHRoZW0gaW50byBwcml2YXRlIHNjYWxhciwgd2l0aCB0aGUgbW9kdWxvIGJpYXMgYmVpbmcgbmVnbGlnaWJsZS5cbiAqIE5lZWRzIGF0IGxlYXN0IDQ4IGJ5dGVzIG9mIGlucHV0IGZvciAzMi1ieXRlIHByaXZhdGUga2V5LlxuICogaHR0cHM6Ly9yZXNlYXJjaC5rdWRlbHNraXNlY3VyaXR5LmNvbS8yMDIwLzA3LzI4L3RoZS1kZWZpbml0aXZlLWd1aWRlLXRvLW1vZHVsby1iaWFzLWFuZC1ob3ctdG8tYXZvaWQtaXQvXG4gKiBGSVBTIDE4Ni01LCBBLjIgaHR0cHM6Ly9jc3JjLm5pc3QuZ292L3B1YmxpY2F0aW9ucy9kZXRhaWwvZmlwcy8xODYvNS9maW5hbFxuICogUkZDIDkzODAsIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNVxuICogQHBhcmFtIGhhc2ggaGFzaCBvdXRwdXQgZnJvbSBTSEEzIG9yIGEgc2ltaWxhciBmdW5jdGlvblxuICogQHBhcmFtIGdyb3VwT3JkZXIgc2l6ZSBvZiBzdWJncm91cCAtIChlLmcuIHNlY3AyNTZrMS5DVVJWRS5uKVxuICogQHBhcmFtIGlzTEUgaW50ZXJwcmV0IGhhc2ggYnl0ZXMgYXMgTEUgbnVtXG4gKiBAcmV0dXJucyB2YWxpZCBwcml2YXRlIHNjYWxhclxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFwSGFzaFRvRmllbGQoa2V5OiBVaW50OEFycmF5LCBmaWVsZE9yZGVyOiBiaWdpbnQsIGlzTEUgPSBmYWxzZSk6IFVpbnQ4QXJyYXkge1xuICBjb25zdCBsZW4gPSBrZXkubGVuZ3RoO1xuICBjb25zdCBmaWVsZExlbiA9IGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcik7XG4gIGNvbnN0IG1pbkxlbiA9IGdldE1pbkhhc2hMZW5ndGgoZmllbGRPcmRlcik7XG4gIC8vIE5vIHNtYWxsIG51bWJlcnM6IG5lZWQgdG8gdW5kZXJzdGFuZCBiaWFzIHN0b3J5LiBObyBodWdlIG51bWJlcnM6IGVhc2llciB0byBkZXRlY3QgSlMgdGltaW5ncy5cbiAgaWYgKGxlbiA8IDE2IHx8IGxlbiA8IG1pbkxlbiB8fCBsZW4gPiAxMDI0KVxuICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgJHttaW5MZW59LTEwMjQgYnl0ZXMgb2YgaW5wdXQsIGdvdCAke2xlbn1gKTtcbiAgY29uc3QgbnVtID0gaXNMRSA/IGJ5dGVzVG9OdW1iZXJCRShrZXkpIDogYnl0ZXNUb051bWJlckxFKGtleSk7XG4gIC8vIGBtb2QoeCwgMTEpYCBjYW4gc29tZXRpbWVzIHByb2R1Y2UgMC4gYG1vZCh4LCAxMCkgKyAxYCBpcyB0aGUgc2FtZSwgYnV0IG5vIDBcbiAgY29uc3QgcmVkdWNlZCA9IG1vZChudW0sIGZpZWxkT3JkZXIgLSBfMW4pICsgXzFuO1xuICByZXR1cm4gaXNMRSA/IG51bWJlclRvQnl0ZXNMRShyZWR1Y2VkLCBmaWVsZExlbikgOiBudW1iZXJUb0J5dGVzQkUocmVkdWNlZCwgZmllbGRMZW4pO1xufVxuIiwgIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIEFiZWxpYW4gZ3JvdXAgdXRpbGl0aWVzXG5pbXBvcnQgeyBJRmllbGQsIHZhbGlkYXRlRmllbGQsIG5MZW5ndGggfSBmcm9tICcuL21vZHVsYXIuanMnO1xuaW1wb3J0IHsgdmFsaWRhdGVPYmplY3QgfSBmcm9tICcuL3V0aWxzLmpzJztcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcblxuZXhwb3J0IHR5cGUgQWZmaW5lUG9pbnQ8VD4gPSB7XG4gIHg6IFQ7XG4gIHk6IFQ7XG59ICYgeyB6PzogbmV2ZXI7IHQ/OiBuZXZlciB9O1xuXG5leHBvcnQgaW50ZXJmYWNlIEdyb3VwPFQgZXh0ZW5kcyBHcm91cDxUPj4ge1xuICBkb3VibGUoKTogVDtcbiAgbmVnYXRlKCk6IFQ7XG4gIGFkZChvdGhlcjogVCk6IFQ7XG4gIHN1YnRyYWN0KG90aGVyOiBUKTogVDtcbiAgZXF1YWxzKG90aGVyOiBUKTogYm9vbGVhbjtcbiAgbXVsdGlwbHkoc2NhbGFyOiBiaWdpbnQpOiBUO1xufVxuXG5leHBvcnQgdHlwZSBHcm91cENvbnN0cnVjdG9yPFQ+ID0ge1xuICBCQVNFOiBUO1xuICBaRVJPOiBUO1xufTtcbmV4cG9ydCB0eXBlIE1hcHBlcjxUPiA9IChpOiBUW10pID0+IFRbXTtcblxuLy8gRWxsaXB0aWMgY3VydmUgbXVsdGlwbGljYXRpb24gb2YgUG9pbnQgYnkgc2NhbGFyLiBGcmFnaWxlLlxuLy8gU2NhbGFycyBzaG91bGQgYWx3YXlzIGJlIGxlc3MgdGhhbiBjdXJ2ZSBvcmRlcjogdGhpcyBzaG91bGQgYmUgY2hlY2tlZCBpbnNpZGUgb2YgYSBjdXJ2ZSBpdHNlbGYuXG4vLyBDcmVhdGVzIHByZWNvbXB1dGF0aW9uIHRhYmxlcyBmb3IgZmFzdCBtdWx0aXBsaWNhdGlvbjpcbi8vIC0gcHJpdmF0ZSBzY2FsYXIgaXMgc3BsaXQgYnkgZml4ZWQgc2l6ZSB3aW5kb3dzIG9mIFcgYml0c1xuLy8gLSBldmVyeSB3aW5kb3cgcG9pbnQgaXMgY29sbGVjdGVkIGZyb20gd2luZG93J3MgdGFibGUgJiBhZGRlZCB0byBhY2N1bXVsYXRvclxuLy8gLSBzaW5jZSB3aW5kb3dzIGFyZSBkaWZmZXJlbnQsIHNhbWUgcG9pbnQgaW5zaWRlIHRhYmxlcyB3b24ndCBiZSBhY2Nlc3NlZCBtb3JlIHRoYW4gb25jZSBwZXIgY2FsY1xuLy8gLSBlYWNoIG11bHRpcGxpY2F0aW9uIGlzICdNYXRoLmNlaWwoQ1VSVkVfT1JERVIgLyBcdUQ4MzVcdURDNEEpICsgMScgcG9pbnQgYWRkaXRpb25zIChmaXhlZCBmb3IgYW55IHNjYWxhcilcbi8vIC0gKzEgd2luZG93IGlzIG5lY2Nlc3NhcnkgZm9yIHdOQUZcbi8vIC0gd05BRiByZWR1Y2VzIHRhYmxlIHNpemU6IDJ4IGxlc3MgbWVtb3J5ICsgMnggZmFzdGVyIGdlbmVyYXRpb24sIGJ1dCAxMCUgc2xvd2VyIG11bHRpcGxpY2F0aW9uXG4vLyBUT0RPOiBSZXNlYXJjaCByZXR1cm5pbmcgMmQgSlMgYXJyYXkgb2Ygd2luZG93cywgaW5zdGVhZCBvZiBhIHNpbmdsZSB3aW5kb3cuIFRoaXMgd291bGQgYWxsb3dcbi8vIHdpbmRvd3MgdG8gYmUgaW4gZGlmZmVyZW50IG1lbW9yeSBsb2NhdGlvbnNcbmV4cG9ydCBmdW5jdGlvbiB3TkFGPFQgZXh0ZW5kcyBHcm91cDxUPj4oYzogR3JvdXBDb25zdHJ1Y3RvcjxUPiwgYml0czogbnVtYmVyKSB7XG4gIGNvbnN0IGNvbnN0VGltZU5lZ2F0ZSA9IChjb25kaXRpb246IGJvb2xlYW4sIGl0ZW06IFQpOiBUID0+IHtcbiAgICBjb25zdCBuZWcgPSBpdGVtLm5lZ2F0ZSgpO1xuICAgIHJldHVybiBjb25kaXRpb24gPyBuZWcgOiBpdGVtO1xuICB9O1xuICBjb25zdCBvcHRzID0gKFc6IG51bWJlcikgPT4ge1xuICAgIGNvbnN0IHdpbmRvd3MgPSBNYXRoLmNlaWwoYml0cyAvIFcpICsgMTsgLy8gKzEsIGJlY2F1c2VcbiAgICBjb25zdCB3aW5kb3dTaXplID0gMiAqKiAoVyAtIDEpOyAvLyAtMSBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgIHJldHVybiB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBjb25zdFRpbWVOZWdhdGUsXG4gICAgLy8gbm9uLWNvbnN0IHRpbWUgbXVsdGlwbGljYXRpb24gbGFkZGVyXG4gICAgdW5zYWZlTGFkZGVyKGVsbTogVCwgbjogYmlnaW50KSB7XG4gICAgICBsZXQgcCA9IGMuWkVSTztcbiAgICAgIGxldCBkOiBUID0gZWxtO1xuICAgICAgd2hpbGUgKG4gPiBfMG4pIHtcbiAgICAgICAgaWYgKG4gJiBfMW4pIHAgPSBwLmFkZChkKTtcbiAgICAgICAgZCA9IGQuZG91YmxlKCk7XG4gICAgICAgIG4gPj49IF8xbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgd05BRiBwcmVjb21wdXRhdGlvbiB3aW5kb3cuIFVzZWQgZm9yIGNhY2hpbmcuXG4gICAgICogRGVmYXVsdCB3aW5kb3cgc2l6ZSBpcyBzZXQgYnkgYHV0aWxzLnByZWNvbXB1dGUoKWAgYW5kIGlzIGVxdWFsIHRvIDguXG4gICAgICogTnVtYmVyIG9mIHByZWNvbXB1dGVkIHBvaW50cyBkZXBlbmRzIG9uIHRoZSBjdXJ2ZSBzaXplOlxuICAgICAqIDJeKFx1RDgzNVx1REM0QVx1MjIxMjEpICogKE1hdGguY2VpbChcdUQ4MzVcdURDNUIgLyBcdUQ4MzVcdURDNEEpICsgMSksIHdoZXJlOlxuICAgICAqIC0gXHVEODM1XHVEQzRBIGlzIHRoZSB3aW5kb3cgc2l6ZVxuICAgICAqIC0gXHVEODM1XHVEQzVCIGlzIHRoZSBiaXRsZW5ndGggb2YgdGhlIGN1cnZlIG9yZGVyLlxuICAgICAqIEZvciBhIDI1Ni1iaXQgY3VydmUgYW5kIHdpbmRvdyBzaXplIDgsIHRoZSBudW1iZXIgb2YgcHJlY29tcHV0ZWQgcG9pbnRzIGlzIDEyOCAqIDMzID0gNDIyNC5cbiAgICAgKiBAcmV0dXJucyBwcmVjb21wdXRlZCBwb2ludCB0YWJsZXMgZmxhdHRlbmVkIHRvIGEgc2luZ2xlIGFycmF5XG4gICAgICovXG4gICAgcHJlY29tcHV0ZVdpbmRvdyhlbG06IFQsIFc6IG51bWJlcik6IEdyb3VwPFQ+W10ge1xuICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBvcHRzKFcpO1xuICAgICAgY29uc3QgcG9pbnRzOiBUW10gPSBbXTtcbiAgICAgIGxldCBwOiBUID0gZWxtO1xuICAgICAgbGV0IGJhc2UgPSBwO1xuICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgYmFzZSA9IHA7XG4gICAgICAgIHBvaW50cy5wdXNoKGJhc2UpO1xuICAgICAgICAvLyA9MSwgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB3aW5kb3dTaXplOyBpKyspIHtcbiAgICAgICAgICBiYXNlID0gYmFzZS5hZGQocCk7XG4gICAgICAgICAgcG9pbnRzLnB1c2goYmFzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcCA9IGJhc2UuZG91YmxlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcG9pbnRzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRzIGVjIG11bHRpcGxpY2F0aW9uIHVzaW5nIHByZWNvbXB1dGVkIHRhYmxlcyBhbmQgdy1hcnkgbm9uLWFkamFjZW50IGZvcm0uXG4gICAgICogQHBhcmFtIFcgd2luZG93IHNpemVcbiAgICAgKiBAcGFyYW0gcHJlY29tcHV0ZXMgcHJlY29tcHV0ZWQgdGFibGVzXG4gICAgICogQHBhcmFtIG4gc2NhbGFyICh3ZSBkb24ndCBjaGVjayBoZXJlLCBidXQgc2hvdWxkIGJlIGxlc3MgdGhhbiBjdXJ2ZSBvcmRlcilcbiAgICAgKiBAcmV0dXJucyByZWFsIGFuZCBmYWtlIChmb3IgY29uc3QtdGltZSkgcG9pbnRzXG4gICAgICovXG4gICAgd05BRihXOiBudW1iZXIsIHByZWNvbXB1dGVzOiBUW10sIG46IGJpZ2ludCk6IHsgcDogVDsgZjogVCB9IHtcbiAgICAgIC8vIFRPRE86IG1heWJlIGNoZWNrIHRoYXQgc2NhbGFyIGlzIGxlc3MgdGhhbiBncm91cCBvcmRlcj8gd05BRiBiZWhhdmlvdXMgaXMgdW5kZWZpbmVkIG90aGVyd2lzZVxuICAgICAgLy8gQnV0IG5lZWQgdG8gY2FyZWZ1bGx5IHJlbW92ZSBvdGhlciBjaGVja3MgYmVmb3JlIHdOQUYuIE9SREVSID09IGJpdHMgaGVyZVxuICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBvcHRzKFcpO1xuXG4gICAgICBsZXQgcCA9IGMuWkVSTztcbiAgICAgIGxldCBmID0gYy5CQVNFO1xuXG4gICAgICBjb25zdCBtYXNrID0gQmlnSW50KDIgKiogVyAtIDEpOyAvLyBDcmVhdGUgbWFzayB3aXRoIFcgb25lczogMGIxMTExIGZvciBXPTQgZXRjLlxuICAgICAgY29uc3QgbWF4TnVtYmVyID0gMiAqKiBXO1xuICAgICAgY29uc3Qgc2hpZnRCeSA9IEJpZ0ludChXKTtcblxuICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gd2luZG93ICogd2luZG93U2l6ZTtcbiAgICAgICAgLy8gRXh0cmFjdCBXIGJpdHMuXG4gICAgICAgIGxldCB3Yml0cyA9IE51bWJlcihuICYgbWFzayk7XG5cbiAgICAgICAgLy8gU2hpZnQgbnVtYmVyIGJ5IFcgYml0cy5cbiAgICAgICAgbiA+Pj0gc2hpZnRCeTtcblxuICAgICAgICAvLyBJZiB0aGUgYml0cyBhcmUgYmlnZ2VyIHRoYW4gbWF4IHNpemUsIHdlJ2xsIHNwbGl0IHRob3NlLlxuICAgICAgICAvLyArMjI0ID0+IDI1NiAtIDMyXG4gICAgICAgIGlmICh3Yml0cyA+IHdpbmRvd1NpemUpIHtcbiAgICAgICAgICB3Yml0cyAtPSBtYXhOdW1iZXI7XG4gICAgICAgICAgbiArPSBfMW47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGlzIGNvZGUgd2FzIGZpcnN0IHdyaXR0ZW4gd2l0aCBhc3N1bXB0aW9uIHRoYXQgJ2YnIGFuZCAncCcgd2lsbCBuZXZlciBiZSBpbmZpbml0eSBwb2ludDpcbiAgICAgICAgLy8gc2luY2UgZWFjaCBhZGRpdGlvbiBpcyBtdWx0aXBsaWVkIGJ5IDIgKiogVywgaXQgY2Fubm90IGNhbmNlbCBlYWNoIG90aGVyLiBIb3dldmVyLFxuICAgICAgICAvLyB0aGVyZSBpcyBuZWdhdGUgbm93OiBpdCBpcyBwb3NzaWJsZSB0aGF0IG5lZ2F0ZWQgZWxlbWVudCBmcm9tIGxvdyB2YWx1ZVxuICAgICAgICAvLyB3b3VsZCBiZSB0aGUgc2FtZSBhcyBoaWdoIGVsZW1lbnQsIHdoaWNoIHdpbGwgY3JlYXRlIGNhcnJ5IGludG8gbmV4dCB3aW5kb3cuXG4gICAgICAgIC8vIEl0J3Mgbm90IG9idmlvdXMgaG93IHRoaXMgY2FuIGZhaWwsIGJ1dCBzdGlsbCB3b3J0aCBpbnZlc3RpZ2F0aW5nIGxhdGVyLlxuXG4gICAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIG9udG8gWmVybyBwb2ludC5cbiAgICAgICAgLy8gQWRkIHJhbmRvbSBwb2ludCBpbnNpZGUgY3VycmVudCB3aW5kb3cgdG8gZi5cbiAgICAgICAgY29uc3Qgb2Zmc2V0MSA9IG9mZnNldDtcbiAgICAgICAgY29uc3Qgb2Zmc2V0MiA9IG9mZnNldCArIE1hdGguYWJzKHdiaXRzKSAtIDE7IC8vIC0xIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgICAgIGNvbnN0IGNvbmQxID0gd2luZG93ICUgMiAhPT0gMDtcbiAgICAgICAgY29uc3QgY29uZDIgPSB3Yml0cyA8IDA7XG4gICAgICAgIGlmICh3Yml0cyA9PT0gMCkge1xuICAgICAgICAgIC8vIFRoZSBtb3N0IGltcG9ydGFudCBwYXJ0IGZvciBjb25zdC10aW1lIGdldFB1YmxpY0tleVxuICAgICAgICAgIGYgPSBmLmFkZChjb25zdFRpbWVOZWdhdGUoY29uZDEsIHByZWNvbXB1dGVzW29mZnNldDFdKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcCA9IHAuYWRkKGNvbnN0VGltZU5lZ2F0ZShjb25kMiwgcHJlY29tcHV0ZXNbb2Zmc2V0Ml0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gSklULWNvbXBpbGVyIHNob3VsZCBub3QgZWxpbWluYXRlIGYgaGVyZSwgc2luY2UgaXQgd2lsbCBsYXRlciBiZSB1c2VkIGluIG5vcm1hbGl6ZVooKVxuICAgICAgLy8gRXZlbiBpZiB0aGUgdmFyaWFibGUgaXMgc3RpbGwgdW51c2VkLCB0aGVyZSBhcmUgc29tZSBjaGVja3Mgd2hpY2ggd2lsbFxuICAgICAgLy8gdGhyb3cgYW4gZXhjZXB0aW9uLCBzbyBjb21waWxlciBuZWVkcyB0byBwcm92ZSB0aGV5IHdvbid0IGhhcHBlbiwgd2hpY2ggaXMgaGFyZC5cbiAgICAgIC8vIEF0IHRoaXMgcG9pbnQgdGhlcmUgaXMgYSB3YXkgdG8gRiBiZSBpbmZpbml0eS1wb2ludCBldmVuIGlmIHAgaXMgbm90LFxuICAgICAgLy8gd2hpY2ggbWFrZXMgaXQgbGVzcyBjb25zdC10aW1lOiBhcm91bmQgMSBiaWdpbnQgbXVsdGlwbHkuXG4gICAgICByZXR1cm4geyBwLCBmIH07XG4gICAgfSxcblxuICAgIHdOQUZDYWNoZWQoUDogVCwgcHJlY29tcHV0ZXNNYXA6IE1hcDxULCBUW10+LCBuOiBiaWdpbnQsIHRyYW5zZm9ybTogTWFwcGVyPFQ+KTogeyBwOiBUOyBmOiBUIH0ge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgY29uc3QgVzogbnVtYmVyID0gUC5fV0lORE9XX1NJWkUgfHwgMTtcbiAgICAgIC8vIENhbGN1bGF0ZSBwcmVjb21wdXRlcyBvbiBhIGZpcnN0IHJ1biwgcmV1c2UgdGhlbSBhZnRlclxuICAgICAgbGV0IGNvbXAgPSBwcmVjb21wdXRlc01hcC5nZXQoUCk7XG4gICAgICBpZiAoIWNvbXApIHtcbiAgICAgICAgY29tcCA9IHRoaXMucHJlY29tcHV0ZVdpbmRvdyhQLCBXKSBhcyBUW107XG4gICAgICAgIGlmIChXICE9PSAxKSB7XG4gICAgICAgICAgcHJlY29tcHV0ZXNNYXAuc2V0KFAsIHRyYW5zZm9ybShjb21wKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLndOQUYoVywgY29tcCwgbik7XG4gICAgfSxcbiAgfTtcbn1cblxuLy8gR2VuZXJpYyBCYXNpY0N1cnZlIGludGVyZmFjZTogd29ya3MgZXZlbiBmb3IgcG9seW5vbWlhbCBmaWVsZHMgKEJMUyk6IFAsIG4sIGggd291bGQgYmUgb2suXG4vLyBUaG91Z2ggZ2VuZXJhdG9yIGNhbiBiZSBkaWZmZXJlbnQgKEZwMiAvIEZwNiBmb3IgQkxTKS5cbmV4cG9ydCB0eXBlIEJhc2ljQ3VydmU8VD4gPSB7XG4gIEZwOiBJRmllbGQ8VD47IC8vIEZpZWxkIG92ZXIgd2hpY2ggd2UnbGwgZG8gY2FsY3VsYXRpb25zIChGcClcbiAgbjogYmlnaW50OyAvLyBDdXJ2ZSBvcmRlciwgdG90YWwgY291bnQgb2YgdmFsaWQgcG9pbnRzIGluIHRoZSBmaWVsZFxuICBuQml0TGVuZ3RoPzogbnVtYmVyOyAvLyBiaXQgbGVuZ3RoIG9mIGN1cnZlIG9yZGVyXG4gIG5CeXRlTGVuZ3RoPzogbnVtYmVyOyAvLyBieXRlIGxlbmd0aCBvZiBjdXJ2ZSBvcmRlclxuICBoOiBiaWdpbnQ7IC8vIGNvZmFjdG9yLiB3ZSBjYW4gYXNzaWduIGRlZmF1bHQ9MSwgYnV0IHVzZXJzIHdpbGwganVzdCBpZ25vcmUgaXQgdy9vIHZhbGlkYXRpb25cbiAgaEVmZj86IGJpZ2ludDsgLy8gTnVtYmVyIHRvIG11bHRpcGx5IHRvIGNsZWFyIGNvZmFjdG9yXG4gIEd4OiBUOyAvLyBiYXNlIHBvaW50IFggY29vcmRpbmF0ZVxuICBHeTogVDsgLy8gYmFzZSBwb2ludCBZIGNvb3JkaW5hdGVcbiAgYWxsb3dJbmZpbml0eVBvaW50PzogYm9vbGVhbjsgLy8gYmxzMTItMzgxIHJlcXVpcmVzIGl0LiBaRVJPIHBvaW50IGlzIHZhbGlkLCBidXQgaW52YWxpZCBwdWJrZXlcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUJhc2ljPEZQLCBUPihjdXJ2ZTogQmFzaWNDdXJ2ZTxGUD4gJiBUKSB7XG4gIHZhbGlkYXRlRmllbGQoY3VydmUuRnApO1xuICB2YWxpZGF0ZU9iamVjdChcbiAgICBjdXJ2ZSxcbiAgICB7XG4gICAgICBuOiAnYmlnaW50JyxcbiAgICAgIGg6ICdiaWdpbnQnLFxuICAgICAgR3g6ICdmaWVsZCcsXG4gICAgICBHeTogJ2ZpZWxkJyxcbiAgICB9LFxuICAgIHtcbiAgICAgIG5CaXRMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgIG5CeXRlTGVuZ3RoOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgfVxuICApO1xuICAvLyBTZXQgZGVmYXVsdHNcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgIC4uLm5MZW5ndGgoY3VydmUubiwgY3VydmUubkJpdExlbmd0aCksXG4gICAgLi4uY3VydmUsXG4gICAgLi4ueyBwOiBjdXJ2ZS5GcC5PUkRFUiB9LFxuICB9IGFzIGNvbnN0KTtcbn1cbiIsICIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBTaG9ydCBXZWllcnN0cmFzcyBjdXJ2ZS4gVGhlIGZvcm11bGEgaXM6IHlcdTAwQjIgPSB4XHUwMEIzICsgYXggKyBiXG5pbXBvcnQgKiBhcyBtb2QgZnJvbSAnLi9tb2R1bGFyLmpzJztcbmltcG9ydCAqIGFzIHV0IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgQ0hhc2gsIEhleCwgUHJpdktleSwgZW5zdXJlQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7IEdyb3VwLCBHcm91cENvbnN0cnVjdG9yLCB3TkFGLCBCYXNpY0N1cnZlLCB2YWxpZGF0ZUJhc2ljLCBBZmZpbmVQb2ludCB9IGZyb20gJy4vY3VydmUuanMnO1xuXG5leHBvcnQgdHlwZSB7IEFmZmluZVBvaW50IH07XG50eXBlIEhtYWNGblN5bmMgPSAoa2V5OiBVaW50OEFycmF5LCAuLi5tZXNzYWdlczogVWludDhBcnJheVtdKSA9PiBVaW50OEFycmF5O1xudHlwZSBFbmRvbW9ycGhpc21PcHRzID0ge1xuICBiZXRhOiBiaWdpbnQ7XG4gIHNwbGl0U2NhbGFyOiAoazogYmlnaW50KSA9PiB7IGsxbmVnOiBib29sZWFuOyBrMTogYmlnaW50OyBrMm5lZzogYm9vbGVhbjsgazI6IGJpZ2ludCB9O1xufTtcbmV4cG9ydCB0eXBlIEJhc2ljV0N1cnZlPFQ+ID0gQmFzaWNDdXJ2ZTxUPiAmIHtcbiAgLy8gUGFyYW1zOiBhLCBiXG4gIGE6IFQ7XG4gIGI6IFQ7XG5cbiAgLy8gT3B0aW9uYWwgcGFyYW1zXG4gIGFsbG93ZWRQcml2YXRlS2V5TGVuZ3Rocz86IHJlYWRvbmx5IG51bWJlcltdOyAvLyBmb3IgUDUyMVxuICB3cmFwUHJpdmF0ZUtleT86IGJvb2xlYW47IC8vIGJsczEyLTM4MSByZXF1aXJlcyBtb2QobikgaW5zdGVhZCBvZiByZWplY3Rpbmcga2V5cyA+PSBuXG4gIGVuZG8/OiBFbmRvbW9ycGhpc21PcHRzOyAvLyBFbmRvbW9ycGhpc20gb3B0aW9ucyBmb3IgS29ibGl0eiBjdXJ2ZXNcbiAgLy8gV2hlbiBhIGNvZmFjdG9yICE9IDEsIHRoZXJlIGNhbiBiZSBhbiBlZmZlY3RpdmUgbWV0aG9kcyB0bzpcbiAgLy8gMS4gRGV0ZXJtaW5lIHdoZXRoZXIgYSBwb2ludCBpcyB0b3JzaW9uLWZyZWVcbiAgaXNUb3JzaW9uRnJlZT86IChjOiBQcm9qQ29uc3RydWN0b3I8VD4sIHBvaW50OiBQcm9qUG9pbnRUeXBlPFQ+KSA9PiBib29sZWFuO1xuICAvLyAyLiBDbGVhciB0b3JzaW9uIGNvbXBvbmVudFxuICBjbGVhckNvZmFjdG9yPzogKGM6IFByb2pDb25zdHJ1Y3RvcjxUPiwgcG9pbnQ6IFByb2pQb2ludFR5cGU8VD4pID0+IFByb2pQb2ludFR5cGU8VD47XG59O1xuXG50eXBlIEVudHJvcHkgPSBIZXggfCB0cnVlO1xuZXhwb3J0IHR5cGUgU2lnbk9wdHMgPSB7IGxvd1M/OiBib29sZWFuOyBleHRyYUVudHJvcHk/OiBFbnRyb3B5OyBwcmVoYXNoPzogYm9vbGVhbiB9O1xuZXhwb3J0IHR5cGUgVmVyT3B0cyA9IHsgbG93Uz86IGJvb2xlYW47IHByZWhhc2g/OiBib29sZWFuIH07XG5cbi8qKlxuICogIyMjIERlc2lnbiByYXRpb25hbGUgZm9yIHR5cGVzXG4gKlxuICogKiBJbnRlcmFjdGlvbiBiZXR3ZWVuIGNsYXNzZXMgZnJvbSBkaWZmZXJlbnQgY3VydmVzIHNob3VsZCBmYWlsOlxuICogICBgazI1Ni5Qb2ludC5CQVNFLmFkZChwMjU2LlBvaW50LkJBU0UpYFxuICogKiBGb3IgdGhpcyBwdXJwb3NlIHdlIHdhbnQgdG8gdXNlIGBpbnN0YW5jZW9mYCBvcGVyYXRvciwgd2hpY2ggaXMgZmFzdCBhbmQgd29ya3MgZHVyaW5nIHJ1bnRpbWVcbiAqICogRGlmZmVyZW50IGNhbGxzIG9mIGBjdXJ2ZSgpYCB3b3VsZCByZXR1cm4gZGlmZmVyZW50IGNsYXNzZXMgLVxuICogICBgY3VydmUocGFyYW1zKSAhPT0gY3VydmUocGFyYW1zKWA6IGlmIHNvbWVib2R5IGRlY2lkZWQgdG8gbW9ua2V5LXBhdGNoIHRoZWlyIGN1cnZlLFxuICogICBpdCB3b24ndCBhZmZlY3Qgb3RoZXJzXG4gKlxuICogVHlwZVNjcmlwdCBjYW4ndCBpbmZlciB0eXBlcyBmb3IgY2xhc3NlcyBjcmVhdGVkIGluc2lkZSBhIGZ1bmN0aW9uLiBDbGFzc2VzIGlzIG9uZSBpbnN0YW5jZSBvZiBub21pbmF0aXZlIHR5cGVzIGluIFR5cGVTY3JpcHQgYW5kIGludGVyZmFjZXMgb25seSBjaGVjayBmb3Igc2hhcGUsIHNvIGl0J3MgaGFyZCB0byBjcmVhdGUgdW5pcXVlIHR5cGUgZm9yIGV2ZXJ5IGZ1bmN0aW9uIGNhbGwuXG4gKlxuICogV2UgY2FuIHVzZSBnZW5lcmljIHR5cGVzIHZpYSBzb21lIHBhcmFtLCBsaWtlIGN1cnZlIG9wdHMsIGJ1dCB0aGF0IHdvdWxkOlxuICogICAgIDEuIEVuYWJsZSBpbnRlcmFjdGlvbiBiZXR3ZWVuIGBjdXJ2ZShwYXJhbXMpYCBhbmQgYGN1cnZlKHBhcmFtcylgIChjdXJ2ZXMgb2Ygc2FtZSBwYXJhbXMpXG4gKiAgICAgd2hpY2ggaXMgaGFyZCB0byBkZWJ1Zy5cbiAqICAgICAyLiBQYXJhbXMgY2FuIGJlIGdlbmVyaWMgYW5kIHdlIGNhbid0IGVuZm9yY2UgdGhlbSB0byBiZSBjb25zdGFudCB2YWx1ZTpcbiAqICAgICBpZiBzb21lYm9keSBjcmVhdGVzIGN1cnZlIGZyb20gbm9uLWNvbnN0YW50IHBhcmFtcyxcbiAqICAgICBpdCB3b3VsZCBiZSBhbGxvd2VkIHRvIGludGVyYWN0IHdpdGggb3RoZXIgY3VydmVzIHdpdGggbm9uLWNvbnN0YW50IHBhcmFtc1xuICpcbiAqIFRPRE86IGh0dHBzOi8vd3d3LnR5cGVzY3JpcHRsYW5nLm9yZy9kb2NzL2hhbmRib29rL3JlbGVhc2Utbm90ZXMvdHlwZXNjcmlwdC0yLTcuaHRtbCN1bmlxdWUtc3ltYm9sXG4gKi9cblxuLy8gSW5zdGFuY2UgZm9yIDNkIFhZWiBwb2ludHNcbmV4cG9ydCBpbnRlcmZhY2UgUHJvalBvaW50VHlwZTxUPiBleHRlbmRzIEdyb3VwPFByb2pQb2ludFR5cGU8VD4+IHtcbiAgcmVhZG9ubHkgcHg6IFQ7XG4gIHJlYWRvbmx5IHB5OiBUO1xuICByZWFkb25seSBwejogVDtcbiAgZ2V0IHgoKTogVDtcbiAgZ2V0IHkoKTogVDtcbiAgbXVsdGlwbHkoc2NhbGFyOiBiaWdpbnQpOiBQcm9qUG9pbnRUeXBlPFQ+O1xuICB0b0FmZmluZShpej86IFQpOiBBZmZpbmVQb2ludDxUPjtcbiAgaXNUb3JzaW9uRnJlZSgpOiBib29sZWFuO1xuICBjbGVhckNvZmFjdG9yKCk6IFByb2pQb2ludFR5cGU8VD47XG4gIGFzc2VydFZhbGlkaXR5KCk6IHZvaWQ7XG4gIGhhc0V2ZW5ZKCk6IGJvb2xlYW47XG4gIHRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkPzogYm9vbGVhbik6IFVpbnQ4QXJyYXk7XG4gIHRvSGV4KGlzQ29tcHJlc3NlZD86IGJvb2xlYW4pOiBzdHJpbmc7XG5cbiAgbXVsdGlwbHlVbnNhZmUoc2NhbGFyOiBiaWdpbnQpOiBQcm9qUG9pbnRUeXBlPFQ+O1xuICBtdWx0aXBseUFuZEFkZFVuc2FmZShROiBQcm9qUG9pbnRUeXBlPFQ+LCBhOiBiaWdpbnQsIGI6IGJpZ2ludCk6IFByb2pQb2ludFR5cGU8VD4gfCB1bmRlZmluZWQ7XG4gIF9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemU6IG51bWJlcik6IHZvaWQ7XG59XG4vLyBTdGF0aWMgbWV0aG9kcyBmb3IgM2QgWFlaIHBvaW50c1xuZXhwb3J0IGludGVyZmFjZSBQcm9qQ29uc3RydWN0b3I8VD4gZXh0ZW5kcyBHcm91cENvbnN0cnVjdG9yPFByb2pQb2ludFR5cGU8VD4+IHtcbiAgbmV3ICh4OiBULCB5OiBULCB6OiBUKTogUHJvalBvaW50VHlwZTxUPjtcbiAgZnJvbUFmZmluZShwOiBBZmZpbmVQb2ludDxUPik6IFByb2pQb2ludFR5cGU8VD47XG4gIGZyb21IZXgoaGV4OiBIZXgpOiBQcm9qUG9pbnRUeXBlPFQ+O1xuICBmcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5OiBQcml2S2V5KTogUHJvalBvaW50VHlwZTxUPjtcbiAgbm9ybWFsaXplWihwb2ludHM6IFByb2pQb2ludFR5cGU8VD5bXSk6IFByb2pQb2ludFR5cGU8VD5bXTtcbn1cblxuZXhwb3J0IHR5cGUgQ3VydmVQb2ludHNUeXBlPFQ+ID0gQmFzaWNXQ3VydmU8VD4gJiB7XG4gIC8vIEJ5dGVzXG4gIGZyb21CeXRlcz86IChieXRlczogVWludDhBcnJheSkgPT4gQWZmaW5lUG9pbnQ8VD47XG4gIHRvQnl0ZXM/OiAoYzogUHJvakNvbnN0cnVjdG9yPFQ+LCBwb2ludDogUHJvalBvaW50VHlwZTxUPiwgaXNDb21wcmVzc2VkOiBib29sZWFuKSA9PiBVaW50OEFycmF5O1xufTtcblxuZnVuY3Rpb24gdmFsaWRhdGVQb2ludE9wdHM8VD4oY3VydmU6IEN1cnZlUG9pbnRzVHlwZTxUPikge1xuICBjb25zdCBvcHRzID0gdmFsaWRhdGVCYXNpYyhjdXJ2ZSk7XG4gIHV0LnZhbGlkYXRlT2JqZWN0KFxuICAgIG9wdHMsXG4gICAge1xuICAgICAgYTogJ2ZpZWxkJyxcbiAgICAgIGI6ICdmaWVsZCcsXG4gICAgfSxcbiAgICB7XG4gICAgICBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHM6ICdhcnJheScsXG4gICAgICB3cmFwUHJpdmF0ZUtleTogJ2Jvb2xlYW4nLFxuICAgICAgaXNUb3JzaW9uRnJlZTogJ2Z1bmN0aW9uJyxcbiAgICAgIGNsZWFyQ29mYWN0b3I6ICdmdW5jdGlvbicsXG4gICAgICBhbGxvd0luZmluaXR5UG9pbnQ6ICdib29sZWFuJyxcbiAgICAgIGZyb21CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICAgIHRvQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgfVxuICApO1xuICBjb25zdCB7IGVuZG8sIEZwLCBhIH0gPSBvcHRzO1xuICBpZiAoZW5kbykge1xuICAgIGlmICghRnAuZXFsKGEsIEZwLlpFUk8pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuZG9tb3JwaGlzbSBjYW4gb25seSBiZSBkZWZpbmVkIGZvciBLb2JsaXR6IGN1cnZlcyB0aGF0IGhhdmUgYT0wJyk7XG4gICAgfVxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBlbmRvICE9PSAnb2JqZWN0JyB8fFxuICAgICAgdHlwZW9mIGVuZG8uYmV0YSAhPT0gJ2JpZ2ludCcgfHxcbiAgICAgIHR5cGVvZiBlbmRvLnNwbGl0U2NhbGFyICE9PSAnZnVuY3Rpb24nXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGVuZG9tb3JwaGlzbSB3aXRoIGJldGE6IGJpZ2ludCBhbmQgc3BsaXRTY2FsYXI6IGZ1bmN0aW9uJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHsgLi4ub3B0cyB9IGFzIGNvbnN0KTtcbn1cblxuZXhwb3J0IHR5cGUgQ3VydmVQb2ludHNSZXM8VD4gPSB7XG4gIFByb2plY3RpdmVQb2ludDogUHJvakNvbnN0cnVjdG9yPFQ+O1xuICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyOiAoa2V5OiBQcml2S2V5KSA9PiBiaWdpbnQ7XG4gIHdlaWVyc3RyYXNzRXF1YXRpb246ICh4OiBUKSA9PiBUO1xuICBpc1dpdGhpbkN1cnZlT3JkZXI6IChudW06IGJpZ2ludCkgPT4gYm9vbGVhbjtcbn07XG5cbi8vIEFTTi4xIERFUiBlbmNvZGluZyB1dGlsaXRpZXNcbmNvbnN0IHsgYnl0ZXNUb051bWJlckJFOiBiMm4sIGhleFRvQnl0ZXM6IGgyYiB9ID0gdXQ7XG5leHBvcnQgY29uc3QgREVSID0ge1xuICAvLyBhc24uMSBERVIgZW5jb2RpbmcgdXRpbHNcbiAgRXJyOiBjbGFzcyBERVJFcnIgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobSA9ICcnKSB7XG4gICAgICBzdXBlcihtKTtcbiAgICB9XG4gIH0sXG4gIF9wYXJzZUludChkYXRhOiBVaW50OEFycmF5KTogeyBkOiBiaWdpbnQ7IGw6IFVpbnQ4QXJyYXkgfSB7XG4gICAgY29uc3QgeyBFcnI6IEUgfSA9IERFUjtcbiAgICBpZiAoZGF0YS5sZW5ndGggPCAyIHx8IGRhdGFbMF0gIT09IDB4MDIpIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyIHRhZycpO1xuICAgIGNvbnN0IGxlbiA9IGRhdGFbMV07XG4gICAgY29uc3QgcmVzID0gZGF0YS5zdWJhcnJheSgyLCBsZW4gKyAyKTtcbiAgICBpZiAoIWxlbiB8fCByZXMubGVuZ3RoICE9PSBsZW4pIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiB3cm9uZyBsZW5ndGgnKTtcbiAgICAvLyBodHRwczovL2NyeXB0by5zdGFja2V4Y2hhbmdlLmNvbS9hLzU3NzM0IExlZnRtb3N0IGJpdCBvZiBmaXJzdCBieXRlIGlzICduZWdhdGl2ZScgZmxhZyxcbiAgICAvLyBzaW5jZSB3ZSBhbHdheXMgdXNlIHBvc2l0aXZlIGludGVnZXJzIGhlcmUuIEl0IG11c3QgYWx3YXlzIGJlIGVtcHR5OlxuICAgIC8vIC0gYWRkIHplcm8gYnl0ZSBpZiBleGlzdHNcbiAgICAvLyAtIGlmIG5leHQgYnl0ZSBkb2Vzbid0IGhhdmUgYSBmbGFnLCBsZWFkaW5nIHplcm8gaXMgbm90IGFsbG93ZWQgKG1pbmltYWwgZW5jb2RpbmcpXG4gICAgaWYgKHJlc1swXSAmIDBiMTAwMDAwMDApIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiBuZWdhdGl2ZScpO1xuICAgIGlmIChyZXNbMF0gPT09IDB4MDAgJiYgIShyZXNbMV0gJiAwYjEwMDAwMDAwKSlcbiAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiB1bm5lY2Vzc2FyeSBsZWFkaW5nIHplcm8nKTtcbiAgICByZXR1cm4geyBkOiBiMm4ocmVzKSwgbDogZGF0YS5zdWJhcnJheShsZW4gKyAyKSB9OyAvLyBkIGlzIGRhdGEsIGwgaXMgbGVmdFxuICB9LFxuICB0b1NpZyhoZXg6IHN0cmluZyB8IFVpbnQ4QXJyYXkpOiB7IHI6IGJpZ2ludDsgczogYmlnaW50IH0ge1xuICAgIC8vIHBhcnNlIERFUiBzaWduYXR1cmVcbiAgICBjb25zdCB7IEVycjogRSB9ID0gREVSO1xuICAgIGNvbnN0IGRhdGEgPSB0eXBlb2YgaGV4ID09PSAnc3RyaW5nJyA/IGgyYihoZXgpIDogaGV4O1xuICAgIGlmICghKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkgdGhyb3cgbmV3IEVycm9yKCd1aThhIGV4cGVjdGVkJyk7XG4gICAgbGV0IGwgPSBkYXRhLmxlbmd0aDtcbiAgICBpZiAobCA8IDIgfHwgZGF0YVswXSAhPSAweDMwKSB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgdGFnJyk7XG4gICAgaWYgKGRhdGFbMV0gIT09IGwgLSAyKSB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmU6IGluY29ycmVjdCBsZW5ndGgnKTtcbiAgICBjb25zdCB7IGQ6IHIsIGw6IHNCeXRlcyB9ID0gREVSLl9wYXJzZUludChkYXRhLnN1YmFycmF5KDIpKTtcbiAgICBjb25zdCB7IGQ6IHMsIGw6IHJCeXRlc0xlZnQgfSA9IERFUi5fcGFyc2VJbnQoc0J5dGVzKTtcbiAgICBpZiAockJ5dGVzTGVmdC5sZW5ndGgpIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZTogbGVmdCBieXRlcyBhZnRlciBwYXJzaW5nJyk7XG4gICAgcmV0dXJuIHsgciwgcyB9O1xuICB9LFxuICBoZXhGcm9tU2lnKHNpZzogeyByOiBiaWdpbnQ7IHM6IGJpZ2ludCB9KTogc3RyaW5nIHtcbiAgICAvLyBBZGQgbGVhZGluZyB6ZXJvIGlmIGZpcnN0IGJ5dGUgaGFzIG5lZ2F0aXZlIGJpdCBlbmFibGVkLiBNb3JlIGRldGFpbHMgaW4gJ19wYXJzZUludCdcbiAgICBjb25zdCBzbGljZSA9IChzOiBzdHJpbmcpOiBzdHJpbmcgPT4gKE51bWJlci5wYXJzZUludChzWzBdLCAxNikgJiAwYjEwMDAgPyAnMDAnICsgcyA6IHMpO1xuICAgIGNvbnN0IGggPSAobnVtOiBudW1iZXIgfCBiaWdpbnQpID0+IHtcbiAgICAgIGNvbnN0IGhleCA9IG51bS50b1N0cmluZygxNik7XG4gICAgICByZXR1cm4gaGV4Lmxlbmd0aCAmIDEgPyBgMCR7aGV4fWAgOiBoZXg7XG4gICAgfTtcbiAgICBjb25zdCBzID0gc2xpY2UoaChzaWcucykpO1xuICAgIGNvbnN0IHIgPSBzbGljZShoKHNpZy5yKSk7XG4gICAgY29uc3Qgc2hsID0gcy5sZW5ndGggLyAyO1xuICAgIGNvbnN0IHJobCA9IHIubGVuZ3RoIC8gMjtcbiAgICBjb25zdCBzbCA9IGgoc2hsKTtcbiAgICBjb25zdCBybCA9IGgocmhsKTtcbiAgICByZXR1cm4gYDMwJHtoKHJobCArIHNobCArIDQpfTAyJHtybH0ke3J9MDIke3NsfSR7c31gO1xuICB9LFxufTtcblxuLy8gQmUgZnJpZW5kbHkgdG8gYmFkIEVDTUFTY3JpcHQgcGFyc2VycyBieSBub3QgdXNpbmcgYmlnaW50IGxpdGVyYWxzXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF8zbiA9IEJpZ0ludCgzKSwgXzRuID0gQmlnSW50KDQpO1xuXG5leHBvcnQgZnVuY3Rpb24gd2VpZXJzdHJhc3NQb2ludHM8VD4ob3B0czogQ3VydmVQb2ludHNUeXBlPFQ+KSB7XG4gIGNvbnN0IENVUlZFID0gdmFsaWRhdGVQb2ludE9wdHMob3B0cyk7XG4gIGNvbnN0IHsgRnAgfSA9IENVUlZFOyAvLyBBbGwgY3VydmVzIGhhcyBzYW1lIGZpZWxkIC8gZ3JvdXAgbGVuZ3RoIGFzIGZvciBub3csIGJ1dCB0aGV5IGNhbiBkaWZmZXJcblxuICBjb25zdCB0b0J5dGVzID1cbiAgICBDVVJWRS50b0J5dGVzIHx8XG4gICAgKChfYzogUHJvakNvbnN0cnVjdG9yPFQ+LCBwb2ludDogUHJvalBvaW50VHlwZTxUPiwgX2lzQ29tcHJlc3NlZDogYm9vbGVhbikgPT4ge1xuICAgICAgY29uc3QgYSA9IHBvaW50LnRvQWZmaW5lKCk7XG4gICAgICByZXR1cm4gdXQuY29uY2F0Qnl0ZXMoVWludDhBcnJheS5mcm9tKFsweDA0XSksIEZwLnRvQnl0ZXMoYS54KSwgRnAudG9CeXRlcyhhLnkpKTtcbiAgICB9KTtcbiAgY29uc3QgZnJvbUJ5dGVzID1cbiAgICBDVVJWRS5mcm9tQnl0ZXMgfHxcbiAgICAoKGJ5dGVzOiBVaW50OEFycmF5KSA9PiB7XG4gICAgICAvLyBjb25zdCBoZWFkID0gYnl0ZXNbMF07XG4gICAgICBjb25zdCB0YWlsID0gYnl0ZXMuc3ViYXJyYXkoMSk7XG4gICAgICAvLyBpZiAoaGVhZCAhPT0gMHgwNCkgdGhyb3cgbmV3IEVycm9yKCdPbmx5IG5vbi1jb21wcmVzc2VkIGVuY29kaW5nIGlzIHN1cHBvcnRlZCcpO1xuICAgICAgY29uc3QgeCA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KDAsIEZwLkJZVEVTKSk7XG4gICAgICBjb25zdCB5ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoRnAuQllURVMsIDIgKiBGcC5CWVRFUykpO1xuICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH0pO1xuXG4gIC8qKlxuICAgKiB5XHUwMEIyID0geFx1MDBCMyArIGF4ICsgYjogU2hvcnQgd2VpZXJzdHJhc3MgY3VydmUgZm9ybXVsYVxuICAgKiBAcmV0dXJucyB5XHUwMEIyXG4gICAqL1xuICBmdW5jdGlvbiB3ZWllcnN0cmFzc0VxdWF0aW9uKHg6IFQpOiBUIHtcbiAgICBjb25zdCB7IGEsIGIgfSA9IENVUlZFO1xuICAgIGNvbnN0IHgyID0gRnAuc3FyKHgpOyAvLyB4ICogeFxuICAgIGNvbnN0IHgzID0gRnAubXVsKHgyLCB4KTsgLy8geDIgKiB4XG4gICAgcmV0dXJuIEZwLmFkZChGcC5hZGQoeDMsIEZwLm11bCh4LCBhKSksIGIpOyAvLyB4MyArIGEgKiB4ICsgYlxuICB9XG4gIC8vIFZhbGlkYXRlIHdoZXRoZXIgdGhlIHBhc3NlZCBjdXJ2ZSBwYXJhbXMgYXJlIHZhbGlkLlxuICAvLyBXZSBjaGVjayBpZiBjdXJ2ZSBlcXVhdGlvbiB3b3JrcyBmb3IgZ2VuZXJhdG9yIHBvaW50LlxuICAvLyBgYXNzZXJ0VmFsaWRpdHkoKWAgd29uJ3Qgd29yazogYGlzVG9yc2lvbkZyZWUoKWAgaXMgbm90IGF2YWlsYWJsZSBhdCB0aGlzIHBvaW50IGluIGJsczEyLTM4MS5cbiAgLy8gUHJvamVjdGl2ZVBvaW50IGNsYXNzIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXQuXG4gIGlmICghRnAuZXFsKEZwLnNxcihDVVJWRS5HeSksIHdlaWVyc3RyYXNzRXF1YXRpb24oQ1VSVkUuR3gpKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBnZW5lcmF0b3IgcG9pbnQ6IGVxdWF0aW9uIGxlZnQgIT0gcmlnaHQnKTtcblxuICAvLyBWYWxpZCBncm91cCBlbGVtZW50cyByZXNpZGUgaW4gcmFuZ2UgMS4ubi0xXG4gIGZ1bmN0aW9uIGlzV2l0aGluQ3VydmVPcmRlcihudW06IGJpZ2ludCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0eXBlb2YgbnVtID09PSAnYmlnaW50JyAmJiBfMG4gPCBudW0gJiYgbnVtIDwgQ1VSVkUubjtcbiAgfVxuICBmdW5jdGlvbiBhc3NlcnRHRShudW06IGJpZ2ludCkge1xuICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKG51bSkpIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdmFsaWQgYmlnaW50OiAwIDwgYmlnaW50IDwgY3VydmUubicpO1xuICB9XG4gIC8vIFZhbGlkYXRlcyBpZiBwcml2IGtleSBpcyB2YWxpZCBhbmQgY29udmVydHMgaXQgdG8gYmlnaW50LlxuICAvLyBTdXBwb3J0cyBvcHRpb25zIGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RocyBhbmQgd3JhcFByaXZhdGVLZXkuXG4gIGZ1bmN0aW9uIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIoa2V5OiBQcml2S2V5KTogYmlnaW50IHtcbiAgICBjb25zdCB7IGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RoczogbGVuZ3RocywgbkJ5dGVMZW5ndGgsIHdyYXBQcml2YXRlS2V5LCBuIH0gPSBDVVJWRTtcbiAgICBpZiAobGVuZ3RocyAmJiB0eXBlb2Yga2V5ICE9PSAnYmlnaW50Jykge1xuICAgICAgaWYgKGtleSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIGtleSA9IHV0LmJ5dGVzVG9IZXgoa2V5KTtcbiAgICAgIC8vIE5vcm1hbGl6ZSB0byBoZXggc3RyaW5nLCBwYWQuIEUuZy4gUDUyMSB3b3VsZCBub3JtIDEzMC0xMzIgY2hhciBoZXggdG8gMTMyLWNoYXIgYnl0ZXNcbiAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJyB8fCAhbGVuZ3Rocy5pbmNsdWRlcyhrZXkubGVuZ3RoKSkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGtleScpO1xuICAgICAga2V5ID0ga2V5LnBhZFN0YXJ0KG5CeXRlTGVuZ3RoICogMiwgJzAnKTtcbiAgICB9XG4gICAgbGV0IG51bTogYmlnaW50O1xuICAgIHRyeSB7XG4gICAgICBudW0gPVxuICAgICAgICB0eXBlb2Yga2V5ID09PSAnYmlnaW50J1xuICAgICAgICAgID8ga2V5XG4gICAgICAgICAgOiB1dC5ieXRlc1RvTnVtYmVyQkUoZW5zdXJlQnl0ZXMoJ3ByaXZhdGUga2V5Jywga2V5LCBuQnl0ZUxlbmd0aCkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHByaXZhdGUga2V5IG11c3QgYmUgJHtuQnl0ZUxlbmd0aH0gYnl0ZXMsIGhleCBvciBiaWdpbnQsIG5vdCAke3R5cGVvZiBrZXl9YCk7XG4gICAgfVxuICAgIGlmICh3cmFwUHJpdmF0ZUtleSkgbnVtID0gbW9kLm1vZChudW0sIG4pOyAvLyBkaXNhYmxlZCBieSBkZWZhdWx0LCBlbmFibGVkIGZvciBCTFNcbiAgICBhc3NlcnRHRShudW0pOyAvLyBudW0gaW4gcmFuZ2UgWzEuLk4tMV1cbiAgICByZXR1cm4gbnVtO1xuICB9XG5cbiAgY29uc3QgcG9pbnRQcmVjb21wdXRlcyA9IG5ldyBNYXA8UG9pbnQsIFBvaW50W10+KCk7XG4gIGZ1bmN0aW9uIGFzc2VydFByalBvaW50KG90aGVyOiB1bmtub3duKSB7XG4gICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBQb2ludCkpIHRocm93IG5ldyBFcnJvcignUHJvamVjdGl2ZVBvaW50IGV4cGVjdGVkJyk7XG4gIH1cbiAgLyoqXG4gICAqIFByb2plY3RpdmUgUG9pbnQgd29ya3MgaW4gM2QgLyBwcm9qZWN0aXZlIChob21vZ2VuZW91cykgY29vcmRpbmF0ZXM6ICh4LCB5LCB6KSBcdTIyMEIgKHg9eC96LCB5PXkveilcbiAgICogRGVmYXVsdCBQb2ludCB3b3JrcyBpbiAyZCAvIGFmZmluZSBjb29yZGluYXRlczogKHgsIHkpXG4gICAqIFdlJ3JlIGRvaW5nIGNhbGN1bGF0aW9ucyBpbiBwcm9qZWN0aXZlLCBiZWNhdXNlIGl0cyBvcGVyYXRpb25zIGRvbid0IHJlcXVpcmUgY29zdGx5IGludmVyc2lvbi5cbiAgICovXG4gIGNsYXNzIFBvaW50IGltcGxlbWVudHMgUHJvalBvaW50VHlwZTxUPiB7XG4gICAgc3RhdGljIHJlYWRvbmx5IEJBU0UgPSBuZXcgUG9pbnQoQ1VSVkUuR3gsIENVUlZFLkd5LCBGcC5PTkUpO1xuICAgIHN0YXRpYyByZWFkb25seSBaRVJPID0gbmV3IFBvaW50KEZwLlpFUk8sIEZwLk9ORSwgRnAuWkVSTyk7XG5cbiAgICBjb25zdHJ1Y3RvcihyZWFkb25seSBweDogVCwgcmVhZG9ubHkgcHk6IFQsIHJlYWRvbmx5IHB6OiBUKSB7XG4gICAgICBpZiAocHggPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweCkpIHRocm93IG5ldyBFcnJvcigneCByZXF1aXJlZCcpO1xuICAgICAgaWYgKHB5ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHkpKSB0aHJvdyBuZXcgRXJyb3IoJ3kgcmVxdWlyZWQnKTtcbiAgICAgIGlmIChweiA9PSBudWxsIHx8ICFGcC5pc1ZhbGlkKHB6KSkgdGhyb3cgbmV3IEVycm9yKCd6IHJlcXVpcmVkJyk7XG4gICAgfVxuXG4gICAgLy8gRG9lcyBub3QgdmFsaWRhdGUgaWYgdGhlIHBvaW50IGlzIG9uLWN1cnZlLlxuICAgIC8vIFVzZSBmcm9tSGV4IGluc3RlYWQsIG9yIGNhbGwgYXNzZXJ0VmFsaWRpdHkoKSBsYXRlci5cbiAgICBzdGF0aWMgZnJvbUFmZmluZShwOiBBZmZpbmVQb2ludDxUPik6IFBvaW50IHtcbiAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcCB8fCB7fTtcbiAgICAgIGlmICghcCB8fCAhRnAuaXNWYWxpZCh4KSB8fCAhRnAuaXNWYWxpZCh5KSkgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFmZmluZSBwb2ludCcpO1xuICAgICAgaWYgKHAgaW5zdGFuY2VvZiBQb2ludCkgdGhyb3cgbmV3IEVycm9yKCdwcm9qZWN0aXZlIHBvaW50IG5vdCBhbGxvd2VkJyk7XG4gICAgICBjb25zdCBpczAgPSAoaTogVCkgPT4gRnAuZXFsKGksIEZwLlpFUk8pO1xuICAgICAgLy8gZnJvbUFmZmluZSh4OjAsIHk6MCkgd291bGQgcHJvZHVjZSAoeDowLCB5OjAsIHo6MSksIGJ1dCB3ZSBuZWVkICh4OjAsIHk6MSwgejowKVxuICAgICAgaWYgKGlzMCh4KSAmJiBpczAoeSkpIHJldHVybiBQb2ludC5aRVJPO1xuICAgICAgcmV0dXJuIG5ldyBQb2ludCh4LCB5LCBGcC5PTkUpO1xuICAgIH1cblxuICAgIGdldCB4KCk6IFQge1xuICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS54O1xuICAgIH1cbiAgICBnZXQgeSgpOiBUIHtcbiAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUYWtlcyBhIGJ1bmNoIG9mIFByb2plY3RpdmUgUG9pbnRzIGJ1dCBleGVjdXRlcyBvbmx5IG9uZVxuICAgICAqIGludmVyc2lvbiBvbiBhbGwgb2YgdGhlbS4gSW52ZXJzaW9uIGlzIHZlcnkgc2xvdyBvcGVyYXRpb24sXG4gICAgICogc28gdGhpcyBpbXByb3ZlcyBwZXJmb3JtYW5jZSBtYXNzaXZlbHkuXG4gICAgICogT3B0aW1pemF0aW9uOiBjb252ZXJ0cyBhIGxpc3Qgb2YgcHJvamVjdGl2ZSBwb2ludHMgdG8gYSBsaXN0IG9mIGlkZW50aWNhbCBwb2ludHMgd2l0aCBaPTEuXG4gICAgICovXG4gICAgc3RhdGljIG5vcm1hbGl6ZVoocG9pbnRzOiBQb2ludFtdKTogUG9pbnRbXSB7XG4gICAgICBjb25zdCB0b0ludiA9IEZwLmludmVydEJhdGNoKHBvaW50cy5tYXAoKHApID0+IHAucHopKTtcbiAgICAgIHJldHVybiBwb2ludHMubWFwKChwLCBpKSA9PiBwLnRvQWZmaW5lKHRvSW52W2ldKSkubWFwKFBvaW50LmZyb21BZmZpbmUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGhhc2ggc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gUG9pbnQuXG4gICAgICogQHBhcmFtIGhleCBzaG9ydC9sb25nIEVDRFNBIGhleFxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tSGV4KGhleDogSGV4KTogUG9pbnQge1xuICAgICAgY29uc3QgUCA9IFBvaW50LmZyb21BZmZpbmUoZnJvbUJ5dGVzKGVuc3VyZUJ5dGVzKCdwb2ludEhleCcsIGhleCkpKTtcbiAgICAgIFAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgIHJldHVybiBQO1xuICAgIH1cblxuICAgIC8vIE11bHRpcGxpZXMgZ2VuZXJhdG9yIHBvaW50IGJ5IHByaXZhdGVLZXkuXG4gICAgc3RhdGljIGZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXk6IFByaXZLZXkpIHtcbiAgICAgIHJldHVybiBQb2ludC5CQVNFLm11bHRpcGx5KG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSkpO1xuICAgIH1cblxuICAgIC8vIFdlIGNhbGN1bGF0ZSBwcmVjb21wdXRlcyBmb3IgZWxsaXB0aWMgY3VydmUgcG9pbnQgbXVsdGlwbGljYXRpb25cbiAgICAvLyB1c2luZyB3aW5kb3dlZCBtZXRob2QuIFRoaXMgc3BlY2lmaWVzIHdpbmRvdyBzaXplIGFuZFxuICAgIC8vIHN0b3JlcyBwcmVjb21wdXRlZCB2YWx1ZXMuIFVzdWFsbHkgb25seSBiYXNlIHBvaW50IHdvdWxkIGJlIHByZWNvbXB1dGVkLlxuICAgIF9XSU5ET1dfU0laRT86IG51bWJlcjtcblxuICAgIC8vIFwiUHJpdmF0ZSBtZXRob2RcIiwgZG9uJ3QgdXNlIGl0IGRpcmVjdGx5XG4gICAgX3NldFdpbmRvd1NpemUod2luZG93U2l6ZTogbnVtYmVyKSB7XG4gICAgICB0aGlzLl9XSU5ET1dfU0laRSA9IHdpbmRvd1NpemU7XG4gICAgICBwb2ludFByZWNvbXB1dGVzLmRlbGV0ZSh0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBBIHBvaW50IG9uIGN1cnZlIGlzIHZhbGlkIGlmIGl0IGNvbmZvcm1zIHRvIGVxdWF0aW9uLlxuICAgIGFzc2VydFZhbGlkaXR5KCk6IHZvaWQge1xuICAgICAgaWYgKHRoaXMuaXMwKCkpIHtcbiAgICAgICAgLy8gKDAsIDEsIDApIGFrYSBaRVJPIGlzIGludmFsaWQgaW4gbW9zdCBjb250ZXh0cy5cbiAgICAgICAgLy8gSW4gQkxTLCBaRVJPIGNhbiBiZSBzZXJpYWxpemVkLCBzbyB3ZSBhbGxvdyBpdC5cbiAgICAgICAgLy8gKDAsIDAsIDApIGlzIHdyb25nIHJlcHJlc2VudGF0aW9uIG9mIFpFUk8gYW5kIGlzIGFsd2F5cyBpbnZhbGlkLlxuICAgICAgICBpZiAoQ1VSVkUuYWxsb3dJbmZpbml0eVBvaW50ICYmICFGcC5pczAodGhpcy5weSkpIHJldHVybjtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IFpFUk8nKTtcbiAgICAgIH1cbiAgICAgIC8vIFNvbWUgM3JkLXBhcnR5IHRlc3QgdmVjdG9ycyByZXF1aXJlIGRpZmZlcmVudCB3b3JkaW5nIGJldHdlZW4gaGVyZSAmIGBmcm9tQ29tcHJlc3NlZEhleGBcbiAgICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgLy8gQ2hlY2sgaWYgeCwgeSBhcmUgdmFsaWQgZmllbGQgZWxlbWVudHNcbiAgICAgIGlmICghRnAuaXNWYWxpZCh4KSB8fCAhRnAuaXNWYWxpZCh5KSkgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IHggb3IgeSBub3QgRkUnKTtcbiAgICAgIGNvbnN0IGxlZnQgPSBGcC5zcXIoeSk7IC8vIHlcdTAwQjJcbiAgICAgIGNvbnN0IHJpZ2h0ID0gd2VpZXJzdHJhc3NFcXVhdGlvbih4KTsgLy8geFx1MDBCMyArIGF4ICsgYlxuICAgICAgaWYgKCFGcC5lcWwobGVmdCwgcmlnaHQpKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodCcpO1xuICAgICAgaWYgKCF0aGlzLmlzVG9yc2lvbkZyZWUoKSkgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IG5vdCBpbiBwcmltZS1vcmRlciBzdWJncm91cCcpO1xuICAgIH1cbiAgICBoYXNFdmVuWSgpOiBib29sZWFuIHtcbiAgICAgIGNvbnN0IHsgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgaWYgKEZwLmlzT2RkKSByZXR1cm4gIUZwLmlzT2RkKHkpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmllbGQgZG9lc24ndCBzdXBwb3J0IGlzT2RkXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXBhcmUgb25lIHBvaW50IHRvIGFub3RoZXIuXG4gICAgICovXG4gICAgZXF1YWxzKG90aGVyOiBQb2ludCk6IGJvb2xlYW4ge1xuICAgICAgYXNzZXJ0UHJqUG9pbnQob3RoZXIpO1xuICAgICAgY29uc3QgeyBweDogWDEsIHB5OiBZMSwgcHo6IFoxIH0gPSB0aGlzO1xuICAgICAgY29uc3QgeyBweDogWDIsIHB5OiBZMiwgcHo6IFoyIH0gPSBvdGhlcjtcbiAgICAgIGNvbnN0IFUxID0gRnAuZXFsKEZwLm11bChYMSwgWjIpLCBGcC5tdWwoWDIsIFoxKSk7XG4gICAgICBjb25zdCBVMiA9IEZwLmVxbChGcC5tdWwoWTEsIFoyKSwgRnAubXVsKFkyLCBaMSkpO1xuICAgICAgcmV0dXJuIFUxICYmIFUyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZsaXBzIHBvaW50IHRvIG9uZSBjb3JyZXNwb25kaW5nIHRvICh4LCAteSkgaW4gQWZmaW5lIGNvb3JkaW5hdGVzLlxuICAgICAqL1xuICAgIG5lZ2F0ZSgpOiBQb2ludCB7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMucHgsIEZwLm5lZyh0aGlzLnB5KSwgdGhpcy5weik7XG4gICAgfVxuXG4gICAgLy8gUmVuZXMtQ29zdGVsbG8tQmF0aW5hIGV4Y2VwdGlvbi1mcmVlIGRvdWJsaW5nIGZvcm11bGEuXG4gICAgLy8gVGhlcmUgaXMgMzAlIGZhc3RlciBKYWNvYmlhbiBmb3JtdWxhLCBidXQgaXQgaXMgbm90IGNvbXBsZXRlLlxuICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTUvMTA2MCwgYWxnb3JpdGhtIDNcbiAgICAvLyBDb3N0OiA4TSArIDNTICsgMyphICsgMipiMyArIDE1YWRkLlxuICAgIGRvdWJsZSgpIHtcbiAgICAgIGNvbnN0IHsgYSwgYiB9ID0gQ1VSVkU7XG4gICAgICBjb25zdCBiMyA9IEZwLm11bChiLCBfM24pO1xuICAgICAgY29uc3QgeyBweDogWDEsIHB5OiBZMSwgcHo6IFoxIH0gPSB0aGlzO1xuICAgICAgbGV0IFgzID0gRnAuWkVSTywgWTMgPSBGcC5aRVJPLCBaMyA9IEZwLlpFUk87IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgbGV0IHQwID0gRnAubXVsKFgxLCBYMSk7IC8vIHN0ZXAgMVxuICAgICAgbGV0IHQxID0gRnAubXVsKFkxLCBZMSk7XG4gICAgICBsZXQgdDIgPSBGcC5tdWwoWjEsIFoxKTtcbiAgICAgIGxldCB0MyA9IEZwLm11bChYMSwgWTEpO1xuICAgICAgdDMgPSBGcC5hZGQodDMsIHQzKTsgLy8gc3RlcCA1XG4gICAgICBaMyA9IEZwLm11bChYMSwgWjEpO1xuICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTtcbiAgICAgIFgzID0gRnAubXVsKGEsIFozKTtcbiAgICAgIFkzID0gRnAubXVsKGIzLCB0Mik7XG4gICAgICBZMyA9IEZwLmFkZChYMywgWTMpOyAvLyBzdGVwIDEwXG4gICAgICBYMyA9IEZwLnN1Yih0MSwgWTMpO1xuICAgICAgWTMgPSBGcC5hZGQodDEsIFkzKTtcbiAgICAgIFkzID0gRnAubXVsKFgzLCBZMyk7XG4gICAgICBYMyA9IEZwLm11bCh0MywgWDMpO1xuICAgICAgWjMgPSBGcC5tdWwoYjMsIFozKTsgLy8gc3RlcCAxNVxuICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuICAgICAgdDMgPSBGcC5zdWIodDAsIHQyKTtcbiAgICAgIHQzID0gRnAubXVsKGEsIHQzKTtcbiAgICAgIHQzID0gRnAuYWRkKHQzLCBaMyk7XG4gICAgICBaMyA9IEZwLmFkZCh0MCwgdDApOyAvLyBzdGVwIDIwXG4gICAgICB0MCA9IEZwLmFkZChaMywgdDApO1xuICAgICAgdDAgPSBGcC5hZGQodDAsIHQyKTtcbiAgICAgIHQwID0gRnAubXVsKHQwLCB0Myk7XG4gICAgICBZMyA9IEZwLmFkZChZMywgdDApO1xuICAgICAgdDIgPSBGcC5tdWwoWTEsIFoxKTsgLy8gc3RlcCAyNVxuICAgICAgdDIgPSBGcC5hZGQodDIsIHQyKTtcbiAgICAgIHQwID0gRnAubXVsKHQyLCB0Myk7XG4gICAgICBYMyA9IEZwLnN1YihYMywgdDApO1xuICAgICAgWjMgPSBGcC5tdWwodDIsIHQxKTtcbiAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7IC8vIHN0ZXAgMzBcbiAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7XG4gICAgICByZXR1cm4gbmV3IFBvaW50KFgzLCBZMywgWjMpO1xuICAgIH1cblxuICAgIC8vIFJlbmVzLUNvc3RlbGxvLUJhdGluYSBleGNlcHRpb24tZnJlZSBhZGRpdGlvbiBmb3JtdWxhLlxuICAgIC8vIFRoZXJlIGlzIDMwJSBmYXN0ZXIgSmFjb2JpYW4gZm9ybXVsYSwgYnV0IGl0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAvLyBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE1LzEwNjAsIGFsZ29yaXRobSAxXG4gICAgLy8gQ29zdDogMTJNICsgMFMgKyAzKmEgKyAzKmIzICsgMjNhZGQuXG4gICAgYWRkKG90aGVyOiBQb2ludCk6IFBvaW50IHtcbiAgICAgIGFzc2VydFByalBvaW50KG90aGVyKTtcbiAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgIGNvbnN0IHsgcHg6IFgyLCBweTogWTIsIHB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICBsZXQgWDMgPSBGcC5aRVJPLCBZMyA9IEZwLlpFUk8sIFozID0gRnAuWkVSTzsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICBjb25zdCBhID0gQ1VSVkUuYTtcbiAgICAgIGNvbnN0IGIzID0gRnAubXVsKENVUlZFLmIsIF8zbik7XG4gICAgICBsZXQgdDAgPSBGcC5tdWwoWDEsIFgyKTsgLy8gc3RlcCAxXG4gICAgICBsZXQgdDEgPSBGcC5tdWwoWTEsIFkyKTtcbiAgICAgIGxldCB0MiA9IEZwLm11bChaMSwgWjIpO1xuICAgICAgbGV0IHQzID0gRnAuYWRkKFgxLCBZMSk7XG4gICAgICBsZXQgdDQgPSBGcC5hZGQoWDIsIFkyKTsgLy8gc3RlcCA1XG4gICAgICB0MyA9IEZwLm11bCh0MywgdDQpO1xuICAgICAgdDQgPSBGcC5hZGQodDAsIHQxKTtcbiAgICAgIHQzID0gRnAuc3ViKHQzLCB0NCk7XG4gICAgICB0NCA9IEZwLmFkZChYMSwgWjEpO1xuICAgICAgbGV0IHQ1ID0gRnAuYWRkKFgyLCBaMik7IC8vIHN0ZXAgMTBcbiAgICAgIHQ0ID0gRnAubXVsKHQ0LCB0NSk7XG4gICAgICB0NSA9IEZwLmFkZCh0MCwgdDIpO1xuICAgICAgdDQgPSBGcC5zdWIodDQsIHQ1KTtcbiAgICAgIHQ1ID0gRnAuYWRkKFkxLCBaMSk7XG4gICAgICBYMyA9IEZwLmFkZChZMiwgWjIpOyAvLyBzdGVwIDE1XG4gICAgICB0NSA9IEZwLm11bCh0NSwgWDMpO1xuICAgICAgWDMgPSBGcC5hZGQodDEsIHQyKTtcbiAgICAgIHQ1ID0gRnAuc3ViKHQ1LCBYMyk7XG4gICAgICBaMyA9IEZwLm11bChhLCB0NCk7XG4gICAgICBYMyA9IEZwLm11bChiMywgdDIpOyAvLyBzdGVwIDIwXG4gICAgICBaMyA9IEZwLmFkZChYMywgWjMpO1xuICAgICAgWDMgPSBGcC5zdWIodDEsIFozKTtcbiAgICAgIFozID0gRnAuYWRkKHQxLCBaMyk7XG4gICAgICBZMyA9IEZwLm11bChYMywgWjMpO1xuICAgICAgdDEgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyNVxuICAgICAgdDEgPSBGcC5hZGQodDEsIHQwKTtcbiAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgIHQ0ID0gRnAubXVsKGIzLCB0NCk7XG4gICAgICB0MSA9IEZwLmFkZCh0MSwgdDIpO1xuICAgICAgdDIgPSBGcC5zdWIodDAsIHQyKTsgLy8gc3RlcCAzMFxuICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuICAgICAgdDQgPSBGcC5hZGQodDQsIHQyKTtcbiAgICAgIHQwID0gRnAubXVsKHQxLCB0NCk7XG4gICAgICBZMyA9IEZwLmFkZChZMywgdDApO1xuICAgICAgdDAgPSBGcC5tdWwodDUsIHQ0KTsgLy8gc3RlcCAzNVxuICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgIFgzID0gRnAuc3ViKFgzLCB0MCk7XG4gICAgICB0MCA9IEZwLm11bCh0MywgdDEpO1xuICAgICAgWjMgPSBGcC5tdWwodDUsIFozKTtcbiAgICAgIFozID0gRnAuYWRkKFozLCB0MCk7IC8vIHN0ZXAgNDBcbiAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMyk7XG4gICAgfVxuXG4gICAgc3VidHJhY3Qob3RoZXI6IFBvaW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5hZGQob3RoZXIubmVnYXRlKCkpO1xuICAgIH1cblxuICAgIHByaXZhdGUgaXMwKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKFBvaW50LlpFUk8pO1xuICAgIH1cbiAgICBwcml2YXRlIHdOQUYobjogYmlnaW50KTogeyBwOiBQb2ludDsgZjogUG9pbnQgfSB7XG4gICAgICByZXR1cm4gd25hZi53TkFGQ2FjaGVkKHRoaXMsIHBvaW50UHJlY29tcHV0ZXMsIG4sIChjb21wOiBQb2ludFtdKSA9PiB7XG4gICAgICAgIGNvbnN0IHRvSW52ID0gRnAuaW52ZXJ0QmF0Y2goY29tcC5tYXAoKHApID0+IHAucHopKTtcbiAgICAgICAgcmV0dXJuIGNvbXAubWFwKChwLCBpKSA9PiBwLnRvQWZmaW5lKHRvSW52W2ldKSkubWFwKFBvaW50LmZyb21BZmZpbmUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm9uLWNvbnN0YW50LXRpbWUgbXVsdGlwbGljYXRpb24uIFVzZXMgZG91YmxlLWFuZC1hZGQgYWxnb3JpdGhtLlxuICAgICAqIEl0J3MgZmFzdGVyLCBidXQgc2hvdWxkIG9ubHkgYmUgdXNlZCB3aGVuIHlvdSBkb24ndCBjYXJlIGFib3V0XG4gICAgICogYW4gZXhwb3NlZCBwcml2YXRlIGtleSBlLmcuIHNpZyB2ZXJpZmljYXRpb24sIHdoaWNoIHdvcmtzIG92ZXIgKnB1YmxpYyoga2V5cy5cbiAgICAgKi9cbiAgICBtdWx0aXBseVVuc2FmZShuOiBiaWdpbnQpOiBQb2ludCB7XG4gICAgICBjb25zdCBJID0gUG9pbnQuWkVSTztcbiAgICAgIGlmIChuID09PSBfMG4pIHJldHVybiBJO1xuICAgICAgYXNzZXJ0R0Uobik7IC8vIFdpbGwgdGhyb3cgb24gMFxuICAgICAgaWYgKG4gPT09IF8xbikgcmV0dXJuIHRoaXM7XG4gICAgICBjb25zdCB7IGVuZG8gfSA9IENVUlZFO1xuICAgICAgaWYgKCFlbmRvKSByZXR1cm4gd25hZi51bnNhZmVMYWRkZXIodGhpcywgbik7XG5cbiAgICAgIC8vIEFwcGx5IGVuZG9tb3JwaGlzbVxuICAgICAgbGV0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIobik7XG4gICAgICBsZXQgazFwID0gSTtcbiAgICAgIGxldCBrMnAgPSBJO1xuICAgICAgbGV0IGQ6IFBvaW50ID0gdGhpcztcbiAgICAgIHdoaWxlIChrMSA+IF8wbiB8fCBrMiA+IF8wbikge1xuICAgICAgICBpZiAoazEgJiBfMW4pIGsxcCA9IGsxcC5hZGQoZCk7XG4gICAgICAgIGlmIChrMiAmIF8xbikgazJwID0gazJwLmFkZChkKTtcbiAgICAgICAgZCA9IGQuZG91YmxlKCk7XG4gICAgICAgIGsxID4+PSBfMW47XG4gICAgICAgIGsyID4+PSBfMW47XG4gICAgICB9XG4gICAgICBpZiAoazFuZWcpIGsxcCA9IGsxcC5uZWdhdGUoKTtcbiAgICAgIGlmIChrMm5lZykgazJwID0gazJwLm5lZ2F0ZSgpO1xuICAgICAgazJwID0gbmV3IFBvaW50KEZwLm11bChrMnAucHgsIGVuZG8uYmV0YSksIGsycC5weSwgazJwLnB6KTtcbiAgICAgIHJldHVybiBrMXAuYWRkKGsycCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uc3RhbnQgdGltZSBtdWx0aXBsaWNhdGlvbi5cbiAgICAgKiBVc2VzIHdOQUYgbWV0aG9kLiBXaW5kb3dlZCBtZXRob2QgbWF5IGJlIDEwJSBmYXN0ZXIsXG4gICAgICogYnV0IHRha2VzIDJ4IGxvbmdlciB0byBnZW5lcmF0ZSBhbmQgY29uc3VtZXMgMnggbWVtb3J5LlxuICAgICAqIFVzZXMgcHJlY29tcHV0ZXMgd2hlbiBhdmFpbGFibGUuXG4gICAgICogVXNlcyBlbmRvbW9ycGhpc20gZm9yIEtvYmxpdHogY3VydmVzLlxuICAgICAqIEBwYXJhbSBzY2FsYXIgYnkgd2hpY2ggdGhlIHBvaW50IHdvdWxkIGJlIG11bHRpcGxpZWRcbiAgICAgKiBAcmV0dXJucyBOZXcgcG9pbnRcbiAgICAgKi9cbiAgICBtdWx0aXBseShzY2FsYXI6IGJpZ2ludCk6IFBvaW50IHtcbiAgICAgIGFzc2VydEdFKHNjYWxhcik7XG4gICAgICBsZXQgbiA9IHNjYWxhcjtcbiAgICAgIGxldCBwb2ludDogUG9pbnQsIGZha2U6IFBvaW50OyAvLyBGYWtlIHBvaW50IGlzIHVzZWQgdG8gY29uc3QtdGltZSBtdWx0XG4gICAgICBjb25zdCB7IGVuZG8gfSA9IENVUlZFO1xuICAgICAgaWYgKGVuZG8pIHtcbiAgICAgICAgY29uc3QgeyBrMW5lZywgazEsIGsybmVnLCBrMiB9ID0gZW5kby5zcGxpdFNjYWxhcihuKTtcbiAgICAgICAgbGV0IHsgcDogazFwLCBmOiBmMXAgfSA9IHRoaXMud05BRihrMSk7XG4gICAgICAgIGxldCB7IHA6IGsycCwgZjogZjJwIH0gPSB0aGlzLndOQUYoazIpO1xuICAgICAgICBrMXAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMW5lZywgazFwKTtcbiAgICAgICAgazJwID0gd25hZi5jb25zdFRpbWVOZWdhdGUoazJuZWcsIGsycCk7XG4gICAgICAgIGsycCA9IG5ldyBQb2ludChGcC5tdWwoazJwLnB4LCBlbmRvLmJldGEpLCBrMnAucHksIGsycC5weik7XG4gICAgICAgIHBvaW50ID0gazFwLmFkZChrMnApO1xuICAgICAgICBmYWtlID0gZjFwLmFkZChmMnApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgeyBwLCBmIH0gPSB0aGlzLndOQUYobik7XG4gICAgICAgIHBvaW50ID0gcDtcbiAgICAgICAgZmFrZSA9IGY7XG4gICAgICB9XG4gICAgICAvLyBOb3JtYWxpemUgYHpgIGZvciBib3RoIHBvaW50cywgYnV0IHJldHVybiBvbmx5IHJlYWwgb25lXG4gICAgICByZXR1cm4gUG9pbnQubm9ybWFsaXplWihbcG9pbnQsIGZha2VdKVswXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFZmZpY2llbnRseSBjYWxjdWxhdGUgYGFQICsgYlFgLiBVbnNhZmUsIGNhbiBleHBvc2UgcHJpdmF0ZSBrZXksIGlmIHVzZWQgaW5jb3JyZWN0bHkuXG4gICAgICogTm90IHVzaW5nIFN0cmF1c3MtU2hhbWlyIHRyaWNrOiBwcmVjb21wdXRhdGlvbiB0YWJsZXMgYXJlIGZhc3Rlci5cbiAgICAgKiBUaGUgdHJpY2sgY291bGQgYmUgdXNlZnVsIGlmIGJvdGggUCBhbmQgUSBhcmUgbm90IEcgKG5vdCBpbiBvdXIgY2FzZSkuXG4gICAgICogQHJldHVybnMgbm9uLXplcm8gYWZmaW5lIHBvaW50XG4gICAgICovXG4gICAgbXVsdGlwbHlBbmRBZGRVbnNhZmUoUTogUG9pbnQsIGE6IGJpZ2ludCwgYjogYmlnaW50KTogUG9pbnQgfCB1bmRlZmluZWQge1xuICAgICAgY29uc3QgRyA9IFBvaW50LkJBU0U7IC8vIE5vIFN0cmF1c3MtU2hhbWlyIHRyaWNrOiB3ZSBoYXZlIDEwJSBmYXN0ZXIgRyBwcmVjb21wdXRlc1xuICAgICAgY29uc3QgbXVsID0gKFxuICAgICAgICBQOiBQb2ludCxcbiAgICAgICAgYTogYmlnaW50IC8vIFNlbGVjdCBmYXN0ZXIgbXVsdGlwbHkoKSBtZXRob2RcbiAgICAgICkgPT4gKGEgPT09IF8wbiB8fCBhID09PSBfMW4gfHwgIVAuZXF1YWxzKEcpID8gUC5tdWx0aXBseVVuc2FmZShhKSA6IFAubXVsdGlwbHkoYSkpO1xuICAgICAgY29uc3Qgc3VtID0gbXVsKHRoaXMsIGEpLmFkZChtdWwoUSwgYikpO1xuICAgICAgcmV0dXJuIHN1bS5pczAoKSA/IHVuZGVmaW5lZCA6IHN1bTtcbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0cyBQcm9qZWN0aXZlIHBvaW50IHRvIGFmZmluZSAoeCwgeSkgY29vcmRpbmF0ZXMuXG4gICAgLy8gQ2FuIGFjY2VwdCBwcmVjb21wdXRlZCBaXi0xIC0gZm9yIGV4YW1wbGUsIGZyb20gaW52ZXJ0QmF0Y2guXG4gICAgLy8gKHgsIHksIHopIFx1MjIwQiAoeD14L3osIHk9eS96KVxuICAgIHRvQWZmaW5lKGl6PzogVCk6IEFmZmluZVBvaW50PFQ+IHtcbiAgICAgIGNvbnN0IHsgcHg6IHgsIHB5OiB5LCBwejogeiB9ID0gdGhpcztcbiAgICAgIGNvbnN0IGlzMCA9IHRoaXMuaXMwKCk7XG4gICAgICAvLyBJZiBpbnZaIHdhcyAwLCB3ZSByZXR1cm4gemVybyBwb2ludC4gSG93ZXZlciB3ZSBzdGlsbCB3YW50IHRvIGV4ZWN1dGVcbiAgICAgIC8vIGFsbCBvcGVyYXRpb25zLCBzbyB3ZSByZXBsYWNlIGludlogd2l0aCBhIHJhbmRvbSBudW1iZXIsIDEuXG4gICAgICBpZiAoaXogPT0gbnVsbCkgaXogPSBpczAgPyBGcC5PTkUgOiBGcC5pbnYoeik7XG4gICAgICBjb25zdCBheCA9IEZwLm11bCh4LCBpeik7XG4gICAgICBjb25zdCBheSA9IEZwLm11bCh5LCBpeik7XG4gICAgICBjb25zdCB6eiA9IEZwLm11bCh6LCBpeik7XG4gICAgICBpZiAoaXMwKSByZXR1cm4geyB4OiBGcC5aRVJPLCB5OiBGcC5aRVJPIH07XG4gICAgICBpZiAoIUZwLmVxbCh6eiwgRnAuT05FKSkgdGhyb3cgbmV3IEVycm9yKCdpbnZaIHdhcyBpbnZhbGlkJyk7XG4gICAgICByZXR1cm4geyB4OiBheCwgeTogYXkgfTtcbiAgICB9XG4gICAgaXNUb3JzaW9uRnJlZSgpOiBib29sZWFuIHtcbiAgICAgIGNvbnN0IHsgaDogY29mYWN0b3IsIGlzVG9yc2lvbkZyZWUgfSA9IENVUlZFO1xuICAgICAgaWYgKGNvZmFjdG9yID09PSBfMW4pIHJldHVybiB0cnVlOyAvLyBObyBzdWJncm91cHMsIGFsd2F5cyB0b3JzaW9uLWZyZWVcbiAgICAgIGlmIChpc1RvcnNpb25GcmVlKSByZXR1cm4gaXNUb3JzaW9uRnJlZShQb2ludCwgdGhpcyk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lzVG9yc2lvbkZyZWUoKSBoYXMgbm90IGJlZW4gZGVjbGFyZWQgZm9yIHRoZSBlbGxpcHRpYyBjdXJ2ZScpO1xuICAgIH1cbiAgICBjbGVhckNvZmFjdG9yKCk6IFBvaW50IHtcbiAgICAgIGNvbnN0IHsgaDogY29mYWN0b3IsIGNsZWFyQ29mYWN0b3IgfSA9IENVUlZFO1xuICAgICAgaWYgKGNvZmFjdG9yID09PSBfMW4pIHJldHVybiB0aGlzOyAvLyBGYXN0LXBhdGhcbiAgICAgIGlmIChjbGVhckNvZmFjdG9yKSByZXR1cm4gY2xlYXJDb2ZhY3RvcihQb2ludCwgdGhpcykgYXMgUG9pbnQ7XG4gICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVVuc2FmZShDVVJWRS5oKTtcbiAgICB9XG5cbiAgICB0b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCA9IHRydWUpOiBVaW50OEFycmF5IHtcbiAgICAgIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgIHJldHVybiB0b0J5dGVzKFBvaW50LCB0aGlzLCBpc0NvbXByZXNzZWQpO1xuICAgIH1cblxuICAgIHRvSGV4KGlzQ29tcHJlc3NlZCA9IHRydWUpOiBzdHJpbmcge1xuICAgICAgcmV0dXJuIHV0LmJ5dGVzVG9IZXgodGhpcy50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCkpO1xuICAgIH1cbiAgfVxuICBjb25zdCBfYml0cyA9IENVUlZFLm5CaXRMZW5ndGg7XG4gIGNvbnN0IHduYWYgPSB3TkFGKFBvaW50LCBDVVJWRS5lbmRvID8gTWF0aC5jZWlsKF9iaXRzIC8gMikgOiBfYml0cyk7XG4gIC8vIFZhbGlkYXRlIGlmIGdlbmVyYXRvciBwb2ludCBpcyBvbiBjdXJ2ZVxuICByZXR1cm4ge1xuICAgIENVUlZFLFxuICAgIFByb2plY3RpdmVQb2ludDogUG9pbnQgYXMgUHJvakNvbnN0cnVjdG9yPFQ+LFxuICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsXG4gICAgd2VpZXJzdHJhc3NFcXVhdGlvbixcbiAgICBpc1dpdGhpbkN1cnZlT3JkZXIsXG4gIH07XG59XG5cbi8vIEluc3RhbmNlXG5leHBvcnQgaW50ZXJmYWNlIFNpZ25hdHVyZVR5cGUge1xuICByZWFkb25seSByOiBiaWdpbnQ7XG4gIHJlYWRvbmx5IHM6IGJpZ2ludDtcbiAgcmVhZG9ubHkgcmVjb3Zlcnk/OiBudW1iZXI7XG4gIGFzc2VydFZhbGlkaXR5KCk6IHZvaWQ7XG4gIGFkZFJlY292ZXJ5Qml0KHJlY292ZXJ5OiBudW1iZXIpOiBSZWNvdmVyZWRTaWduYXR1cmVUeXBlO1xuICBoYXNIaWdoUygpOiBib29sZWFuO1xuICBub3JtYWxpemVTKCk6IFNpZ25hdHVyZVR5cGU7XG4gIHJlY292ZXJQdWJsaWNLZXkobXNnSGFzaDogSGV4KTogUHJvalBvaW50VHlwZTxiaWdpbnQ+O1xuICB0b0NvbXBhY3RSYXdCeXRlcygpOiBVaW50OEFycmF5O1xuICB0b0NvbXBhY3RIZXgoKTogc3RyaW5nO1xuICAvLyBERVItZW5jb2RlZFxuICB0b0RFUlJhd0J5dGVzKGlzQ29tcHJlc3NlZD86IGJvb2xlYW4pOiBVaW50OEFycmF5O1xuICB0b0RFUkhleChpc0NvbXByZXNzZWQ/OiBib29sZWFuKTogc3RyaW5nO1xufVxuZXhwb3J0IHR5cGUgUmVjb3ZlcmVkU2lnbmF0dXJlVHlwZSA9IFNpZ25hdHVyZVR5cGUgJiB7XG4gIHJlYWRvbmx5IHJlY292ZXJ5OiBudW1iZXI7XG59O1xuLy8gU3RhdGljIG1ldGhvZHNcbmV4cG9ydCB0eXBlIFNpZ25hdHVyZUNvbnN0cnVjdG9yID0ge1xuICBuZXcgKHI6IGJpZ2ludCwgczogYmlnaW50KTogU2lnbmF0dXJlVHlwZTtcbiAgZnJvbUNvbXBhY3QoaGV4OiBIZXgpOiBTaWduYXR1cmVUeXBlO1xuICBmcm9tREVSKGhleDogSGV4KTogU2lnbmF0dXJlVHlwZTtcbn07XG50eXBlIFNpZ25hdHVyZUxpa2UgPSB7IHI6IGJpZ2ludDsgczogYmlnaW50IH07XG5cbmV4cG9ydCB0eXBlIFB1YktleSA9IEhleCB8IFByb2pQb2ludFR5cGU8YmlnaW50PjtcblxuZXhwb3J0IHR5cGUgQ3VydmVUeXBlID0gQmFzaWNXQ3VydmU8YmlnaW50PiAmIHtcbiAgaGFzaDogQ0hhc2g7IC8vIENIYXNoIG5vdCBGSGFzaCBiZWNhdXNlIHdlIG5lZWQgb3V0cHV0TGVuIGZvciBEUkJHXG4gIGhtYWM6IEhtYWNGblN5bmM7XG4gIHJhbmRvbUJ5dGVzOiAoYnl0ZXNMZW5ndGg/OiBudW1iZXIpID0+IFVpbnQ4QXJyYXk7XG4gIGxvd1M/OiBib29sZWFuO1xuICBiaXRzMmludD86IChieXRlczogVWludDhBcnJheSkgPT4gYmlnaW50O1xuICBiaXRzMmludF9tb2ROPzogKGJ5dGVzOiBVaW50OEFycmF5KSA9PiBiaWdpbnQ7XG59O1xuXG5mdW5jdGlvbiB2YWxpZGF0ZU9wdHMoY3VydmU6IEN1cnZlVHlwZSkge1xuICBjb25zdCBvcHRzID0gdmFsaWRhdGVCYXNpYyhjdXJ2ZSk7XG4gIHV0LnZhbGlkYXRlT2JqZWN0KFxuICAgIG9wdHMsXG4gICAge1xuICAgICAgaGFzaDogJ2hhc2gnLFxuICAgICAgaG1hYzogJ2Z1bmN0aW9uJyxcbiAgICAgIHJhbmRvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgIH0sXG4gICAge1xuICAgICAgYml0czJpbnQ6ICdmdW5jdGlvbicsXG4gICAgICBiaXRzMmludF9tb2ROOiAnZnVuY3Rpb24nLFxuICAgICAgbG93UzogJ2Jvb2xlYW4nLFxuICAgIH1cbiAgKTtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyBsb3dTOiB0cnVlLCAuLi5vcHRzIH0gYXMgY29uc3QpO1xufVxuXG5leHBvcnQgdHlwZSBDdXJ2ZUZuID0ge1xuICBDVVJWRTogUmV0dXJuVHlwZTx0eXBlb2YgdmFsaWRhdGVPcHRzPjtcbiAgZ2V0UHVibGljS2V5OiAocHJpdmF0ZUtleTogUHJpdktleSwgaXNDb21wcmVzc2VkPzogYm9vbGVhbikgPT4gVWludDhBcnJheTtcbiAgZ2V0U2hhcmVkU2VjcmV0OiAocHJpdmF0ZUE6IFByaXZLZXksIHB1YmxpY0I6IEhleCwgaXNDb21wcmVzc2VkPzogYm9vbGVhbikgPT4gVWludDhBcnJheTtcbiAgc2lnbjogKG1zZ0hhc2g6IEhleCwgcHJpdktleTogUHJpdktleSwgb3B0cz86IFNpZ25PcHRzKSA9PiBSZWNvdmVyZWRTaWduYXR1cmVUeXBlO1xuICB2ZXJpZnk6IChzaWduYXR1cmU6IEhleCB8IFNpZ25hdHVyZUxpa2UsIG1zZ0hhc2g6IEhleCwgcHVibGljS2V5OiBIZXgsIG9wdHM/OiBWZXJPcHRzKSA9PiBib29sZWFuO1xuICBQcm9qZWN0aXZlUG9pbnQ6IFByb2pDb25zdHJ1Y3RvcjxiaWdpbnQ+O1xuICBTaWduYXR1cmU6IFNpZ25hdHVyZUNvbnN0cnVjdG9yO1xuICB1dGlsczoge1xuICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXI6IChrZXk6IFByaXZLZXkpID0+IGJpZ2ludDtcbiAgICBpc1ZhbGlkUHJpdmF0ZUtleShwcml2YXRlS2V5OiBQcml2S2V5KTogYm9vbGVhbjtcbiAgICByYW5kb21Qcml2YXRlS2V5OiAoKSA9PiBVaW50OEFycmF5O1xuICAgIHByZWNvbXB1dGU6ICh3aW5kb3dTaXplPzogbnVtYmVyLCBwb2ludD86IFByb2pQb2ludFR5cGU8YmlnaW50PikgPT4gUHJvalBvaW50VHlwZTxiaWdpbnQ+O1xuICB9O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHdlaWVyc3RyYXNzKGN1cnZlRGVmOiBDdXJ2ZVR5cGUpOiBDdXJ2ZUZuIHtcbiAgY29uc3QgQ1VSVkUgPSB2YWxpZGF0ZU9wdHMoY3VydmVEZWYpIGFzIFJldHVyblR5cGU8dHlwZW9mIHZhbGlkYXRlT3B0cz47XG4gIGNvbnN0IHsgRnAsIG46IENVUlZFX09SREVSIH0gPSBDVVJWRTtcbiAgY29uc3QgY29tcHJlc3NlZExlbiA9IEZwLkJZVEVTICsgMTsgLy8gZS5nLiAzMyBmb3IgMzJcbiAgY29uc3QgdW5jb21wcmVzc2VkTGVuID0gMiAqIEZwLkJZVEVTICsgMTsgLy8gZS5nLiA2NSBmb3IgMzJcblxuICBmdW5jdGlvbiBpc1ZhbGlkRmllbGRFbGVtZW50KG51bTogYmlnaW50KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIF8wbiA8IG51bSAmJiBudW0gPCBGcC5PUkRFUjsgLy8gMCBpcyBiYW5uZWQgc2luY2UgaXQncyBub3QgaW52ZXJ0aWJsZSBGRVxuICB9XG4gIGZ1bmN0aW9uIG1vZE4oYTogYmlnaW50KSB7XG4gICAgcmV0dXJuIG1vZC5tb2QoYSwgQ1VSVkVfT1JERVIpO1xuICB9XG4gIGZ1bmN0aW9uIGludk4oYTogYmlnaW50KSB7XG4gICAgcmV0dXJuIG1vZC5pbnZlcnQoYSwgQ1VSVkVfT1JERVIpO1xuICB9XG5cbiAgY29uc3Qge1xuICAgIFByb2plY3RpdmVQb2ludDogUG9pbnQsXG4gICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcixcbiAgICB3ZWllcnN0cmFzc0VxdWF0aW9uLFxuICAgIGlzV2l0aGluQ3VydmVPcmRlcixcbiAgfSA9IHdlaWVyc3RyYXNzUG9pbnRzKHtcbiAgICAuLi5DVVJWRSxcbiAgICB0b0J5dGVzKF9jLCBwb2ludCwgaXNDb21wcmVzc2VkOiBib29sZWFuKTogVWludDhBcnJheSB7XG4gICAgICBjb25zdCBhID0gcG9pbnQudG9BZmZpbmUoKTtcbiAgICAgIGNvbnN0IHggPSBGcC50b0J5dGVzKGEueCk7XG4gICAgICBjb25zdCBjYXQgPSB1dC5jb25jYXRCeXRlcztcbiAgICAgIGlmIChpc0NvbXByZXNzZWQpIHtcbiAgICAgICAgcmV0dXJuIGNhdChVaW50OEFycmF5LmZyb20oW3BvaW50Lmhhc0V2ZW5ZKCkgPyAweDAyIDogMHgwM10pLCB4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjYXQoVWludDhBcnJheS5mcm9tKFsweDA0XSksIHgsIEZwLnRvQnl0ZXMoYS55KSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBmcm9tQnl0ZXMoYnl0ZXM6IFVpbnQ4QXJyYXkpIHtcbiAgICAgIGNvbnN0IGxlbiA9IGJ5dGVzLmxlbmd0aDtcbiAgICAgIGNvbnN0IGhlYWQgPSBieXRlc1swXTtcbiAgICAgIGNvbnN0IHRhaWwgPSBieXRlcy5zdWJhcnJheSgxKTtcbiAgICAgIC8vIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKSBpcyBkb25lIGluc2lkZSBvZiBmcm9tSGV4XG4gICAgICBpZiAobGVuID09PSBjb21wcmVzc2VkTGVuICYmIChoZWFkID09PSAweDAyIHx8IGhlYWQgPT09IDB4MDMpKSB7XG4gICAgICAgIGNvbnN0IHggPSB1dC5ieXRlc1RvTnVtYmVyQkUodGFpbCk7XG4gICAgICAgIGlmICghaXNWYWxpZEZpZWxkRWxlbWVudCh4KSkgdGhyb3cgbmV3IEVycm9yKCdQb2ludCBpcyBub3Qgb24gY3VydmUnKTtcbiAgICAgICAgY29uc3QgeTIgPSB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpOyAvLyB5XHUwMEIyID0geFx1MDBCMyArIGF4ICsgYlxuICAgICAgICBsZXQgeSA9IEZwLnNxcnQoeTIpOyAvLyB5ID0geVx1MDBCMiBeIChwKzEpLzRcbiAgICAgICAgY29uc3QgaXNZT2RkID0gKHkgJiBfMW4pID09PSBfMW47XG4gICAgICAgIC8vIEVDRFNBXG4gICAgICAgIGNvbnN0IGlzSGVhZE9kZCA9IChoZWFkICYgMSkgPT09IDE7XG4gICAgICAgIGlmIChpc0hlYWRPZGQgIT09IGlzWU9kZCkgeSA9IEZwLm5lZyh5KTtcbiAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgfSBlbHNlIGlmIChsZW4gPT09IHVuY29tcHJlc3NlZExlbiAmJiBoZWFkID09PSAweDA0KSB7XG4gICAgICAgIGNvbnN0IHggPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheSgwLCBGcC5CWVRFUykpO1xuICAgICAgICBjb25zdCB5ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoRnAuQllURVMsIDIgKiBGcC5CWVRFUykpO1xuICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFBvaW50IG9mIGxlbmd0aCAke2xlbn0gd2FzIGludmFsaWQuIEV4cGVjdGVkICR7Y29tcHJlc3NlZExlbn0gY29tcHJlc3NlZCBieXRlcyBvciAke3VuY29tcHJlc3NlZExlbn0gdW5jb21wcmVzc2VkIGJ5dGVzYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0sXG4gIH0pO1xuICBjb25zdCBudW1Ub05CeXRlU3RyID0gKG51bTogYmlnaW50KTogc3RyaW5nID0+XG4gICAgdXQuYnl0ZXNUb0hleCh1dC5udW1iZXJUb0J5dGVzQkUobnVtLCBDVVJWRS5uQnl0ZUxlbmd0aCkpO1xuXG4gIGZ1bmN0aW9uIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihudW1iZXI6IGJpZ2ludCkge1xuICAgIGNvbnN0IEhBTEYgPSBDVVJWRV9PUkRFUiA+PiBfMW47XG4gICAgcmV0dXJuIG51bWJlciA+IEhBTEY7XG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVTKHM6IGJpZ2ludCkge1xuICAgIHJldHVybiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIocykgPyBtb2ROKC1zKSA6IHM7XG4gIH1cbiAgLy8gc2xpY2UgYnl0ZXMgbnVtXG4gIGNvbnN0IHNsY051bSA9IChiOiBVaW50OEFycmF5LCBmcm9tOiBudW1iZXIsIHRvOiBudW1iZXIpID0+IHV0LmJ5dGVzVG9OdW1iZXJCRShiLnNsaWNlKGZyb20sIHRvKSk7XG5cbiAgLyoqXG4gICAqIEVDRFNBIHNpZ25hdHVyZSB3aXRoIGl0cyAociwgcykgcHJvcGVydGllcy4gU3VwcG9ydHMgREVSICYgY29tcGFjdCByZXByZXNlbnRhdGlvbnMuXG4gICAqL1xuICBjbGFzcyBTaWduYXR1cmUgaW1wbGVtZW50cyBTaWduYXR1cmVUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihyZWFkb25seSByOiBiaWdpbnQsIHJlYWRvbmx5IHM6IGJpZ2ludCwgcmVhZG9ubHkgcmVjb3Zlcnk/OiBudW1iZXIpIHtcbiAgICAgIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICB9XG5cbiAgICAvLyBwYWlyIChieXRlcyBvZiByLCBieXRlcyBvZiBzKVxuICAgIHN0YXRpYyBmcm9tQ29tcGFjdChoZXg6IEhleCkge1xuICAgICAgY29uc3QgbCA9IENVUlZFLm5CeXRlTGVuZ3RoO1xuICAgICAgaGV4ID0gZW5zdXJlQnl0ZXMoJ2NvbXBhY3RTaWduYXR1cmUnLCBoZXgsIGwgKiAyKTtcbiAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHNsY051bShoZXgsIDAsIGwpLCBzbGNOdW0oaGV4LCBsLCAyICogbCkpO1xuICAgIH1cblxuICAgIC8vIERFUiBlbmNvZGVkIEVDRFNBIHNpZ25hdHVyZVxuICAgIC8vIGh0dHBzOi8vYml0Y29pbi5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvNTc2NDQvd2hhdC1hcmUtdGhlLXBhcnRzLW9mLWEtYml0Y29pbi10cmFuc2FjdGlvbi1pbnB1dC1zY3JpcHRcbiAgICBzdGF0aWMgZnJvbURFUihoZXg6IEhleCkge1xuICAgICAgY29uc3QgeyByLCBzIH0gPSBERVIudG9TaWcoZW5zdXJlQnl0ZXMoJ0RFUicsIGhleCkpO1xuICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgcyk7XG4gICAgfVxuXG4gICAgYXNzZXJ0VmFsaWRpdHkoKTogdm9pZCB7XG4gICAgICAvLyBjYW4gdXNlIGFzc2VydEdFIGhlcmVcbiAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKHRoaXMucikpIHRocm93IG5ldyBFcnJvcignciBtdXN0IGJlIDAgPCByIDwgQ1VSVkUubicpO1xuICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIodGhpcy5zKSkgdGhyb3cgbmV3IEVycm9yKCdzIG11c3QgYmUgMCA8IHMgPCBDVVJWRS5uJyk7XG4gICAgfVxuXG4gICAgYWRkUmVjb3ZlcnlCaXQocmVjb3Zlcnk6IG51bWJlcik6IFJlY292ZXJlZFNpZ25hdHVyZSB7XG4gICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIHRoaXMucywgcmVjb3ZlcnkpIGFzIFJlY292ZXJlZFNpZ25hdHVyZTtcbiAgICB9XG5cbiAgICByZWNvdmVyUHVibGljS2V5KG1zZ0hhc2g6IEhleCk6IHR5cGVvZiBQb2ludC5CQVNFIHtcbiAgICAgIGNvbnN0IHsgciwgcywgcmVjb3Zlcnk6IHJlYyB9ID0gdGhpcztcbiAgICAgIGNvbnN0IGggPSBiaXRzMmludF9tb2ROKGVuc3VyZUJ5dGVzKCdtc2dIYXNoJywgbXNnSGFzaCkpOyAvLyBUcnVuY2F0ZSBoYXNoXG4gICAgICBpZiAocmVjID09IG51bGwgfHwgIVswLCAxLCAyLCAzXS5pbmNsdWRlcyhyZWMpKSB0aHJvdyBuZXcgRXJyb3IoJ3JlY292ZXJ5IGlkIGludmFsaWQnKTtcbiAgICAgIGNvbnN0IHJhZGogPSByZWMgPT09IDIgfHwgcmVjID09PSAzID8gciArIENVUlZFLm4gOiByO1xuICAgICAgaWYgKHJhZGogPj0gRnAuT1JERVIpIHRocm93IG5ldyBFcnJvcigncmVjb3ZlcnkgaWQgMiBvciAzIGludmFsaWQnKTtcbiAgICAgIGNvbnN0IHByZWZpeCA9IChyZWMgJiAxKSA9PT0gMCA/ICcwMicgOiAnMDMnO1xuICAgICAgY29uc3QgUiA9IFBvaW50LmZyb21IZXgocHJlZml4ICsgbnVtVG9OQnl0ZVN0cihyYWRqKSk7XG4gICAgICBjb25zdCBpciA9IGludk4ocmFkaik7IC8vIHJeLTFcbiAgICAgIGNvbnN0IHUxID0gbW9kTigtaCAqIGlyKTsgLy8gLWhyXi0xXG4gICAgICBjb25zdCB1MiA9IG1vZE4ocyAqIGlyKTsgLy8gc3JeLTFcbiAgICAgIGNvbnN0IFEgPSBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFIsIHUxLCB1Mik7IC8vIChzcl4tMSlSLShocl4tMSlHID0gLShocl4tMSlHICsgKHNyXi0xKVxuICAgICAgaWYgKCFRKSB0aHJvdyBuZXcgRXJyb3IoJ3BvaW50IGF0IGluZmluaWZ5Jyk7IC8vIHVuc2FmZSBpcyBmaW5lOiBubyBwcml2IGRhdGEgbGVha2VkXG4gICAgICBRLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICByZXR1cm4gUTtcbiAgICB9XG5cbiAgICAvLyBTaWduYXR1cmVzIHNob3VsZCBiZSBsb3ctcywgdG8gcHJldmVudCBtYWxsZWFiaWxpdHkuXG4gICAgaGFzSGlnaFMoKTogYm9vbGVhbiB7XG4gICAgICByZXR1cm4gaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHRoaXMucyk7XG4gICAgfVxuXG4gICAgbm9ybWFsaXplUygpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhc0hpZ2hTKCkgPyBuZXcgU2lnbmF0dXJlKHRoaXMuciwgbW9kTigtdGhpcy5zKSwgdGhpcy5yZWNvdmVyeSkgOiB0aGlzO1xuICAgIH1cblxuICAgIC8vIERFUi1lbmNvZGVkXG4gICAgdG9ERVJSYXdCeXRlcygpIHtcbiAgICAgIHJldHVybiB1dC5oZXhUb0J5dGVzKHRoaXMudG9ERVJIZXgoKSk7XG4gICAgfVxuICAgIHRvREVSSGV4KCkge1xuICAgICAgcmV0dXJuIERFUi5oZXhGcm9tU2lnKHsgcjogdGhpcy5yLCBzOiB0aGlzLnMgfSk7XG4gICAgfVxuXG4gICAgLy8gcGFkZGVkIGJ5dGVzIG9mIHIsIHRoZW4gcGFkZGVkIGJ5dGVzIG9mIHNcbiAgICB0b0NvbXBhY3RSYXdCeXRlcygpIHtcbiAgICAgIHJldHVybiB1dC5oZXhUb0J5dGVzKHRoaXMudG9Db21wYWN0SGV4KCkpO1xuICAgIH1cbiAgICB0b0NvbXBhY3RIZXgoKSB7XG4gICAgICByZXR1cm4gbnVtVG9OQnl0ZVN0cih0aGlzLnIpICsgbnVtVG9OQnl0ZVN0cih0aGlzLnMpO1xuICAgIH1cbiAgfVxuICB0eXBlIFJlY292ZXJlZFNpZ25hdHVyZSA9IFNpZ25hdHVyZSAmIHsgcmVjb3Zlcnk6IG51bWJlciB9O1xuXG4gIGNvbnN0IHV0aWxzID0ge1xuICAgIGlzVmFsaWRQcml2YXRlS2V5KHByaXZhdGVLZXk6IFByaXZLZXkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG4gICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcjogbm9ybVByaXZhdGVLZXlUb1NjYWxhcixcblxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VzIGNyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZSBwcml2YXRlIGtleSBmcm9tIHJhbmRvbSBvZiBzaXplXG4gICAgICogKGdyb3VwTGVuICsgY2VpbChncm91cExlbiAvIDIpKSB3aXRoIG1vZHVsbyBiaWFzIGJlaW5nIG5lZ2xpZ2libGUuXG4gICAgICovXG4gICAgcmFuZG9tUHJpdmF0ZUtleTogKCk6IFVpbnQ4QXJyYXkgPT4ge1xuICAgICAgY29uc3QgbGVuZ3RoID0gbW9kLmdldE1pbkhhc2hMZW5ndGgoQ1VSVkUubik7XG4gICAgICByZXR1cm4gbW9kLm1hcEhhc2hUb0ZpZWxkKENVUlZFLnJhbmRvbUJ5dGVzKGxlbmd0aCksIENVUlZFLm4pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHByZWNvbXB1dGUgdGFibGUgZm9yIGFuIGFyYml0cmFyeSBFQyBwb2ludC4gTWFrZXMgcG9pbnQgXCJjYWNoZWRcIi5cbiAgICAgKiBBbGxvd3MgdG8gbWFzc2l2ZWx5IHNwZWVkLXVwIGBwb2ludC5tdWx0aXBseShzY2FsYXIpYC5cbiAgICAgKiBAcmV0dXJucyBjYWNoZWQgcG9pbnRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IGZhc3QgPSB1dGlscy5wcmVjb21wdXRlKDgsIFByb2plY3RpdmVQb2ludC5mcm9tSGV4KHNvbWVvbmVzUHViS2V5KSk7XG4gICAgICogZmFzdC5tdWx0aXBseShwcml2S2V5KTsgLy8gbXVjaCBmYXN0ZXIgRUNESCBub3dcbiAgICAgKi9cbiAgICBwcmVjb21wdXRlKHdpbmRvd1NpemUgPSA4LCBwb2ludCA9IFBvaW50LkJBU0UpOiB0eXBlb2YgUG9pbnQuQkFTRSB7XG4gICAgICBwb2ludC5fc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKTtcbiAgICAgIHBvaW50Lm11bHRpcGx5KEJpZ0ludCgzKSk7IC8vIDMgaXMgYXJiaXRyYXJ5LCBqdXN0IG5lZWQgYW55IG51bWJlciBoZXJlXG4gICAgICByZXR1cm4gcG9pbnQ7XG4gICAgfSxcbiAgfTtcblxuICAvKipcbiAgICogQ29tcHV0ZXMgcHVibGljIGtleSBmb3IgYSBwcml2YXRlIGtleS4gQ2hlY2tzIGZvciB2YWxpZGl0eSBvZiB0aGUgcHJpdmF0ZSBrZXkuXG4gICAqIEBwYXJhbSBwcml2YXRlS2V5IHByaXZhdGUga2V5XG4gICAqIEBwYXJhbSBpc0NvbXByZXNzZWQgd2hldGhlciB0byByZXR1cm4gY29tcGFjdCAoZGVmYXVsdCksIG9yIGZ1bGwga2V5XG4gICAqIEByZXR1cm5zIFB1YmxpYyBrZXksIGZ1bGwgd2hlbiBpc0NvbXByZXNzZWQ9ZmFsc2U7IHNob3J0IHdoZW4gaXNDb21wcmVzc2VkPXRydWVcbiAgICovXG4gIGZ1bmN0aW9uIGdldFB1YmxpY0tleShwcml2YXRlS2V5OiBQcml2S2V5LCBpc0NvbXByZXNzZWQgPSB0cnVlKTogVWludDhBcnJheSB7XG4gICAgcmV0dXJuIFBvaW50LmZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBRdWljayBhbmQgZGlydHkgY2hlY2sgZm9yIGl0ZW0gYmVpbmcgcHVibGljIGtleS4gRG9lcyBub3QgdmFsaWRhdGUgaGV4LCBvciBiZWluZyBvbi1jdXJ2ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGlzUHJvYlB1YihpdGVtOiBQcml2S2V5IHwgUHViS2V5KTogYm9vbGVhbiB7XG4gICAgY29uc3QgYXJyID0gaXRlbSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG4gICAgY29uc3Qgc3RyID0gdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnO1xuICAgIGNvbnN0IGxlbiA9IChhcnIgfHwgc3RyKSAmJiAoaXRlbSBhcyBIZXgpLmxlbmd0aDtcbiAgICBpZiAoYXJyKSByZXR1cm4gbGVuID09PSBjb21wcmVzc2VkTGVuIHx8IGxlbiA9PT0gdW5jb21wcmVzc2VkTGVuO1xuICAgIGlmIChzdHIpIHJldHVybiBsZW4gPT09IDIgKiBjb21wcmVzc2VkTGVuIHx8IGxlbiA9PT0gMiAqIHVuY29tcHJlc3NlZExlbjtcbiAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIFBvaW50KSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogRUNESCAoRWxsaXB0aWMgQ3VydmUgRGlmZmllIEhlbGxtYW4pLlxuICAgKiBDb21wdXRlcyBzaGFyZWQgcHVibGljIGtleSBmcm9tIHByaXZhdGUga2V5IGFuZCBwdWJsaWMga2V5LlxuICAgKiBDaGVja3M6IDEpIHByaXZhdGUga2V5IHZhbGlkaXR5IDIpIHNoYXJlZCBrZXkgaXMgb24tY3VydmUuXG4gICAqIERvZXMgTk9UIGhhc2ggdGhlIHJlc3VsdC5cbiAgICogQHBhcmFtIHByaXZhdGVBIHByaXZhdGUga2V5XG4gICAqIEBwYXJhbSBwdWJsaWNCIGRpZmZlcmVudCBwdWJsaWMga2V5XG4gICAqIEBwYXJhbSBpc0NvbXByZXNzZWQgd2hldGhlciB0byByZXR1cm4gY29tcGFjdCAoZGVmYXVsdCksIG9yIGZ1bGwga2V5XG4gICAqIEByZXR1cm5zIHNoYXJlZCBwdWJsaWMga2V5XG4gICAqL1xuICBmdW5jdGlvbiBnZXRTaGFyZWRTZWNyZXQocHJpdmF0ZUE6IFByaXZLZXksIHB1YmxpY0I6IEhleCwgaXNDb21wcmVzc2VkID0gdHJ1ZSk6IFVpbnQ4QXJyYXkge1xuICAgIGlmIChpc1Byb2JQdWIocHJpdmF0ZUEpKSB0aHJvdyBuZXcgRXJyb3IoJ2ZpcnN0IGFyZyBtdXN0IGJlIHByaXZhdGUga2V5Jyk7XG4gICAgaWYgKCFpc1Byb2JQdWIocHVibGljQikpIHRocm93IG5ldyBFcnJvcignc2Vjb25kIGFyZyBtdXN0IGJlIHB1YmxpYyBrZXknKTtcbiAgICBjb25zdCBiID0gUG9pbnQuZnJvbUhleChwdWJsaWNCKTsgLy8gY2hlY2sgZm9yIGJlaW5nIG9uLWN1cnZlXG4gICAgcmV0dXJuIGIubXVsdGlwbHkobm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlQSkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcbiAgfVxuXG4gIC8vIFJGQzY5Nzk6IGVuc3VyZSBFQ0RTQSBtc2cgaXMgWCBieXRlcyBhbmQgPCBOLiBSRkMgc3VnZ2VzdHMgb3B0aW9uYWwgdHJ1bmNhdGluZyB2aWEgYml0czJvY3RldHMuXG4gIC8vIEZJUFMgMTg2LTQgNC42IHN1Z2dlc3RzIHRoZSBsZWZ0bW9zdCBtaW4obkJpdExlbiwgb3V0TGVuKSBiaXRzLCB3aGljaCBtYXRjaGVzIGJpdHMyaW50LlxuICAvLyBiaXRzMmludCBjYW4gcHJvZHVjZSByZXM+Tiwgd2UgY2FuIGRvIG1vZChyZXMsIE4pIHNpbmNlIHRoZSBiaXRMZW4gaXMgdGhlIHNhbWUuXG4gIC8vIGludDJvY3RldHMgY2FuJ3QgYmUgdXNlZDsgcGFkcyBzbWFsbCBtc2dzIHdpdGggMDogdW5hY2NlcHRhdGJsZSBmb3IgdHJ1bmMgYXMgcGVyIFJGQyB2ZWN0b3JzXG4gIGNvbnN0IGJpdHMyaW50ID1cbiAgICBDVVJWRS5iaXRzMmludCB8fFxuICAgIGZ1bmN0aW9uIChieXRlczogVWludDhBcnJheSk6IGJpZ2ludCB7XG4gICAgICAvLyBGb3IgY3VydmVzIHdpdGggbkJpdExlbmd0aCAlIDggIT09IDA6IGJpdHMyb2N0ZXRzKGJpdHMyb2N0ZXRzKG0pKSAhPT0gYml0czJvY3RldHMobSlcbiAgICAgIC8vIGZvciBzb21lIGNhc2VzLCBzaW5jZSBieXRlcy5sZW5ndGggKiA4IGlzIG5vdCBhY3R1YWwgYml0TGVuZ3RoLlxuICAgICAgY29uc3QgbnVtID0gdXQuYnl0ZXNUb051bWJlckJFKGJ5dGVzKTsgLy8gY2hlY2sgZm9yID09IHU4IGRvbmUgaGVyZVxuICAgICAgY29uc3QgZGVsdGEgPSBieXRlcy5sZW5ndGggKiA4IC0gQ1VSVkUubkJpdExlbmd0aDsgLy8gdHJ1bmNhdGUgdG8gbkJpdExlbmd0aCBsZWZ0bW9zdCBiaXRzXG4gICAgICByZXR1cm4gZGVsdGEgPiAwID8gbnVtID4+IEJpZ0ludChkZWx0YSkgOiBudW07XG4gICAgfTtcbiAgY29uc3QgYml0czJpbnRfbW9kTiA9XG4gICAgQ1VSVkUuYml0czJpbnRfbW9kTiB8fFxuICAgIGZ1bmN0aW9uIChieXRlczogVWludDhBcnJheSk6IGJpZ2ludCB7XG4gICAgICByZXR1cm4gbW9kTihiaXRzMmludChieXRlcykpOyAvLyBjYW4ndCB1c2UgYnl0ZXNUb051bWJlckJFIGhlcmVcbiAgICB9O1xuICAvLyBOT1RFOiBwYWRzIG91dHB1dCB3aXRoIHplcm8gYXMgcGVyIHNwZWNcbiAgY29uc3QgT1JERVJfTUFTSyA9IHV0LmJpdE1hc2soQ1VSVkUubkJpdExlbmd0aCk7XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0byBieXRlcy4gQ2hlY2tzIGlmIG51bSBpbiBgWzAuLk9SREVSX01BU0stMV1gIGUuZy46IGBbMC4uMl4yNTYtMV1gLlxuICAgKi9cbiAgZnVuY3Rpb24gaW50Mm9jdGV0cyhudW06IGJpZ2ludCk6IFVpbnQ4QXJyYXkge1xuICAgIGlmICh0eXBlb2YgbnVtICE9PSAnYmlnaW50JykgdGhyb3cgbmV3IEVycm9yKCdiaWdpbnQgZXhwZWN0ZWQnKTtcbiAgICBpZiAoIShfMG4gPD0gbnVtICYmIG51bSA8IE9SREVSX01BU0spKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBiaWdpbnQgZXhwZWN0ZWQgPCAyXiR7Q1VSVkUubkJpdExlbmd0aH1gKTtcbiAgICAvLyB3b3JrcyB3aXRoIG9yZGVyLCBjYW4gaGF2ZSBkaWZmZXJlbnQgc2l6ZSB0aGFuIG51bVRvRmllbGQhXG4gICAgcmV0dXJuIHV0Lm51bWJlclRvQnl0ZXNCRShudW0sIENVUlZFLm5CeXRlTGVuZ3RoKTtcbiAgfVxuXG4gIC8vIFN0ZXBzIEEsIEQgb2YgUkZDNjk3OSAzLjJcbiAgLy8gQ3JlYXRlcyBSRkM2OTc5IHNlZWQ7IGNvbnZlcnRzIG1zZy9wcml2S2V5IHRvIG51bWJlcnMuXG4gIC8vIFVzZWQgb25seSBpbiBzaWduLCBub3QgaW4gdmVyaWZ5LlxuICAvLyBOT1RFOiB3ZSBjYW5ub3QgYXNzdW1lIGhlcmUgdGhhdCBtc2dIYXNoIGhhcyBzYW1lIGFtb3VudCBvZiBieXRlcyBhcyBjdXJ2ZSBvcmRlciwgdGhpcyB3aWxsIGJlIHdyb25nIGF0IGxlYXN0IGZvciBQNTIxLlxuICAvLyBBbHNvIGl0IGNhbiBiZSBiaWdnZXIgZm9yIFAyMjQgKyBTSEEyNTZcbiAgZnVuY3Rpb24gcHJlcFNpZyhtc2dIYXNoOiBIZXgsIHByaXZhdGVLZXk6IFByaXZLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xuICAgIGlmIChbJ3JlY292ZXJlZCcsICdjYW5vbmljYWwnXS5zb21lKChrKSA9PiBrIGluIG9wdHMpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduKCkgbGVnYWN5IG9wdGlvbnMgbm90IHN1cHBvcnRlZCcpO1xuICAgIGNvbnN0IHsgaGFzaCwgcmFuZG9tQnl0ZXMgfSA9IENVUlZFO1xuICAgIGxldCB7IGxvd1MsIHByZWhhc2gsIGV4dHJhRW50cm9weTogZW50IH0gPSBvcHRzOyAvLyBnZW5lcmF0ZXMgbG93LXMgc2lncyBieSBkZWZhdWx0XG4gICAgaWYgKGxvd1MgPT0gbnVsbCkgbG93UyA9IHRydWU7IC8vIFJGQzY5NzkgMy4yOiB3ZSBza2lwIHN0ZXAgQSwgYmVjYXVzZSB3ZSBhbHJlYWR5IHByb3ZpZGUgaGFzaFxuICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpO1xuICAgIGlmIChwcmVoYXNoKSBtc2dIYXNoID0gZW5zdXJlQnl0ZXMoJ3ByZWhhc2hlZCBtc2dIYXNoJywgaGFzaChtc2dIYXNoKSk7XG5cbiAgICAvLyBXZSBjYW4ndCBsYXRlciBjYWxsIGJpdHMyb2N0ZXRzLCBzaW5jZSBuZXN0ZWQgYml0czJpbnQgaXMgYnJva2VuIGZvciBjdXJ2ZXNcbiAgICAvLyB3aXRoIG5CaXRMZW5ndGggJSA4ICE9PSAwLiBCZWNhdXNlIG9mIHRoYXQsIHdlIHVud3JhcCBpdCBoZXJlIGFzIGludDJvY3RldHMgY2FsbC5cbiAgICAvLyBjb25zdCBiaXRzMm9jdGV0cyA9IChiaXRzKSA9PiBpbnQyb2N0ZXRzKGJpdHMyaW50X21vZE4oYml0cykpXG4gICAgY29uc3QgaDFpbnQgPSBiaXRzMmludF9tb2ROKG1zZ0hhc2gpO1xuICAgIGNvbnN0IGQgPSBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpOyAvLyB2YWxpZGF0ZSBwcml2YXRlIGtleSwgY29udmVydCB0byBiaWdpbnRcbiAgICBjb25zdCBzZWVkQXJncyA9IFtpbnQyb2N0ZXRzKGQpLCBpbnQyb2N0ZXRzKGgxaW50KV07XG4gICAgLy8gZXh0cmFFbnRyb3B5LiBSRkM2OTc5IDMuNjogYWRkaXRpb25hbCBrJyAob3B0aW9uYWwpLlxuICAgIGlmIChlbnQgIT0gbnVsbCkge1xuICAgICAgLy8gSyA9IEhNQUNfSyhWIHx8IDB4MDAgfHwgaW50Mm9jdGV0cyh4KSB8fCBiaXRzMm9jdGV0cyhoMSkgfHwgaycpXG4gICAgICBjb25zdCBlID0gZW50ID09PSB0cnVlID8gcmFuZG9tQnl0ZXMoRnAuQllURVMpIDogZW50OyAvLyBnZW5lcmF0ZSByYW5kb20gYnl0ZXMgT1IgcGFzcyBhcy1pc1xuICAgICAgc2VlZEFyZ3MucHVzaChlbnN1cmVCeXRlcygnZXh0cmFFbnRyb3B5JywgZSkpOyAvLyBjaGVjayBmb3IgYmVpbmcgYnl0ZXNcbiAgICB9XG4gICAgY29uc3Qgc2VlZCA9IHV0LmNvbmNhdEJ5dGVzKC4uLnNlZWRBcmdzKTsgLy8gU3RlcCBEIG9mIFJGQzY5NzkgMy4yXG4gICAgY29uc3QgbSA9IGgxaW50OyAvLyBOT1RFOiBubyBuZWVkIHRvIGNhbGwgYml0czJpbnQgc2Vjb25kIHRpbWUgaGVyZSwgaXQgaXMgaW5zaWRlIHRydW5jYXRlSGFzaCFcbiAgICAvLyBDb252ZXJ0cyBzaWduYXR1cmUgcGFyYW1zIGludG8gcG9pbnQgdyByL3MsIGNoZWNrcyByZXN1bHQgZm9yIHZhbGlkaXR5LlxuICAgIGZ1bmN0aW9uIGsyc2lnKGtCeXRlczogVWludDhBcnJheSk6IFJlY292ZXJlZFNpZ25hdHVyZSB8IHVuZGVmaW5lZCB7XG4gICAgICAvLyBSRkMgNjk3OSBTZWN0aW9uIDMuMiwgc3RlcCAzOiBrID0gYml0czJpbnQoVClcbiAgICAgIGNvbnN0IGsgPSBiaXRzMmludChrQnl0ZXMpOyAvLyBDYW5ub3QgdXNlIGZpZWxkcyBtZXRob2RzLCBzaW5jZSBpdCBpcyBncm91cCBlbGVtZW50XG4gICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcihrKSkgcmV0dXJuOyAvLyBJbXBvcnRhbnQ6IGFsbCBtb2QoKSBjYWxscyBoZXJlIG11c3QgYmUgZG9uZSBvdmVyIE5cbiAgICAgIGNvbnN0IGlrID0gaW52TihrKTsgLy8ga14tMSBtb2QgblxuICAgICAgY29uc3QgcSA9IFBvaW50LkJBU0UubXVsdGlwbHkoaykudG9BZmZpbmUoKTsgLy8gcSA9IEdrXG4gICAgICBjb25zdCByID0gbW9kTihxLngpOyAvLyByID0gcS54IG1vZCBuXG4gICAgICBpZiAociA9PT0gXzBuKSByZXR1cm47XG4gICAgICAvLyBDYW4gdXNlIHNjYWxhciBibGluZGluZyBiXi0xKGJtICsgYmRyKSB3aGVyZSBiIFx1MjIwOCBbMSxxXHUyMjEyMV0gYWNjb3JkaW5nIHRvXG4gICAgICAvLyBodHRwczovL3RjaGVzLmlhY3Iub3JnL2luZGV4LnBocC9UQ0hFUy9hcnRpY2xlL3ZpZXcvNzMzNy82NTA5LiBXZSd2ZSBkZWNpZGVkIGFnYWluc3QgaXQ6XG4gICAgICAvLyBhKSBkZXBlbmRlbmN5IG9uIENTUFJORyBiKSAxNSUgc2xvd2Rvd24gYykgZG9lc24ndCByZWFsbHkgaGVscCBzaW5jZSBiaWdpbnRzIGFyZSBub3QgQ1RcbiAgICAgIGNvbnN0IHMgPSBtb2ROKGlrICogbW9kTihtICsgciAqIGQpKTsgLy8gTm90IHVzaW5nIGJsaW5kaW5nIGhlcmVcbiAgICAgIGlmIChzID09PSBfMG4pIHJldHVybjtcbiAgICAgIGxldCByZWNvdmVyeSA9IChxLnggPT09IHIgPyAwIDogMikgfCBOdW1iZXIocS55ICYgXzFuKTsgLy8gcmVjb3ZlcnkgYml0ICgyIG9yIDMsIHdoZW4gcS54ID4gbilcbiAgICAgIGxldCBub3JtUyA9IHM7XG4gICAgICBpZiAobG93UyAmJiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIocykpIHtcbiAgICAgICAgbm9ybVMgPSBub3JtYWxpemVTKHMpOyAvLyBpZiBsb3dTIHdhcyBwYXNzZWQsIGVuc3VyZSBzIGlzIGFsd2F5c1xuICAgICAgICByZWNvdmVyeSBePSAxOyAvLyAvLyBpbiB0aGUgYm90dG9tIGhhbGYgb2YgTlxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgbm9ybVMsIHJlY292ZXJ5KSBhcyBSZWNvdmVyZWRTaWduYXR1cmU7IC8vIHVzZSBub3JtUywgbm90IHNcbiAgICB9XG4gICAgcmV0dXJuIHsgc2VlZCwgazJzaWcgfTtcbiAgfVxuICBjb25zdCBkZWZhdWx0U2lnT3B0czogU2lnbk9wdHMgPSB7IGxvd1M6IENVUlZFLmxvd1MsIHByZWhhc2g6IGZhbHNlIH07XG4gIGNvbnN0IGRlZmF1bHRWZXJPcHRzOiBWZXJPcHRzID0geyBsb3dTOiBDVVJWRS5sb3dTLCBwcmVoYXNoOiBmYWxzZSB9O1xuXG4gIC8qKlxuICAgKiBTaWducyBtZXNzYWdlIGhhc2ggd2l0aCBhIHByaXZhdGUga2V5LlxuICAgKiBgYGBcbiAgICogc2lnbihtLCBkLCBrKSB3aGVyZVxuICAgKiAgICh4LCB5KSA9IEcgXHUwMEQ3IGtcbiAgICogICByID0geCBtb2QgblxuICAgKiAgIHMgPSAobSArIGRyKS9rIG1vZCBuXG4gICAqIGBgYFxuICAgKiBAcGFyYW0gbXNnSGFzaCBOT1QgbWVzc2FnZS4gbXNnIG5lZWRzIHRvIGJlIGhhc2hlZCB0byBgbXNnSGFzaGAsIG9yIHVzZSBgcHJlaGFzaGAuXG4gICAqIEBwYXJhbSBwcml2S2V5IHByaXZhdGUga2V5XG4gICAqIEBwYXJhbSBvcHRzIGxvd1MgZm9yIG5vbi1tYWxsZWFibGUgc2lncy4gZXh0cmFFbnRyb3B5IGZvciBtaXhpbmcgcmFuZG9tbmVzcyBpbnRvIGsuIHByZWhhc2ggd2lsbCBoYXNoIGZpcnN0IGFyZy5cbiAgICogQHJldHVybnMgc2lnbmF0dXJlIHdpdGggcmVjb3ZlcnkgcGFyYW1cbiAgICovXG4gIGZ1bmN0aW9uIHNpZ24obXNnSGFzaDogSGV4LCBwcml2S2V5OiBQcml2S2V5LCBvcHRzID0gZGVmYXVsdFNpZ09wdHMpOiBSZWNvdmVyZWRTaWduYXR1cmUge1xuICAgIGNvbnN0IHsgc2VlZCwgazJzaWcgfSA9IHByZXBTaWcobXNnSGFzaCwgcHJpdktleSwgb3B0cyk7IC8vIFN0ZXBzIEEsIEQgb2YgUkZDNjk3OSAzLjIuXG4gICAgY29uc3QgQyA9IENVUlZFO1xuICAgIGNvbnN0IGRyYmcgPSB1dC5jcmVhdGVIbWFjRHJiZzxSZWNvdmVyZWRTaWduYXR1cmU+KEMuaGFzaC5vdXRwdXRMZW4sIEMubkJ5dGVMZW5ndGgsIEMuaG1hYyk7XG4gICAgcmV0dXJuIGRyYmcoc2VlZCwgazJzaWcpOyAvLyBTdGVwcyBCLCBDLCBELCBFLCBGLCBHXG4gIH1cblxuICAvLyBFbmFibGUgcHJlY29tcHV0ZXMuIFNsb3dzIGRvd24gZmlyc3QgcHVibGljS2V5IGNvbXB1dGF0aW9uIGJ5IDIwbXMuXG4gIFBvaW50LkJBU0UuX3NldFdpbmRvd1NpemUoOCk7XG4gIC8vIHV0aWxzLnByZWNvbXB1dGUoOCwgUHJvamVjdGl2ZVBvaW50LkJBU0UpXG5cbiAgLyoqXG4gICAqIFZlcmlmaWVzIGEgc2lnbmF0dXJlIGFnYWluc3QgbWVzc2FnZSBoYXNoIGFuZCBwdWJsaWMga2V5LlxuICAgKiBSZWplY3RzIGxvd1Mgc2lnbmF0dXJlcyBieSBkZWZhdWx0OiB0byBvdmVycmlkZSxcbiAgICogc3BlY2lmeSBvcHRpb24gYHtsb3dTOiBmYWxzZX1gLiBJbXBsZW1lbnRzIHNlY3Rpb24gNC4xLjQgZnJvbSBodHRwczovL3d3dy5zZWNnLm9yZy9zZWMxLXYyLnBkZjpcbiAgICpcbiAgICogYGBgXG4gICAqIHZlcmlmeShyLCBzLCBoLCBQKSB3aGVyZVxuICAgKiAgIFUxID0gaHNeLTEgbW9kIG5cbiAgICogICBVMiA9IHJzXi0xIG1vZCBuXG4gICAqICAgUiA9IFUxXHUyMkM1RyAtIFUyXHUyMkM1UFxuICAgKiAgIG1vZChSLngsIG4pID09IHJcbiAgICogYGBgXG4gICAqL1xuICBmdW5jdGlvbiB2ZXJpZnkoXG4gICAgc2lnbmF0dXJlOiBIZXggfCBTaWduYXR1cmVMaWtlLFxuICAgIG1zZ0hhc2g6IEhleCxcbiAgICBwdWJsaWNLZXk6IEhleCxcbiAgICBvcHRzID0gZGVmYXVsdFZlck9wdHNcbiAgKTogYm9vbGVhbiB7XG4gICAgY29uc3Qgc2cgPSBzaWduYXR1cmU7XG4gICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKCdtc2dIYXNoJywgbXNnSGFzaCk7XG4gICAgcHVibGljS2V5ID0gZW5zdXJlQnl0ZXMoJ3B1YmxpY0tleScsIHB1YmxpY0tleSk7XG4gICAgaWYgKCdzdHJpY3QnIGluIG9wdHMpIHRocm93IG5ldyBFcnJvcignb3B0aW9ucy5zdHJpY3Qgd2FzIHJlbmFtZWQgdG8gbG93UycpO1xuICAgIGNvbnN0IHsgbG93UywgcHJlaGFzaCB9ID0gb3B0cztcblxuICAgIGxldCBfc2lnOiBTaWduYXR1cmUgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgbGV0IFA6IFByb2pQb2ludFR5cGU8YmlnaW50PjtcbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiBzZyA9PT0gJ3N0cmluZycgfHwgc2cgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIC8vIFNpZ25hdHVyZSBjYW4gYmUgcmVwcmVzZW50ZWQgaW4gMiB3YXlzOiBjb21wYWN0ICgyKm5CeXRlTGVuZ3RoKSAmIERFUiAodmFyaWFibGUtbGVuZ3RoKS5cbiAgICAgICAgLy8gU2luY2UgREVSIGNhbiBhbHNvIGJlIDIqbkJ5dGVMZW5ndGggYnl0ZXMsIHdlIGNoZWNrIGZvciBpdCBmaXJzdC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21ERVIoc2cpO1xuICAgICAgICB9IGNhdGNoIChkZXJFcnJvcikge1xuICAgICAgICAgIGlmICghKGRlckVycm9yIGluc3RhbmNlb2YgREVSLkVycikpIHRocm93IGRlckVycm9yO1xuICAgICAgICAgIF9zaWcgPSBTaWduYXR1cmUuZnJvbUNvbXBhY3Qoc2cpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHNnLnIgPT09ICdiaWdpbnQnICYmIHR5cGVvZiBzZy5zID09PSAnYmlnaW50Jykge1xuICAgICAgICBjb25zdCB7IHIsIHMgfSA9IHNnO1xuICAgICAgICBfc2lnID0gbmV3IFNpZ25hdHVyZShyLCBzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUEFSU0UnKTtcbiAgICAgIH1cbiAgICAgIFAgPSBQb2ludC5mcm9tSGV4KHB1YmxpY0tleSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmICgoZXJyb3IgYXMgRXJyb3IpLm1lc3NhZ2UgPT09ICdQQVJTRScpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgc2lnbmF0dXJlIG11c3QgYmUgU2lnbmF0dXJlIGluc3RhbmNlLCBVaW50OEFycmF5IG9yIGhleCBzdHJpbmdgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGxvd1MgJiYgX3NpZy5oYXNIaWdoUygpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHByZWhhc2gpIG1zZ0hhc2ggPSBDVVJWRS5oYXNoKG1zZ0hhc2gpO1xuICAgIGNvbnN0IHsgciwgcyB9ID0gX3NpZztcbiAgICBjb25zdCBoID0gYml0czJpbnRfbW9kTihtc2dIYXNoKTsgLy8gQ2Fubm90IHVzZSBmaWVsZHMgbWV0aG9kcywgc2luY2UgaXQgaXMgZ3JvdXAgZWxlbWVudFxuICAgIGNvbnN0IGlzID0gaW52TihzKTsgLy8gc14tMVxuICAgIGNvbnN0IHUxID0gbW9kTihoICogaXMpOyAvLyB1MSA9IGhzXi0xIG1vZCBuXG4gICAgY29uc3QgdTIgPSBtb2ROKHIgKiBpcyk7IC8vIHUyID0gcnNeLTEgbW9kIG5cbiAgICBjb25zdCBSID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShQLCB1MSwgdTIpPy50b0FmZmluZSgpOyAvLyBSID0gdTFcdTIyQzVHICsgdTJcdTIyQzVQXG4gICAgaWYgKCFSKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgdiA9IG1vZE4oUi54KTtcbiAgICByZXR1cm4gdiA9PT0gcjtcbiAgfVxuICByZXR1cm4ge1xuICAgIENVUlZFLFxuICAgIGdldFB1YmxpY0tleSxcbiAgICBnZXRTaGFyZWRTZWNyZXQsXG4gICAgc2lnbixcbiAgICB2ZXJpZnksXG4gICAgUHJvamVjdGl2ZVBvaW50OiBQb2ludCxcbiAgICBTaWduYXR1cmUsXG4gICAgdXRpbHMsXG4gIH07XG59XG5cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgdGhlIFNoYWxsdWUgYW5kIHZhbiBkZSBXb2VzdGlqbmUgbWV0aG9kIGZvciBhbnkgd2VpZXJzdHJhc3MgY3VydmUuXG4gKiBUT0RPOiBjaGVjayBpZiB0aGVyZSBpcyBhIHdheSB0byBtZXJnZSB0aGlzIHdpdGggdXZSYXRpbyBpbiBFZHdhcmRzOyBtb3ZlIHRvIG1vZHVsYXIuXG4gKiBiID0gVHJ1ZSBhbmQgeSA9IHNxcnQodSAvIHYpIGlmICh1IC8gdikgaXMgc3F1YXJlIGluIEYsIGFuZFxuICogYiA9IEZhbHNlIGFuZCB5ID0gc3FydChaICogKHUgLyB2KSkgb3RoZXJ3aXNlLlxuICogQHBhcmFtIEZwXG4gKiBAcGFyYW0gWlxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFNXVUZwU3FydFJhdGlvPFQ+KEZwOiBtb2QuSUZpZWxkPFQ+LCBaOiBUKSB7XG4gIC8vIEdlbmVyaWMgaW1wbGVtZW50YXRpb25cbiAgY29uc3QgcSA9IEZwLk9SREVSO1xuICBsZXQgbCA9IF8wbjtcbiAgZm9yIChsZXQgbyA9IHEgLSBfMW47IG8gJSBfMm4gPT09IF8wbjsgbyAvPSBfMm4pIGwgKz0gXzFuO1xuICBjb25zdCBjMSA9IGw7IC8vIDEuIGMxLCB0aGUgbGFyZ2VzdCBpbnRlZ2VyIHN1Y2ggdGhhdCAyXmMxIGRpdmlkZXMgcSAtIDEuXG4gIC8vIFdlIG5lZWQgMm4gKiogYzEgYW5kIDJuICoqIChjMS0xKS4gV2UgY2FuJ3QgdXNlICoqOyBidXQgd2UgY2FuIHVzZSA8PC5cbiAgLy8gMm4gKiogYzEgPT0gMm4gPDwgKGMxLTEpXG4gIGNvbnN0IF8ybl9wb3dfYzFfMSA9IF8ybiA8PCAoYzEgLSBfMW4gLSBfMW4pO1xuICBjb25zdCBfMm5fcG93X2MxID0gXzJuX3Bvd19jMV8xICogXzJuO1xuICBjb25zdCBjMiA9IChxIC0gXzFuKSAvIF8ybl9wb3dfYzE7IC8vIDIuIGMyID0gKHEgLSAxKSAvICgyXmMxKSAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgY29uc3QgYzMgPSAoYzIgLSBfMW4pIC8gXzJuOyAvLyAzLiBjMyA9IChjMiAtIDEpIC8gMiAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gIGNvbnN0IGM0ID0gXzJuX3Bvd19jMSAtIF8xbjsgLy8gNC4gYzQgPSAyXmMxIC0gMSAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICBjb25zdCBjNSA9IF8ybl9wb3dfYzFfMTsgLy8gNS4gYzUgPSAyXihjMSAtIDEpICAgICAgICAgICAgICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgY29uc3QgYzYgPSBGcC5wb3coWiwgYzIpOyAvLyA2LiBjNiA9IFpeYzJcbiAgY29uc3QgYzcgPSBGcC5wb3coWiwgKGMyICsgXzFuKSAvIF8ybik7IC8vIDcuIGM3ID0gWl4oKGMyICsgMSkgLyAyKVxuICBsZXQgc3FydFJhdGlvID0gKHU6IFQsIHY6IFQpOiB7IGlzVmFsaWQ6IGJvb2xlYW47IHZhbHVlOiBUIH0gPT4ge1xuICAgIGxldCB0djEgPSBjNjsgLy8gMS4gdHYxID0gYzZcbiAgICBsZXQgdHYyID0gRnAucG93KHYsIGM0KTsgLy8gMi4gdHYyID0gdl5jNFxuICAgIGxldCB0djMgPSBGcC5zcXIodHYyKTsgLy8gMy4gdHYzID0gdHYyXjJcbiAgICB0djMgPSBGcC5tdWwodHYzLCB2KTsgLy8gNC4gdHYzID0gdHYzICogdlxuICAgIGxldCB0djUgPSBGcC5tdWwodSwgdHYzKTsgLy8gNS4gdHY1ID0gdSAqIHR2M1xuICAgIHR2NSA9IEZwLnBvdyh0djUsIGMzKTsgLy8gNi4gdHY1ID0gdHY1XmMzXG4gICAgdHY1ID0gRnAubXVsKHR2NSwgdHYyKTsgLy8gNy4gdHY1ID0gdHY1ICogdHYyXG4gICAgdHYyID0gRnAubXVsKHR2NSwgdik7IC8vIDguIHR2MiA9IHR2NSAqIHZcbiAgICB0djMgPSBGcC5tdWwodHY1LCB1KTsgLy8gOS4gdHYzID0gdHY1ICogdVxuICAgIGxldCB0djQgPSBGcC5tdWwodHYzLCB0djIpOyAvLyAxMC4gdHY0ID0gdHYzICogdHYyXG4gICAgdHY1ID0gRnAucG93KHR2NCwgYzUpOyAvLyAxMS4gdHY1ID0gdHY0XmM1XG4gICAgbGV0IGlzUVIgPSBGcC5lcWwodHY1LCBGcC5PTkUpOyAvLyAxMi4gaXNRUiA9IHR2NSA9PSAxXG4gICAgdHYyID0gRnAubXVsKHR2MywgYzcpOyAvLyAxMy4gdHYyID0gdHYzICogYzdcbiAgICB0djUgPSBGcC5tdWwodHY0LCB0djEpOyAvLyAxNC4gdHY1ID0gdHY0ICogdHYxXG4gICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgaXNRUik7IC8vIDE1LiB0djMgPSBDTU9WKHR2MiwgdHYzLCBpc1FSKVxuICAgIHR2NCA9IEZwLmNtb3YodHY1LCB0djQsIGlzUVIpOyAvLyAxNi4gdHY0ID0gQ01PVih0djUsIHR2NCwgaXNRUilcbiAgICAvLyAxNy4gZm9yIGkgaW4gKGMxLCBjMSAtIDEsIC4uLiwgMik6XG4gICAgZm9yIChsZXQgaSA9IGMxOyBpID4gXzFuOyBpLS0pIHtcbiAgICAgIGxldCB0djUgPSBpIC0gXzJuOyAvLyAxOC4gICAgdHY1ID0gaSAtIDJcbiAgICAgIHR2NSA9IF8ybiA8PCAodHY1IC0gXzFuKTsgLy8gMTkuICAgIHR2NSA9IDJedHY1XG4gICAgICBsZXQgdHZ2NSA9IEZwLnBvdyh0djQsIHR2NSk7IC8vIDIwLiAgICB0djUgPSB0djRedHY1XG4gICAgICBjb25zdCBlMSA9IEZwLmVxbCh0dnY1LCBGcC5PTkUpOyAvLyAyMS4gICAgZTEgPSB0djUgPT0gMVxuICAgICAgdHYyID0gRnAubXVsKHR2MywgdHYxKTsgLy8gMjIuICAgIHR2MiA9IHR2MyAqIHR2MVxuICAgICAgdHYxID0gRnAubXVsKHR2MSwgdHYxKTsgLy8gMjMuICAgIHR2MSA9IHR2MSAqIHR2MVxuICAgICAgdHZ2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDI0LiAgICB0djUgPSB0djQgKiB0djFcbiAgICAgIHR2MyA9IEZwLmNtb3YodHYyLCB0djMsIGUxKTsgLy8gMjUuICAgIHR2MyA9IENNT1YodHYyLCB0djMsIGUxKVxuICAgICAgdHY0ID0gRnAuY21vdih0dnY1LCB0djQsIGUxKTsgLy8gMjYuICAgIHR2NCA9IENNT1YodHY1LCB0djQsIGUxKVxuICAgIH1cbiAgICByZXR1cm4geyBpc1ZhbGlkOiBpc1FSLCB2YWx1ZTogdHYzIH07XG4gIH07XG4gIGlmIChGcC5PUkRFUiAlIF80biA9PT0gXzNuKSB7XG4gICAgLy8gc3FydF9yYXRpb18zbW9kNCh1LCB2KVxuICAgIGNvbnN0IGMxID0gKEZwLk9SREVSIC0gXzNuKSAvIF80bjsgLy8gMS4gYzEgPSAocSAtIDMpIC8gNCAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICBjb25zdCBjMiA9IEZwLnNxcnQoRnAubmVnKFopKTsgLy8gMi4gYzIgPSBzcXJ0KC1aKVxuICAgIHNxcnRSYXRpbyA9ICh1OiBULCB2OiBUKSA9PiB7XG4gICAgICBsZXQgdHYxID0gRnAuc3FyKHYpOyAvLyAxLiB0djEgPSB2XjJcbiAgICAgIGNvbnN0IHR2MiA9IEZwLm11bCh1LCB2KTsgLy8gMi4gdHYyID0gdSAqIHZcbiAgICAgIHR2MSA9IEZwLm11bCh0djEsIHR2Mik7IC8vIDMuIHR2MSA9IHR2MSAqIHR2MlxuICAgICAgbGV0IHkxID0gRnAucG93KHR2MSwgYzEpOyAvLyA0LiB5MSA9IHR2MV5jMVxuICAgICAgeTEgPSBGcC5tdWwoeTEsIHR2Mik7IC8vIDUuIHkxID0geTEgKiB0djJcbiAgICAgIGNvbnN0IHkyID0gRnAubXVsKHkxLCBjMik7IC8vIDYuIHkyID0geTEgKiBjMlxuICAgICAgY29uc3QgdHYzID0gRnAubXVsKEZwLnNxcih5MSksIHYpOyAvLyA3LiB0djMgPSB5MV4yOyA4LiB0djMgPSB0djMgKiB2XG4gICAgICBjb25zdCBpc1FSID0gRnAuZXFsKHR2MywgdSk7IC8vIDkuIGlzUVIgPSB0djMgPT0gdVxuICAgICAgbGV0IHkgPSBGcC5jbW92KHkyLCB5MSwgaXNRUik7IC8vIDEwLiB5ID0gQ01PVih5MiwgeTEsIGlzUVIpXG4gICAgICByZXR1cm4geyBpc1ZhbGlkOiBpc1FSLCB2YWx1ZTogeSB9OyAvLyAxMS4gcmV0dXJuIChpc1FSLCB5KSBpc1FSID8geSA6IHkqYzJcbiAgICB9O1xuICB9XG4gIC8vIE5vIGN1cnZlcyB1c2VzIHRoYXRcbiAgLy8gaWYgKEZwLk9SREVSICUgXzhuID09PSBfNW4pIC8vIHNxcnRfcmF0aW9fNW1vZDhcbiAgcmV0dXJuIHNxcnRSYXRpbztcbn1cbi8qKlxuICogU2ltcGxpZmllZCBTaGFsbHVlLXZhbiBkZSBXb2VzdGlqbmUtVWxhcyBNZXRob2RcbiAqIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNi42LjJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcFRvQ3VydmVTaW1wbGVTV1U8VD4oXG4gIEZwOiBtb2QuSUZpZWxkPFQ+LFxuICBvcHRzOiB7XG4gICAgQTogVDtcbiAgICBCOiBUO1xuICAgIFo6IFQ7XG4gIH1cbikge1xuICBtb2QudmFsaWRhdGVGaWVsZChGcCk7XG4gIGlmICghRnAuaXNWYWxpZChvcHRzLkEpIHx8ICFGcC5pc1ZhbGlkKG9wdHMuQikgfHwgIUZwLmlzVmFsaWQob3B0cy5aKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFRvQ3VydmVTaW1wbGVTV1U6IGludmFsaWQgb3B0cycpO1xuICBjb25zdCBzcXJ0UmF0aW8gPSBTV1VGcFNxcnRSYXRpbyhGcCwgb3B0cy5aKTtcbiAgaWYgKCFGcC5pc09kZCkgdGhyb3cgbmV3IEVycm9yKCdGcC5pc09kZCBpcyBub3QgaW1wbGVtZW50ZWQhJyk7XG4gIC8vIElucHV0OiB1LCBhbiBlbGVtZW50IG9mIEYuXG4gIC8vIE91dHB1dDogKHgsIHkpLCBhIHBvaW50IG9uIEUuXG4gIHJldHVybiAodTogVCk6IHsgeDogVDsgeTogVCB9ID0+IHtcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBsZXQgdHYxLCB0djIsIHR2MywgdHY0LCB0djUsIHR2NiwgeCwgeTtcbiAgICB0djEgPSBGcC5zcXIodSk7IC8vIDEuICB0djEgPSB1XjJcbiAgICB0djEgPSBGcC5tdWwodHYxLCBvcHRzLlopOyAvLyAyLiAgdHYxID0gWiAqIHR2MVxuICAgIHR2MiA9IEZwLnNxcih0djEpOyAvLyAzLiAgdHYyID0gdHYxXjJcbiAgICB0djIgPSBGcC5hZGQodHYyLCB0djEpOyAvLyA0LiAgdHYyID0gdHYyICsgdHYxXG4gICAgdHYzID0gRnAuYWRkKHR2MiwgRnAuT05FKTsgLy8gNS4gIHR2MyA9IHR2MiArIDFcbiAgICB0djMgPSBGcC5tdWwodHYzLCBvcHRzLkIpOyAvLyA2LiAgdHYzID0gQiAqIHR2M1xuICAgIHR2NCA9IEZwLmNtb3Yob3B0cy5aLCBGcC5uZWcodHYyKSwgIUZwLmVxbCh0djIsIEZwLlpFUk8pKTsgLy8gNy4gIHR2NCA9IENNT1YoWiwgLXR2MiwgdHYyICE9IDApXG4gICAgdHY0ID0gRnAubXVsKHR2NCwgb3B0cy5BKTsgLy8gOC4gIHR2NCA9IEEgKiB0djRcbiAgICB0djIgPSBGcC5zcXIodHYzKTsgLy8gOS4gIHR2MiA9IHR2M14yXG4gICAgdHY2ID0gRnAuc3FyKHR2NCk7IC8vIDEwLiB0djYgPSB0djReMlxuICAgIHR2NSA9IEZwLm11bCh0djYsIG9wdHMuQSk7IC8vIDExLiB0djUgPSBBICogdHY2XG4gICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTIuIHR2MiA9IHR2MiArIHR2NVxuICAgIHR2MiA9IEZwLm11bCh0djIsIHR2Myk7IC8vIDEzLiB0djIgPSB0djIgKiB0djNcbiAgICB0djYgPSBGcC5tdWwodHY2LCB0djQpOyAvLyAxNC4gdHY2ID0gdHY2ICogdHY0XG4gICAgdHY1ID0gRnAubXVsKHR2Niwgb3B0cy5CKTsgLy8gMTUuIHR2NSA9IEIgKiB0djZcbiAgICB0djIgPSBGcC5hZGQodHYyLCB0djUpOyAvLyAxNi4gdHYyID0gdHYyICsgdHY1XG4gICAgeCA9IEZwLm11bCh0djEsIHR2Myk7IC8vIDE3LiAgIHggPSB0djEgKiB0djNcbiAgICBjb25zdCB7IGlzVmFsaWQsIHZhbHVlIH0gPSBzcXJ0UmF0aW8odHYyLCB0djYpOyAvLyAxOC4gKGlzX2d4MV9zcXVhcmUsIHkxKSA9IHNxcnRfcmF0aW8odHYyLCB0djYpXG4gICAgeSA9IEZwLm11bCh0djEsIHUpOyAvLyAxOS4gICB5ID0gdHYxICogdSAgLT4gWiAqIHVeMyAqIHkxXG4gICAgeSA9IEZwLm11bCh5LCB2YWx1ZSk7IC8vIDIwLiAgIHkgPSB5ICogeTFcbiAgICB4ID0gRnAuY21vdih4LCB0djMsIGlzVmFsaWQpOyAvLyAyMS4gICB4ID0gQ01PVih4LCB0djMsIGlzX2d4MV9zcXVhcmUpXG4gICAgeSA9IEZwLmNtb3YoeSwgdmFsdWUsIGlzVmFsaWQpOyAvLyAyMi4gICB5ID0gQ01PVih5LCB5MSwgaXNfZ3gxX3NxdWFyZSlcbiAgICBjb25zdCBlMSA9IEZwLmlzT2RkISh1KSA9PT0gRnAuaXNPZGQhKHkpOyAvLyAyMy4gIGUxID0gc2duMCh1KSA9PSBzZ24wKHkpXG4gICAgeSA9IEZwLmNtb3YoRnAubmVnKHkpLCB5LCBlMSk7IC8vIDI0LiAgIHkgPSBDTU9WKC15LCB5LCBlMSlcbiAgICB4ID0gRnAuZGl2KHgsIHR2NCk7IC8vIDI1LiAgIHggPSB4IC8gdHY0XG4gICAgcmV0dXJuIHsgeCwgeSB9O1xuICB9O1xufVxuIiwgImltcG9ydCB7IGhhc2ggYXMgYXNzZXJ0SGFzaCwgYnl0ZXMgYXMgYXNzZXJ0Qnl0ZXMsIGV4aXN0cyBhcyBhc3NlcnRFeGlzdHMgfSBmcm9tICcuL19hc3NlcnQuanMnO1xuaW1wb3J0IHsgSGFzaCwgQ0hhc2gsIElucHV0LCB0b0J5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBITUFDIChSRkMgMjEwNClcbmV4cG9ydCBjbGFzcyBITUFDPFQgZXh0ZW5kcyBIYXNoPFQ+PiBleHRlbmRzIEhhc2g8SE1BQzxUPj4ge1xuICBvSGFzaDogVDtcbiAgaUhhc2g6IFQ7XG4gIGJsb2NrTGVuOiBudW1iZXI7XG4gIG91dHB1dExlbjogbnVtYmVyO1xuICBwcml2YXRlIGZpbmlzaGVkID0gZmFsc2U7XG4gIHByaXZhdGUgZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IoaGFzaDogQ0hhc2gsIF9rZXk6IElucHV0KSB7XG4gICAgc3VwZXIoKTtcbiAgICBhc3NlcnRIYXNoKGhhc2gpO1xuICAgIGNvbnN0IGtleSA9IHRvQnl0ZXMoX2tleSk7XG4gICAgdGhpcy5pSGFzaCA9IGhhc2guY3JlYXRlKCkgYXMgVDtcbiAgICBpZiAodHlwZW9mIHRoaXMuaUhhc2gudXBkYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBpbnN0YW5jZSBvZiBjbGFzcyB3aGljaCBleHRlbmRzIHV0aWxzLkhhc2gnKTtcbiAgICB0aGlzLmJsb2NrTGVuID0gdGhpcy5pSGFzaC5ibG9ja0xlbjtcbiAgICB0aGlzLm91dHB1dExlbiA9IHRoaXMuaUhhc2gub3V0cHV0TGVuO1xuICAgIGNvbnN0IGJsb2NrTGVuID0gdGhpcy5ibG9ja0xlbjtcbiAgICBjb25zdCBwYWQgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgLy8gYmxvY2tMZW4gY2FuIGJlIGJpZ2dlciB0aGFuIG91dHB1dExlblxuICAgIHBhZC5zZXQoa2V5Lmxlbmd0aCA+IGJsb2NrTGVuID8gaGFzaC5jcmVhdGUoKS51cGRhdGUoa2V5KS5kaWdlc3QoKSA6IGtleSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspIHBhZFtpXSBePSAweDM2O1xuICAgIHRoaXMuaUhhc2gudXBkYXRlKHBhZCk7XG4gICAgLy8gQnkgZG9pbmcgdXBkYXRlIChwcm9jZXNzaW5nIG9mIGZpcnN0IGJsb2NrKSBvZiBvdXRlciBoYXNoIGhlcmUgd2UgY2FuIHJlLXVzZSBpdCBiZXR3ZWVuIG11bHRpcGxlIGNhbGxzIHZpYSBjbG9uZVxuICAgIHRoaXMub0hhc2ggPSBoYXNoLmNyZWF0ZSgpIGFzIFQ7XG4gICAgLy8gVW5kbyBpbnRlcm5hbCBYT1IgJiYgYXBwbHkgb3V0ZXIgWE9SXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspIHBhZFtpXSBePSAweDM2IF4gMHg1YztcbiAgICB0aGlzLm9IYXNoLnVwZGF0ZShwYWQpO1xuICAgIHBhZC5maWxsKDApO1xuICB9XG4gIHVwZGF0ZShidWY6IElucHV0KSB7XG4gICAgYXNzZXJ0RXhpc3RzKHRoaXMpO1xuICAgIHRoaXMuaUhhc2gudXBkYXRlKGJ1Zik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZGlnZXN0SW50byhvdXQ6IFVpbnQ4QXJyYXkpIHtcbiAgICBhc3NlcnRFeGlzdHModGhpcyk7XG4gICAgYXNzZXJ0Qnl0ZXMob3V0LCB0aGlzLm91dHB1dExlbik7XG4gICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgdGhpcy5pSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgdGhpcy5vSGFzaC51cGRhdGUob3V0KTtcbiAgICB0aGlzLm9IYXNoLmRpZ2VzdEludG8ob3V0KTtcbiAgICB0aGlzLmRlc3Ryb3koKTtcbiAgfVxuICBkaWdlc3QoKSB7XG4gICAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5vSGFzaC5vdXRwdXRMZW4pO1xuICAgIHRoaXMuZGlnZXN0SW50byhvdXQpO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgX2Nsb25lSW50byh0bz86IEhNQUM8VD4pOiBITUFDPFQ+IHtcbiAgICAvLyBDcmVhdGUgbmV3IGluc3RhbmNlIHdpdGhvdXQgY2FsbGluZyBjb25zdHJ1Y3RvciBzaW5jZSBrZXkgYWxyZWFkeSBpbiBzdGF0ZSBhbmQgd2UgZG9uJ3Qga25vdyBpdC5cbiAgICB0byB8fD0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIHt9KTtcbiAgICBjb25zdCB7IG9IYXNoLCBpSGFzaCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgYmxvY2tMZW4sIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICB0byA9IHRvIGFzIHRoaXM7XG4gICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgdG8uYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICB0by5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgdG8ub0hhc2ggPSBvSGFzaC5fY2xvbmVJbnRvKHRvLm9IYXNoKTtcbiAgICB0by5pSGFzaCA9IGlIYXNoLl9jbG9uZUludG8odG8uaUhhc2gpO1xuICAgIHJldHVybiB0bztcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB0aGlzLm9IYXNoLmRlc3Ryb3koKTtcbiAgICB0aGlzLmlIYXNoLmRlc3Ryb3koKTtcbiAgfVxufVxuXG4vKipcbiAqIEhNQUM6IFJGQzIxMDQgbWVzc2FnZSBhdXRoZW50aWNhdGlvbiBjb2RlLlxuICogQHBhcmFtIGhhc2ggLSBmdW5jdGlvbiB0aGF0IHdvdWxkIGJlIHVzZWQgZS5nLiBzaGEyNTZcbiAqIEBwYXJhbSBrZXkgLSBtZXNzYWdlIGtleVxuICogQHBhcmFtIG1lc3NhZ2UgLSBtZXNzYWdlIGRhdGFcbiAqL1xuZXhwb3J0IGNvbnN0IGhtYWMgPSAoaGFzaDogQ0hhc2gsIGtleTogSW5wdXQsIG1lc3NhZ2U6IElucHV0KTogVWludDhBcnJheSA9PlxuICBuZXcgSE1BQzxhbnk+KGhhc2gsIGtleSkudXBkYXRlKG1lc3NhZ2UpLmRpZ2VzdCgpO1xuaG1hYy5jcmVhdGUgPSAoaGFzaDogQ0hhc2gsIGtleTogSW5wdXQpID0+IG5ldyBITUFDPGFueT4oaGFzaCwga2V5KTtcbiIsICIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgeyBobWFjIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9obWFjJztcbmltcG9ydCB7IGNvbmNhdEJ5dGVzLCByYW5kb21CeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMnO1xuaW1wb3J0IHsgd2VpZXJzdHJhc3MsIEN1cnZlVHlwZSB9IGZyb20gJy4vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMnO1xuaW1wb3J0IHsgQ0hhc2ggfSBmcm9tICcuL2Fic3RyYWN0L3V0aWxzLmpzJztcblxuLy8gY29ubmVjdHMgbm9ibGUtY3VydmVzIHRvIG5vYmxlLWhhc2hlc1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhhc2goaGFzaDogQ0hhc2gpIHtcbiAgcmV0dXJuIHtcbiAgICBoYXNoLFxuICAgIGhtYWM6IChrZXk6IFVpbnQ4QXJyYXksIC4uLm1zZ3M6IFVpbnQ4QXJyYXlbXSkgPT4gaG1hYyhoYXNoLCBrZXksIGNvbmNhdEJ5dGVzKC4uLm1zZ3MpKSxcbiAgICByYW5kb21CeXRlcyxcbiAgfTtcbn1cbi8vIFNhbWUgQVBJIGFzIEBub2JsZS9oYXNoZXMsIHdpdGggYWJpbGl0eSB0byBjcmVhdGUgY3VydmUgd2l0aCBjdXN0b20gaGFzaFxudHlwZSBDdXJ2ZURlZiA9IFJlYWRvbmx5PE9taXQ8Q3VydmVUeXBlLCAnaGFzaCcgfCAnaG1hYycgfCAncmFuZG9tQnl0ZXMnPj47XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ3VydmUoY3VydmVEZWY6IEN1cnZlRGVmLCBkZWZIYXNoOiBDSGFzaCkge1xuICBjb25zdCBjcmVhdGUgPSAoaGFzaDogQ0hhc2gpID0+IHdlaWVyc3RyYXNzKHsgLi4uY3VydmVEZWYsIC4uLmdldEhhc2goaGFzaCkgfSk7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHsgLi4uY3JlYXRlKGRlZkhhc2gpLCBjcmVhdGUgfSk7XG59XG4iLCAiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEyNTYnO1xuaW1wb3J0IHsgcmFuZG9tQnl0ZXMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzJztcbmltcG9ydCB7IEZpZWxkLCBtb2QsIHBvdzIgfSBmcm9tICcuL2Fic3RyYWN0L21vZHVsYXIuanMnO1xuaW1wb3J0IHsgUHJvalBvaW50VHlwZSBhcyBQb2ludFR5cGUsIG1hcFRvQ3VydmVTaW1wbGVTV1UgfSBmcm9tICcuL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzJztcbmltcG9ydCB0eXBlIHsgSGV4LCBQcml2S2V5IH0gZnJvbSAnLi9hYnN0cmFjdC91dGlscy5qcyc7XG5pbXBvcnQgeyBieXRlc1RvTnVtYmVyQkUsIGNvbmNhdEJ5dGVzLCBlbnN1cmVCeXRlcywgbnVtYmVyVG9CeXRlc0JFIH0gZnJvbSAnLi9hYnN0cmFjdC91dGlscy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVIYXNoZXIsIGlzb2dlbnlNYXAgfSBmcm9tICcuL2Fic3RyYWN0L2hhc2gtdG8tY3VydmUuanMnO1xuaW1wb3J0IHsgY3JlYXRlQ3VydmUgfSBmcm9tICcuL19zaG9ydHdfdXRpbHMuanMnO1xuXG5jb25zdCBzZWNwMjU2azFQID0gQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmZjMmYnKTtcbmNvbnN0IHNlY3AyNTZrMU4gPSBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmViYWFlZGNlNmFmNDhhMDNiYmZkMjVlOGNkMDM2NDE0MScpO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuY29uc3QgXzJuID0gQmlnSW50KDIpO1xuY29uc3QgZGl2TmVhcmVzdCA9IChhOiBiaWdpbnQsIGI6IGJpZ2ludCkgPT4gKGEgKyBiIC8gXzJuKSAvIGI7XG5cbi8qKlxuICogXHUyMjFBbiA9IG5eKChwKzEpLzQpIGZvciBmaWVsZHMgcCA9IDMgbW9kIDQuIFdlIHVud3JhcCB0aGUgbG9vcCBhbmQgbXVsdGlwbHkgYml0LWJ5LWJpdC5cbiAqIChQKzFuLzRuKS50b1N0cmluZygyKSB3b3VsZCBwcm9kdWNlIGJpdHMgWzIyM3ggMSwgMCwgMjJ4IDEsIDR4IDAsIDExLCAwMF1cbiAqL1xuZnVuY3Rpb24gc3FydE1vZCh5OiBiaWdpbnQpOiBiaWdpbnQge1xuICBjb25zdCBQID0gc2VjcDI1NmsxUDtcbiAgLy8gcHJldHRpZXItaWdub3JlXG4gIGNvbnN0IF8zbiA9IEJpZ0ludCgzKSwgXzZuID0gQmlnSW50KDYpLCBfMTFuID0gQmlnSW50KDExKSwgXzIybiA9IEJpZ0ludCgyMik7XG4gIC8vIHByZXR0aWVyLWlnbm9yZVxuICBjb25zdCBfMjNuID0gQmlnSW50KDIzKSwgXzQ0biA9IEJpZ0ludCg0NCksIF84OG4gPSBCaWdJbnQoODgpO1xuICBjb25zdCBiMiA9ICh5ICogeSAqIHkpICUgUDsgLy8geF4zLCAxMVxuICBjb25zdCBiMyA9IChiMiAqIGIyICogeSkgJSBQOyAvLyB4XjdcbiAgY29uc3QgYjYgPSAocG93MihiMywgXzNuLCBQKSAqIGIzKSAlIFA7XG4gIGNvbnN0IGI5ID0gKHBvdzIoYjYsIF8zbiwgUCkgKiBiMykgJSBQO1xuICBjb25zdCBiMTEgPSAocG93MihiOSwgXzJuLCBQKSAqIGIyKSAlIFA7XG4gIGNvbnN0IGIyMiA9IChwb3cyKGIxMSwgXzExbiwgUCkgKiBiMTEpICUgUDtcbiAgY29uc3QgYjQ0ID0gKHBvdzIoYjIyLCBfMjJuLCBQKSAqIGIyMikgJSBQO1xuICBjb25zdCBiODggPSAocG93MihiNDQsIF80NG4sIFApICogYjQ0KSAlIFA7XG4gIGNvbnN0IGIxNzYgPSAocG93MihiODgsIF84OG4sIFApICogYjg4KSAlIFA7XG4gIGNvbnN0IGIyMjAgPSAocG93MihiMTc2LCBfNDRuLCBQKSAqIGI0NCkgJSBQO1xuICBjb25zdCBiMjIzID0gKHBvdzIoYjIyMCwgXzNuLCBQKSAqIGIzKSAlIFA7XG4gIGNvbnN0IHQxID0gKHBvdzIoYjIyMywgXzIzbiwgUCkgKiBiMjIpICUgUDtcbiAgY29uc3QgdDIgPSAocG93Mih0MSwgXzZuLCBQKSAqIGIyKSAlIFA7XG4gIGNvbnN0IHJvb3QgPSBwb3cyKHQyLCBfMm4sIFApO1xuICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIHkpKSB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gIHJldHVybiByb290O1xufVxuXG5jb25zdCBGcCA9IEZpZWxkKHNlY3AyNTZrMVAsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7IHNxcnQ6IHNxcnRNb2QgfSk7XG5cbmV4cG9ydCBjb25zdCBzZWNwMjU2azEgPSBjcmVhdGVDdXJ2ZShcbiAge1xuICAgIGE6IEJpZ0ludCgwKSwgLy8gZXF1YXRpb24gcGFyYW1zOiBhLCBiXG4gICAgYjogQmlnSW50KDcpLCAvLyBTZWVtIHRvIGJlIHJpZ2lkOiBiaXRjb2ludGFsay5vcmcvaW5kZXgucGhwP3RvcGljPTI4OTc5NS5tc2czMTgzOTc1I21zZzMxODM5NzVcbiAgICBGcCwgLy8gRmllbGQncyBwcmltZTogMm4qKjI1Nm4gLSAybioqMzJuIC0gMm4qKjluIC0gMm4qKjhuIC0gMm4qKjduIC0gMm4qKjZuIC0gMm4qKjRuIC0gMW5cbiAgICBuOiBzZWNwMjU2azFOLCAvLyBDdXJ2ZSBvcmRlciwgdG90YWwgY291bnQgb2YgdmFsaWQgcG9pbnRzIGluIHRoZSBmaWVsZFxuICAgIC8vIEJhc2UgcG9pbnQgKHgsIHkpIGFrYSBnZW5lcmF0b3IgcG9pbnRcbiAgICBHeDogQmlnSW50KCc1NTA2NjI2MzAyMjI3NzM0MzY2OTU3ODcxODg5NTE2ODUzNDMyNjI1MDYwMzQ1Mzc3NzU5NDE3NTUwMDE4NzM2MDM4OTExNjcyOTI0MCcpLFxuICAgIEd5OiBCaWdJbnQoJzMyNjcwNTEwMDIwNzU4ODE2OTc4MDgzMDg1MTMwNTA3MDQzMTg0NDcxMjczMzgwNjU5MjQzMjc1OTM4OTA0MzM1NzU3MzM3NDgyNDI0JyksXG4gICAgaDogQmlnSW50KDEpLCAvLyBDb2ZhY3RvclxuICAgIGxvd1M6IHRydWUsIC8vIEFsbG93IG9ubHkgbG93LVMgc2lnbmF0dXJlcyBieSBkZWZhdWx0IGluIHNpZ24oKSBhbmQgdmVyaWZ5KClcbiAgICAvKipcbiAgICAgKiBzZWNwMjU2azEgYmVsb25ncyB0byBLb2JsaXR6IGN1cnZlczogaXQgaGFzIGVmZmljaWVudGx5IGNvbXB1dGFibGUgZW5kb21vcnBoaXNtLlxuICAgICAqIEVuZG9tb3JwaGlzbSB1c2VzIDJ4IGxlc3MgUkFNLCBzcGVlZHMgdXAgcHJlY29tcHV0YXRpb24gYnkgMnggYW5kIEVDREggLyBrZXkgcmVjb3ZlcnkgYnkgMjAlLlxuICAgICAqIEZvciBwcmVjb21wdXRlZCB3TkFGIGl0IHRyYWRlcyBvZmYgMS8yIGluaXQgdGltZSAmIDEvMyByYW0gZm9yIDIwJSBwZXJmIGhpdC5cbiAgICAgKiBFeHBsYW5hdGlvbjogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGF1bG1pbGxyL2ViNjcwODA2NzkzZTg0ZGY2MjhhN2M0MzRhODczMDY2XG4gICAgICovXG4gICAgZW5kbzoge1xuICAgICAgYmV0YTogQmlnSW50KCcweDdhZTk2YTJiNjU3YzA3MTA2ZTY0NDc5ZWFjMzQzNGU5OWNmMDQ5NzUxMmY1ODk5NWMxMzk2YzI4NzE5NTAxZWUnKSxcbiAgICAgIHNwbGl0U2NhbGFyOiAoazogYmlnaW50KSA9PiB7XG4gICAgICAgIGNvbnN0IG4gPSBzZWNwMjU2azFOO1xuICAgICAgICBjb25zdCBhMSA9IEJpZ0ludCgnMHgzMDg2ZDIyMWE3ZDQ2YmNkZTg2YzkwZTQ5Mjg0ZWIxNScpO1xuICAgICAgICBjb25zdCBiMSA9IC1fMW4gKiBCaWdJbnQoJzB4ZTQ0MzdlZDYwMTBlODgyODZmNTQ3ZmE5MGFiZmU0YzMnKTtcbiAgICAgICAgY29uc3QgYTIgPSBCaWdJbnQoJzB4MTE0Y2E1MGY3YThlMmYzZjY1N2MxMTA4ZDlkNDRjZmQ4Jyk7XG4gICAgICAgIGNvbnN0IGIyID0gYTE7XG4gICAgICAgIGNvbnN0IFBPV18yXzEyOCA9IEJpZ0ludCgnMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnKTsgLy8gKDJuKioxMjhuKS50b1N0cmluZygxNilcblxuICAgICAgICBjb25zdCBjMSA9IGRpdk5lYXJlc3QoYjIgKiBrLCBuKTtcbiAgICAgICAgY29uc3QgYzIgPSBkaXZOZWFyZXN0KC1iMSAqIGssIG4pO1xuICAgICAgICBsZXQgazEgPSBtb2QoayAtIGMxICogYTEgLSBjMiAqIGEyLCBuKTtcbiAgICAgICAgbGV0IGsyID0gbW9kKC1jMSAqIGIxIC0gYzIgKiBiMiwgbik7XG4gICAgICAgIGNvbnN0IGsxbmVnID0gazEgPiBQT1dfMl8xMjg7XG4gICAgICAgIGNvbnN0IGsybmVnID0gazIgPiBQT1dfMl8xMjg7XG4gICAgICAgIGlmIChrMW5lZykgazEgPSBuIC0gazE7XG4gICAgICAgIGlmIChrMm5lZykgazIgPSBuIC0gazI7XG4gICAgICAgIGlmIChrMSA+IFBPV18yXzEyOCB8fCBrMiA+IFBPV18yXzEyOCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3BsaXRTY2FsYXI6IEVuZG9tb3JwaGlzbSBmYWlsZWQsIGs9JyArIGspO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH07XG4gICAgICB9LFxuICAgIH0sXG4gIH0sXG4gIHNoYTI1NlxuKTtcblxuLy8gU2Nobm9yciBzaWduYXR1cmVzIGFyZSBzdXBlcmlvciB0byBFQ0RTQSBmcm9tIGFib3ZlLiBCZWxvdyBpcyBTY2hub3JyLXNwZWNpZmljIEJJUDAzNDAgY29kZS5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAzNDAubWVkaWF3aWtpXG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBmZSA9ICh4OiBiaWdpbnQpID0+IHR5cGVvZiB4ID09PSAnYmlnaW50JyAmJiBfMG4gPCB4ICYmIHggPCBzZWNwMjU2azFQO1xuY29uc3QgZ2UgPSAoeDogYmlnaW50KSA9PiB0eXBlb2YgeCA9PT0gJ2JpZ2ludCcgJiYgXzBuIDwgeCAmJiB4IDwgc2VjcDI1NmsxTjtcbi8qKiBBbiBvYmplY3QgbWFwcGluZyB0YWdzIHRvIHRoZWlyIHRhZ2dlZCBoYXNoIHByZWZpeCBvZiBbU0hBMjU2KHRhZykgfCBTSEEyNTYodGFnKV0gKi9cbmNvbnN0IFRBR0dFRF9IQVNIX1BSRUZJWEVTOiB7IFt0YWc6IHN0cmluZ106IFVpbnQ4QXJyYXkgfSA9IHt9O1xuZnVuY3Rpb24gdGFnZ2VkSGFzaCh0YWc6IHN0cmluZywgLi4ubWVzc2FnZXM6IFVpbnQ4QXJyYXlbXSk6IFVpbnQ4QXJyYXkge1xuICBsZXQgdGFnUCA9IFRBR0dFRF9IQVNIX1BSRUZJWEVTW3RhZ107XG4gIGlmICh0YWdQID09PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCB0YWdIID0gc2hhMjU2KFVpbnQ4QXJyYXkuZnJvbSh0YWcsIChjKSA9PiBjLmNoYXJDb2RlQXQoMCkpKTtcbiAgICB0YWdQID0gY29uY2F0Qnl0ZXModGFnSCwgdGFnSCk7XG4gICAgVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXSA9IHRhZ1A7XG4gIH1cbiAgcmV0dXJuIHNoYTI1Nihjb25jYXRCeXRlcyh0YWdQLCAuLi5tZXNzYWdlcykpO1xufVxuXG4vLyBFQ0RTQSBjb21wYWN0IHBvaW50cyBhcmUgMzMtYnl0ZS4gU2Nobm9yciBpcyAzMjogd2Ugc3RyaXAgZmlyc3QgYnl0ZSAweDAyIG9yIDB4MDNcbmNvbnN0IHBvaW50VG9CeXRlcyA9IChwb2ludDogUG9pbnRUeXBlPGJpZ2ludD4pID0+IHBvaW50LnRvUmF3Qnl0ZXModHJ1ZSkuc2xpY2UoMSk7XG5jb25zdCBudW1UbzMyYiA9IChuOiBiaWdpbnQpID0+IG51bWJlclRvQnl0ZXNCRShuLCAzMik7XG5jb25zdCBtb2RQID0gKHg6IGJpZ2ludCkgPT4gbW9kKHgsIHNlY3AyNTZrMVApO1xuY29uc3QgbW9kTiA9ICh4OiBiaWdpbnQpID0+IG1vZCh4LCBzZWNwMjU2azFOKTtcbmNvbnN0IFBvaW50ID0gc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludDtcbmNvbnN0IEdtdWxBZGQgPSAoUTogUG9pbnRUeXBlPGJpZ2ludD4sIGE6IGJpZ2ludCwgYjogYmlnaW50KSA9PlxuICBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFEsIGEsIGIpO1xuXG4vLyBDYWxjdWxhdGUgcG9pbnQsIHNjYWxhciBhbmQgYnl0ZXNcbmZ1bmN0aW9uIHNjaG5vcnJHZXRFeHRQdWJLZXkocHJpdjogUHJpdktleSkge1xuICBsZXQgZF8gPSBzZWNwMjU2azEudXRpbHMubm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2KTsgLy8gc2FtZSBtZXRob2QgZXhlY3V0ZWQgaW4gZnJvbVByaXZhdGVLZXlcbiAgbGV0IHAgPSBQb2ludC5mcm9tUHJpdmF0ZUtleShkXyk7IC8vIFAgPSBkJ1x1MjJDNUc7IDAgPCBkJyA8IG4gY2hlY2sgaXMgZG9uZSBpbnNpZGVcbiAgY29uc3Qgc2NhbGFyID0gcC5oYXNFdmVuWSgpID8gZF8gOiBtb2ROKC1kXyk7XG4gIHJldHVybiB7IHNjYWxhcjogc2NhbGFyLCBieXRlczogcG9pbnRUb0J5dGVzKHApIH07XG59XG4vKipcbiAqIGxpZnRfeCBmcm9tIEJJUDM0MC4gQ29udmVydCAzMi1ieXRlIHggY29vcmRpbmF0ZSB0byBlbGxpcHRpYyBjdXJ2ZSBwb2ludC5cbiAqIEByZXR1cm5zIHZhbGlkIHBvaW50IGNoZWNrZWQgZm9yIGJlaW5nIG9uLWN1cnZlXG4gKi9cbmZ1bmN0aW9uIGxpZnRfeCh4OiBiaWdpbnQpOiBQb2ludFR5cGU8YmlnaW50PiB7XG4gIGlmICghZmUoeCkpIHRocm93IG5ldyBFcnJvcignYmFkIHg6IG5lZWQgMCA8IHggPCBwJyk7IC8vIEZhaWwgaWYgeCBcdTIyNjUgcC5cbiAgY29uc3QgeHggPSBtb2RQKHggKiB4KTtcbiAgY29uc3QgYyA9IG1vZFAoeHggKiB4ICsgQmlnSW50KDcpKTsgLy8gTGV0IGMgPSB4XHUwMEIzICsgNyBtb2QgcC5cbiAgbGV0IHkgPSBzcXJ0TW9kKGMpOyAvLyBMZXQgeSA9IGNeKHArMSkvNCBtb2QgcC5cbiAgaWYgKHkgJSBfMm4gIT09IF8wbikgeSA9IG1vZFAoLXkpOyAvLyBSZXR1cm4gdGhlIHVuaXF1ZSBwb2ludCBQIHN1Y2ggdGhhdCB4KFApID0geCBhbmRcbiAgY29uc3QgcCA9IG5ldyBQb2ludCh4LCB5LCBfMW4pOyAvLyB5KFApID0geSBpZiB5IG1vZCAyID0gMCBvciB5KFApID0gcC15IG90aGVyd2lzZS5cbiAgcC5hc3NlcnRWYWxpZGl0eSgpO1xuICByZXR1cm4gcDtcbn1cbi8qKlxuICogQ3JlYXRlIHRhZ2dlZCBoYXNoLCBjb252ZXJ0IGl0IHRvIGJpZ2ludCwgcmVkdWNlIG1vZHVsby1uLlxuICovXG5mdW5jdGlvbiBjaGFsbGVuZ2UoLi4uYXJnczogVWludDhBcnJheVtdKTogYmlnaW50IHtcbiAgcmV0dXJuIG1vZE4oYnl0ZXNUb051bWJlckJFKHRhZ2dlZEhhc2goJ0JJUDAzNDAvY2hhbGxlbmdlJywgLi4uYXJncykpKTtcbn1cblxuLyoqXG4gKiBTY2hub3JyIHB1YmxpYyBrZXkgaXMganVzdCBgeGAgY29vcmRpbmF0ZSBvZiBQb2ludCBhcyBwZXIgQklQMzQwLlxuICovXG5mdW5jdGlvbiBzY2hub3JyR2V0UHVibGljS2V5KHByaXZhdGVLZXk6IEhleCk6IFVpbnQ4QXJyYXkge1xuICByZXR1cm4gc2Nobm9yckdldEV4dFB1YktleShwcml2YXRlS2V5KS5ieXRlczsgLy8gZCc9aW50KHNrKS4gRmFpbCBpZiBkJz0wIG9yIGQnXHUyMjY1bi4gUmV0IGJ5dGVzKGQnXHUyMkM1Rylcbn1cblxuLyoqXG4gKiBDcmVhdGVzIFNjaG5vcnIgc2lnbmF0dXJlIGFzIHBlciBCSVAzNDAuIFZlcmlmaWVzIGl0c2VsZiBiZWZvcmUgcmV0dXJuaW5nIGFueXRoaW5nLlxuICogYXV4UmFuZCBpcyBvcHRpb25hbCBhbmQgaXMgbm90IHRoZSBzb2xlIHNvdXJjZSBvZiBrIGdlbmVyYXRpb246IGJhZCBDU1BSTkcgd29uJ3QgYmUgZGFuZ2Vyb3VzLlxuICovXG5mdW5jdGlvbiBzY2hub3JyU2lnbihcbiAgbWVzc2FnZTogSGV4LFxuICBwcml2YXRlS2V5OiBQcml2S2V5LFxuICBhdXhSYW5kOiBIZXggPSByYW5kb21CeXRlcygzMilcbik6IFVpbnQ4QXJyYXkge1xuICBjb25zdCBtID0gZW5zdXJlQnl0ZXMoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgY29uc3QgeyBieXRlczogcHgsIHNjYWxhcjogZCB9ID0gc2Nobm9yckdldEV4dFB1YktleShwcml2YXRlS2V5KTsgLy8gY2hlY2tzIGZvciBpc1dpdGhpbkN1cnZlT3JkZXJcbiAgY29uc3QgYSA9IGVuc3VyZUJ5dGVzKCdhdXhSYW5kJywgYXV4UmFuZCwgMzIpOyAvLyBBdXhpbGlhcnkgcmFuZG9tIGRhdGEgYTogYSAzMi1ieXRlIGFycmF5XG4gIGNvbnN0IHQgPSBudW1UbzMyYihkIF4gYnl0ZXNUb051bWJlckJFKHRhZ2dlZEhhc2goJ0JJUDAzNDAvYXV4JywgYSkpKTsgLy8gTGV0IHQgYmUgdGhlIGJ5dGUtd2lzZSB4b3Igb2YgYnl0ZXMoZCkgYW5kIGhhc2gvYXV4KGEpXG4gIGNvbnN0IHJhbmQgPSB0YWdnZWRIYXNoKCdCSVAwMzQwL25vbmNlJywgdCwgcHgsIG0pOyAvLyBMZXQgcmFuZCA9IGhhc2gvbm9uY2UodCB8fCBieXRlcyhQKSB8fCBtKVxuICBjb25zdCBrXyA9IG1vZE4oYnl0ZXNUb051bWJlckJFKHJhbmQpKTsgLy8gTGV0IGsnID0gaW50KHJhbmQpIG1vZCBuXG4gIGlmIChrXyA9PT0gXzBuKSB0aHJvdyBuZXcgRXJyb3IoJ3NpZ24gZmFpbGVkOiBrIGlzIHplcm8nKTsgLy8gRmFpbCBpZiBrJyA9IDAuXG4gIGNvbnN0IHsgYnl0ZXM6IHJ4LCBzY2FsYXI6IGsgfSA9IHNjaG5vcnJHZXRFeHRQdWJLZXkoa18pOyAvLyBMZXQgUiA9IGsnXHUyMkM1Ry5cbiAgY29uc3QgZSA9IGNoYWxsZW5nZShyeCwgcHgsIG0pOyAvLyBMZXQgZSA9IGludChoYXNoL2NoYWxsZW5nZShieXRlcyhSKSB8fCBieXRlcyhQKSB8fCBtKSkgbW9kIG4uXG4gIGNvbnN0IHNpZyA9IG5ldyBVaW50OEFycmF5KDY0KTsgLy8gTGV0IHNpZyA9IGJ5dGVzKFIpIHx8IGJ5dGVzKChrICsgZWQpIG1vZCBuKS5cbiAgc2lnLnNldChyeCwgMCk7XG4gIHNpZy5zZXQobnVtVG8zMmIobW9kTihrICsgZSAqIGQpKSwgMzIpO1xuICAvLyBJZiBWZXJpZnkoYnl0ZXMoUCksIG0sIHNpZykgKHNlZSBiZWxvdykgcmV0dXJucyBmYWlsdXJlLCBhYm9ydFxuICBpZiAoIXNjaG5vcnJWZXJpZnkoc2lnLCBtLCBweCkpIHRocm93IG5ldyBFcnJvcignc2lnbjogSW52YWxpZCBzaWduYXR1cmUgcHJvZHVjZWQnKTtcbiAgcmV0dXJuIHNpZztcbn1cblxuLyoqXG4gKiBWZXJpZmllcyBTY2hub3JyIHNpZ25hdHVyZS5cbiAqIFdpbGwgc3dhbGxvdyBlcnJvcnMgJiByZXR1cm4gZmFsc2UgZXhjZXB0IGZvciBpbml0aWFsIHR5cGUgdmFsaWRhdGlvbiBvZiBhcmd1bWVudHMuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJWZXJpZnkoc2lnbmF0dXJlOiBIZXgsIG1lc3NhZ2U6IEhleCwgcHVibGljS2V5OiBIZXgpOiBib29sZWFuIHtcbiAgY29uc3Qgc2lnID0gZW5zdXJlQnl0ZXMoJ3NpZ25hdHVyZScsIHNpZ25hdHVyZSwgNjQpO1xuICBjb25zdCBtID0gZW5zdXJlQnl0ZXMoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgY29uc3QgcHViID0gZW5zdXJlQnl0ZXMoJ3B1YmxpY0tleScsIHB1YmxpY0tleSwgMzIpO1xuICB0cnkge1xuICAgIGNvbnN0IFAgPSBsaWZ0X3goYnl0ZXNUb051bWJlckJFKHB1YikpOyAvLyBQID0gbGlmdF94KGludChwaykpOyBmYWlsIGlmIHRoYXQgZmFpbHNcbiAgICBjb25zdCByID0gYnl0ZXNUb051bWJlckJFKHNpZy5zdWJhcnJheSgwLCAzMikpOyAvLyBMZXQgciA9IGludChzaWdbMDozMl0pOyBmYWlsIGlmIHIgXHUyMjY1IHAuXG4gICAgaWYgKCFmZShyKSkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHMgPSBieXRlc1RvTnVtYmVyQkUoc2lnLnN1YmFycmF5KDMyLCA2NCkpOyAvLyBMZXQgcyA9IGludChzaWdbMzI6NjRdKTsgZmFpbCBpZiBzIFx1MjI2NSBuLlxuICAgIGlmICghZ2UocykpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBlID0gY2hhbGxlbmdlKG51bVRvMzJiKHIpLCBwb2ludFRvQnl0ZXMoUCksIG0pOyAvLyBpbnQoY2hhbGxlbmdlKGJ5dGVzKHIpfHxieXRlcyhQKXx8bSkpJW5cbiAgICBjb25zdCBSID0gR211bEFkZChQLCBzLCBtb2ROKC1lKSk7IC8vIFIgPSBzXHUyMkM1RyAtIGVcdTIyQzVQXG4gICAgaWYgKCFSIHx8ICFSLmhhc0V2ZW5ZKCkgfHwgUi50b0FmZmluZSgpLnggIT09IHIpIHJldHVybiBmYWxzZTsgLy8gLWVQID09IChuLWUpUFxuICAgIHJldHVybiB0cnVlOyAvLyBGYWlsIGlmIGlzX2luZmluaXRlKFIpIC8gbm90IGhhc19ldmVuX3koUikgLyB4KFIpIFx1MjI2MCByLlxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc2Nobm9yciA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gKHtcbiAgZ2V0UHVibGljS2V5OiBzY2hub3JyR2V0UHVibGljS2V5LFxuICBzaWduOiBzY2hub3JyU2lnbixcbiAgdmVyaWZ5OiBzY2hub3JyVmVyaWZ5LFxuICB1dGlsczoge1xuICAgIHJhbmRvbVByaXZhdGVLZXk6IHNlY3AyNTZrMS51dGlscy5yYW5kb21Qcml2YXRlS2V5LFxuICAgIGxpZnRfeCxcbiAgICBwb2ludFRvQnl0ZXMsXG4gICAgbnVtYmVyVG9CeXRlc0JFLFxuICAgIGJ5dGVzVG9OdW1iZXJCRSxcbiAgICB0YWdnZWRIYXNoLFxuICAgIG1vZCxcbiAgfSxcbn0pKSgpO1xuXG5jb25zdCBpc29NYXAgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+XG4gIGlzb2dlbnlNYXAoXG4gICAgRnAsXG4gICAgW1xuICAgICAgLy8geE51bVxuICAgICAgW1xuICAgICAgICAnMHg4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZGFhYWFhOGM3JyxcbiAgICAgICAgJzB4N2QzZDRjODBiYzMyMWQ1YjlmMzE1Y2VhN2ZkNDRjNWQ1OTVkMmZjMGJmNjNiOTJkZmZmMTA0NGYxN2M2NTgxJyxcbiAgICAgICAgJzB4NTM0YzMyOGQyM2YyMzRlNmUyYTQxM2RlY2EyNWNhZWNlNDUwNjE0NDAzN2M0MDMxNGVjYmQwYjUzZDlkZDI2MicsXG4gICAgICAgICcweDhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhkYWFhYWE4OGMnLFxuICAgICAgXSxcbiAgICAgIC8vIHhEZW5cbiAgICAgIFtcbiAgICAgICAgJzB4ZDM1NzcxMTkzZDk0OTE4YTljYTM0Y2NiYjdiNjQwZGQ4NmNkNDA5NTQyZjg0ODdkOWZlNmI3NDU3ODFlYjQ5YicsXG4gICAgICAgICcweGVkYWRjNmY2NDM4M2RjMWRmN2M0YjJkNTFiNTQyMjU0MDZkMzZiNjQxZjVlNDFiYmM1MmE1NjYxMmE4YzZkMTQnLFxuICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgLy8gTEFTVCAxXG4gICAgICBdLFxuICAgICAgLy8geU51bVxuICAgICAgW1xuICAgICAgICAnMHg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YjhlMzhlMjNjJyxcbiAgICAgICAgJzB4Yzc1ZTBjMzJkNWNiN2MwZmE5ZDBhNTRiMTJhMGE2ZDU2NDdhYjA0NmQ2ODZkYTZmZGZmYzkwZmMyMDFkNzFhMycsXG4gICAgICAgICcweDI5YTYxOTQ2OTFmOTFhNzM3MTUyMDllZjY1MTJlNTc2NzIyODMwYTIwMWJlMjAxOGE3NjVlODVhOWVjZWU5MzEnLFxuICAgICAgICAnMHgyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjM4ZTM4ZDg0JyxcbiAgICAgIF0sXG4gICAgICAvLyB5RGVuXG4gICAgICBbXG4gICAgICAgICcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmY5M2InLFxuICAgICAgICAnMHg3YTA2NTM0YmI4YmRiNDlmZDVlOWU2NjMyNzIyYzI5ODk0NjdjMWJmYzhlOGQ5NzhkZmI0MjVkMjY4NWMyNTczJyxcbiAgICAgICAgJzB4NjQ4NGFhNzE2NTQ1Y2EyY2YzYTcwYzNmYThmZTMzN2UwYTNkMjExNjJmMGQ2Mjk5YTdiZjgxOTJiZmQyYTc2ZicsXG4gICAgICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLCAvLyBMQVNUIDFcbiAgICAgIF0sXG4gICAgXS5tYXAoKGkpID0+IGkubWFwKChqKSA9PiBCaWdJbnQoaikpKSBhcyBbYmlnaW50W10sIGJpZ2ludFtdLCBiaWdpbnRbXSwgYmlnaW50W11dXG4gICkpKCk7XG5jb25zdCBtYXBTV1UgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+XG4gIG1hcFRvQ3VydmVTaW1wbGVTV1UoRnAsIHtcbiAgICBBOiBCaWdJbnQoJzB4M2Y4NzMxYWJkZDY2MWFkY2EwOGE1NTU4ZjBmNWQyNzJlOTUzZDM2M2NiNmYwZTVkNDA1NDQ3YzAxYTQ0NDUzMycpLFxuICAgIEI6IEJpZ0ludCgnMTc3MScpLFxuICAgIFo6IEZwLmNyZWF0ZShCaWdJbnQoJy0xMScpKSxcbiAgfSkpKCk7XG5jb25zdCBodGYgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+XG4gIGNyZWF0ZUhhc2hlcihcbiAgICBzZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LFxuICAgIChzY2FsYXJzOiBiaWdpbnRbXSkgPT4ge1xuICAgICAgY29uc3QgeyB4LCB5IH0gPSBtYXBTV1UoRnAuY3JlYXRlKHNjYWxhcnNbMF0pKTtcbiAgICAgIHJldHVybiBpc29NYXAoeCwgeSk7XG4gICAgfSxcbiAgICB7XG4gICAgICBEU1Q6ICdzZWNwMjU2azFfWE1EOlNIQS0yNTZfU1NXVV9ST18nLFxuICAgICAgZW5jb2RlRFNUOiAnc2VjcDI1NmsxX1hNRDpTSEEtMjU2X1NTV1VfTlVfJyxcbiAgICAgIHA6IEZwLk9SREVSLFxuICAgICAgbTogMSxcbiAgICAgIGs6IDEyOCxcbiAgICAgIGV4cGFuZDogJ3htZCcsXG4gICAgICBoYXNoOiBzaGEyNTYsXG4gICAgfVxuICApKSgpO1xuZXhwb3J0IGNvbnN0IGhhc2hUb0N1cnZlID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBodGYuaGFzaFRvQ3VydmUpKCk7XG5leHBvcnQgY29uc3QgZW5jb2RlVG9DdXJ2ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gaHRmLmVuY29kZVRvQ3VydmUpKCk7XG4iLCAiLy8gV2UgdXNlIFdlYkNyeXB0byBha2EgZ2xvYmFsVGhpcy5jcnlwdG8sIHdoaWNoIGV4aXN0cyBpbiBicm93c2VycyBhbmQgbm9kZS5qcyAxNisuXG4vLyBTZWUgdXRpbHMudHMgZm9yIGRldGFpbHMuXG5kZWNsYXJlIGNvbnN0IGdsb2JhbFRoaXM6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQ7XG5leHBvcnQgY29uc3QgY3J5cHRvID1cbiAgdHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnICYmICdjcnlwdG8nIGluIGdsb2JhbFRoaXMgPyBnbG9iYWxUaGlzLmNyeXB0byA6IHVuZGVmaW5lZDtcbiIsICIvKiEgbm9ibGUtaGFzaGVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5cbi8vIFdlIHVzZSBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gYnJvd3NlcnMgYW5kIG5vZGUuanMgMTYrLlxuLy8gbm9kZS5qcyB2ZXJzaW9ucyBlYXJsaWVyIHRoYW4gdjE5IGRvbid0IGRlY2xhcmUgaXQgaW4gZ2xvYmFsIHNjb3BlLlxuLy8gRm9yIG5vZGUuanMsIHBhY2thZ2UuanNvbiNleHBvcnRzIGZpZWxkIG1hcHBpbmcgcmV3cml0ZXMgaW1wb3J0XG4vLyBmcm9tIGBjcnlwdG9gIHRvIGBjcnlwdG9Ob2RlYCwgd2hpY2ggaW1wb3J0cyBuYXRpdmUgbW9kdWxlLlxuLy8gTWFrZXMgdGhlIHV0aWxzIHVuLWltcG9ydGFibGUgaW4gYnJvd3NlcnMgd2l0aG91dCBhIGJ1bmRsZXIuXG4vLyBPbmNlIG5vZGUuanMgMTggaXMgZGVwcmVjYXRlZCwgd2UgY2FuIGp1c3QgZHJvcCB0aGUgaW1wb3J0LlxuaW1wb3J0IHsgY3J5cHRvIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9jcnlwdG8nO1xuXG4vLyBwcmV0dGllci1pZ25vcmVcbmV4cG9ydCB0eXBlIFR5cGVkQXJyYXkgPSBJbnQ4QXJyYXkgfCBVaW50OENsYW1wZWRBcnJheSB8IFVpbnQ4QXJyYXkgfFxuICBVaW50MTZBcnJheSB8IEludDE2QXJyYXkgfCBVaW50MzJBcnJheSB8IEludDMyQXJyYXk7XG5cbmNvbnN0IHU4YSA9IChhOiBhbnkpOiBhIGlzIFVpbnQ4QXJyYXkgPT4gYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG4vLyBDYXN0IGFycmF5IHRvIGRpZmZlcmVudCB0eXBlXG5leHBvcnQgY29uc3QgdTggPSAoYXJyOiBUeXBlZEFycmF5KSA9PiBuZXcgVWludDhBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuZXhwb3J0IGNvbnN0IHUzMiA9IChhcnI6IFR5cGVkQXJyYXkpID0+XG4gIG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDQpKTtcblxuLy8gQ2FzdCBhcnJheSB0byB2aWV3XG5leHBvcnQgY29uc3QgY3JlYXRlVmlldyA9IChhcnI6IFR5cGVkQXJyYXkpID0+XG4gIG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuXG4vLyBUaGUgcm90YXRlIHJpZ2h0IChjaXJjdWxhciByaWdodCBzaGlmdCkgb3BlcmF0aW9uIGZvciB1aW50MzJcbmV4cG9ydCBjb25zdCByb3RyID0gKHdvcmQ6IG51bWJlciwgc2hpZnQ6IG51bWJlcikgPT4gKHdvcmQgPDwgKDMyIC0gc2hpZnQpKSB8ICh3b3JkID4+PiBzaGlmdCk7XG5cbi8vIGJpZy1lbmRpYW4gaGFyZHdhcmUgaXMgcmFyZS4gSnVzdCBpbiBjYXNlIHNvbWVvbmUgc3RpbGwgZGVjaWRlcyB0byBydW4gaGFzaGVzOlxuLy8gZWFybHktdGhyb3cgYW4gZXJyb3IgYmVjYXVzZSB3ZSBkb24ndCBzdXBwb3J0IEJFIHlldC5cbmV4cG9ydCBjb25zdCBpc0xFID0gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQzMkFycmF5KFsweDExMjIzMzQ0XSkuYnVmZmVyKVswXSA9PT0gMHg0NDtcbmlmICghaXNMRSkgdGhyb3cgbmV3IEVycm9yKCdOb24gbGl0dGxlLWVuZGlhbiBoYXJkd2FyZSBpcyBub3Qgc3VwcG9ydGVkJyk7XG5cbmNvbnN0IGhleGVzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sICh2LCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlczogVWludDhBcnJheSk6IHN0cmluZyB7XG4gIGlmICghdThhKGJ5dGVzKSkgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICBsZXQgaGV4ID0gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBoZXggKz0gaGV4ZXNbYnl0ZXNbaV1dO1xuICB9XG4gIHJldHVybiBoZXg7XG59XG5cbi8qKlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXg6IHN0cmluZyk6IFVpbnQ4QXJyYXkge1xuICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgY29uc3QgbGVuID0gaGV4Lmxlbmd0aDtcbiAgaWYgKGxlbiAlIDIpIHRocm93IG5ldyBFcnJvcigncGFkZGVkIGhleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoICcgKyBsZW4pO1xuICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGxlbiAvIDIpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgaiA9IGkgKiAyO1xuICAgIGNvbnN0IGhleEJ5dGUgPSBoZXguc2xpY2UoaiwgaiArIDIpO1xuICAgIGNvbnN0IGJ5dGUgPSBOdW1iZXIucGFyc2VJbnQoaGV4Qnl0ZSwgMTYpO1xuICAgIGlmIChOdW1iZXIuaXNOYU4oYnl0ZSkgfHwgYnl0ZSA8IDApIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBieXRlIHNlcXVlbmNlJyk7XG4gICAgYXJyYXlbaV0gPSBieXRlO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuLy8gVGhlcmUgaXMgbm8gc2V0SW1tZWRpYXRlIGluIGJyb3dzZXIgYW5kIHNldFRpbWVvdXQgaXMgc2xvdy5cbi8vIGNhbGwgb2YgYXN5bmMgZm4gd2lsbCByZXR1cm4gUHJvbWlzZSwgd2hpY2ggd2lsbCBiZSBmdWxsZmlsZWQgb25seSBvblxuLy8gbmV4dCBzY2hlZHVsZXIgcXVldWUgcHJvY2Vzc2luZyBzdGVwIGFuZCB0aGlzIGlzIGV4YWN0bHkgd2hhdCB3ZSBuZWVkLlxuZXhwb3J0IGNvbnN0IG5leHRUaWNrID0gYXN5bmMgKCkgPT4ge307XG5cbi8vIFJldHVybnMgY29udHJvbCB0byB0aHJlYWQgZWFjaCAndGljaycgbXMgdG8gYXZvaWQgYmxvY2tpbmdcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3luY0xvb3AoaXRlcnM6IG51bWJlciwgdGljazogbnVtYmVyLCBjYjogKGk6IG51bWJlcikgPT4gdm9pZCkge1xuICBsZXQgdHMgPSBEYXRlLm5vdygpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJzOyBpKyspIHtcbiAgICBjYihpKTtcbiAgICAvLyBEYXRlLm5vdygpIGlzIG5vdCBtb25vdG9uaWMsIHNvIGluIGNhc2UgaWYgY2xvY2sgZ29lcyBiYWNrd2FyZHMgd2UgcmV0dXJuIHJldHVybiBjb250cm9sIHRvb1xuICAgIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gdHM7XG4gICAgaWYgKGRpZmYgPj0gMCAmJiBkaWZmIDwgdGljaykgY29udGludWU7XG4gICAgYXdhaXQgbmV4dFRpY2soKTtcbiAgICB0cyArPSBkaWZmO1xuICB9XG59XG5cbi8vIEdsb2JhbCBzeW1ib2xzIGluIGJvdGggYnJvd3NlcnMgYW5kIE5vZGUuanMgc2luY2UgdjExXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8zMTUzNVxuZGVjbGFyZSBjb25zdCBUZXh0RW5jb2RlcjogYW55O1xuXG4vKipcbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHI6IHN0cmluZyk6IFVpbnQ4QXJyYXkge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBFcnJvcihgdXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc3RyfWApO1xuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG5cbmV4cG9ydCB0eXBlIElucHV0ID0gVWludDhBcnJheSB8IHN0cmluZztcbi8qKlxuICogTm9ybWFsaXplcyAobm9uLWhleCkgc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gVWludDhBcnJheS5cbiAqIFdhcm5pbmc6IHdoZW4gVWludDhBcnJheSBpcyBwYXNzZWQsIGl0IHdvdWxkIE5PVCBnZXQgY29waWVkLlxuICogS2VlcCBpbiBtaW5kIGZvciBmdXR1cmUgbXV0YWJsZSBvcGVyYXRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CeXRlcyhkYXRhOiBJbnB1dCk6IFVpbnQ4QXJyYXkge1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSBkYXRhID0gdXRmOFRvQnl0ZXMoZGF0YSk7XG4gIGlmICghdThhKGRhdGEpKSB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIFVpbnQ4QXJyYXksIGdvdCAke3R5cGVvZiBkYXRhfWApO1xuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBDb3BpZXMgc2V2ZXJhbCBVaW50OEFycmF5cyBpbnRvIG9uZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5czogVWludDhBcnJheVtdKTogVWludDhBcnJheSB7XG4gIGNvbnN0IHIgPSBuZXcgVWludDhBcnJheShhcnJheXMucmVkdWNlKChzdW0sIGEpID0+IHN1bSArIGEubGVuZ3RoLCAwKSk7XG4gIGxldCBwYWQgPSAwOyAvLyB3YWxrIHRocm91Z2ggZWFjaCBpdGVtLCBlbnN1cmUgdGhleSBoYXZlIHByb3BlciB0eXBlXG4gIGFycmF5cy5mb3JFYWNoKChhKSA9PiB7XG4gICAgaWYgKCF1OGEoYSkpIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIHIuc2V0KGEsIHBhZCk7XG4gICAgcGFkICs9IGEubGVuZ3RoO1xuICB9KTtcbiAgcmV0dXJuIHI7XG59XG5cbi8vIEZvciBydW50aW1lIGNoZWNrIGlmIGNsYXNzIGltcGxlbWVudHMgaW50ZXJmYWNlXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgSGFzaDxUIGV4dGVuZHMgSGFzaDxUPj4ge1xuICBhYnN0cmFjdCBibG9ja0xlbjogbnVtYmVyOyAvLyBCeXRlcyBwZXIgYmxvY2tcbiAgYWJzdHJhY3Qgb3V0cHV0TGVuOiBudW1iZXI7IC8vIEJ5dGVzIGluIG91dHB1dFxuICBhYnN0cmFjdCB1cGRhdGUoYnVmOiBJbnB1dCk6IHRoaXM7XG4gIC8vIFdyaXRlcyBkaWdlc3QgaW50byBidWZcbiAgYWJzdHJhY3QgZGlnZXN0SW50byhidWY6IFVpbnQ4QXJyYXkpOiB2b2lkO1xuICBhYnN0cmFjdCBkaWdlc3QoKTogVWludDhBcnJheTtcbiAgLyoqXG4gICAqIFJlc2V0cyBpbnRlcm5hbCBzdGF0ZS4gTWFrZXMgSGFzaCBpbnN0YW5jZSB1bnVzYWJsZS5cbiAgICogUmVzZXQgaXMgaW1wb3NzaWJsZSBmb3Iga2V5ZWQgaGFzaGVzIGlmIGtleSBpcyBjb25zdW1lZCBpbnRvIHN0YXRlLiBJZiBkaWdlc3QgaXMgbm90IGNvbnN1bWVkXG4gICAqIGJ5IHVzZXIsIHRoZXkgd2lsbCBuZWVkIHRvIG1hbnVhbGx5IGNhbGwgYGRlc3Ryb3koKWAgd2hlbiB6ZXJvaW5nIGlzIG5lY2Vzc2FyeS5cbiAgICovXG4gIGFic3RyYWN0IGRlc3Ryb3koKTogdm9pZDtcbiAgLyoqXG4gICAqIENsb25lcyBoYXNoIGluc3RhbmNlLiBVbnNhZmU6IGRvZXNuJ3QgY2hlY2sgd2hldGhlciBgdG9gIGlzIHZhbGlkLiBDYW4gYmUgdXNlZCBhcyBgY2xvbmUoKWBcbiAgICogd2hlbiBubyBvcHRpb25zIGFyZSBwYXNzZWQuXG4gICAqIFJlYXNvbnMgdG8gdXNlIGBfY2xvbmVJbnRvYCBpbnN0ZWFkIG9mIGNsb25lOiAxKSBwZXJmb3JtYW5jZSAyKSByZXVzZSBpbnN0YW5jZSA9PiBhbGwgaW50ZXJuYWxcbiAgICogYnVmZmVycyBhcmUgb3ZlcndyaXR0ZW4gPT4gY2F1c2VzIGJ1ZmZlciBvdmVyd3JpdGUgd2hpY2ggaXMgdXNlZCBmb3IgZGlnZXN0IGluIHNvbWUgY2FzZXMuXG4gICAqIFRoZXJlIGFyZSBubyBndWFyYW50ZWVzIGZvciBjbGVhbi11cCBiZWNhdXNlIGl0J3MgaW1wb3NzaWJsZSBpbiBKUy5cbiAgICovXG4gIGFic3RyYWN0IF9jbG9uZUludG8odG8/OiBUKTogVDtcbiAgLy8gU2FmZSB2ZXJzaW9uIHRoYXQgY2xvbmVzIGludGVybmFsIHN0YXRlXG4gIGNsb25lKCk6IFQge1xuICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcbiAgfVxufVxuXG4vKipcbiAqIFhPRjogc3RyZWFtaW5nIEFQSSB0byByZWFkIGRpZ2VzdCBpbiBjaHVua3MuXG4gKiBTYW1lIGFzICdzcXVlZXplJyBpbiBrZWNjYWsvazEyIGFuZCAnc2VlaycgaW4gYmxha2UzLCBidXQgbW9yZSBnZW5lcmljIG5hbWUuXG4gKiBXaGVuIGhhc2ggdXNlZCBpbiBYT0YgbW9kZSBpdCBpcyB1cCB0byB1c2VyIHRvIGNhbGwgJy5kZXN0cm95JyBhZnRlcndhcmRzLCBzaW5jZSB3ZSBjYW5ub3RcbiAqIGRlc3Ryb3kgc3RhdGUsIG5leHQgY2FsbCBjYW4gcmVxdWlyZSBtb3JlIGJ5dGVzLlxuICovXG5leHBvcnQgdHlwZSBIYXNoWE9GPFQgZXh0ZW5kcyBIYXNoPFQ+PiA9IEhhc2g8VD4gJiB7XG4gIHhvZihieXRlczogbnVtYmVyKTogVWludDhBcnJheTsgLy8gUmVhZCAnYnl0ZXMnIGJ5dGVzIGZyb20gZGlnZXN0IHN0cmVhbVxuICB4b2ZJbnRvKGJ1ZjogVWludDhBcnJheSk6IFVpbnQ4QXJyYXk7IC8vIHJlYWQgYnVmLmxlbmd0aCBieXRlcyBmcm9tIGRpZ2VzdCBzdHJlYW0gaW50byBidWZcbn07XG5cbi8vIENoZWNrIGlmIG9iamVjdCBkb2Vucyd0IGhhdmUgY3VzdG9tIGNvbnN0cnVjdG9yIChsaWtlIFVpbnQ4QXJyYXkvQXJyYXkpXG5jb25zdCBpc1BsYWluT2JqZWN0ID0gKG9iajogYW55KSA9PlxuICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG5cbnR5cGUgRW1wdHlPYmogPSB7fTtcbmV4cG9ydCBmdW5jdGlvbiBjaGVja09wdHM8VDEgZXh0ZW5kcyBFbXB0eU9iaiwgVDIgZXh0ZW5kcyBFbXB0eU9iaj4oXG4gIGRlZmF1bHRzOiBUMSxcbiAgb3B0cz86IFQyXG4pOiBUMSAmIFQyIHtcbiAgaWYgKG9wdHMgIT09IHVuZGVmaW5lZCAmJiAodHlwZW9mIG9wdHMgIT09ICdvYmplY3QnIHx8ICFpc1BsYWluT2JqZWN0KG9wdHMpKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCBvciB1bmRlZmluZWQnKTtcbiAgY29uc3QgbWVyZ2VkID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0cywgb3B0cyk7XG4gIHJldHVybiBtZXJnZWQgYXMgVDEgJiBUMjtcbn1cblxuZXhwb3J0IHR5cGUgQ0hhc2ggPSBSZXR1cm5UeXBlPHR5cGVvZiB3cmFwQ29uc3RydWN0b3I+O1xuXG5leHBvcnQgZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yPFQgZXh0ZW5kcyBIYXNoPFQ+PihoYXNoQ29uczogKCkgPT4gSGFzaDxUPikge1xuICBjb25zdCBoYXNoQyA9IChtc2c6IElucHV0KTogVWludDhBcnJheSA9PiBoYXNoQ29ucygpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICBjb25zdCB0bXAgPSBoYXNoQ29ucygpO1xuICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgaGFzaEMuY3JlYXRlID0gKCkgPT4gaGFzaENvbnMoKTtcbiAgcmV0dXJuIGhhc2hDO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yV2l0aE9wdHM8SCBleHRlbmRzIEhhc2g8SD4sIFQgZXh0ZW5kcyBPYmplY3Q+KFxuICBoYXNoQ29uczogKG9wdHM/OiBUKSA9PiBIYXNoPEg+XG4pIHtcbiAgY29uc3QgaGFzaEMgPSAobXNnOiBJbnB1dCwgb3B0cz86IFQpOiBVaW50OEFycmF5ID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSBhcyBUKTtcbiAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gIGhhc2hDLmNyZWF0ZSA9IChvcHRzOiBUKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgcmV0dXJuIGhhc2hDO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHM8SCBleHRlbmRzIEhhc2hYT0Y8SD4sIFQgZXh0ZW5kcyBPYmplY3Q+KFxuICBoYXNoQ29uczogKG9wdHM/OiBUKSA9PiBIYXNoWE9GPEg+XG4pIHtcbiAgY29uc3QgaGFzaEMgPSAobXNnOiBJbnB1dCwgb3B0cz86IFQpOiBVaW50OEFycmF5ID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSBhcyBUKTtcbiAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gIGhhc2hDLmNyZWF0ZSA9IChvcHRzOiBUKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgcmV0dXJuIGhhc2hDO1xufVxuXG4vKipcbiAqIFNlY3VyZSBQUk5HLiBVc2VzIGBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzYCwgd2hpY2ggZGVmZXJzIHRvIE9TLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGggPSAzMik6IFVpbnQ4QXJyYXkge1xuICBpZiAoY3J5cHRvICYmIHR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXNMZW5ndGgpKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMgbXVzdCBiZSBkZWZpbmVkJyk7XG59XG4iLCAiZXhwb3J0IGZ1bmN0aW9uIG51bWJlcihuOiBudW1iZXIpIHtcbiAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSB8fCBuIDwgMCkgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBwb3NpdGl2ZSBpbnRlZ2VyOiAke259YCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBib29sKGI6IGJvb2xlYW4pIHtcbiAgaWYgKHR5cGVvZiBiICE9PSAnYm9vbGVhbicpIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYm9vbGVhbiwgbm90ICR7Yn1gKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzKGI6IFVpbnQ4QXJyYXkgfCB1bmRlZmluZWQsIC4uLmxlbmd0aHM6IG51bWJlcltdKSB7XG4gIGlmICghKGIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBVaW50OEFycmF5Jyk7XG4gIGlmIChsZW5ndGhzLmxlbmd0aCA+IDAgJiYgIWxlbmd0aHMuaW5jbHVkZXMoYi5sZW5ndGgpKVxuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgVWludDhBcnJheSBvZiBsZW5ndGggJHtsZW5ndGhzfSwgbm90IG9mIGxlbmd0aD0ke2IubGVuZ3RofWApO1xufVxuXG50eXBlIEhhc2ggPSB7XG4gIChkYXRhOiBVaW50OEFycmF5KTogVWludDhBcnJheTtcbiAgYmxvY2tMZW46IG51bWJlcjtcbiAgb3V0cHV0TGVuOiBudW1iZXI7XG4gIGNyZWF0ZTogYW55O1xufTtcbmV4cG9ydCBmdW5jdGlvbiBoYXNoKGhhc2g6IEhhc2gpIHtcbiAgaWYgKHR5cGVvZiBoYXNoICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBoYXNoLmNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggc2hvdWxkIGJlIHdyYXBwZWQgYnkgdXRpbHMud3JhcENvbnN0cnVjdG9yJyk7XG4gIG51bWJlcihoYXNoLm91dHB1dExlbik7XG4gIG51bWJlcihoYXNoLmJsb2NrTGVuKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4aXN0cyhpbnN0YW5jZTogYW55LCBjaGVja0ZpbmlzaGVkID0gdHJ1ZSkge1xuICBpZiAoaW5zdGFuY2UuZGVzdHJveWVkKSB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkJyk7XG4gIGlmIChjaGVja0ZpbmlzaGVkICYmIGluc3RhbmNlLmZpbmlzaGVkKSB0aHJvdyBuZXcgRXJyb3IoJ0hhc2gjZGlnZXN0KCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQnKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBvdXRwdXQob3V0OiBhbnksIGluc3RhbmNlOiBhbnkpIHtcbiAgYnl0ZXMob3V0KTtcbiAgY29uc3QgbWluID0gaW5zdGFuY2Uub3V0cHV0TGVuO1xuICBpZiAob3V0Lmxlbmd0aCA8IG1pbikge1xuICAgIHRocm93IG5ldyBFcnJvcihgZGlnZXN0SW50bygpIGV4cGVjdHMgb3V0cHV0IGJ1ZmZlciBvZiBsZW5ndGggYXQgbGVhc3QgJHttaW59YCk7XG4gIH1cbn1cblxuY29uc3QgYXNzZXJ0ID0ge1xuICBudW1iZXIsXG4gIGJvb2wsXG4gIGJ5dGVzLFxuICBoYXNoLFxuICBleGlzdHMsXG4gIG91dHB1dCxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGFzc2VydDtcbiIsICJpbXBvcnQgYXNzZXJ0IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBIYXNoLCBjcmVhdGVWaWV3LCBJbnB1dCwgdG9CeXRlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuXG4vLyBQb2x5ZmlsbCBmb3IgU2FmYXJpIDE0XG5mdW5jdGlvbiBzZXRCaWdVaW50NjQodmlldzogRGF0YVZpZXcsIGJ5dGVPZmZzZXQ6IG51bWJlciwgdmFsdWU6IGJpZ2ludCwgaXNMRTogYm9vbGVhbik6IHZvaWQge1xuICBpZiAodHlwZW9mIHZpZXcuc2V0QmlnVWludDY0ID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdmlldy5zZXRCaWdVaW50NjQoYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpO1xuICBjb25zdCBfMzJuID0gQmlnSW50KDMyKTtcbiAgY29uc3QgX3UzMl9tYXggPSBCaWdJbnQoMHhmZmZmZmZmZik7XG4gIGNvbnN0IHdoID0gTnVtYmVyKCh2YWx1ZSA+PiBfMzJuKSAmIF91MzJfbWF4KTtcbiAgY29uc3Qgd2wgPSBOdW1iZXIodmFsdWUgJiBfdTMyX21heCk7XG4gIGNvbnN0IGggPSBpc0xFID8gNCA6IDA7XG4gIGNvbnN0IGwgPSBpc0xFID8gMCA6IDQ7XG4gIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBoLCB3aCwgaXNMRSk7XG4gIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBsLCB3bCwgaXNMRSk7XG59XG5cbi8vIEJhc2UgU0hBMiBjbGFzcyAoUkZDIDYyMzQpXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU0hBMjxUIGV4dGVuZHMgU0hBMjxUPj4gZXh0ZW5kcyBIYXNoPFQ+IHtcbiAgcHJvdGVjdGVkIGFic3RyYWN0IHByb2Nlc3MoYnVmOiBEYXRhVmlldywgb2Zmc2V0OiBudW1iZXIpOiB2b2lkO1xuICBwcm90ZWN0ZWQgYWJzdHJhY3QgZ2V0KCk6IG51bWJlcltdO1xuICBwcm90ZWN0ZWQgYWJzdHJhY3Qgc2V0KC4uLmFyZ3M6IG51bWJlcltdKTogdm9pZDtcbiAgYWJzdHJhY3QgZGVzdHJveSgpOiB2b2lkO1xuICBwcm90ZWN0ZWQgYWJzdHJhY3Qgcm91bmRDbGVhbigpOiB2b2lkO1xuICAvLyBGb3IgcGFydGlhbCB1cGRhdGVzIGxlc3MgdGhhbiBibG9jayBzaXplXG4gIHByb3RlY3RlZCBidWZmZXI6IFVpbnQ4QXJyYXk7XG4gIHByb3RlY3RlZCB2aWV3OiBEYXRhVmlldztcbiAgcHJvdGVjdGVkIGZpbmlzaGVkID0gZmFsc2U7XG4gIHByb3RlY3RlZCBsZW5ndGggPSAwO1xuICBwcm90ZWN0ZWQgcG9zID0gMDtcbiAgcHJvdGVjdGVkIGRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHJlYWRvbmx5IGJsb2NrTGVuOiBudW1iZXIsXG4gICAgcHVibGljIG91dHB1dExlbjogbnVtYmVyLFxuICAgIHJlYWRvbmx5IHBhZE9mZnNldDogbnVtYmVyLFxuICAgIHJlYWRvbmx5IGlzTEU6IGJvb2xlYW5cbiAgKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICB0aGlzLnZpZXcgPSBjcmVhdGVWaWV3KHRoaXMuYnVmZmVyKTtcbiAgfVxuICB1cGRhdGUoZGF0YTogSW5wdXQpOiB0aGlzIHtcbiAgICBhc3NlcnQuZXhpc3RzKHRoaXMpO1xuICAgIGNvbnN0IHsgdmlldywgYnVmZmVyLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICBkYXRhID0gdG9CeXRlcyhkYXRhKTtcbiAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47ICkge1xuICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAvLyBGYXN0IHBhdGg6IHdlIGhhdmUgYXQgbGVhc3Qgb25lIGJsb2NrIGluIGlucHV0LCBjYXN0IGl0IHRvIHZpZXcgYW5kIHByb2Nlc3NcbiAgICAgIGlmICh0YWtlID09PSBibG9ja0xlbikge1xuICAgICAgICBjb25zdCBkYXRhVmlldyA9IGNyZWF0ZVZpZXcoZGF0YSk7XG4gICAgICAgIGZvciAoOyBibG9ja0xlbiA8PSBsZW4gLSBwb3M7IHBvcyArPSBibG9ja0xlbikgdGhpcy5wcm9jZXNzKGRhdGFWaWV3LCBwb3MpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJ1ZmZlci5zZXQoZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIHRha2UpLCB0aGlzLnBvcyk7XG4gICAgICB0aGlzLnBvcyArPSB0YWtlO1xuICAgICAgcG9zICs9IHRha2U7XG4gICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmxlbmd0aCArPSBkYXRhLmxlbmd0aDtcbiAgICB0aGlzLnJvdW5kQ2xlYW4oKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBkaWdlc3RJbnRvKG91dDogVWludDhBcnJheSkge1xuICAgIGFzc2VydC5leGlzdHModGhpcyk7XG4gICAgYXNzZXJ0Lm91dHB1dChvdXQsIHRoaXMpO1xuICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgIC8vIFBhZGRpbmdcbiAgICAvLyBXZSBjYW4gYXZvaWQgYWxsb2NhdGlvbiBvZiBidWZmZXIgZm9yIHBhZGRpbmcgY29tcGxldGVseSBpZiBpdFxuICAgIC8vIHdhcyBwcmV2aW91c2x5IG5vdCBhbGxvY2F0ZWQgaGVyZS4gQnV0IGl0IHdvbid0IGNoYW5nZSBwZXJmb3JtYW5jZS5cbiAgICBjb25zdCB7IGJ1ZmZlciwgdmlldywgYmxvY2tMZW4sIGlzTEUgfSA9IHRoaXM7XG4gICAgbGV0IHsgcG9zIH0gPSB0aGlzO1xuICAgIC8vIGFwcGVuZCB0aGUgYml0ICcxJyB0byB0aGUgbWVzc2FnZVxuICAgIGJ1ZmZlcltwb3MrK10gPSAwYjEwMDAwMDAwO1xuICAgIHRoaXMuYnVmZmVyLnN1YmFycmF5KHBvcykuZmlsbCgwKTtcbiAgICAvLyB3ZSBoYXZlIGxlc3MgdGhhbiBwYWRPZmZzZXQgbGVmdCBpbiBidWZmZXIsIHNvIHdlIGNhbm5vdCBwdXQgbGVuZ3RoIGluIGN1cnJlbnQgYmxvY2ssIG5lZWQgcHJvY2VzcyBpdCBhbmQgcGFkIGFnYWluXG4gICAgaWYgKHRoaXMucGFkT2Zmc2V0ID4gYmxvY2tMZW4gLSBwb3MpIHtcbiAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgIHBvcyA9IDA7XG4gICAgfVxuICAgIC8vIFBhZCB1bnRpbCBmdWxsIGJsb2NrIGJ5dGUgd2l0aCB6ZXJvc1xuICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBibG9ja0xlbjsgaSsrKSBidWZmZXJbaV0gPSAwO1xuICAgIC8vIE5vdGU6IHNoYTUxMiByZXF1aXJlcyBsZW5ndGggdG8gYmUgMTI4Yml0IGludGVnZXIsIGJ1dCBsZW5ndGggaW4gSlMgd2lsbCBvdmVyZmxvdyBiZWZvcmUgdGhhdFxuICAgIC8vIFlvdSBuZWVkIHRvIHdyaXRlIGFyb3VuZCAyIGV4YWJ5dGVzICh1NjRfbWF4IC8gOCAvICgxMDI0Kio2KSkgZm9yIHRoaXMgdG8gaGFwcGVuLlxuICAgIC8vIFNvIHdlIGp1c3Qgd3JpdGUgbG93ZXN0IDY0IGJpdHMgb2YgdGhhdCB2YWx1ZS5cbiAgICBzZXRCaWdVaW50NjQodmlldywgYmxvY2tMZW4gLSA4LCBCaWdJbnQodGhpcy5sZW5ndGggKiA4KSwgaXNMRSk7XG4gICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgIGNvbnN0IG92aWV3ID0gY3JlYXRlVmlldyhvdXQpO1xuICAgIGNvbnN0IGxlbiA9IHRoaXMub3V0cHV0TGVuO1xuICAgIC8vIE5PVEU6IHdlIGRvIGRpdmlzaW9uIGJ5IDQgbGF0ZXIsIHdoaWNoIHNob3VsZCBiZSBmdXNlZCBpbiBzaW5nbGUgb3Agd2l0aCBtb2R1bG8gYnkgSklUXG4gICAgaWYgKGxlbiAlIDQpIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBzaG91bGQgYmUgYWxpZ25lZCB0byAzMmJpdCcpO1xuICAgIGNvbnN0IG91dExlbiA9IGxlbiAvIDQ7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldCgpO1xuICAgIGlmIChvdXRMZW4gPiBzdGF0ZS5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBiaWdnZXIgdGhhbiBzdGF0ZScpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0TGVuOyBpKyspIG92aWV3LnNldFVpbnQzMig0ICogaSwgc3RhdGVbaV0sIGlzTEUpO1xuICB9XG4gIGRpZ2VzdCgpIHtcbiAgICBjb25zdCB7IGJ1ZmZlciwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgIHRoaXMuZGlnZXN0SW50byhidWZmZXIpO1xuICAgIGNvbnN0IHJlcyA9IGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRMZW4pO1xuICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIHJldHVybiByZXM7XG4gIH1cbiAgX2Nsb25lSW50byh0bz86IFQpOiBUIHtcbiAgICB0byB8fD0gbmV3ICh0aGlzLmNvbnN0cnVjdG9yIGFzIGFueSkoKSBhcyBUO1xuICAgIHRvLnNldCguLi50aGlzLmdldCgpKTtcbiAgICBjb25zdCB7IGJsb2NrTGVuLCBidWZmZXIsIGxlbmd0aCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgcG9zIH0gPSB0aGlzO1xuICAgIHRvLmxlbmd0aCA9IGxlbmd0aDtcbiAgICB0by5wb3MgPSBwb3M7XG4gICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgaWYgKGxlbmd0aCAlIGJsb2NrTGVuKSB0by5idWZmZXIuc2V0KGJ1ZmZlcik7XG4gICAgcmV0dXJuIHRvO1xuICB9XG59XG4iLCAiaW1wb3J0IHsgU0hBMiB9IGZyb20gJy4vX3NoYTIuanMnO1xuaW1wb3J0IHsgcm90ciwgd3JhcENvbnN0cnVjdG9yIH0gZnJvbSAnLi91dGlscy5qcyc7XG5cbi8vIENob2ljZTogYSA/IGIgOiBjXG5jb25zdCBDaGkgPSAoYTogbnVtYmVyLCBiOiBudW1iZXIsIGM6IG51bWJlcikgPT4gKGEgJiBiKSBeICh+YSAmIGMpO1xuLy8gTWFqb3JpdHkgZnVuY3Rpb24sIHRydWUgaWYgYW55IHR3byBpbnB1c3QgaXMgdHJ1ZVxuY29uc3QgTWFqID0gKGE6IG51bWJlciwgYjogbnVtYmVyLCBjOiBudW1iZXIpID0+IChhICYgYikgXiAoYSAmIGMpIF4gKGIgJiBjKTtcblxuLy8gUm91bmQgY29uc3RhbnRzOlxuLy8gZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgY3ViZSByb290cyBvZiB0aGUgZmlyc3QgNjQgcHJpbWVzIDIuLjMxMSlcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgU0hBMjU2X0sgPSBuZXcgVWludDMyQXJyYXkoW1xuICAweDQyOGEyZjk4LCAweDcxMzc0NDkxLCAweGI1YzBmYmNmLCAweGU5YjVkYmE1LCAweDM5NTZjMjViLCAweDU5ZjExMWYxLCAweDkyM2Y4MmE0LCAweGFiMWM1ZWQ1LFxuICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLCAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAweGU0OWI2OWMxLCAweGVmYmU0Nzg2LCAweDBmYzE5ZGM2LCAweDI0MGNhMWNjLCAweDJkZTkyYzZmLCAweDRhNzQ4NGFhLCAweDVjYjBhOWRjLCAweDc2Zjk4OGRhLFxuICAweDk4M2U1MTUyLCAweGE4MzFjNjZkLCAweGIwMDMyN2M4LCAweGJmNTk3ZmM3LCAweGM2ZTAwYmYzLCAweGQ1YTc5MTQ3LCAweDA2Y2E2MzUxLCAweDE0MjkyOTY3LFxuICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLCAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAweGEyYmZlOGExLCAweGE4MWE2NjRiLCAweGMyNGI4YjcwLCAweGM3NmM1MWEzLCAweGQxOTJlODE5LCAweGQ2OTkwNjI0LCAweGY0MGUzNTg1LCAweDEwNmFhMDcwLFxuICAweDE5YTRjMTE2LCAweDFlMzc2YzA4LCAweDI3NDg3NzRjLCAweDM0YjBiY2I1LCAweDM5MWMwY2IzLCAweDRlZDhhYTRhLCAweDViOWNjYTRmLCAweDY4MmU2ZmYzLFxuICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LCAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5dKTtcblxuLy8gSW5pdGlhbCBzdGF0ZSAoZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgc3F1YXJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4IHByaW1lcyAyLi4xOSk6XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IElWID0gbmV3IFVpbnQzMkFycmF5KFtcbiAgMHg2YTA5ZTY2NywgMHhiYjY3YWU4NSwgMHgzYzZlZjM3MiwgMHhhNTRmZjUzYSwgMHg1MTBlNTI3ZiwgMHg5YjA1Njg4YywgMHgxZjgzZDlhYiwgMHg1YmUwY2QxOVxuXSk7XG5cbi8vIFRlbXBvcmFyeSBidWZmZXIsIG5vdCB1c2VkIHRvIHN0b3JlIGFueXRoaW5nIGJldHdlZW4gcnVuc1xuLy8gTmFtZWQgdGhpcyB3YXkgYmVjYXVzZSBpdCBtYXRjaGVzIHNwZWNpZmljYXRpb24uXG5jb25zdCBTSEEyNTZfVyA9IG5ldyBVaW50MzJBcnJheSg2NCk7XG5jbGFzcyBTSEEyNTYgZXh0ZW5kcyBTSEEyPFNIQTI1Nj4ge1xuICAvLyBXZSBjYW5ub3QgdXNlIGFycmF5IGhlcmUgc2luY2UgYXJyYXkgYWxsb3dzIGluZGV4aW5nIGJ5IHZhcmlhYmxlXG4gIC8vIHdoaWNoIG1lYW5zIG9wdGltaXplci9jb21waWxlciBjYW5ub3QgdXNlIHJlZ2lzdGVycy5cbiAgQSA9IElWWzBdIHwgMDtcbiAgQiA9IElWWzFdIHwgMDtcbiAgQyA9IElWWzJdIHwgMDtcbiAgRCA9IElWWzNdIHwgMDtcbiAgRSA9IElWWzRdIHwgMDtcbiAgRiA9IElWWzVdIHwgMDtcbiAgRyA9IElWWzZdIHwgMDtcbiAgSCA9IElWWzddIHwgMDtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcig2NCwgMzIsIDgsIGZhbHNlKTtcbiAgfVxuICBwcm90ZWN0ZWQgZ2V0KCk6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0ge1xuICAgIGNvbnN0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcbiAgICByZXR1cm4gW0EsIEIsIEMsIEQsIEUsIEYsIEcsIEhdO1xuICB9XG4gIC8vIHByZXR0aWVyLWlnbm9yZVxuICBwcm90ZWN0ZWQgc2V0KFxuICAgIEE6IG51bWJlciwgQjogbnVtYmVyLCBDOiBudW1iZXIsIEQ6IG51bWJlciwgRTogbnVtYmVyLCBGOiBudW1iZXIsIEc6IG51bWJlciwgSDogbnVtYmVyXG4gICkge1xuICAgIHRoaXMuQSA9IEEgfCAwO1xuICAgIHRoaXMuQiA9IEIgfCAwO1xuICAgIHRoaXMuQyA9IEMgfCAwO1xuICAgIHRoaXMuRCA9IEQgfCAwO1xuICAgIHRoaXMuRSA9IEUgfCAwO1xuICAgIHRoaXMuRiA9IEYgfCAwO1xuICAgIHRoaXMuRyA9IEcgfCAwO1xuICAgIHRoaXMuSCA9IEggfCAwO1xuICB9XG4gIHByb3RlY3RlZCBwcm9jZXNzKHZpZXc6IERhdGFWaWV3LCBvZmZzZXQ6IG51bWJlcik6IHZvaWQge1xuICAgIC8vIEV4dGVuZCB0aGUgZmlyc3QgMTYgd29yZHMgaW50byB0aGUgcmVtYWluaW5nIDQ4IHdvcmRzIHdbMTYuLjYzXSBvZiB0aGUgbWVzc2FnZSBzY2hlZHVsZSBhcnJheVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpIFNIQTI1Nl9XW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0LCBmYWxzZSk7XG4gICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgNjQ7IGkrKykge1xuICAgICAgY29uc3QgVzE1ID0gU0hBMjU2X1dbaSAtIDE1XTtcbiAgICAgIGNvbnN0IFcyID0gU0hBMjU2X1dbaSAtIDJdO1xuICAgICAgY29uc3QgczAgPSByb3RyKFcxNSwgNykgXiByb3RyKFcxNSwgMTgpIF4gKFcxNSA+Pj4gMyk7XG4gICAgICBjb25zdCBzMSA9IHJvdHIoVzIsIDE3KSBeIHJvdHIoVzIsIDE5KSBeIChXMiA+Pj4gMTApO1xuICAgICAgU0hBMjU2X1dbaV0gPSAoczEgKyBTSEEyNTZfV1tpIC0gN10gKyBzMCArIFNIQTI1Nl9XW2kgLSAxNl0pIHwgMDtcbiAgICB9XG4gICAgLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24gbWFpbiBsb29wLCA2NCByb3VuZHNcbiAgICBsZXQgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgICAgY29uc3Qgc2lnbWExID0gcm90cihFLCA2KSBeIHJvdHIoRSwgMTEpIF4gcm90cihFLCAyNSk7XG4gICAgICBjb25zdCBUMSA9IChIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSkgfCAwO1xuICAgICAgY29uc3Qgc2lnbWEwID0gcm90cihBLCAyKSBeIHJvdHIoQSwgMTMpIF4gcm90cihBLCAyMik7XG4gICAgICBjb25zdCBUMiA9IChzaWdtYTAgKyBNYWooQSwgQiwgQykpIHwgMDtcbiAgICAgIEggPSBHO1xuICAgICAgRyA9IEY7XG4gICAgICBGID0gRTtcbiAgICAgIEUgPSAoRCArIFQxKSB8IDA7XG4gICAgICBEID0gQztcbiAgICAgIEMgPSBCO1xuICAgICAgQiA9IEE7XG4gICAgICBBID0gKFQxICsgVDIpIHwgMDtcbiAgICB9XG4gICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICBBID0gKEEgKyB0aGlzLkEpIHwgMDtcbiAgICBCID0gKEIgKyB0aGlzLkIpIHwgMDtcbiAgICBDID0gKEMgKyB0aGlzLkMpIHwgMDtcbiAgICBEID0gKEQgKyB0aGlzLkQpIHwgMDtcbiAgICBFID0gKEUgKyB0aGlzLkUpIHwgMDtcbiAgICBGID0gKEYgKyB0aGlzLkYpIHwgMDtcbiAgICBHID0gKEcgKyB0aGlzLkcpIHwgMDtcbiAgICBIID0gKEggKyB0aGlzLkgpIHwgMDtcbiAgICB0aGlzLnNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKTtcbiAgfVxuICBwcm90ZWN0ZWQgcm91bmRDbGVhbigpIHtcbiAgICBTSEEyNTZfVy5maWxsKDApO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgfVxufVxuLy8gQ29uc3RhbnRzIGZyb20gaHR0cHM6Ly9udmxwdWJzLm5pc3QuZ292L25pc3RwdWJzL0ZJUFMvTklTVC5GSVBTLjE4MC00LnBkZlxuY2xhc3MgU0hBMjI0IGV4dGVuZHMgU0hBMjU2IHtcbiAgQSA9IDB4YzEwNTllZDggfCAwO1xuICBCID0gMHgzNjdjZDUwNyB8IDA7XG4gIEMgPSAweDMwNzBkZDE3IHwgMDtcbiAgRCA9IDB4ZjcwZTU5MzkgfCAwO1xuICBFID0gMHhmZmMwMGIzMSB8IDA7XG4gIEYgPSAweDY4NTgxNTExIHwgMDtcbiAgRyA9IDB4NjRmOThmYTcgfCAwO1xuICBIID0gMHhiZWZhNGZhNCB8IDA7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vdXRwdXRMZW4gPSAyODtcbiAgfVxufVxuXG4vKipcbiAqIFNIQTItMjU2IGhhc2ggZnVuY3Rpb25cbiAqIEBwYXJhbSBtZXNzYWdlIC0gZGF0YSB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICovXG5leHBvcnQgY29uc3Qgc2hhMjU2ID0gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEEyNTYoKSk7XG5leHBvcnQgY29uc3Qgc2hhMjI0ID0gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEEyMjQoKSk7XG4iLCAiLyohIHNjdXJlLWJhc2UgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnROdW1iZXIobikge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgaW50ZWdlcjogJHtufWApO1xufVxuZnVuY3Rpb24gY2hhaW4oLi4uYXJncykge1xuICAgIGNvbnN0IHdyYXAgPSAoYSwgYikgPT4gKGMpID0+IGEoYihjKSk7XG4gICAgY29uc3QgZW5jb2RlID0gQXJyYXkuZnJvbShhcmdzKVxuICAgICAgICAucmV2ZXJzZSgpXG4gICAgICAgIC5yZWR1Y2UoKGFjYywgaSkgPT4gKGFjYyA/IHdyYXAoYWNjLCBpLmVuY29kZSkgOiBpLmVuY29kZSksIHVuZGVmaW5lZCk7XG4gICAgY29uc3QgZGVjb2RlID0gYXJncy5yZWR1Y2UoKGFjYywgaSkgPT4gKGFjYyA/IHdyYXAoYWNjLCBpLmRlY29kZSkgOiBpLmRlY29kZSksIHVuZGVmaW5lZCk7XG4gICAgcmV0dXJuIHsgZW5jb2RlLCBkZWNvZGUgfTtcbn1cbmZ1bmN0aW9uIGFscGhhYmV0KGFscGhhYmV0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlOiAoZGlnaXRzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGlnaXRzKSB8fCAoZGlnaXRzLmxlbmd0aCAmJiB0eXBlb2YgZGlnaXRzWzBdICE9PSAnbnVtYmVyJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbHBoYWJldC5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIGFuIGFycmF5IG9mIG51bWJlcnMnKTtcbiAgICAgICAgICAgIHJldHVybiBkaWdpdHMubWFwKChpKSA9PiB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0TnVtYmVyKGkpO1xuICAgICAgICAgICAgICAgIGlmIChpIDwgMCB8fCBpID49IGFscGhhYmV0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEaWdpdCBpbmRleCBvdXRzaWRlIGFscGhhYmV0OiAke2l9IChhbHBoYWJldDogJHthbHBoYWJldC5sZW5ndGh9KWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBhbHBoYWJldFtpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6IChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSB8fCAoaW5wdXQubGVuZ3RoICYmIHR5cGVvZiBpbnB1dFswXSAhPT0gJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWxwaGFiZXQuZGVjb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQubWFwKChsZXR0ZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxldHRlciAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYWxwaGFiZXQuZGVjb2RlOiBub3Qgc3RyaW5nIGVsZW1lbnQ9JHtsZXR0ZXJ9YCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBhbHBoYWJldC5pbmRleE9mKGxldHRlcik7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGxldHRlcjogXCIke2xldHRlcn1cIi4gQWxsb3dlZDogJHthbHBoYWJldH1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gam9pbihzZXBhcmF0b3IgPSAnJykge1xuICAgIGlmICh0eXBlb2Ygc2VwYXJhdG9yICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdqb2luIHNlcGFyYXRvciBzaG91bGQgYmUgc3RyaW5nJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlOiAoZnJvbSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGZyb20pIHx8IChmcm9tLmxlbmd0aCAmJiB0eXBlb2YgZnJvbVswXSAhPT0gJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignam9pbi5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgb2YgZnJvbSlcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGpvaW4uZW5jb2RlOiBub24tc3RyaW5nIGlucHV0PSR7aX1gKTtcbiAgICAgICAgICAgIHJldHVybiBmcm9tLmpvaW4oc2VwYXJhdG9yKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlOiAodG8pID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdG8gIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignam9pbi5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIHN0cmluZycpO1xuICAgICAgICAgICAgcmV0dXJuIHRvLnNwbGl0KHNlcGFyYXRvcik7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHBhZGRpbmcoYml0cywgY2hyID0gJz0nKSB7XG4gICAgYXNzZXJ0TnVtYmVyKGJpdHMpO1xuICAgIGlmICh0eXBlb2YgY2hyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkaW5nIGNociBzaG91bGQgYmUgc3RyaW5nJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSB8fCAoZGF0YS5sZW5ndGggJiYgdHlwZW9mIGRhdGFbMF0gIT09ICdzdHJpbmcnKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRpbmcuZW5jb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpIG9mIGRhdGEpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYWRkaW5nLmVuY29kZTogbm9uLXN0cmluZyBpbnB1dD0ke2l9YCk7XG4gICAgICAgICAgICB3aGlsZSAoKGRhdGEubGVuZ3RoICogYml0cykgJSA4KVxuICAgICAgICAgICAgICAgIGRhdGEucHVzaChjaHIpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZShpbnB1dCkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSB8fCAoaW5wdXQubGVuZ3RoICYmIHR5cGVvZiBpbnB1dFswXSAhPT0gJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGluZy5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgb2YgaW5wdXQpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYWRkaW5nLmRlY29kZTogbm9uLXN0cmluZyBpbnB1dD0ke2l9YCk7XG4gICAgICAgICAgICBsZXQgZW5kID0gaW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKChlbmQgKiBiaXRzKSAlIDgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBhZGRpbmc6IHN0cmluZyBzaG91bGQgaGF2ZSB3aG9sZSBudW1iZXIgb2YgYnl0ZXMnKTtcbiAgICAgICAgICAgIGZvciAoOyBlbmQgPiAwICYmIGlucHV0W2VuZCAtIDFdID09PSBjaHI7IGVuZC0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoKChlbmQgLSAxKSAqIGJpdHMpICUgOCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYWRkaW5nOiBzdHJpbmcgaGFzIHRvbyBtdWNoIHBhZGRpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5zbGljZSgwLCBlbmQpO1xuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBub3JtYWxpemUoZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vcm1hbGl6ZSBmbiBzaG91bGQgYmUgZnVuY3Rpb24nKTtcbiAgICByZXR1cm4geyBlbmNvZGU6IChmcm9tKSA9PiBmcm9tLCBkZWNvZGU6ICh0bykgPT4gZm4odG8pIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0UmFkaXgoZGF0YSwgZnJvbSwgdG8pIHtcbiAgICBpZiAoZnJvbSA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4OiB3cm9uZyBmcm9tPSR7ZnJvbX0sIGJhc2UgY2Fubm90IGJlIGxlc3MgdGhhbiAyYCk7XG4gICAgaWYgKHRvIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXg6IHdyb25nIHRvPSR7dG99LCBiYXNlIGNhbm5vdCBiZSBsZXNzIHRoYW4gMmApO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb252ZXJ0UmFkaXg6IGRhdGEgc2hvdWxkIGJlIGFycmF5Jyk7XG4gICAgaWYgKCFkYXRhLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIGxldCBwb3MgPSAwO1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGNvbnN0IGRpZ2l0cyA9IEFycmF5LmZyb20oZGF0YSk7XG4gICAgZGlnaXRzLmZvckVhY2goKGQpID0+IHtcbiAgICAgICAgYXNzZXJ0TnVtYmVyKGQpO1xuICAgICAgICBpZiAoZCA8IDAgfHwgZCA+PSBmcm9tKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBpbnRlZ2VyOiAke2R9YCk7XG4gICAgfSk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgbGV0IGNhcnJ5ID0gMDtcbiAgICAgICAgbGV0IGRvbmUgPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gcG9zOyBpIDwgZGlnaXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBkaWdpdCA9IGRpZ2l0c1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGRpZ2l0QmFzZSA9IGZyb20gKiBjYXJyeSArIGRpZ2l0O1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihkaWdpdEJhc2UpIHx8XG4gICAgICAgICAgICAgICAgKGZyb20gKiBjYXJyeSkgLyBmcm9tICE9PSBjYXJyeSB8fFxuICAgICAgICAgICAgICAgIGRpZ2l0QmFzZSAtIGRpZ2l0ICE9PSBmcm9tICogY2FycnkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnZlcnRSYWRpeDogY2Fycnkgb3ZlcmZsb3cnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhcnJ5ID0gZGlnaXRCYXNlICUgdG87XG4gICAgICAgICAgICBkaWdpdHNbaV0gPSBNYXRoLmZsb29yKGRpZ2l0QmFzZSAvIHRvKTtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoZGlnaXRzW2ldKSB8fCBkaWdpdHNbaV0gKiB0byArIGNhcnJ5ICE9PSBkaWdpdEJhc2UpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb252ZXJ0UmFkaXg6IGNhcnJ5IG92ZXJmbG93Jyk7XG4gICAgICAgICAgICBpZiAoIWRvbmUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBlbHNlIGlmICghZGlnaXRzW2ldKVxuICAgICAgICAgICAgICAgIHBvcyA9IGk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZG9uZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoKGNhcnJ5KTtcbiAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aCAtIDEgJiYgZGF0YVtpXSA9PT0gMDsgaSsrKVxuICAgICAgICByZXMucHVzaCgwKTtcbiAgICByZXR1cm4gcmVzLnJldmVyc2UoKTtcbn1cbmNvbnN0IGdjZCA9IChhLCBiKSA9PiAoIWIgPyBhIDogZ2NkKGIsIGEgJSBiKSk7XG5jb25zdCByYWRpeDJjYXJyeSA9IChmcm9tLCB0bykgPT4gZnJvbSArICh0byAtIGdjZChmcm9tLCB0bykpO1xuZnVuY3Rpb24gY29udmVydFJhZGl4MihkYXRhLCBmcm9tLCB0bywgcGFkZGluZykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb252ZXJ0UmFkaXgyOiBkYXRhIHNob3VsZCBiZSBhcnJheScpO1xuICAgIGlmIChmcm9tIDw9IDAgfHwgZnJvbSA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IHdyb25nIGZyb209JHtmcm9tfWApO1xuICAgIGlmICh0byA8PSAwIHx8IHRvID4gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4Mjogd3JvbmcgdG89JHt0b31gKTtcbiAgICBpZiAocmFkaXgyY2FycnkoZnJvbSwgdG8pID4gMzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiBjYXJyeSBvdmVyZmxvdyBmcm9tPSR7ZnJvbX0gdG89JHt0b30gY2FycnlCaXRzPSR7cmFkaXgyY2FycnkoZnJvbSwgdG8pfWApO1xuICAgIH1cbiAgICBsZXQgY2FycnkgPSAwO1xuICAgIGxldCBwb3MgPSAwO1xuICAgIGNvbnN0IG1hc2sgPSAyICoqIHRvIC0gMTtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG4gb2YgZGF0YSkge1xuICAgICAgICBhc3NlcnROdW1iZXIobik7XG4gICAgICAgIGlmIChuID49IDIgKiogZnJvbSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4MjogaW52YWxpZCBkYXRhIHdvcmQ9JHtufSBmcm9tPSR7ZnJvbX1gKTtcbiAgICAgICAgY2FycnkgPSAoY2FycnkgPDwgZnJvbSkgfCBuO1xuICAgICAgICBpZiAocG9zICsgZnJvbSA+IDMyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiBjYXJyeSBvdmVyZmxvdyBwb3M9JHtwb3N9IGZyb209JHtmcm9tfWApO1xuICAgICAgICBwb3MgKz0gZnJvbTtcbiAgICAgICAgZm9yICg7IHBvcyA+PSB0bzsgcG9zIC09IHRvKVxuICAgICAgICAgICAgcmVzLnB1c2goKChjYXJyeSA+PiAocG9zIC0gdG8pKSAmIG1hc2spID4+PiAwKTtcbiAgICAgICAgY2FycnkgJj0gMiAqKiBwb3MgLSAxO1xuICAgIH1cbiAgICBjYXJyeSA9IChjYXJyeSA8PCAodG8gLSBwb3MpKSAmIG1hc2s7XG4gICAgaWYgKCFwYWRkaW5nICYmIHBvcyA+PSBmcm9tKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4Y2VzcyBwYWRkaW5nJyk7XG4gICAgaWYgKCFwYWRkaW5nICYmIGNhcnJ5KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vbi16ZXJvIHBhZGRpbmc6ICR7Y2Fycnl9YCk7XG4gICAgaWYgKHBhZGRpbmcgJiYgcG9zID4gMClcbiAgICAgICAgcmVzLnB1c2goY2FycnkgPj4+IDApO1xuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiByYWRpeChudW0pIHtcbiAgICBhc3NlcnROdW1iZXIobnVtKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IChieXRlcykgPT4ge1xuICAgICAgICAgICAgaWYgKCEoYnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4LmVuY29kZSBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRSYWRpeChBcnJheS5mcm9tKGJ5dGVzKSwgMiAqKiA4LCBudW0pO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6IChkaWdpdHMpID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkaWdpdHMpIHx8IChkaWdpdHMubGVuZ3RoICYmIHR5cGVvZiBkaWdpdHNbMF0gIT09ICdudW1iZXInKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4LmRlY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShjb252ZXJ0UmFkaXgoZGlnaXRzLCBudW0sIDIgKiogOCkpO1xuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiByYWRpeDIoYml0cywgcmV2UGFkZGluZyA9IGZhbHNlKSB7XG4gICAgYXNzZXJ0TnVtYmVyKGJpdHMpO1xuICAgIGlmIChiaXRzIDw9IDAgfHwgYml0cyA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4MjogYml0cyBzaG91bGQgYmUgaW4gKDAuLjMyXScpO1xuICAgIGlmIChyYWRpeDJjYXJyeSg4LCBiaXRzKSA+IDMyIHx8IHJhZGl4MmNhcnJ5KGJpdHMsIDgpID4gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXgyOiBjYXJyeSBvdmVyZmxvdycpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZTogKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIShieXRlcyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXgyLmVuY29kZSBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRSYWRpeDIoQXJyYXkuZnJvbShieXRlcyksIDgsIGJpdHMsICFyZXZQYWRkaW5nKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlOiAoZGlnaXRzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGlnaXRzKSB8fCAoZGlnaXRzLmxlbmd0aCAmJiB0eXBlb2YgZGlnaXRzWzBdICE9PSAnbnVtYmVyJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeDIuZGVjb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGNvbnZlcnRSYWRpeDIoZGlnaXRzLCBiaXRzLCA4LCByZXZQYWRkaW5nKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHVuc2FmZVdyYXBwZXIoZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc2FmZVdyYXBwZXIgZm4gc2hvdWxkIGJlIGZ1bmN0aW9uJyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgIH07XG59XG5mdW5jdGlvbiBjaGVja3N1bShsZW4sIGZuKSB7XG4gICAgYXNzZXJ0TnVtYmVyKGxlbik7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjaGVja3N1bSBmbiBzaG91bGQgYmUgZnVuY3Rpb24nKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGUoZGF0YSkge1xuICAgICAgICAgICAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2hlY2tzdW0uZW5jb2RlOiBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgY29uc3QgY2hlY2tzdW0gPSBmbihkYXRhKS5zbGljZSgwLCBsZW4pO1xuICAgICAgICAgICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGggKyBsZW4pO1xuICAgICAgICAgICAgcmVzLnNldChkYXRhKTtcbiAgICAgICAgICAgIHJlcy5zZXQoY2hlY2tzdW0sIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZShkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIShkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjaGVja3N1bS5kZWNvZGU6IGlucHV0IHNob3VsZCBiZSBVaW50OEFycmF5Jyk7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gZGF0YS5zbGljZSgwLCAtbGVuKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NoZWNrc3VtID0gZm4ocGF5bG9hZCkuc2xpY2UoMCwgbGVuKTtcbiAgICAgICAgICAgIGNvbnN0IG9sZENoZWNrc3VtID0gZGF0YS5zbGljZSgtbGVuKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKG5ld0NoZWNrc3VtW2ldICE9PSBvbGRDaGVja3N1bVtpXSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNoZWNrc3VtJyk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0IGNvbnN0IHV0aWxzID0geyBhbHBoYWJldCwgY2hhaW4sIGNoZWNrc3VtLCByYWRpeCwgcmFkaXgyLCBqb2luLCBwYWRkaW5nIH07XG5leHBvcnQgY29uc3QgYmFzZTE2ID0gY2hhaW4ocmFkaXgyKDQpLCBhbHBoYWJldCgnMDEyMzQ1Njc4OUFCQ0RFRicpLCBqb2luKCcnKSk7XG5leHBvcnQgY29uc3QgYmFzZTMyID0gY2hhaW4ocmFkaXgyKDUpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1NjcnKSwgcGFkZGluZyg1KSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2UzMmhleCA9IGNoYWluKHJhZGl4Mig1KSwgYWxwaGFiZXQoJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWJyksIHBhZGRpbmcoNSksIGpvaW4oJycpKTtcbmV4cG9ydCBjb25zdCBiYXNlMzJjcm9ja2ZvcmQgPSBjaGFpbihyYWRpeDIoNSksIGFscGhhYmV0KCcwMTIzNDU2Nzg5QUJDREVGR0hKS01OUFFSU1RWV1hZWicpLCBqb2luKCcnKSwgbm9ybWFsaXplKChzKSA9PiBzLnRvVXBwZXJDYXNlKCkucmVwbGFjZSgvTy9nLCAnMCcpLnJlcGxhY2UoL1tJTF0vZywgJzEnKSkpO1xuZXhwb3J0IGNvbnN0IGJhc2U2NCA9IGNoYWluKHJhZGl4Mig2KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nKSwgcGFkZGluZyg2KSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2U2NHVybCA9IGNoYWluKHJhZGl4Mig2KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV8nKSwgcGFkZGluZyg2KSwgam9pbignJykpO1xuY29uc3QgZ2VuQmFzZTU4ID0gKGFiYykgPT4gY2hhaW4ocmFkaXgoNTgpLCBhbHBoYWJldChhYmMpLCBqb2luKCcnKSk7XG5leHBvcnQgY29uc3QgYmFzZTU4ID0gZ2VuQmFzZTU4KCcxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6Jyk7XG5leHBvcnQgY29uc3QgYmFzZTU4ZmxpY2tyID0gZ2VuQmFzZTU4KCcxMjM0NTY3ODlhYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaJyk7XG5leHBvcnQgY29uc3QgYmFzZTU4eHJwID0gZ2VuQmFzZTU4KCdycHNobmFmMzl3QlVETkVHSEpLTE00UFFSU1Q3VldYWVoyYmNkZUNnNjVqa204b0ZxaTF0dXZBeHl6Jyk7XG5jb25zdCBYTVJfQkxPQ0tfTEVOID0gWzAsIDIsIDMsIDUsIDYsIDcsIDksIDEwLCAxMV07XG5leHBvcnQgY29uc3QgYmFzZTU4eG1yID0ge1xuICAgIGVuY29kZShkYXRhKSB7XG4gICAgICAgIGxldCByZXMgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSA4KSB7XG4gICAgICAgICAgICBjb25zdCBibG9jayA9IGRhdGEuc3ViYXJyYXkoaSwgaSArIDgpO1xuICAgICAgICAgICAgcmVzICs9IGJhc2U1OC5lbmNvZGUoYmxvY2spLnBhZFN0YXJ0KFhNUl9CTE9DS19MRU5bYmxvY2subGVuZ3RoXSwgJzEnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG4gICAgZGVjb2RlKHN0cikge1xuICAgICAgICBsZXQgcmVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSAxMSkge1xuICAgICAgICAgICAgY29uc3Qgc2xpY2UgPSBzdHIuc2xpY2UoaSwgaSArIDExKTtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrTGVuID0gWE1SX0JMT0NLX0xFTi5pbmRleE9mKHNsaWNlLmxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBibG9jayA9IGJhc2U1OC5kZWNvZGUoc2xpY2UpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBibG9jay5sZW5ndGggLSBibG9ja0xlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrW2pdICE9PSAwKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Jhc2U1OHhtcjogd3JvbmcgcGFkZGluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzID0gcmVzLmNvbmNhdChBcnJheS5mcm9tKGJsb2NrLnNsaWNlKGJsb2NrLmxlbmd0aCAtIGJsb2NrTGVuKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20ocmVzKTtcbiAgICB9LFxufTtcbmV4cG9ydCBjb25zdCBiYXNlNThjaGVjayA9IChzaGEyNTYpID0+IGNoYWluKGNoZWNrc3VtKDQsIChkYXRhKSA9PiBzaGEyNTYoc2hhMjU2KGRhdGEpKSksIGJhc2U1OCk7XG5jb25zdCBCRUNIX0FMUEhBQkVUID0gY2hhaW4oYWxwaGFiZXQoJ3FwenJ5OXg4Z2YydHZkdzBzM2puNTRraGNlNm11YTdsJyksIGpvaW4oJycpKTtcbmNvbnN0IFBPTFlNT0RfR0VORVJBVE9SUyA9IFsweDNiNmE1N2IyLCAweDI2NTA4ZTZkLCAweDFlYTExOWZhLCAweDNkNDIzM2RkLCAweDJhMTQ2MmIzXTtcbmZ1bmN0aW9uIGJlY2gzMlBvbHltb2QocHJlKSB7XG4gICAgY29uc3QgYiA9IHByZSA+PiAyNTtcbiAgICBsZXQgY2hrID0gKHByZSAmIDB4MWZmZmZmZikgPDwgNTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IFBPTFlNT0RfR0VORVJBVE9SUy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoKChiID4+IGkpICYgMSkgPT09IDEpXG4gICAgICAgICAgICBjaGsgXj0gUE9MWU1PRF9HRU5FUkFUT1JTW2ldO1xuICAgIH1cbiAgICByZXR1cm4gY2hrO1xufVxuZnVuY3Rpb24gYmVjaENoZWNrc3VtKHByZWZpeCwgd29yZHMsIGVuY29kaW5nQ29uc3QgPSAxKSB7XG4gICAgY29uc3QgbGVuID0gcHJlZml4Lmxlbmd0aDtcbiAgICBsZXQgY2hrID0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSBwcmVmaXguY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAzMyB8fCBjID4gMTI2KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHByZWZpeCAoJHtwcmVmaXh9KWApO1xuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoaykgXiAoYyA+PiA1KTtcbiAgICB9XG4gICAgY2hrID0gYmVjaDMyUG9seW1vZChjaGspO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKSBeIChwcmVmaXguY2hhckNvZGVBdChpKSAmIDB4MWYpO1xuICAgIGZvciAobGV0IHYgb2Ygd29yZHMpXG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKSBeIHY7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspXG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKTtcbiAgICBjaGsgXj0gZW5jb2RpbmdDb25zdDtcbiAgICByZXR1cm4gQkVDSF9BTFBIQUJFVC5lbmNvZGUoY29udmVydFJhZGl4MihbY2hrICUgMiAqKiAzMF0sIDMwLCA1LCBmYWxzZSkpO1xufVxuZnVuY3Rpb24gZ2VuQmVjaDMyKGVuY29kaW5nKSB7XG4gICAgY29uc3QgRU5DT0RJTkdfQ09OU1QgPSBlbmNvZGluZyA9PT0gJ2JlY2gzMicgPyAxIDogMHgyYmM4MzBhMztcbiAgICBjb25zdCBfd29yZHMgPSByYWRpeDIoNSk7XG4gICAgY29uc3QgZnJvbVdvcmRzID0gX3dvcmRzLmRlY29kZTtcbiAgICBjb25zdCB0b1dvcmRzID0gX3dvcmRzLmVuY29kZTtcbiAgICBjb25zdCBmcm9tV29yZHNVbnNhZmUgPSB1bnNhZmVXcmFwcGVyKGZyb21Xb3Jkcyk7XG4gICAgZnVuY3Rpb24gZW5jb2RlKHByZWZpeCwgd29yZHMsIGxpbWl0ID0gOTApIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcmVmaXggIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiZWNoMzIuZW5jb2RlIHByZWZpeCBzaG91bGQgYmUgc3RyaW5nLCBub3QgJHt0eXBlb2YgcHJlZml4fWApO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkod29yZHMpIHx8ICh3b3Jkcy5sZW5ndGggJiYgdHlwZW9mIHdvcmRzWzBdICE9PSAnbnVtYmVyJykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJlY2gzMi5lbmNvZGUgd29yZHMgc2hvdWxkIGJlIGFycmF5IG9mIG51bWJlcnMsIG5vdCAke3R5cGVvZiB3b3Jkc31gKTtcbiAgICAgICAgY29uc3QgYWN0dWFsTGVuZ3RoID0gcHJlZml4Lmxlbmd0aCArIDcgKyB3b3Jkcy5sZW5ndGg7XG4gICAgICAgIGlmIChsaW1pdCAhPT0gZmFsc2UgJiYgYWN0dWFsTGVuZ3RoID4gbGltaXQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBMZW5ndGggJHthY3R1YWxMZW5ndGh9IGV4Y2VlZHMgbGltaXQgJHtsaW1pdH1gKTtcbiAgICAgICAgcHJlZml4ID0gcHJlZml4LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiBgJHtwcmVmaXh9MSR7QkVDSF9BTFBIQUJFVC5lbmNvZGUod29yZHMpfSR7YmVjaENoZWNrc3VtKHByZWZpeCwgd29yZHMsIEVOQ09ESU5HX0NPTlNUKX1gO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWNvZGUoc3RyLCBsaW1pdCA9IDkwKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYmVjaDMyLmRlY29kZSBpbnB1dCBzaG91bGQgYmUgc3RyaW5nLCBub3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgICAgICBpZiAoc3RyLmxlbmd0aCA8IDggfHwgKGxpbWl0ICE9PSBmYWxzZSAmJiBzdHIubGVuZ3RoID4gbGltaXQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgV3Jvbmcgc3RyaW5nIGxlbmd0aDogJHtzdHIubGVuZ3RofSAoJHtzdHJ9KS4gRXhwZWN0ZWQgKDguLiR7bGltaXR9KWApO1xuICAgICAgICBjb25zdCBsb3dlcmVkID0gc3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChzdHIgIT09IGxvd2VyZWQgJiYgc3RyICE9PSBzdHIudG9VcHBlckNhc2UoKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU3RyaW5nIG11c3QgYmUgbG93ZXJjYXNlIG9yIHVwcGVyY2FzZWApO1xuICAgICAgICBzdHIgPSBsb3dlcmVkO1xuICAgICAgICBjb25zdCBzZXBJbmRleCA9IHN0ci5sYXN0SW5kZXhPZignMScpO1xuICAgICAgICBpZiAoc2VwSW5kZXggPT09IDAgfHwgc2VwSW5kZXggPT09IC0xKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMZXR0ZXIgXCIxXCIgbXVzdCBiZSBwcmVzZW50IGJldHdlZW4gcHJlZml4IGFuZCBkYXRhIG9ubHlgKTtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gc3RyLnNsaWNlKDAsIHNlcEluZGV4KTtcbiAgICAgICAgY29uc3QgX3dvcmRzID0gc3RyLnNsaWNlKHNlcEluZGV4ICsgMSk7XG4gICAgICAgIGlmIChfd29yZHMubGVuZ3RoIDwgNilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YSBtdXN0IGJlIGF0IGxlYXN0IDYgY2hhcmFjdGVycyBsb25nJyk7XG4gICAgICAgIGNvbnN0IHdvcmRzID0gQkVDSF9BTFBIQUJFVC5kZWNvZGUoX3dvcmRzKS5zbGljZSgwLCAtNik7XG4gICAgICAgIGNvbnN0IHN1bSA9IGJlY2hDaGVja3N1bShwcmVmaXgsIHdvcmRzLCBFTkNPRElOR19DT05TVCk7XG4gICAgICAgIGlmICghX3dvcmRzLmVuZHNXaXRoKHN1bSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY2hlY2tzdW0gaW4gJHtzdHJ9OiBleHBlY3RlZCBcIiR7c3VtfVwiYCk7XG4gICAgICAgIHJldHVybiB7IHByZWZpeCwgd29yZHMgfTtcbiAgICB9XG4gICAgY29uc3QgZGVjb2RlVW5zYWZlID0gdW5zYWZlV3JhcHBlcihkZWNvZGUpO1xuICAgIGZ1bmN0aW9uIGRlY29kZVRvQnl0ZXMoc3RyKSB7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCB3b3JkcyB9ID0gZGVjb2RlKHN0ciwgZmFsc2UpO1xuICAgICAgICByZXR1cm4geyBwcmVmaXgsIHdvcmRzLCBieXRlczogZnJvbVdvcmRzKHdvcmRzKSB9O1xuICAgIH1cbiAgICByZXR1cm4geyBlbmNvZGUsIGRlY29kZSwgZGVjb2RlVG9CeXRlcywgZGVjb2RlVW5zYWZlLCBmcm9tV29yZHMsIGZyb21Xb3Jkc1Vuc2FmZSwgdG9Xb3JkcyB9O1xufVxuZXhwb3J0IGNvbnN0IGJlY2gzMiA9IGdlbkJlY2gzMignYmVjaDMyJyk7XG5leHBvcnQgY29uc3QgYmVjaDMybSA9IGdlbkJlY2gzMignYmVjaDMybScpO1xuZXhwb3J0IGNvbnN0IHV0ZjggPSB7XG4gICAgZW5jb2RlOiAoZGF0YSkgPT4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGRhdGEpLFxuICAgIGRlY29kZTogKHN0cikgPT4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0ciksXG59O1xuZXhwb3J0IGNvbnN0IGhleCA9IGNoYWluKHJhZGl4Mig0KSwgYWxwaGFiZXQoJzAxMjM0NTY3ODlhYmNkZWYnKSwgam9pbignJyksIG5vcm1hbGl6ZSgocykgPT4ge1xuICAgIGlmICh0eXBlb2YgcyAhPT0gJ3N0cmluZycgfHwgcy5sZW5ndGggJSAyKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBoZXguZGVjb2RlOiBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzfSB3aXRoIGxlbmd0aCAke3MubGVuZ3RofWApO1xuICAgIHJldHVybiBzLnRvTG93ZXJDYXNlKCk7XG59KSk7XG5jb25zdCBDT0RFUlMgPSB7XG4gICAgdXRmOCwgaGV4LCBiYXNlMTYsIGJhc2UzMiwgYmFzZTY0LCBiYXNlNjR1cmwsIGJhc2U1OCwgYmFzZTU4eG1yXG59O1xuY29uc3QgY29kZXJUeXBlRXJyb3IgPSBgSW52YWxpZCBlbmNvZGluZyB0eXBlLiBBdmFpbGFibGUgdHlwZXM6ICR7T2JqZWN0LmtleXMoQ09ERVJTKS5qb2luKCcsICcpfWA7XG5leHBvcnQgY29uc3QgYnl0ZXNUb1N0cmluZyA9ICh0eXBlLCBieXRlcykgPT4ge1xuICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycgfHwgIUNPREVSUy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihjb2RlclR5cGVFcnJvcik7XG4gICAgaWYgKCEoYnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYnl0ZXNUb1N0cmluZygpIGV4cGVjdHMgVWludDhBcnJheScpO1xuICAgIHJldHVybiBDT0RFUlNbdHlwZV0uZW5jb2RlKGJ5dGVzKTtcbn07XG5leHBvcnQgY29uc3Qgc3RyID0gYnl0ZXNUb1N0cmluZztcbmV4cG9ydCBjb25zdCBzdHJpbmdUb0J5dGVzID0gKHR5cGUsIHN0cikgPT4ge1xuICAgIGlmICghQ09ERVJTLmhhc093blByb3BlcnR5KHR5cGUpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGNvZGVyVHlwZUVycm9yKTtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3N0cmluZ1RvQnl0ZXMoKSBleHBlY3RzIHN0cmluZycpO1xuICAgIHJldHVybiBDT0RFUlNbdHlwZV0uZGVjb2RlKHN0cik7XG59O1xuZXhwb3J0IGNvbnN0IGJ5dGVzID0gc3RyaW5nVG9CeXRlcztcbiIsICJmdW5jdGlvbiBudW1iZXIobjogbnVtYmVyKSB7XG4gIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikgfHwgbiA8IDApIHRocm93IG5ldyBFcnJvcihgcG9zaXRpdmUgaW50ZWdlciBleHBlY3RlZCwgbm90ICR7bn1gKTtcbn1cblxuZnVuY3Rpb24gYm9vbChiOiBib29sZWFuKSB7XG4gIGlmICh0eXBlb2YgYiAhPT0gJ2Jvb2xlYW4nKSB0aHJvdyBuZXcgRXJyb3IoYGJvb2xlYW4gZXhwZWN0ZWQsIG5vdCAke2J9YCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0J5dGVzKGE6IHVua25vd24pOiBhIGlzIFVpbnQ4QXJyYXkge1xuICByZXR1cm4gKFxuICAgIGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8XG4gICAgKGEgIT0gbnVsbCAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpXG4gICk7XG59XG5cbmZ1bmN0aW9uIGJ5dGVzKGI6IFVpbnQ4QXJyYXkgfCB1bmRlZmluZWQsIC4uLmxlbmd0aHM6IG51bWJlcltdKSB7XG4gIGlmICghaXNCeXRlcyhiKSkgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gIGlmIChsZW5ndGhzLmxlbmd0aCA+IDAgJiYgIWxlbmd0aHMuaW5jbHVkZXMoYi5sZW5ndGgpKVxuICAgIHRocm93IG5ldyBFcnJvcihgVWludDhBcnJheSBleHBlY3RlZCBvZiBsZW5ndGggJHtsZW5ndGhzfSwgbm90IG9mIGxlbmd0aD0ke2IubGVuZ3RofWApO1xufVxuXG5leHBvcnQgdHlwZSBIYXNoID0ge1xuICAoZGF0YTogVWludDhBcnJheSk6IFVpbnQ4QXJyYXk7XG4gIGJsb2NrTGVuOiBudW1iZXI7XG4gIG91dHB1dExlbjogbnVtYmVyO1xuICBjcmVhdGU6IGFueTtcbn07XG5mdW5jdGlvbiBoYXNoKGhhc2g6IEhhc2gpIHtcbiAgaWYgKHR5cGVvZiBoYXNoICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBoYXNoLmNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2hhc2ggbXVzdCBiZSB3cmFwcGVkIGJ5IHV0aWxzLndyYXBDb25zdHJ1Y3RvcicpO1xuICBudW1iZXIoaGFzaC5vdXRwdXRMZW4pO1xuICBudW1iZXIoaGFzaC5ibG9ja0xlbik7XG59XG5cbmZ1bmN0aW9uIGV4aXN0cyhpbnN0YW5jZTogYW55LCBjaGVja0ZpbmlzaGVkID0gdHJ1ZSkge1xuICBpZiAoaW5zdGFuY2UuZGVzdHJveWVkKSB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkJyk7XG4gIGlmIChjaGVja0ZpbmlzaGVkICYmIGluc3RhbmNlLmZpbmlzaGVkKSB0aHJvdyBuZXcgRXJyb3IoJ0hhc2gjZGlnZXN0KCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQnKTtcbn1cblxuZnVuY3Rpb24gb3V0cHV0KG91dDogYW55LCBpbnN0YW5jZTogYW55KSB7XG4gIGJ5dGVzKG91dCk7XG4gIGNvbnN0IG1pbiA9IGluc3RhbmNlLm91dHB1dExlbjtcbiAgaWYgKG91dC5sZW5ndGggPCBtaW4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGRpZ2VzdEludG8oKSBleHBlY3RzIG91dHB1dCBidWZmZXIgb2YgbGVuZ3RoIGF0IGxlYXN0ICR7bWlufWApO1xuICB9XG59XG5cbmV4cG9ydCB7IG51bWJlciwgYm9vbCwgYnl0ZXMsIGhhc2gsIGV4aXN0cywgb3V0cHV0IH07XG5jb25zdCBhc3NlcnQgPSB7IG51bWJlciwgYm9vbCwgYnl0ZXMsIGhhc2gsIGV4aXN0cywgb3V0cHV0IH07XG5leHBvcnQgZGVmYXVsdCBhc3NlcnQ7XG4iLCAiLyohIG5vYmxlLWNpcGhlcnMgLSBNSVQgTGljZW5zZSAoYykgMjAyMyBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IGJ5dGVzIGFzIGFieXRlcywgaXNCeXRlcyB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG4vLyBwcmV0dGllci1pZ25vcmVcbmV4cG9ydCB0eXBlIFR5cGVkQXJyYXkgPSBJbnQ4QXJyYXkgfCBVaW50OENsYW1wZWRBcnJheSB8IFVpbnQ4QXJyYXkgfFxuICBVaW50MTZBcnJheSB8IEludDE2QXJyYXkgfCBVaW50MzJBcnJheSB8IEludDMyQXJyYXk7XG5cbi8vIENhc3QgYXJyYXkgdG8gZGlmZmVyZW50IHR5cGVcbmV4cG9ydCBjb25zdCB1OCA9IChhcnI6IFR5cGVkQXJyYXkpID0+IG5ldyBVaW50OEFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG5leHBvcnQgY29uc3QgdTE2ID0gKGFycjogVHlwZWRBcnJheSkgPT5cbiAgbmV3IFVpbnQxNkFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBNYXRoLmZsb29yKGFyci5ieXRlTGVuZ3RoIC8gMikpO1xuZXhwb3J0IGNvbnN0IHUzMiA9IChhcnI6IFR5cGVkQXJyYXkpID0+XG4gIG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDQpKTtcblxuLy8gQ2FzdCBhcnJheSB0byB2aWV3XG5leHBvcnQgY29uc3QgY3JlYXRlVmlldyA9IChhcnI6IFR5cGVkQXJyYXkpID0+XG4gIG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuXG4vLyBiaWctZW5kaWFuIGhhcmR3YXJlIGlzIHJhcmUuIEp1c3QgaW4gY2FzZSBzb21lb25lIHN0aWxsIGRlY2lkZXMgdG8gcnVuIGNpcGhlcnM6XG4vLyBlYXJseS10aHJvdyBhbiBlcnJvciBiZWNhdXNlIHdlIGRvbid0IHN1cHBvcnQgQkUgeWV0LlxuZXhwb3J0IGNvbnN0IGlzTEUgPSBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzB4MTEyMjMzNDRdKS5idWZmZXIpWzBdID09PSAweDQ0O1xuaWYgKCFpc0xFKSB0aHJvdyBuZXcgRXJyb3IoJ05vbiBsaXR0bGUtZW5kaWFuIGhhcmR3YXJlIGlzIG5vdCBzdXBwb3J0ZWQnKTtcblxuLy8gQXJyYXkgd2hlcmUgaW5kZXggMHhmMCAoMjQwKSBpcyBtYXBwZWQgdG8gc3RyaW5nICdmMCdcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT5cbiAgaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKVxuKTtcbi8qKlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlczogVWludDhBcnJheSk6IHN0cmluZyB7XG4gIGFieXRlcyhieXRlcyk7XG4gIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICBsZXQgaGV4ID0gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBoZXggKz0gaGV4ZXNbYnl0ZXNbaV1dO1xuICB9XG4gIHJldHVybiBoZXg7XG59XG5cbi8vIFdlIHVzZSBvcHRpbWl6ZWQgdGVjaG5pcXVlIHRvIGNvbnZlcnQgaGV4IHN0cmluZyB0byBieXRlIGFycmF5XG5jb25zdCBhc2NpaXMgPSB7IF8wOiA0OCwgXzk6IDU3LCBfQTogNjUsIF9GOiA3MCwgX2E6IDk3LCBfZjogMTAyIH0gYXMgY29uc3Q7XG5mdW5jdGlvbiBhc2NpaVRvQmFzZTE2KGNoYXI6IG51bWJlcik6IG51bWJlciB8IHVuZGVmaW5lZCB7XG4gIGlmIChjaGFyID49IGFzY2lpcy5fMCAmJiBjaGFyIDw9IGFzY2lpcy5fOSkgcmV0dXJuIGNoYXIgLSBhc2NpaXMuXzA7XG4gIGlmIChjaGFyID49IGFzY2lpcy5fQSAmJiBjaGFyIDw9IGFzY2lpcy5fRikgcmV0dXJuIGNoYXIgLSAoYXNjaWlzLl9BIC0gMTApO1xuICBpZiAoY2hhciA+PSBhc2NpaXMuX2EgJiYgY2hhciA8PSBhc2NpaXMuX2YpIHJldHVybiBjaGFyIC0gKGFzY2lpcy5fYSAtIDEwKTtcbiAgcmV0dXJuO1xufVxuXG4vKipcbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4OiBzdHJpbmcpOiBVaW50OEFycmF5IHtcbiAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKSB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gIGNvbnN0IGhsID0gaGV4Lmxlbmd0aDtcbiAgY29uc3QgYWwgPSBobCAvIDI7XG4gIGlmIChobCAlIDIpIHRocm93IG5ldyBFcnJvcigncGFkZGVkIGhleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoICcgKyBobCk7XG4gIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYWwpO1xuICBmb3IgKGxldCBhaSA9IDAsIGhpID0gMDsgYWkgPCBhbDsgYWkrKywgaGkgKz0gMikge1xuICAgIGNvbnN0IG4xID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSkpO1xuICAgIGNvbnN0IG4yID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSArIDEpKTtcbiAgICBpZiAobjEgPT09IHVuZGVmaW5lZCB8fCBuMiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBjaGFyID0gaGV4W2hpXSArIGhleFtoaSArIDFdO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3Qgbm9uLWhleCBjaGFyYWN0ZXIgXCInICsgY2hhciArICdcIiBhdCBpbmRleCAnICsgaGkpO1xuICAgIH1cbiAgICBhcnJheVthaV0gPSBuMSAqIDE2ICsgbjI7XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9OdW1iZXIoaGV4OiBzdHJpbmcpOiBiaWdpbnQge1xuICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgLy8gQmlnIEVuZGlhblxuICByZXR1cm4gQmlnSW50KGhleCA9PT0gJycgPyAnMCcgOiBgMHgke2hleH1gKTtcbn1cblxuLy8gQkU6IEJpZyBFbmRpYW4sIExFOiBMaXR0bGUgRW5kaWFuXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb051bWJlckJFKGJ5dGVzOiBVaW50OEFycmF5KTogYmlnaW50IHtcbiAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXgoYnl0ZXMpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvQnl0ZXNCRShuOiBudW1iZXIgfCBiaWdpbnQsIGxlbjogbnVtYmVyKTogVWludDhBcnJheSB7XG4gIHJldHVybiBoZXhUb0J5dGVzKG4udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KGxlbiAqIDIsICcwJykpO1xufVxuXG4vLyBUaGVyZSBpcyBubyBzZXRJbW1lZGlhdGUgaW4gYnJvd3NlciBhbmQgc2V0VGltZW91dCBpcyBzbG93LlxuLy8gY2FsbCBvZiBhc3luYyBmbiB3aWxsIHJldHVybiBQcm9taXNlLCB3aGljaCB3aWxsIGJlIGZ1bGxmaWxlZCBvbmx5IG9uXG4vLyBuZXh0IHNjaGVkdWxlciBxdWV1ZSBwcm9jZXNzaW5nIHN0ZXAgYW5kIHRoaXMgaXMgZXhhY3RseSB3aGF0IHdlIG5lZWQuXG5leHBvcnQgY29uc3QgbmV4dFRpY2sgPSBhc3luYyAoKSA9PiB7fTtcblxuLy8gUmV0dXJucyBjb250cm9sIHRvIHRocmVhZCBlYWNoICd0aWNrJyBtcyB0byBhdm9pZCBibG9ja2luZ1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFzeW5jTG9vcChpdGVyczogbnVtYmVyLCB0aWNrOiBudW1iZXIsIGNiOiAoaTogbnVtYmVyKSA9PiB2b2lkKSB7XG4gIGxldCB0cyA9IERhdGUubm93KCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcnM7IGkrKykge1xuICAgIGNiKGkpO1xuICAgIC8vIERhdGUubm93KCkgaXMgbm90IG1vbm90b25pYywgc28gaW4gY2FzZSBpZiBjbG9jayBnb2VzIGJhY2t3YXJkcyB3ZSByZXR1cm4gcmV0dXJuIGNvbnRyb2wgdG9vXG4gICAgY29uc3QgZGlmZiA9IERhdGUubm93KCkgLSB0cztcbiAgICBpZiAoZGlmZiA+PSAwICYmIGRpZmYgPCB0aWNrKSBjb250aW51ZTtcbiAgICBhd2FpdCBuZXh0VGljaygpO1xuICAgIHRzICs9IGRpZmY7XG4gIH1cbn1cblxuLy8gR2xvYmFsIHN5bWJvbHMgaW4gYm90aCBicm93c2VycyBhbmQgTm9kZS5qcyBzaW5jZSB2MTFcbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzMxNTM1XG5kZWNsYXJlIGNvbnN0IFRleHRFbmNvZGVyOiBhbnk7XG5kZWNsYXJlIGNvbnN0IFRleHREZWNvZGVyOiBhbnk7XG5cbi8qKlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cjogc3RyaW5nKTogVWludDhBcnJheSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IEVycm9yKGBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAke3R5cGVvZiBzdHJ9YCk7XG4gIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cblxuLyoqXG4gKiBAZXhhbXBsZSBieXRlc1RvVXRmOChuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pKSAvLyAnYWJjJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb1V0ZjgoYnl0ZXM6IFVpbnQ4QXJyYXkpOiBzdHJpbmcge1xuICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGJ5dGVzKTtcbn1cblxuZXhwb3J0IHR5cGUgSW5wdXQgPSBVaW50OEFycmF5IHwgc3RyaW5nO1xuLyoqXG4gKiBOb3JtYWxpemVzIChub24taGV4KSBzdHJpbmcgb3IgVWludDhBcnJheSB0byBVaW50OEFycmF5LlxuICogV2FybmluZzogd2hlbiBVaW50OEFycmF5IGlzIHBhc3NlZCwgaXQgd291bGQgTk9UIGdldCBjb3BpZWQuXG4gKiBLZWVwIGluIG1pbmQgZm9yIGZ1dHVyZSBtdXRhYmxlIG9wZXJhdGlvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0J5dGVzKGRhdGE6IElucHV0KTogVWludDhBcnJheSB7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIGRhdGEgPSB1dGY4VG9CeXRlcyhkYXRhKTtcbiAgZWxzZSBpZiAoaXNCeXRlcyhkYXRhKSkgZGF0YSA9IGRhdGEuc2xpY2UoKTtcbiAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoYFVpbnQ4QXJyYXkgZXhwZWN0ZWQsIGdvdCAke3R5cGVvZiBkYXRhfWApO1xuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBDb3BpZXMgc2V2ZXJhbCBVaW50OEFycmF5cyBpbnRvIG9uZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5czogVWludDhBcnJheVtdKTogVWludDhBcnJheSB7XG4gIGxldCBzdW0gPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgYWJ5dGVzKGEpO1xuICAgIHN1bSArPSBhLmxlbmd0aDtcbiAgfVxuICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShzdW0pO1xuICBmb3IgKGxldCBpID0gMCwgcGFkID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgcmVzLnNldChhLCBwYWQpO1xuICAgIHBhZCArPSBhLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG50eXBlIEVtcHR5T2JqID0ge307XG5leHBvcnQgZnVuY3Rpb24gY2hlY2tPcHRzPFQxIGV4dGVuZHMgRW1wdHlPYmosIFQyIGV4dGVuZHMgRW1wdHlPYmo+KFxuICBkZWZhdWx0czogVDEsXG4gIG9wdHM6IFQyXG4pOiBUMSAmIFQyIHtcbiAgaWYgKG9wdHMgPT0gbnVsbCB8fCB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHRocm93IG5ldyBFcnJvcignb3B0aW9ucyBtdXN0IGJlIGRlZmluZWQnKTtcbiAgY29uc3QgbWVyZ2VkID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0cywgb3B0cyk7XG4gIHJldHVybiBtZXJnZWQgYXMgVDEgJiBUMjtcbn1cblxuLy8gQ29tcGFyZXMgMiB1OGEtcyBpbiBraW5kYSBjb25zdGFudCB0aW1lXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxCeXRlcyhhOiBVaW50OEFycmF5LCBiOiBVaW50OEFycmF5KSB7XG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgbGV0IGRpZmYgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIGRpZmYgfD0gYVtpXSBeIGJbaV07XG4gIHJldHVybiBkaWZmID09PSAwO1xufVxuXG4vLyBGb3IgcnVudGltZSBjaGVjayBpZiBjbGFzcyBpbXBsZW1lbnRzIGludGVyZmFjZVxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEhhc2g8VCBleHRlbmRzIEhhc2g8VD4+IHtcbiAgYWJzdHJhY3QgYmxvY2tMZW46IG51bWJlcjsgLy8gQnl0ZXMgcGVyIGJsb2NrXG4gIGFic3RyYWN0IG91dHB1dExlbjogbnVtYmVyOyAvLyBCeXRlcyBpbiBvdXRwdXRcbiAgYWJzdHJhY3QgdXBkYXRlKGJ1ZjogSW5wdXQpOiB0aGlzO1xuICAvLyBXcml0ZXMgZGlnZXN0IGludG8gYnVmXG4gIGFic3RyYWN0IGRpZ2VzdEludG8oYnVmOiBVaW50OEFycmF5KTogdm9pZDtcbiAgYWJzdHJhY3QgZGlnZXN0KCk6IFVpbnQ4QXJyYXk7XG4gIC8qKlxuICAgKiBSZXNldHMgaW50ZXJuYWwgc3RhdGUuIE1ha2VzIEhhc2ggaW5zdGFuY2UgdW51c2FibGUuXG4gICAqIFJlc2V0IGlzIGltcG9zc2libGUgZm9yIGtleWVkIGhhc2hlcyBpZiBrZXkgaXMgY29uc3VtZWQgaW50byBzdGF0ZS4gSWYgZGlnZXN0IGlzIG5vdCBjb25zdW1lZFxuICAgKiBieSB1c2VyLCB0aGV5IHdpbGwgbmVlZCB0byBtYW51YWxseSBjYWxsIGBkZXN0cm95KClgIHdoZW4gemVyb2luZyBpcyBuZWNlc3NhcnkuXG4gICAqL1xuICBhYnN0cmFjdCBkZXN0cm95KCk6IHZvaWQ7XG59XG5cbi8vIFRoaXMgd2lsbCBhbGxvdyB0byByZS11c2Ugd2l0aCBjb21wb3NhYmxlIHRoaW5ncyBsaWtlIHBhY2tlZCAmIGJhc2UgZW5jb2RlcnNcbi8vIEFsc28sIHdlIHByb2JhYmx5IGNhbiBtYWtlIHRhZ3MgY29tcG9zYWJsZVxuZXhwb3J0IHR5cGUgQ2lwaGVyID0ge1xuICBlbmNyeXB0KHBsYWludGV4dDogVWludDhBcnJheSk6IFVpbnQ4QXJyYXk7XG4gIGRlY3J5cHQoY2lwaGVydGV4dDogVWludDhBcnJheSk6IFVpbnQ4QXJyYXk7XG59O1xuXG5leHBvcnQgdHlwZSBBc3luY0NpcGhlciA9IHtcbiAgZW5jcnlwdChwbGFpbnRleHQ6IFVpbnQ4QXJyYXkpOiBQcm9taXNlPFVpbnQ4QXJyYXk+O1xuICBkZWNyeXB0KGNpcGhlcnRleHQ6IFVpbnQ4QXJyYXkpOiBQcm9taXNlPFVpbnQ4QXJyYXk+O1xufTtcblxuZXhwb3J0IHR5cGUgQ2lwaGVyV2l0aE91dHB1dCA9IENpcGhlciAmIHtcbiAgZW5jcnlwdChwbGFpbnRleHQ6IFVpbnQ4QXJyYXksIG91dHB1dD86IFVpbnQ4QXJyYXkpOiBVaW50OEFycmF5O1xuICBkZWNyeXB0KGNpcGhlcnRleHQ6IFVpbnQ4QXJyYXksIG91dHB1dD86IFVpbnQ4QXJyYXkpOiBVaW50OEFycmF5O1xufTtcblxuLy8gUGFyYW1zIGlzIG91dHNpZGUgcmV0dXJuIHR5cGUsIHNvIGl0IGlzIGFjY2Vzc2libGUgYmVmb3JlIGNhbGxpbmcgY29uc3RydWN0b3Jcbi8vIElmIGZ1bmN0aW9uIHN1cHBvcnQgbXVsdGlwbGUgbm9uY2VMZW5ndGgncywgd2UgcmV0dXJuIGJlc3Qgb25lXG5leHBvcnQgdHlwZSBDaXBoZXJQYXJhbXMgPSB7IGJsb2NrU2l6ZTogbnVtYmVyOyBub25jZUxlbmd0aD86IG51bWJlcjsgdGFnTGVuZ3RoPzogbnVtYmVyIH07XG5leHBvcnQgdHlwZSBDaXBoZXJDb25zPFQgZXh0ZW5kcyBhbnlbXT4gPSAoa2V5OiBVaW50OEFycmF5LCAuLi5hcmdzOiBUKSA9PiBDaXBoZXI7XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmV4cG9ydCBjb25zdCB3cmFwQ2lwaGVyID0gPEMgZXh0ZW5kcyBDaXBoZXJDb25zPGFueT4sIFAgZXh0ZW5kcyBDaXBoZXJQYXJhbXM+KFxuICBwYXJhbXM6IFAsXG4gIGM6IENcbik6IEMgJiBQID0+IHtcbiAgT2JqZWN0LmFzc2lnbihjLCBwYXJhbXMpO1xuICByZXR1cm4gYyBhcyBDICYgUDtcbn07XG5cbmV4cG9ydCB0eXBlIFhvclN0cmVhbSA9IChcbiAga2V5OiBVaW50OEFycmF5LFxuICBub25jZTogVWludDhBcnJheSxcbiAgZGF0YTogVWludDhBcnJheSxcbiAgb3V0cHV0PzogVWludDhBcnJheSxcbiAgY291bnRlcj86IG51bWJlclxuKSA9PiBVaW50OEFycmF5O1xuXG4vLyBQb2x5ZmlsbCBmb3IgU2FmYXJpIDE0XG5leHBvcnQgZnVuY3Rpb24gc2V0QmlnVWludDY0KFxuICB2aWV3OiBEYXRhVmlldyxcbiAgYnl0ZU9mZnNldDogbnVtYmVyLFxuICB2YWx1ZTogYmlnaW50LFxuICBpc0xFOiBib29sZWFuXG4pOiB2b2lkIHtcbiAgaWYgKHR5cGVvZiB2aWV3LnNldEJpZ1VpbnQ2NCA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHZpZXcuc2V0QmlnVWludDY0KGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKTtcbiAgY29uc3QgXzMybiA9IEJpZ0ludCgzMik7XG4gIGNvbnN0IF91MzJfbWF4ID0gQmlnSW50KDB4ZmZmZmZmZmYpO1xuICBjb25zdCB3aCA9IE51bWJlcigodmFsdWUgPj4gXzMybikgJiBfdTMyX21heCk7XG4gIGNvbnN0IHdsID0gTnVtYmVyKHZhbHVlICYgX3UzMl9tYXgpO1xuICBjb25zdCBoID0gaXNMRSA/IDQgOiAwO1xuICBjb25zdCBsID0gaXNMRSA/IDAgOiA0O1xuICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgaCwgd2gsIGlzTEUpO1xuICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgbCwgd2wsIGlzTEUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdTY0TGVuZ3RocyhjaXBoZXJ0ZXh0OiBVaW50OEFycmF5LCBBQUQ/OiBVaW50OEFycmF5KSB7XG4gIGNvbnN0IG51bSA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgY29uc3QgdmlldyA9IGNyZWF0ZVZpZXcobnVtKTtcbiAgc2V0QmlnVWludDY0KHZpZXcsIDAsIEJpZ0ludChBQUQgPyBBQUQubGVuZ3RoIDogMCksIHRydWUpO1xuICBzZXRCaWdVaW50NjQodmlldywgOCwgQmlnSW50KGNpcGhlcnRleHQubGVuZ3RoKSwgdHJ1ZSk7XG4gIHJldHVybiBudW07XG59XG4iLCAiaW1wb3J0IHsgY3JlYXRlVmlldywgdG9CeXRlcywgSW5wdXQsIEhhc2gsIHUzMiB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgYnl0ZXMgYXMgYWJ5dGVzLCBleGlzdHMgYXMgYWV4aXN0cywgb3V0cHV0IGFzIGFvdXRwdXQgfSBmcm9tICcuL19hc3NlcnQuanMnO1xuXG4vLyBHSGFzaCBmcm9tIEFFUy1HQ00gYW5kIGl0cyBsaXR0bGUtZW5kaWFuIFwibWlycm9yIGltYWdlXCIgUG9seXZhbCBmcm9tIEFFUy1TSVYuXG4vLyBJbXBsZW1lbnRlZCBpbiB0ZXJtcyBvZiBHSGFzaCB3aXRoIGNvbnZlcnNpb24gZnVuY3Rpb24gZm9yIGtleXNcbi8vIEdDTSBHSEFTSCBmcm9tIE5JU1QgU1A4MDAtMzhkLCBTSVYgZnJvbSBSRkMgODQ1Mi5cbi8vIGh0dHBzOi8vbnZscHVicy5uaXN0Lmdvdi9uaXN0cHVicy9MZWdhY3kvU1AvbmlzdHNwZWNpYWxwdWJsaWNhdGlvbjgwMC0zOGQucGRmXG5cbi8vIEdIQVNIICAgbW9kdWxvOiB4XjEyOCArIHheNyAgICsgeF4yICAgKyB4ICAgICArIDFcbi8vIFBPTFlWQUwgbW9kdWxvOiB4XjEyOCArIHheMTI3ICsgeF4xMjYgKyB4XjEyMSArIDFcblxuY29uc3QgQkxPQ0tfU0laRSA9IDE2O1xuLy8gVE9ETzogcmV3cml0ZVxuLy8gdGVtcG9yYXJ5IHBhZGRpbmcgYnVmZmVyXG5jb25zdCBaRVJPUzE2ID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50OEFycmF5KDE2KTtcbmNvbnN0IFpFUk9TMzIgPSB1MzIoWkVST1MxNik7XG5jb25zdCBQT0xZID0gMHhlMTsgLy8gdiA9IDIqdiAlIFBPTFlcblxuLy8gdiA9IDIqdiAlIFBPTFlcbi8vIE5PVEU6IGJlY2F1c2UgeCArIHggPSAwIChhZGQvc3ViIGlzIHNhbWUpLCBtdWwyKHgpICE9IHgreFxuLy8gV2UgY2FuIG11bHRpcGx5IGFueSBudW1iZXIgdXNpbmcgbW9udGdvbWVyeSBsYWRkZXIgYW5kIHRoaXMgZnVuY3Rpb24gKHdvcmtzIGFzIGRvdWJsZSwgYWRkIGlzIHNpbXBsZSB4b3IpXG5jb25zdCBtdWwyID0gKHMwOiBudW1iZXIsIHMxOiBudW1iZXIsIHMyOiBudW1iZXIsIHMzOiBudW1iZXIpID0+IHtcbiAgY29uc3QgaGlCaXQgPSBzMyAmIDE7XG4gIHJldHVybiB7XG4gICAgczM6IChzMiA8PCAzMSkgfCAoczMgPj4+IDEpLFxuICAgIHMyOiAoczEgPDwgMzEpIHwgKHMyID4+PiAxKSxcbiAgICBzMTogKHMwIDw8IDMxKSB8IChzMSA+Pj4gMSksXG4gICAgczA6IChzMCA+Pj4gMSkgXiAoKFBPTFkgPDwgMjQpICYgLShoaUJpdCAmIDEpKSwgLy8gcmVkdWNlICUgcG9seVxuICB9O1xufTtcblxuY29uc3Qgc3dhcExFID0gKG46IG51bWJlcikgPT5cbiAgKCgobiA+Pj4gMCkgJiAweGZmKSA8PCAyNCkgfFxuICAoKChuID4+PiA4KSAmIDB4ZmYpIDw8IDE2KSB8XG4gICgoKG4gPj4+IDE2KSAmIDB4ZmYpIDw8IDgpIHxcbiAgKChuID4+PiAyNCkgJiAweGZmKSB8XG4gIDA7XG5cbi8qKlxuICogYG11bFhfUE9MWVZBTChCeXRlUmV2ZXJzZShIKSlgIGZyb20gc3BlY1xuICogQHBhcmFtIGsgbXV0YXRlZCBpbiBwbGFjZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX3RvR0hBU0hLZXkoazogVWludDhBcnJheSk6IFVpbnQ4QXJyYXkge1xuICBrLnJldmVyc2UoKTtcbiAgY29uc3QgaGlCaXQgPSBrWzE1XSAmIDE7XG4gIC8vIGsgPj49IDFcbiAgbGV0IGNhcnJ5ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdCA9IGtbaV07XG4gICAga1tpXSA9ICh0ID4+PiAxKSB8IGNhcnJ5O1xuICAgIGNhcnJ5ID0gKHQgJiAxKSA8PCA3O1xuICB9XG4gIGtbMF0gXj0gLWhpQml0ICYgMHhlMTsgLy8gaWYgKGhpQml0KSBuIF49IDB4ZTEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA7XG4gIHJldHVybiBrO1xufVxuXG50eXBlIFZhbHVlID0geyBzMDogbnVtYmVyOyBzMTogbnVtYmVyOyBzMjogbnVtYmVyOyBzMzogbnVtYmVyIH07XG5cbmNvbnN0IGVzdGltYXRlV2luZG93ID0gKGJ5dGVzOiBudW1iZXIpID0+IHtcbiAgaWYgKGJ5dGVzID4gNjQgKiAxMDI0KSByZXR1cm4gODtcbiAgaWYgKGJ5dGVzID4gMTAyNCkgcmV0dXJuIDQ7XG4gIHJldHVybiAyO1xufTtcblxuY2xhc3MgR0hBU0ggaW1wbGVtZW50cyBIYXNoPEdIQVNIPiB7XG4gIHJlYWRvbmx5IGJsb2NrTGVuID0gQkxPQ0tfU0laRTtcbiAgcmVhZG9ubHkgb3V0cHV0TGVuID0gQkxPQ0tfU0laRTtcbiAgcHJvdGVjdGVkIHMwID0gMDtcbiAgcHJvdGVjdGVkIHMxID0gMDtcbiAgcHJvdGVjdGVkIHMyID0gMDtcbiAgcHJvdGVjdGVkIHMzID0gMDtcbiAgcHJvdGVjdGVkIGZpbmlzaGVkID0gZmFsc2U7XG4gIHByb3RlY3RlZCB0OiBWYWx1ZVtdO1xuICBwcml2YXRlIFc6IG51bWJlcjtcbiAgcHJpdmF0ZSB3aW5kb3dTaXplOiBudW1iZXI7XG4gIC8vIFdlIHNlbGVjdCBiaXRzIHBlciB3aW5kb3cgYWRhcHRpdmVseSBiYXNlZCBvbiBleHBlY3RlZExlbmd0aFxuICBjb25zdHJ1Y3RvcihrZXk6IElucHV0LCBleHBlY3RlZExlbmd0aD86IG51bWJlcikge1xuICAgIGtleSA9IHRvQnl0ZXMoa2V5KTtcbiAgICBhYnl0ZXMoa2V5LCAxNik7XG4gICAgY29uc3Qga1ZpZXcgPSBjcmVhdGVWaWV3KGtleSk7XG4gICAgbGV0IGswID0ga1ZpZXcuZ2V0VWludDMyKDAsIGZhbHNlKTtcbiAgICBsZXQgazEgPSBrVmlldy5nZXRVaW50MzIoNCwgZmFsc2UpO1xuICAgIGxldCBrMiA9IGtWaWV3LmdldFVpbnQzMig4LCBmYWxzZSk7XG4gICAgbGV0IGszID0ga1ZpZXcuZ2V0VWludDMyKDEyLCBmYWxzZSk7XG4gICAgLy8gZ2VuZXJhdGUgdGFibGUgb2YgZG91YmxlZCBrZXlzIChoYWxmIG9mIG1vbnRnb21lcnkgbGFkZGVyKVxuICAgIGNvbnN0IGRvdWJsZXM6IFZhbHVlW10gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEyODsgaSsrKSB7XG4gICAgICBkb3VibGVzLnB1c2goeyBzMDogc3dhcExFKGswKSwgczE6IHN3YXBMRShrMSksIHMyOiBzd2FwTEUoazIpLCBzMzogc3dhcExFKGszKSB9KTtcbiAgICAgICh7IHMwOiBrMCwgczE6IGsxLCBzMjogazIsIHMzOiBrMyB9ID0gbXVsMihrMCwgazEsIGsyLCBrMykpO1xuICAgIH1cbiAgICBjb25zdCBXID0gZXN0aW1hdGVXaW5kb3coZXhwZWN0ZWRMZW5ndGggfHwgMTAyNCk7XG4gICAgaWYgKCFbMSwgMiwgNCwgOF0uaW5jbHVkZXMoVykpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGdoYXNoOiB3cm9uZyB3aW5kb3cgc2l6ZT0ke1d9LCBzaG91bGQgYmUgMiwgNCBvciA4YCk7XG4gICAgdGhpcy5XID0gVztcbiAgICBjb25zdCBiaXRzID0gMTI4OyAvLyBhbHdheXMgMTI4IGJpdHM7XG4gICAgY29uc3Qgd2luZG93cyA9IGJpdHMgLyBXO1xuICAgIGNvbnN0IHdpbmRvd1NpemUgPSAodGhpcy53aW5kb3dTaXplID0gMiAqKiBXKTtcbiAgICBjb25zdCBpdGVtczogVmFsdWVbXSA9IFtdO1xuICAgIC8vIENyZWF0ZSBwcmVjb21wdXRlIHRhYmxlIGZvciB3aW5kb3cgb2YgVyBiaXRzXG4gICAgZm9yIChsZXQgdyA9IDA7IHcgPCB3aW5kb3dzOyB3KyspIHtcbiAgICAgIC8vIHRydXRoIHRhYmxlOiAwMCwgMDEsIDEwLCAxMVxuICAgICAgZm9yIChsZXQgYnl0ZSA9IDA7IGJ5dGUgPCB3aW5kb3dTaXplOyBieXRlKyspIHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGxldCBzMCA9IDAsIHMxID0gMCwgczIgPSAwLCBzMyA9IDA7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgVzsgaisrKSB7XG4gICAgICAgICAgY29uc3QgYml0ID0gKGJ5dGUgPj4+IChXIC0gaiAtIDEpKSAmIDE7XG4gICAgICAgICAgaWYgKCFiaXQpIGNvbnRpbnVlO1xuICAgICAgICAgIGNvbnN0IHsgczA6IGQwLCBzMTogZDEsIHMyOiBkMiwgczM6IGQzIH0gPSBkb3VibGVzW1cgKiB3ICsgal07XG4gICAgICAgICAgKHMwIF49IGQwKSwgKHMxIF49IGQxKSwgKHMyIF49IGQyKSwgKHMzIF49IGQzKTtcbiAgICAgICAgfVxuICAgICAgICBpdGVtcy5wdXNoKHsgczAsIHMxLCBzMiwgczMgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudCA9IGl0ZW1zO1xuICB9XG4gIHByb3RlY3RlZCBfdXBkYXRlQmxvY2soczA6IG51bWJlciwgczE6IG51bWJlciwgczI6IG51bWJlciwgczM6IG51bWJlcikge1xuICAgIChzMCBePSB0aGlzLnMwKSwgKHMxIF49IHRoaXMuczEpLCAoczIgXj0gdGhpcy5zMiksIChzMyBePSB0aGlzLnMzKTtcbiAgICBjb25zdCB7IFcsIHQsIHdpbmRvd1NpemUgfSA9IHRoaXM7XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgbGV0IG8wID0gMCwgbzEgPSAwLCBvMiA9IDAsIG8zID0gMDtcbiAgICBjb25zdCBtYXNrID0gKDEgPDwgVykgLSAxOyAvLyAyKipXIHdpbGwga2lsbCBwZXJmb3JtYW5jZS5cbiAgICBsZXQgdyA9IDA7XG4gICAgZm9yIChjb25zdCBudW0gb2YgW3MwLCBzMSwgczIsIHMzXSkge1xuICAgICAgZm9yIChsZXQgYnl0ZVBvcyA9IDA7IGJ5dGVQb3MgPCA0OyBieXRlUG9zKyspIHtcbiAgICAgICAgY29uc3QgYnl0ZSA9IChudW0gPj4+ICg4ICogYnl0ZVBvcykpICYgMHhmZjtcbiAgICAgICAgZm9yIChsZXQgYml0UG9zID0gOCAvIFcgLSAxOyBiaXRQb3MgPj0gMDsgYml0UG9zLS0pIHtcbiAgICAgICAgICBjb25zdCBiaXQgPSAoYnl0ZSA+Pj4gKFcgKiBiaXRQb3MpKSAmIG1hc2s7XG4gICAgICAgICAgY29uc3QgeyBzMDogZTAsIHMxOiBlMSwgczI6IGUyLCBzMzogZTMgfSA9IHRbdyAqIHdpbmRvd1NpemUgKyBiaXRdO1xuICAgICAgICAgIChvMCBePSBlMCksIChvMSBePSBlMSksIChvMiBePSBlMiksIChvMyBePSBlMyk7XG4gICAgICAgICAgdyArPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuczAgPSBvMDtcbiAgICB0aGlzLnMxID0gbzE7XG4gICAgdGhpcy5zMiA9IG8yO1xuICAgIHRoaXMuczMgPSBvMztcbiAgfVxuICB1cGRhdGUoZGF0YTogSW5wdXQpOiB0aGlzIHtcbiAgICBkYXRhID0gdG9CeXRlcyhkYXRhKTtcbiAgICBhZXhpc3RzKHRoaXMpO1xuICAgIGNvbnN0IGIzMiA9IHUzMihkYXRhKTtcbiAgICBjb25zdCBibG9ja3MgPSBNYXRoLmZsb29yKGRhdGEubGVuZ3RoIC8gQkxPQ0tfU0laRSk7XG4gICAgY29uc3QgbGVmdCA9IGRhdGEubGVuZ3RoICUgQkxPQ0tfU0laRTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsb2NrczsgaSsrKSB7XG4gICAgICB0aGlzLl91cGRhdGVCbG9jayhiMzJbaSAqIDQgKyAwXSwgYjMyW2kgKiA0ICsgMV0sIGIzMltpICogNCArIDJdLCBiMzJbaSAqIDQgKyAzXSk7XG4gICAgfVxuICAgIGlmIChsZWZ0KSB7XG4gICAgICBaRVJPUzE2LnNldChkYXRhLnN1YmFycmF5KGJsb2NrcyAqIEJMT0NLX1NJWkUpKTtcbiAgICAgIHRoaXMuX3VwZGF0ZUJsb2NrKFpFUk9TMzJbMF0sIFpFUk9TMzJbMV0sIFpFUk9TMzJbMl0sIFpFUk9TMzJbM10pO1xuICAgICAgWkVST1MzMi5maWxsKDApOyAvLyBjbGVhbiB0bXAgYnVmZmVyXG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgY29uc3QgeyB0IH0gPSB0aGlzO1xuICAgIC8vIGNsZWFuIHByZWNvbXB1dGUgdGFibGVcbiAgICBmb3IgKGNvbnN0IGVsbSBvZiB0KSB7XG4gICAgICAoZWxtLnMwID0gMCksIChlbG0uczEgPSAwKSwgKGVsbS5zMiA9IDApLCAoZWxtLnMzID0gMCk7XG4gICAgfVxuICB9XG4gIGRpZ2VzdEludG8ob3V0OiBVaW50OEFycmF5KSB7XG4gICAgYWV4aXN0cyh0aGlzKTtcbiAgICBhb3V0cHV0KG91dCwgdGhpcyk7XG4gICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgY29uc3QgeyBzMCwgczEsIHMyLCBzMyB9ID0gdGhpcztcbiAgICBjb25zdCBvMzIgPSB1MzIob3V0KTtcbiAgICBvMzJbMF0gPSBzMDtcbiAgICBvMzJbMV0gPSBzMTtcbiAgICBvMzJbMl0gPSBzMjtcbiAgICBvMzJbM10gPSBzMztcbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIGRpZ2VzdCgpOiBVaW50OEFycmF5IHtcbiAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShCTE9DS19TSVpFKTtcbiAgICB0aGlzLmRpZ2VzdEludG8ocmVzKTtcbiAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG59XG5cbmNsYXNzIFBvbHl2YWwgZXh0ZW5kcyBHSEFTSCB7XG4gIGNvbnN0cnVjdG9yKGtleTogSW5wdXQsIGV4cGVjdGVkTGVuZ3RoPzogbnVtYmVyKSB7XG4gICAga2V5ID0gdG9CeXRlcyhrZXkpO1xuICAgIGNvbnN0IGdoS2V5ID0gX3RvR0hBU0hLZXkoa2V5LnNsaWNlKCkpO1xuICAgIHN1cGVyKGdoS2V5LCBleHBlY3RlZExlbmd0aCk7XG4gICAgZ2hLZXkuZmlsbCgwKTtcbiAgfVxuICB1cGRhdGUoZGF0YTogSW5wdXQpOiB0aGlzIHtcbiAgICBkYXRhID0gdG9CeXRlcyhkYXRhKTtcbiAgICBhZXhpc3RzKHRoaXMpO1xuICAgIGNvbnN0IGIzMiA9IHUzMihkYXRhKTtcbiAgICBjb25zdCBsZWZ0ID0gZGF0YS5sZW5ndGggJSBCTE9DS19TSVpFO1xuICAgIGNvbnN0IGJsb2NrcyA9IE1hdGguZmxvb3IoZGF0YS5sZW5ndGggLyBCTE9DS19TSVpFKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsb2NrczsgaSsrKSB7XG4gICAgICB0aGlzLl91cGRhdGVCbG9jayhcbiAgICAgICAgc3dhcExFKGIzMltpICogNCArIDNdKSxcbiAgICAgICAgc3dhcExFKGIzMltpICogNCArIDJdKSxcbiAgICAgICAgc3dhcExFKGIzMltpICogNCArIDFdKSxcbiAgICAgICAgc3dhcExFKGIzMltpICogNCArIDBdKVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGxlZnQpIHtcbiAgICAgIFpFUk9TMTYuc2V0KGRhdGEuc3ViYXJyYXkoYmxvY2tzICogQkxPQ0tfU0laRSkpO1xuICAgICAgdGhpcy5fdXBkYXRlQmxvY2soXG4gICAgICAgIHN3YXBMRShaRVJPUzMyWzNdKSxcbiAgICAgICAgc3dhcExFKFpFUk9TMzJbMl0pLFxuICAgICAgICBzd2FwTEUoWkVST1MzMlsxXSksXG4gICAgICAgIHN3YXBMRShaRVJPUzMyWzBdKVxuICAgICAgKTtcbiAgICAgIFpFUk9TMzIuZmlsbCgwKTsgLy8gY2xlYW4gdG1wIGJ1ZmZlclxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBkaWdlc3RJbnRvKG91dDogVWludDhBcnJheSkge1xuICAgIGFleGlzdHModGhpcyk7XG4gICAgYW91dHB1dChvdXQsIHRoaXMpO1xuICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgIC8vIHRtcCB1Z2x5IGhhY2tcbiAgICBjb25zdCB7IHMwLCBzMSwgczIsIHMzIH0gPSB0aGlzO1xuICAgIGNvbnN0IG8zMiA9IHUzMihvdXQpO1xuICAgIG8zMlswXSA9IHMwO1xuICAgIG8zMlsxXSA9IHMxO1xuICAgIG8zMlsyXSA9IHMyO1xuICAgIG8zMlszXSA9IHMzO1xuICAgIHJldHVybiBvdXQucmV2ZXJzZSgpO1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIENIYXNoID0gUmV0dXJuVHlwZTx0eXBlb2Ygd3JhcENvbnN0cnVjdG9yV2l0aEtleT47XG5mdW5jdGlvbiB3cmFwQ29uc3RydWN0b3JXaXRoS2V5PEggZXh0ZW5kcyBIYXNoPEg+PihcbiAgaGFzaENvbnM6IChrZXk6IElucHV0LCBleHBlY3RlZExlbmd0aD86IG51bWJlcikgPT4gSGFzaDxIPlxuKSB7XG4gIGNvbnN0IGhhc2hDID0gKG1zZzogSW5wdXQsIGtleTogSW5wdXQpOiBVaW50OEFycmF5ID0+XG4gICAgaGFzaENvbnMoa2V5LCBtc2cubGVuZ3RoKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgY29uc3QgdG1wID0gaGFzaENvbnMobmV3IFVpbnQ4QXJyYXkoMTYpLCAwKTtcbiAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gIGhhc2hDLmNyZWF0ZSA9IChrZXk6IElucHV0LCBleHBlY3RlZExlbmd0aD86IG51bWJlcikgPT4gaGFzaENvbnMoa2V5LCBleHBlY3RlZExlbmd0aCk7XG4gIHJldHVybiBoYXNoQztcbn1cblxuZXhwb3J0IGNvbnN0IGdoYXNoID0gd3JhcENvbnN0cnVjdG9yV2l0aEtleShcbiAgKGtleSwgZXhwZWN0ZWRMZW5ndGgpID0+IG5ldyBHSEFTSChrZXksIGV4cGVjdGVkTGVuZ3RoKVxuKTtcbmV4cG9ydCBjb25zdCBwb2x5dmFsID0gd3JhcENvbnN0cnVjdG9yV2l0aEtleShcbiAgKGtleSwgZXhwZWN0ZWRMZW5ndGgpID0+IG5ldyBQb2x5dmFsKGtleSwgZXhwZWN0ZWRMZW5ndGgpXG4pO1xuIiwgIi8vIHByZXR0aWVyLWlnbm9yZVxuaW1wb3J0IHtcbiAgd3JhcENpcGhlciwgQ2lwaGVyLCBDaXBoZXJXaXRoT3V0cHV0LFxuICBjcmVhdGVWaWV3LCBzZXRCaWdVaW50NjQsIGVxdWFsQnl0ZXMsIHUzMiwgdTgsXG59IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgZ2hhc2gsIHBvbHl2YWwgfSBmcm9tICcuL19wb2x5dmFsLmpzJztcbmltcG9ydCB7IGJ5dGVzIGFzIGFieXRlcyB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5cbi8qXG5BRVMgKEFkdmFuY2VkIEVuY3J5cHRpb24gU3RhbmRhcmQpIGFrYSBSaWpuZGFlbCBibG9jayBjaXBoZXIuXG5cbkRhdGEgaXMgc3BsaXQgaW50byAxMjgtYml0IGJsb2Nrcy4gRW5jcnlwdGVkIGluIDEwLzEyLzE0IHJvdW5kcyAoMTI4LzE5Mi8yNTYgYml0cykuIEluIGV2ZXJ5IHJvdW5kOlxuMS4gKipTLWJveCoqLCB0YWJsZSBzdWJzdGl0dXRpb25cbjIuICoqU2hpZnQgcm93cyoqLCBjeWNsaWMgc2hpZnQgbGVmdCBvZiBhbGwgcm93cyBvZiBkYXRhIGFycmF5XG4zLiAqKk1peCBjb2x1bW5zKiosIG11bHRpcGx5aW5nIGV2ZXJ5IGNvbHVtbiBieSBmaXhlZCBwb2x5bm9taWFsXG40LiAqKkFkZCByb3VuZCBrZXkqKiwgcm91bmRfa2V5IHhvciBpLXRoIGNvbHVtbiBvZiBhcnJheVxuXG5SZXNvdXJjZXM6XG4tIEZJUFMtMTk3IGh0dHBzOi8vY3NyYy5uaXN0Lmdvdi9maWxlcy9wdWJzL2ZpcHMvMTk3L2ZpbmFsL2RvY3MvZmlwcy0xOTcucGRmXG4tIE9yaWdpbmFsIHByb3Bvc2FsOiBodHRwczovL2NzcmMubmlzdC5nb3YvY3NyYy9tZWRpYS9wcm9qZWN0cy9jcnlwdG9ncmFwaGljLXN0YW5kYXJkcy1hbmQtZ3VpZGVsaW5lcy9kb2N1bWVudHMvYWVzLWRldmVsb3BtZW50L3Jpam5kYWVsLWFtbWVuZGVkLnBkZlxuKi9cblxuY29uc3QgQkxPQ0tfU0laRSA9IDE2O1xuY29uc3QgQkxPQ0tfU0laRTMyID0gNDtcbmNvbnN0IEVNUFRZX0JMT0NLID0gbmV3IFVpbnQ4QXJyYXkoQkxPQ0tfU0laRSk7XG5jb25zdCBQT0xZID0gMHgxMWI7IC8vIDEgKyB4ICsgeCoqMyArIHgqKjQgKyB4Kio4XG5cbi8vIFRPRE86IHJlbW92ZSBtdWx0aXBsaWNhdGlvbiwgYmluYXJ5IG9wcyBvbmx5XG5mdW5jdGlvbiBtdWwyKG46IG51bWJlcikge1xuICByZXR1cm4gKG4gPDwgMSkgXiAoUE9MWSAmIC0obiA+PiA3KSk7XG59XG5cbmZ1bmN0aW9uIG11bChhOiBudW1iZXIsIGI6IG51bWJlcikge1xuICBsZXQgcmVzID0gMDtcbiAgZm9yICg7IGIgPiAwOyBiID4+PSAxKSB7XG4gICAgLy8gTW9udGdvbWVyeSBsYWRkZXJcbiAgICByZXMgXj0gYSAmIC0oYiAmIDEpOyAvLyBpZiAoYiYxKSByZXMgXj1hIChidXQgY29uc3QtdGltZSkuXG4gICAgYSA9IG11bDIoYSk7IC8vIGEgPSAyKmFcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vLyBBRVMgUy1ib3ggaXMgZ2VuZXJhdGVkIHVzaW5nIGZpbml0ZSBmaWVsZCBpbnZlcnNpb24sXG4vLyBhbiBhZmZpbmUgdHJhbnNmb3JtLCBhbmQgeG9yIG9mIGEgY29uc3RhbnQgMHg2My5cbmNvbnN0IHNib3ggPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHtcbiAgbGV0IHQgPSBuZXcgVWludDhBcnJheSgyNTYpO1xuICBmb3IgKGxldCBpID0gMCwgeCA9IDE7IGkgPCAyNTY7IGkrKywgeCBePSBtdWwyKHgpKSB0W2ldID0geDtcbiAgY29uc3QgYm94ID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbiAgYm94WzBdID0gMHg2MzsgLy8gZmlyc3QgZWxtXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMjU1OyBpKyspIHtcbiAgICBsZXQgeCA9IHRbMjU1IC0gaV07XG4gICAgeCB8PSB4IDw8IDg7XG4gICAgYm94W3RbaV1dID0gKHggXiAoeCA+PiA0KSBeICh4ID4+IDUpIF4gKHggPj4gNikgXiAoeCA+PiA3KSBeIDB4NjMpICYgMHhmZjtcbiAgfVxuICByZXR1cm4gYm94O1xufSkoKTtcblxuLy8gSW52ZXJ0ZWQgUy1ib3hcbmNvbnN0IGludlNib3ggPSAvKiBAX19QVVJFX18gKi8gc2JveC5tYXAoKF8sIGopID0+IHNib3guaW5kZXhPZihqKSk7XG5cbi8vIFJvdGF0ZSB1MzIgYnkgOFxuY29uc3Qgcm90cjMyXzggPSAobjogbnVtYmVyKSA9PiAobiA8PCAyNCkgfCAobiA+Pj4gOCk7XG5jb25zdCByb3RsMzJfOCA9IChuOiBudW1iZXIpID0+IChuIDw8IDgpIHwgKG4gPj4+IDI0KTtcblxuLy8gVC10YWJsZSBpcyBvcHRpbWl6YXRpb24gc3VnZ2VzdGVkIGluIDUuMiBvZiBvcmlnaW5hbCBwcm9wb3NhbCAobWlzc2VkIGZyb20gRklQUy0xOTcpLiBDaGFuZ2VzOlxuLy8gLSBMRSBpbnN0ZWFkIG9mIEJFXG4vLyAtIGJpZ2dlciB0YWJsZXM6IFQwIGFuZCBUMSBhcmUgbWVyZ2VkIGludG8gVDAxIHRhYmxlIGFuZCBUMiAmIFQzIGludG8gVDIzO1xuLy8gICBzbyBpbmRleCBpcyB1MTYsIGluc3RlYWQgb2YgdTguIFRoaXMgc3BlZWRzIHVwIHRoaW5ncywgdW5leHBlY3RlZGx5XG5mdW5jdGlvbiBnZW5UdGFibGUoc2JveDogVWludDhBcnJheSwgZm46IChuOiBudW1iZXIpID0+IG51bWJlcikge1xuICBpZiAoc2JveC5sZW5ndGggIT09IDI1NikgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyBzYm94IGxlbmd0aCcpO1xuICBjb25zdCBUMCA9IG5ldyBVaW50MzJBcnJheSgyNTYpLm1hcCgoXywgaikgPT4gZm4oc2JveFtqXSkpO1xuICBjb25zdCBUMSA9IFQwLm1hcChyb3RsMzJfOCk7XG4gIGNvbnN0IFQyID0gVDEubWFwKHJvdGwzMl84KTtcbiAgY29uc3QgVDMgPSBUMi5tYXAocm90bDMyXzgpO1xuICBjb25zdCBUMDEgPSBuZXcgVWludDMyQXJyYXkoMjU2ICogMjU2KTtcbiAgY29uc3QgVDIzID0gbmV3IFVpbnQzMkFycmF5KDI1NiAqIDI1Nik7XG4gIGNvbnN0IHNib3gyID0gbmV3IFVpbnQxNkFycmF5KDI1NiAqIDI1Nik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IDI1NjsgaisrKSB7XG4gICAgICBjb25zdCBpZHggPSBpICogMjU2ICsgajtcbiAgICAgIFQwMVtpZHhdID0gVDBbaV0gXiBUMVtqXTtcbiAgICAgIFQyM1tpZHhdID0gVDJbaV0gXiBUM1tqXTtcbiAgICAgIHNib3gyW2lkeF0gPSAoc2JveFtpXSA8PCA4KSB8IHNib3hbal07XG4gICAgfVxuICB9XG4gIHJldHVybiB7IHNib3gsIHNib3gyLCBUMCwgVDEsIFQyLCBUMywgVDAxLCBUMjMgfTtcbn1cblxuY29uc3QgdGFibGVFbmNvZGluZyA9IC8qIEBfX1BVUkVfXyAqLyBnZW5UdGFibGUoXG4gIHNib3gsXG4gIChzOiBudW1iZXIpID0+IChtdWwocywgMykgPDwgMjQpIHwgKHMgPDwgMTYpIHwgKHMgPDwgOCkgfCBtdWwocywgMilcbik7XG5jb25zdCB0YWJsZURlY29kaW5nID0gLyogQF9fUFVSRV9fICovIGdlblR0YWJsZShcbiAgaW52U2JveCxcbiAgKHMpID0+IChtdWwocywgMTEpIDw8IDI0KSB8IChtdWwocywgMTMpIDw8IDE2KSB8IChtdWwocywgOSkgPDwgOCkgfCBtdWwocywgMTQpXG4pO1xuXG5jb25zdCB4UG93ZXJzID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB7XG4gIGNvbnN0IHAgPSBuZXcgVWludDhBcnJheSgxNik7XG4gIGZvciAobGV0IGkgPSAwLCB4ID0gMTsgaSA8IDE2OyBpKyssIHggPSBtdWwyKHgpKSBwW2ldID0geDtcbiAgcmV0dXJuIHA7XG59KSgpO1xuXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kS2V5TEUoa2V5OiBVaW50OEFycmF5KTogVWludDMyQXJyYXkge1xuICBhYnl0ZXMoa2V5KTtcbiAgY29uc3QgbGVuID0ga2V5Lmxlbmd0aDtcbiAgaWYgKCFbMTYsIDI0LCAzMl0uaW5jbHVkZXMobGVuKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGFlczogd3Jvbmcga2V5IHNpemU6IHNob3VsZCBiZSAxNiwgMjQgb3IgMzIsIGdvdDogJHtsZW59YCk7XG4gIGNvbnN0IHsgc2JveDIgfSA9IHRhYmxlRW5jb2Rpbmc7XG4gIGNvbnN0IGszMiA9IHUzMihrZXkpO1xuICBjb25zdCBOayA9IGszMi5sZW5ndGg7XG4gIGNvbnN0IHN1YkJ5dGUgPSAobjogbnVtYmVyKSA9PiBhcHBseVNib3goc2JveDIsIG4sIG4sIG4sIG4pO1xuICBjb25zdCB4ayA9IG5ldyBVaW50MzJBcnJheShsZW4gKyAyOCk7IC8vIGV4cGFuZGVkIGtleVxuICB4ay5zZXQoazMyKTtcbiAgLy8gNC4zLjEgS2V5IGV4cGFuc2lvblxuICBmb3IgKGxldCBpID0gTms7IGkgPCB4ay5sZW5ndGg7IGkrKykge1xuICAgIGxldCB0ID0geGtbaSAtIDFdO1xuICAgIGlmIChpICUgTmsgPT09IDApIHQgPSBzdWJCeXRlKHJvdHIzMl84KHQpKSBeIHhQb3dlcnNbaSAvIE5rIC0gMV07XG4gICAgZWxzZSBpZiAoTmsgPiA2ICYmIGkgJSBOayA9PT0gNCkgdCA9IHN1YkJ5dGUodCk7XG4gICAgeGtbaV0gPSB4a1tpIC0gTmtdIF4gdDtcbiAgfVxuICByZXR1cm4geGs7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRLZXlEZWNMRShrZXk6IFVpbnQ4QXJyYXkpOiBVaW50MzJBcnJheSB7XG4gIGNvbnN0IGVuY0tleSA9IGV4cGFuZEtleUxFKGtleSk7XG4gIGNvbnN0IHhrID0gZW5jS2V5LnNsaWNlKCk7XG4gIGNvbnN0IE5rID0gZW5jS2V5Lmxlbmd0aDtcbiAgY29uc3QgeyBzYm94MiB9ID0gdGFibGVFbmNvZGluZztcbiAgY29uc3QgeyBUMCwgVDEsIFQyLCBUMyB9ID0gdGFibGVEZWNvZGluZztcbiAgLy8gSW52ZXJzZSBrZXkgYnkgY2h1bmtzIG9mIDQgKHJvdW5kcylcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBOazsgaSArPSA0KSB7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCA0OyBqKyspIHhrW2kgKyBqXSA9IGVuY0tleVtOayAtIGkgLSA0ICsgal07XG4gIH1cbiAgZW5jS2V5LmZpbGwoMCk7XG4gIC8vIGFwcGx5IEludk1peENvbHVtbiBleGNlcHQgZmlyc3QgJiBsYXN0IHJvdW5kXG4gIGZvciAobGV0IGkgPSA0OyBpIDwgTmsgLSA0OyBpKyspIHtcbiAgICBjb25zdCB4ID0geGtbaV07XG4gICAgY29uc3QgdyA9IGFwcGx5U2JveChzYm94MiwgeCwgeCwgeCwgeCk7XG4gICAgeGtbaV0gPSBUMFt3ICYgMHhmZl0gXiBUMVsodyA+Pj4gOCkgJiAweGZmXSBeIFQyWyh3ID4+PiAxNikgJiAweGZmXSBeIFQzW3cgPj4+IDI0XTtcbiAgfVxuICByZXR1cm4geGs7XG59XG5cbi8vIEFwcGx5IHRhYmxlc1xuZnVuY3Rpb24gYXBwbHkwMTIzKFxuICBUMDE6IFVpbnQzMkFycmF5LFxuICBUMjM6IFVpbnQzMkFycmF5LFxuICBzMDogbnVtYmVyLFxuICBzMTogbnVtYmVyLFxuICBzMjogbnVtYmVyLFxuICBzMzogbnVtYmVyXG4pIHtcbiAgcmV0dXJuIChcbiAgICBUMDFbKChzMCA8PCA4KSAmIDB4ZmYwMCkgfCAoKHMxID4+PiA4KSAmIDB4ZmYpXSBeXG4gICAgVDIzWygoczIgPj4+IDgpICYgMHhmZjAwKSB8ICgoczMgPj4+IDI0KSAmIDB4ZmYpXVxuICApO1xufVxuXG5mdW5jdGlvbiBhcHBseVNib3goc2JveDI6IFVpbnQxNkFycmF5LCBzMDogbnVtYmVyLCBzMTogbnVtYmVyLCBzMjogbnVtYmVyLCBzMzogbnVtYmVyKSB7XG4gIHJldHVybiAoXG4gICAgc2JveDJbKHMwICYgMHhmZikgfCAoczEgJiAweGZmMDApXSB8XG4gICAgKHNib3gyWygoczIgPj4+IDE2KSAmIDB4ZmYpIHwgKChzMyA+Pj4gMTYpICYgMHhmZjAwKV0gPDwgMTYpXG4gICk7XG59XG5cbmZ1bmN0aW9uIGVuY3J5cHQoeGs6IFVpbnQzMkFycmF5LCBzMDogbnVtYmVyLCBzMTogbnVtYmVyLCBzMjogbnVtYmVyLCBzMzogbnVtYmVyKSB7XG4gIGNvbnN0IHsgc2JveDIsIFQwMSwgVDIzIH0gPSB0YWJsZUVuY29kaW5nO1xuICBsZXQgayA9IDA7XG4gIChzMCBePSB4a1trKytdKSwgKHMxIF49IHhrW2srK10pLCAoczIgXj0geGtbaysrXSksIChzMyBePSB4a1trKytdKTtcbiAgY29uc3Qgcm91bmRzID0geGsubGVuZ3RoIC8gNCAtIDI7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcm91bmRzOyBpKyspIHtcbiAgICBjb25zdCB0MCA9IHhrW2srK10gXiBhcHBseTAxMjMoVDAxLCBUMjMsIHMwLCBzMSwgczIsIHMzKTtcbiAgICBjb25zdCB0MSA9IHhrW2srK10gXiBhcHBseTAxMjMoVDAxLCBUMjMsIHMxLCBzMiwgczMsIHMwKTtcbiAgICBjb25zdCB0MiA9IHhrW2srK10gXiBhcHBseTAxMjMoVDAxLCBUMjMsIHMyLCBzMywgczAsIHMxKTtcbiAgICBjb25zdCB0MyA9IHhrW2srK10gXiBhcHBseTAxMjMoVDAxLCBUMjMsIHMzLCBzMCwgczEsIHMyKTtcbiAgICAoczAgPSB0MCksIChzMSA9IHQxKSwgKHMyID0gdDIpLCAoczMgPSB0Myk7XG4gIH1cbiAgLy8gbGFzdCByb3VuZCAod2l0aG91dCBtaXhjb2x1bW5zLCBzbyB1c2luZyBTQk9YMiB0YWJsZSlcbiAgY29uc3QgdDAgPSB4a1trKytdIF4gYXBwbHlTYm94KHNib3gyLCBzMCwgczEsIHMyLCBzMyk7XG4gIGNvbnN0IHQxID0geGtbaysrXSBeIGFwcGx5U2JveChzYm94MiwgczEsIHMyLCBzMywgczApO1xuICBjb25zdCB0MiA9IHhrW2srK10gXiBhcHBseVNib3goc2JveDIsIHMyLCBzMywgczAsIHMxKTtcbiAgY29uc3QgdDMgPSB4a1trKytdIF4gYXBwbHlTYm94KHNib3gyLCBzMywgczAsIHMxLCBzMik7XG4gIHJldHVybiB7IHMwOiB0MCwgczE6IHQxLCBzMjogdDIsIHMzOiB0MyB9O1xufVxuXG5mdW5jdGlvbiBkZWNyeXB0KHhrOiBVaW50MzJBcnJheSwgczA6IG51bWJlciwgczE6IG51bWJlciwgczI6IG51bWJlciwgczM6IG51bWJlcikge1xuICBjb25zdCB7IHNib3gyLCBUMDEsIFQyMyB9ID0gdGFibGVEZWNvZGluZztcbiAgbGV0IGsgPSAwO1xuICAoczAgXj0geGtbaysrXSksIChzMSBePSB4a1trKytdKSwgKHMyIF49IHhrW2srK10pLCAoczMgXj0geGtbaysrXSk7XG4gIGNvbnN0IHJvdW5kcyA9IHhrLmxlbmd0aCAvIDQgLSAyO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJvdW5kczsgaSsrKSB7XG4gICAgY29uc3QgdDAgPSB4a1trKytdIF4gYXBwbHkwMTIzKFQwMSwgVDIzLCBzMCwgczMsIHMyLCBzMSk7XG4gICAgY29uc3QgdDEgPSB4a1trKytdIF4gYXBwbHkwMTIzKFQwMSwgVDIzLCBzMSwgczAsIHMzLCBzMik7XG4gICAgY29uc3QgdDIgPSB4a1trKytdIF4gYXBwbHkwMTIzKFQwMSwgVDIzLCBzMiwgczEsIHMwLCBzMyk7XG4gICAgY29uc3QgdDMgPSB4a1trKytdIF4gYXBwbHkwMTIzKFQwMSwgVDIzLCBzMywgczIsIHMxLCBzMCk7XG4gICAgKHMwID0gdDApLCAoczEgPSB0MSksIChzMiA9IHQyKSwgKHMzID0gdDMpO1xuICB9XG4gIC8vIExhc3Qgcm91bmRcbiAgY29uc3QgdDAgPSB4a1trKytdIF4gYXBwbHlTYm94KHNib3gyLCBzMCwgczMsIHMyLCBzMSk7XG4gIGNvbnN0IHQxID0geGtbaysrXSBeIGFwcGx5U2JveChzYm94MiwgczEsIHMwLCBzMywgczIpO1xuICBjb25zdCB0MiA9IHhrW2srK10gXiBhcHBseVNib3goc2JveDIsIHMyLCBzMSwgczAsIHMzKTtcbiAgY29uc3QgdDMgPSB4a1trKytdIF4gYXBwbHlTYm94KHNib3gyLCBzMywgczIsIHMxLCBzMCk7XG4gIHJldHVybiB7IHMwOiB0MCwgczE6IHQxLCBzMjogdDIsIHMzOiB0MyB9O1xufVxuXG5mdW5jdGlvbiBnZXREc3QobGVuOiBudW1iZXIsIGRzdD86IFVpbnQ4QXJyYXkpIHtcbiAgaWYgKCFkc3QpIHJldHVybiBuZXcgVWludDhBcnJheShsZW4pO1xuICBhYnl0ZXMoZHN0KTtcbiAgaWYgKGRzdC5sZW5ndGggPCBsZW4pXG4gICAgdGhyb3cgbmV3IEVycm9yKGBhZXM6IHdyb25nIGRlc3RpbmF0aW9uIGxlbmd0aCwgZXhwZWN0ZWQgYXQgbGVhc3QgJHtsZW59LCBnb3Q6ICR7ZHN0Lmxlbmd0aH1gKTtcbiAgcmV0dXJuIGRzdDtcbn1cblxuLy8gVE9ETzogaW52ZXN0aWdhdGUgbWVyZ2luZyB3aXRoIGN0cjMyXG5mdW5jdGlvbiBjdHJDb3VudGVyKHhrOiBVaW50MzJBcnJheSwgbm9uY2U6IFVpbnQ4QXJyYXksIHNyYzogVWludDhBcnJheSwgZHN0PzogVWludDhBcnJheSkge1xuICBhYnl0ZXMobm9uY2UsIEJMT0NLX1NJWkUpO1xuICBhYnl0ZXMoc3JjKTtcbiAgY29uc3Qgc3JjTGVuID0gc3JjLmxlbmd0aDtcbiAgZHN0ID0gZ2V0RHN0KHNyY0xlbiwgZHN0KTtcbiAgY29uc3QgY3RyID0gbm9uY2U7XG4gIGNvbnN0IGMzMiA9IHUzMihjdHIpO1xuICAvLyBGaWxsIGJsb2NrIChlbXB0eSwgY3RyPTApXG4gIGxldCB7IHMwLCBzMSwgczIsIHMzIH0gPSBlbmNyeXB0KHhrLCBjMzJbMF0sIGMzMlsxXSwgYzMyWzJdLCBjMzJbM10pO1xuICBjb25zdCBzcmMzMiA9IHUzMihzcmMpO1xuICBjb25zdCBkc3QzMiA9IHUzMihkc3QpO1xuICAvLyBwcm9jZXNzIGJsb2Nrc1xuICBmb3IgKGxldCBpID0gMDsgaSArIDQgPD0gc3JjMzIubGVuZ3RoOyBpICs9IDQpIHtcbiAgICBkc3QzMltpICsgMF0gPSBzcmMzMltpICsgMF0gXiBzMDtcbiAgICBkc3QzMltpICsgMV0gPSBzcmMzMltpICsgMV0gXiBzMTtcbiAgICBkc3QzMltpICsgMl0gPSBzcmMzMltpICsgMl0gXiBzMjtcbiAgICBkc3QzMltpICsgM10gPSBzcmMzMltpICsgM10gXiBzMztcbiAgICAvLyBGdWxsIDEyOCBiaXQgY291bnRlciB3aXRoIHdyYXAgYXJvdW5kXG4gICAgbGV0IGNhcnJ5ID0gMTtcbiAgICBmb3IgKGxldCBpID0gY3RyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjYXJyeSA9IChjYXJyeSArIChjdHJbaV0gJiAweGZmKSkgfCAwO1xuICAgICAgY3RyW2ldID0gY2FycnkgJiAweGZmO1xuICAgICAgY2FycnkgPj4+PSA4O1xuICAgIH1cbiAgICAoeyBzMCwgczEsIHMyLCBzMyB9ID0gZW5jcnlwdCh4aywgYzMyWzBdLCBjMzJbMV0sIGMzMlsyXSwgYzMyWzNdKSk7XG4gIH1cbiAgLy8gbGVmdG92ZXJzIChsZXNzIHRoYW4gYmxvY2spXG4gIC8vIEl0J3MgcG9zc2libGUgdG8gaGFuZGxlID4gdTMyIGZhc3QsIGJ1dCBpcyBpdCB3b3J0aCBpdD9cbiAgY29uc3Qgc3RhcnQgPSBCTE9DS19TSVpFICogTWF0aC5mbG9vcihzcmMzMi5sZW5ndGggLyBCTE9DS19TSVpFMzIpO1xuICBpZiAoc3RhcnQgPCBzcmNMZW4pIHtcbiAgICBjb25zdCBiMzIgPSBuZXcgVWludDMyQXJyYXkoW3MwLCBzMSwgczIsIHMzXSk7XG4gICAgY29uc3QgYnVmID0gdTgoYjMyKTtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQsIHBvcyA9IDA7IGkgPCBzcmNMZW47IGkrKywgcG9zKyspIGRzdFtpXSA9IHNyY1tpXSBeIGJ1Zltwb3NdO1xuICB9XG4gIHJldHVybiBkc3Q7XG59XG5cbi8vIEFFUyBDVFIgd2l0aCBvdmVyZmxvd2luZyAzMiBiaXQgY291bnRlclxuLy8gSXQncyBwb3NzaWJsZSB0byBkbyAzMmxlIHNpZ25pZmljYW50bHkgc2ltcGxlciAoYW5kIHByb2JhYmx5IGZhc3RlcikgYnkgdXNpbmcgdTMyLlxuLy8gQnV0LCB3ZSBuZWVkIGJvdGgsIGFuZCBwZXJmIGJvdHRsZW5lY2sgaXMgaW4gZ2hhc2ggYW55d2F5LlxuZnVuY3Rpb24gY3RyMzIoXG4gIHhrOiBVaW50MzJBcnJheSxcbiAgaXNMRTogYm9vbGVhbixcbiAgbm9uY2U6IFVpbnQ4QXJyYXksXG4gIHNyYzogVWludDhBcnJheSxcbiAgZHN0PzogVWludDhBcnJheVxuKSB7XG4gIGFieXRlcyhub25jZSwgQkxPQ0tfU0laRSk7XG4gIGFieXRlcyhzcmMpO1xuICBkc3QgPSBnZXREc3Qoc3JjLmxlbmd0aCwgZHN0KTtcbiAgY29uc3QgY3RyID0gbm9uY2U7IC8vIHdyaXRlIG5ldyB2YWx1ZSB0byBub25jZSwgc28gaXQgY2FuIGJlIHJlLXVzZWRcbiAgY29uc3QgYzMyID0gdTMyKGN0cik7XG4gIGNvbnN0IHZpZXcgPSBjcmVhdGVWaWV3KGN0cik7XG4gIGNvbnN0IHNyYzMyID0gdTMyKHNyYyk7XG4gIGNvbnN0IGRzdDMyID0gdTMyKGRzdCk7XG4gIGNvbnN0IGN0clBvcyA9IGlzTEUgPyAwIDogMTI7XG4gIGNvbnN0IHNyY0xlbiA9IHNyYy5sZW5ndGg7XG4gIC8vIEZpbGwgYmxvY2sgKGVtcHR5LCBjdHI9MClcbiAgbGV0IGN0ck51bSA9IHZpZXcuZ2V0VWludDMyKGN0clBvcywgaXNMRSk7IC8vIHJlYWQgY3VycmVudCBjb3VudGVyIHZhbHVlXG4gIGxldCB7IHMwLCBzMSwgczIsIHMzIH0gPSBlbmNyeXB0KHhrLCBjMzJbMF0sIGMzMlsxXSwgYzMyWzJdLCBjMzJbM10pO1xuICAvLyBwcm9jZXNzIGJsb2Nrc1xuICBmb3IgKGxldCBpID0gMDsgaSArIDQgPD0gc3JjMzIubGVuZ3RoOyBpICs9IDQpIHtcbiAgICBkc3QzMltpICsgMF0gPSBzcmMzMltpICsgMF0gXiBzMDtcbiAgICBkc3QzMltpICsgMV0gPSBzcmMzMltpICsgMV0gXiBzMTtcbiAgICBkc3QzMltpICsgMl0gPSBzcmMzMltpICsgMl0gXiBzMjtcbiAgICBkc3QzMltpICsgM10gPSBzcmMzMltpICsgM10gXiBzMztcbiAgICBjdHJOdW0gPSAoY3RyTnVtICsgMSkgPj4+IDA7IC8vIHUzMiB3cmFwXG4gICAgdmlldy5zZXRVaW50MzIoY3RyUG9zLCBjdHJOdW0sIGlzTEUpO1xuICAgICh7IHMwLCBzMSwgczIsIHMzIH0gPSBlbmNyeXB0KHhrLCBjMzJbMF0sIGMzMlsxXSwgYzMyWzJdLCBjMzJbM10pKTtcbiAgfVxuICAvLyBsZWZ0b3ZlcnMgKGxlc3MgdGhhbiBhIGJsb2NrKVxuICBjb25zdCBzdGFydCA9IEJMT0NLX1NJWkUgKiBNYXRoLmZsb29yKHNyYzMyLmxlbmd0aCAvIEJMT0NLX1NJWkUzMik7XG4gIGlmIChzdGFydCA8IHNyY0xlbikge1xuICAgIGNvbnN0IGIzMiA9IG5ldyBVaW50MzJBcnJheShbczAsIHMxLCBzMiwgczNdKTtcbiAgICBjb25zdCBidWYgPSB1OChiMzIpO1xuICAgIGZvciAobGV0IGkgPSBzdGFydCwgcG9zID0gMDsgaSA8IHNyY0xlbjsgaSsrLCBwb3MrKykgZHN0W2ldID0gc3JjW2ldIF4gYnVmW3Bvc107XG4gIH1cbiAgcmV0dXJuIGRzdDtcbn1cblxuLyoqXG4gKiBDVFI6IGNvdW50ZXIgbW9kZS4gQ3JlYXRlcyBzdHJlYW0gY2lwaGVyLlxuICogUmVxdWlyZXMgZ29vZCBJVi4gUGFyYWxsZWxpemFibGUuIE9LLCBidXQgbm8gTUFDLlxuICovXG5leHBvcnQgY29uc3QgY3RyID0gd3JhcENpcGhlcihcbiAgeyBibG9ja1NpemU6IDE2LCBub25jZUxlbmd0aDogMTYgfSxcbiAgZnVuY3Rpb24gY3RyKGtleTogVWludDhBcnJheSwgbm9uY2U6IFVpbnQ4QXJyYXkpOiBDaXBoZXJXaXRoT3V0cHV0IHtcbiAgICBhYnl0ZXMoa2V5KTtcbiAgICBhYnl0ZXMobm9uY2UsIEJMT0NLX1NJWkUpO1xuICAgIGZ1bmN0aW9uIHByb2Nlc3NDdHIoYnVmOiBVaW50OEFycmF5LCBkc3Q/OiBVaW50OEFycmF5KSB7XG4gICAgICBjb25zdCB4ayA9IGV4cGFuZEtleUxFKGtleSk7XG4gICAgICBjb25zdCBuID0gbm9uY2Uuc2xpY2UoKTtcbiAgICAgIGNvbnN0IG91dCA9IGN0ckNvdW50ZXIoeGssIG4sIGJ1ZiwgZHN0KTtcbiAgICAgIHhrLmZpbGwoMCk7XG4gICAgICBuLmZpbGwoMCk7XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZW5jcnlwdDogKHBsYWludGV4dDogVWludDhBcnJheSwgZHN0PzogVWludDhBcnJheSkgPT4gcHJvY2Vzc0N0cihwbGFpbnRleHQsIGRzdCksXG4gICAgICBkZWNyeXB0OiAoY2lwaGVydGV4dDogVWludDhBcnJheSwgZHN0PzogVWludDhBcnJheSkgPT4gcHJvY2Vzc0N0cihjaXBoZXJ0ZXh0LCBkc3QpLFxuICAgIH07XG4gIH1cbik7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQmxvY2tEZWNyeXB0KGRhdGE6IFVpbnQ4QXJyYXkpIHtcbiAgYWJ5dGVzKGRhdGEpO1xuICBpZiAoZGF0YS5sZW5ndGggJSBCTE9DS19TSVpFICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYGFlcy8oY2JjLWVjYikuZGVjcnlwdCBjaXBoZXJ0ZXh0IHNob3VsZCBjb25zaXN0IG9mIGJsb2NrcyB3aXRoIHNpemUgJHtCTE9DS19TSVpFfWBcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQmxvY2tFbmNyeXB0KHBsYWludGV4dDogVWludDhBcnJheSwgcGNrczU6IGJvb2xlYW4sIGRzdD86IFVpbnQ4QXJyYXkpIHtcbiAgbGV0IG91dExlbiA9IHBsYWludGV4dC5sZW5ndGg7XG4gIGNvbnN0IHJlbWFpbmluZyA9IG91dExlbiAlIEJMT0NLX1NJWkU7XG4gIGlmICghcGNrczUgJiYgcmVtYWluaW5nICE9PSAwKVxuICAgIHRocm93IG5ldyBFcnJvcignYWVjLyhjYmMtZWNiKTogdW5wYWRkZWQgcGxhaW50ZXh0IHdpdGggZGlzYWJsZWQgcGFkZGluZycpO1xuICBjb25zdCBiID0gdTMyKHBsYWludGV4dCk7XG4gIGlmIChwY2tzNSkge1xuICAgIGxldCBsZWZ0ID0gQkxPQ0tfU0laRSAtIHJlbWFpbmluZztcbiAgICBpZiAoIWxlZnQpIGxlZnQgPSBCTE9DS19TSVpFOyAvLyBpZiBubyBieXRlcyBsZWZ0LCBjcmVhdGUgZW1wdHkgcGFkZGluZyBibG9ja1xuICAgIG91dExlbiA9IG91dExlbiArIGxlZnQ7XG4gIH1cbiAgY29uc3Qgb3V0ID0gZ2V0RHN0KG91dExlbiwgZHN0KTtcbiAgY29uc3QgbyA9IHUzMihvdXQpO1xuICByZXR1cm4geyBiLCBvLCBvdXQgfTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQQ0tTKGRhdGE6IFVpbnQ4QXJyYXksIHBja3M1OiBib29sZWFuKSB7XG4gIGlmICghcGNrczUpIHJldHVybiBkYXRhO1xuICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgaWYgKCFsZW4pIHRocm93IG5ldyBFcnJvcihgYWVzL3Bja3M1OiBlbXB0eSBjaXBoZXJ0ZXh0IG5vdCBhbGxvd2VkYCk7XG4gIGNvbnN0IGxhc3RCeXRlID0gZGF0YVtsZW4gLSAxXTtcbiAgaWYgKGxhc3RCeXRlIDw9IDAgfHwgbGFzdEJ5dGUgPiAxNikgdGhyb3cgbmV3IEVycm9yKGBhZXMvcGNrczU6IHdyb25nIHBhZGRpbmcgYnl0ZTogJHtsYXN0Qnl0ZX1gKTtcbiAgY29uc3Qgb3V0ID0gZGF0YS5zdWJhcnJheSgwLCAtbGFzdEJ5dGUpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxhc3RCeXRlOyBpKyspXG4gICAgaWYgKGRhdGFbbGVuIC0gaSAtIDFdICE9PSBsYXN0Qnl0ZSkgdGhyb3cgbmV3IEVycm9yKGBhZXMvcGNrczU6IHdyb25nIHBhZGRpbmdgKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gcGFkUENLUyhsZWZ0OiBVaW50OEFycmF5KSB7XG4gIGNvbnN0IHRtcCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgY29uc3QgdG1wMzIgPSB1MzIodG1wKTtcbiAgdG1wLnNldChsZWZ0KTtcbiAgY29uc3QgcGFkZGluZ0J5dGUgPSBCTE9DS19TSVpFIC0gbGVmdC5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSBCTE9DS19TSVpFIC0gcGFkZGluZ0J5dGU7IGkgPCBCTE9DS19TSVpFOyBpKyspIHRtcFtpXSA9IHBhZGRpbmdCeXRlO1xuICByZXR1cm4gdG1wMzI7XG59XG5cbmV4cG9ydCB0eXBlIEJsb2NrT3B0cyA9IHsgZGlzYWJsZVBhZGRpbmc/OiBib29sZWFuIH07XG5cbi8qKlxuICogRUNCOiBFbGVjdHJvbmljIENvZGVCb29rLiBTaW1wbGUgZGV0ZXJtaW5pc3RpYyByZXBsYWNlbWVudC5cbiAqIERhbmdlcm91czogYWx3YXlzIG1hcCB4IHRvIHkuIFNlZSBbQUVTIFBlbmd1aW5dKGh0dHBzOi8vd29yZHMuZmlsaXBwby5pby90aGUtZWNiLXBlbmd1aW4vKS5cbiAqL1xuZXhwb3J0IGNvbnN0IGVjYiA9IHdyYXBDaXBoZXIoXG4gIHsgYmxvY2tTaXplOiAxNiB9LFxuICBmdW5jdGlvbiBlY2Ioa2V5OiBVaW50OEFycmF5LCBvcHRzOiBCbG9ja09wdHMgPSB7fSk6IENpcGhlcldpdGhPdXRwdXQge1xuICAgIGFieXRlcyhrZXkpO1xuICAgIGNvbnN0IHBja3M1ID0gIW9wdHMuZGlzYWJsZVBhZGRpbmc7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVuY3J5cHQ6IChwbGFpbnRleHQ6IFVpbnQ4QXJyYXksIGRzdD86IFVpbnQ4QXJyYXkpID0+IHtcbiAgICAgICAgYWJ5dGVzKHBsYWludGV4dCk7XG4gICAgICAgIGNvbnN0IHsgYiwgbywgb3V0OiBfb3V0IH0gPSB2YWxpZGF0ZUJsb2NrRW5jcnlwdChwbGFpbnRleHQsIHBja3M1LCBkc3QpO1xuICAgICAgICBjb25zdCB4ayA9IGV4cGFuZEtleUxFKGtleSk7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yICg7IGkgKyA0IDw9IGIubGVuZ3RoOyApIHtcbiAgICAgICAgICBjb25zdCB7IHMwLCBzMSwgczIsIHMzIH0gPSBlbmNyeXB0KHhrLCBiW2kgKyAwXSwgYltpICsgMV0sIGJbaSArIDJdLCBiW2kgKyAzXSk7XG4gICAgICAgICAgKG9baSsrXSA9IHMwKSwgKG9baSsrXSA9IHMxKSwgKG9baSsrXSA9IHMyKSwgKG9baSsrXSA9IHMzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGNrczUpIHtcbiAgICAgICAgICBjb25zdCB0bXAzMiA9IHBhZFBDS1MocGxhaW50ZXh0LnN1YmFycmF5KGkgKiA0KSk7XG4gICAgICAgICAgY29uc3QgeyBzMCwgczEsIHMyLCBzMyB9ID0gZW5jcnlwdCh4aywgdG1wMzJbMF0sIHRtcDMyWzFdLCB0bXAzMlsyXSwgdG1wMzJbM10pO1xuICAgICAgICAgIChvW2krK10gPSBzMCksIChvW2krK10gPSBzMSksIChvW2krK10gPSBzMiksIChvW2krK10gPSBzMyk7XG4gICAgICAgIH1cbiAgICAgICAgeGsuZmlsbCgwKTtcbiAgICAgICAgcmV0dXJuIF9vdXQ7XG4gICAgICB9LFxuICAgICAgZGVjcnlwdDogKGNpcGhlcnRleHQ6IFVpbnQ4QXJyYXksIGRzdD86IFVpbnQ4QXJyYXkpID0+IHtcbiAgICAgICAgdmFsaWRhdGVCbG9ja0RlY3J5cHQoY2lwaGVydGV4dCk7XG4gICAgICAgIGNvbnN0IHhrID0gZXhwYW5kS2V5RGVjTEUoa2V5KTtcbiAgICAgICAgY29uc3Qgb3V0ID0gZ2V0RHN0KGNpcGhlcnRleHQubGVuZ3RoLCBkc3QpO1xuICAgICAgICBjb25zdCBiID0gdTMyKGNpcGhlcnRleHQpO1xuICAgICAgICBjb25zdCBvID0gdTMyKG91dCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpICsgNCA8PSBiLmxlbmd0aDsgKSB7XG4gICAgICAgICAgY29uc3QgeyBzMCwgczEsIHMyLCBzMyB9ID0gZGVjcnlwdCh4aywgYltpICsgMF0sIGJbaSArIDFdLCBiW2kgKyAyXSwgYltpICsgM10pO1xuICAgICAgICAgIChvW2krK10gPSBzMCksIChvW2krK10gPSBzMSksIChvW2krK10gPSBzMiksIChvW2krK10gPSBzMyk7XG4gICAgICAgIH1cbiAgICAgICAgeGsuZmlsbCgwKTtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlUENLUyhvdXQsIHBja3M1KTtcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuKTtcblxuLyoqXG4gKiBDQkM6IENpcGhlci1CbG9jay1DaGFpbmluZy4gS2V5IGlzIHByZXZpb3VzIHJvdW5kXHUyMDE5cyBibG9jay5cbiAqIEZyYWdpbGU6IG5lZWRzIHByb3BlciBwYWRkaW5nLiBVbmF1dGhlbnRpY2F0ZWQ6IG5lZWRzIE1BQy5cbiAqL1xuZXhwb3J0IGNvbnN0IGNiYyA9IHdyYXBDaXBoZXIoXG4gIHsgYmxvY2tTaXplOiAxNiwgbm9uY2VMZW5ndGg6IDE2IH0sXG4gIGZ1bmN0aW9uIGNiYyhrZXk6IFVpbnQ4QXJyYXksIGl2OiBVaW50OEFycmF5LCBvcHRzOiBCbG9ja09wdHMgPSB7fSk6IENpcGhlcldpdGhPdXRwdXQge1xuICAgIGFieXRlcyhrZXkpO1xuICAgIGFieXRlcyhpdiwgMTYpO1xuICAgIGNvbnN0IHBja3M1ID0gIW9wdHMuZGlzYWJsZVBhZGRpbmc7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVuY3J5cHQ6IChwbGFpbnRleHQ6IFVpbnQ4QXJyYXksIGRzdD86IFVpbnQ4QXJyYXkpID0+IHtcbiAgICAgICAgY29uc3QgeGsgPSBleHBhbmRLZXlMRShrZXkpO1xuICAgICAgICBjb25zdCB7IGIsIG8sIG91dDogX291dCB9ID0gdmFsaWRhdGVCbG9ja0VuY3J5cHQocGxhaW50ZXh0LCBwY2tzNSwgZHN0KTtcbiAgICAgICAgY29uc3QgbjMyID0gdTMyKGl2KTtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGxldCBzMCA9IG4zMlswXSwgczEgPSBuMzJbMV0sIHMyID0gbjMyWzJdLCBzMyA9IG4zMlszXTtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBmb3IgKDsgaSArIDQgPD0gYi5sZW5ndGg7ICkge1xuICAgICAgICAgIChzMCBePSBiW2kgKyAwXSksIChzMSBePSBiW2kgKyAxXSksIChzMiBePSBiW2kgKyAyXSksIChzMyBePSBiW2kgKyAzXSk7XG4gICAgICAgICAgKHsgczAsIHMxLCBzMiwgczMgfSA9IGVuY3J5cHQoeGssIHMwLCBzMSwgczIsIHMzKSk7XG4gICAgICAgICAgKG9baSsrXSA9IHMwKSwgKG9baSsrXSA9IHMxKSwgKG9baSsrXSA9IHMyKSwgKG9baSsrXSA9IHMzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGNrczUpIHtcbiAgICAgICAgICBjb25zdCB0bXAzMiA9IHBhZFBDS1MocGxhaW50ZXh0LnN1YmFycmF5KGkgKiA0KSk7XG4gICAgICAgICAgKHMwIF49IHRtcDMyWzBdKSwgKHMxIF49IHRtcDMyWzFdKSwgKHMyIF49IHRtcDMyWzJdKSwgKHMzIF49IHRtcDMyWzNdKTtcbiAgICAgICAgICAoeyBzMCwgczEsIHMyLCBzMyB9ID0gZW5jcnlwdCh4aywgczAsIHMxLCBzMiwgczMpKTtcbiAgICAgICAgICAob1tpKytdID0gczApLCAob1tpKytdID0gczEpLCAob1tpKytdID0gczIpLCAob1tpKytdID0gczMpO1xuICAgICAgICB9XG4gICAgICAgIHhrLmZpbGwoMCk7XG4gICAgICAgIHJldHVybiBfb3V0O1xuICAgICAgfSxcbiAgICAgIGRlY3J5cHQ6IChjaXBoZXJ0ZXh0OiBVaW50OEFycmF5LCBkc3Q/OiBVaW50OEFycmF5KSA9PiB7XG4gICAgICAgIHZhbGlkYXRlQmxvY2tEZWNyeXB0KGNpcGhlcnRleHQpO1xuICAgICAgICBjb25zdCB4ayA9IGV4cGFuZEtleURlY0xFKGtleSk7XG4gICAgICAgIGNvbnN0IG4zMiA9IHUzMihpdik7XG4gICAgICAgIGNvbnN0IG91dCA9IGdldERzdChjaXBoZXJ0ZXh0Lmxlbmd0aCwgZHN0KTtcbiAgICAgICAgY29uc3QgYiA9IHUzMihjaXBoZXJ0ZXh0KTtcbiAgICAgICAgY29uc3QgbyA9IHUzMihvdXQpO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgbGV0IHMwID0gbjMyWzBdLCBzMSA9IG4zMlsxXSwgczIgPSBuMzJbMl0sIHMzID0gbjMyWzNdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSArIDQgPD0gYi5sZW5ndGg7ICkge1xuICAgICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgIGNvbnN0IHBzMCA9IHMwLCBwczEgPSBzMSwgcHMyID0gczIsIHBzMyA9IHMzO1xuICAgICAgICAgIChzMCA9IGJbaSArIDBdKSwgKHMxID0gYltpICsgMV0pLCAoczIgPSBiW2kgKyAyXSksIChzMyA9IGJbaSArIDNdKTtcbiAgICAgICAgICBjb25zdCB7IHMwOiBvMCwgczE6IG8xLCBzMjogbzIsIHMzOiBvMyB9ID0gZGVjcnlwdCh4aywgczAsIHMxLCBzMiwgczMpO1xuICAgICAgICAgIChvW2krK10gPSBvMCBeIHBzMCksIChvW2krK10gPSBvMSBeIHBzMSksIChvW2krK10gPSBvMiBeIHBzMiksIChvW2krK10gPSBvMyBeIHBzMyk7XG4gICAgICAgIH1cbiAgICAgICAgeGsuZmlsbCgwKTtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlUENLUyhvdXQsIHBja3M1KTtcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuKTtcblxuLy8gVE9ETzogbWVyZ2Ugd2l0aCBjaGFjaGEsIGhvd2V2ZXIgZ2NtIGhhcyBiaXRMZW4gd2hpbGUgY2hhY2hhIGhhcyBieXRlTGVuXG5mdW5jdGlvbiBjb21wdXRlVGFnKFxuICBmbjogdHlwZW9mIGdoYXNoLFxuICBpc0xFOiBib29sZWFuLFxuICBrZXk6IFVpbnQ4QXJyYXksXG4gIGRhdGE6IFVpbnQ4QXJyYXksXG4gIEFBRD86IFVpbnQ4QXJyYXlcbikge1xuICBjb25zdCBoID0gZm4uY3JlYXRlKGtleSwgZGF0YS5sZW5ndGggKyAoQUFEPy5sZW5ndGggfHwgMCkpO1xuICBpZiAoQUFEKSBoLnVwZGF0ZShBQUQpO1xuICBoLnVwZGF0ZShkYXRhKTtcbiAgY29uc3QgbnVtID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICBjb25zdCB2aWV3ID0gY3JlYXRlVmlldyhudW0pO1xuICBpZiAoQUFEKSBzZXRCaWdVaW50NjQodmlldywgMCwgQmlnSW50KEFBRC5sZW5ndGggKiA4KSwgaXNMRSk7XG4gIHNldEJpZ1VpbnQ2NCh2aWV3LCA4LCBCaWdJbnQoZGF0YS5sZW5ndGggKiA4KSwgaXNMRSk7XG4gIGgudXBkYXRlKG51bSk7XG4gIHJldHVybiBoLmRpZ2VzdCgpO1xufVxuXG4vKipcbiAqIEdDTTogR2Fsb2lzL0NvdW50ZXIgTW9kZS5cbiAqIEdvb2QsIG1vZGVybiB2ZXJzaW9uIG9mIENUUiwgcGFyYWxsZWwsIHdpdGggTUFDLlxuICogQmUgY2FyZWZ1bDogTUFDcyBjYW4gYmUgZm9yZ2VkLlxuICovXG5leHBvcnQgY29uc3QgZ2NtID0gd3JhcENpcGhlcihcbiAgeyBibG9ja1NpemU6IDE2LCBub25jZUxlbmd0aDogMTIsIHRhZ0xlbmd0aDogMTYgfSxcbiAgZnVuY3Rpb24gZ2NtKGtleTogVWludDhBcnJheSwgbm9uY2U6IFVpbnQ4QXJyYXksIEFBRD86IFVpbnQ4QXJyYXkpOiBDaXBoZXIge1xuICAgIGFieXRlcyhub25jZSk7XG4gICAgLy8gTm9uY2UgY2FuIGJlIHByZXR0eSBtdWNoIGFueXRoaW5nIChldmVuIDEgYnl0ZSkuIEJ1dCBzbWFsbGVyIG5vbmNlcyBsZXNzIHNlY3VyZS5cbiAgICBpZiAobm9uY2UubGVuZ3RoID09PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ2Flcy9nY206IGVtcHR5IG5vbmNlJyk7XG4gICAgY29uc3QgdGFnTGVuZ3RoID0gMTY7XG4gICAgZnVuY3Rpb24gX2NvbXB1dGVUYWcoYXV0aEtleTogVWludDhBcnJheSwgdGFnTWFzazogVWludDhBcnJheSwgZGF0YTogVWludDhBcnJheSkge1xuICAgICAgY29uc3QgdGFnID0gY29tcHV0ZVRhZyhnaGFzaCwgZmFsc2UsIGF1dGhLZXksIGRhdGEsIEFBRCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhZ01hc2subGVuZ3RoOyBpKyspIHRhZ1tpXSBePSB0YWdNYXNrW2ldO1xuICAgICAgcmV0dXJuIHRhZztcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVyaXZlS2V5cygpIHtcbiAgICAgIGNvbnN0IHhrID0gZXhwYW5kS2V5TEUoa2V5KTtcbiAgICAgIGNvbnN0IGF1dGhLZXkgPSBFTVBUWV9CTE9DSy5zbGljZSgpO1xuICAgICAgY29uc3QgY291bnRlciA9IEVNUFRZX0JMT0NLLnNsaWNlKCk7XG4gICAgICBjdHIzMih4aywgZmFsc2UsIGNvdW50ZXIsIGNvdW50ZXIsIGF1dGhLZXkpO1xuICAgICAgaWYgKG5vbmNlLmxlbmd0aCA9PT0gMTIpIHtcbiAgICAgICAgY291bnRlci5zZXQobm9uY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU3BlYyAoTklTVCA4MDAtMzhkKSBzdXBwb3J0cyB2YXJpYWJsZSBzaXplIG5vbmNlLlxuICAgICAgICAvLyBOb3Qgc3VwcG9ydGVkIGZvciBub3csIGJ1dCBjYW4gYmUgdXNlZnVsLlxuICAgICAgICBjb25zdCBub25jZUxlbiA9IEVNUFRZX0JMT0NLLnNsaWNlKCk7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBjcmVhdGVWaWV3KG5vbmNlTGVuKTtcbiAgICAgICAgc2V0QmlnVWludDY0KHZpZXcsIDgsIEJpZ0ludChub25jZS5sZW5ndGggKiA4KSwgZmFsc2UpO1xuICAgICAgICAvLyBnaGFzaChub25jZSB8fCB1NjRiZSgwKSB8fCB1NjRiZShub25jZUxlbio4KSlcbiAgICAgICAgZ2hhc2guY3JlYXRlKGF1dGhLZXkpLnVwZGF0ZShub25jZSkudXBkYXRlKG5vbmNlTGVuKS5kaWdlc3RJbnRvKGNvdW50ZXIpO1xuICAgICAgfVxuICAgICAgY29uc3QgdGFnTWFzayA9IGN0cjMyKHhrLCBmYWxzZSwgY291bnRlciwgRU1QVFlfQkxPQ0spO1xuICAgICAgcmV0dXJuIHsgeGssIGF1dGhLZXksIGNvdW50ZXIsIHRhZ01hc2sgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGVuY3J5cHQ6IChwbGFpbnRleHQ6IFVpbnQ4QXJyYXkpID0+IHtcbiAgICAgICAgYWJ5dGVzKHBsYWludGV4dCk7XG4gICAgICAgIGNvbnN0IHsgeGssIGF1dGhLZXksIGNvdW50ZXIsIHRhZ01hc2sgfSA9IGRlcml2ZUtleXMoKTtcbiAgICAgICAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkocGxhaW50ZXh0Lmxlbmd0aCArIHRhZ0xlbmd0aCk7XG4gICAgICAgIGN0cjMyKHhrLCBmYWxzZSwgY291bnRlciwgcGxhaW50ZXh0LCBvdXQpO1xuICAgICAgICBjb25zdCB0YWcgPSBfY29tcHV0ZVRhZyhhdXRoS2V5LCB0YWdNYXNrLCBvdXQuc3ViYXJyYXkoMCwgb3V0Lmxlbmd0aCAtIHRhZ0xlbmd0aCkpO1xuICAgICAgICBvdXQuc2V0KHRhZywgcGxhaW50ZXh0Lmxlbmd0aCk7XG4gICAgICAgIHhrLmZpbGwoMCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgICB9LFxuICAgICAgZGVjcnlwdDogKGNpcGhlcnRleHQ6IFVpbnQ4QXJyYXkpID0+IHtcbiAgICAgICAgYWJ5dGVzKGNpcGhlcnRleHQpO1xuICAgICAgICBpZiAoY2lwaGVydGV4dC5sZW5ndGggPCB0YWdMZW5ndGgpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhZXMvZ2NtOiBjaXBoZXJ0ZXh0IGxlc3MgdGhhbiB0YWdMZW4gKCR7dGFnTGVuZ3RofSlgKTtcbiAgICAgICAgY29uc3QgeyB4aywgYXV0aEtleSwgY291bnRlciwgdGFnTWFzayB9ID0gZGVyaXZlS2V5cygpO1xuICAgICAgICBjb25zdCBkYXRhID0gY2lwaGVydGV4dC5zdWJhcnJheSgwLCAtdGFnTGVuZ3RoKTtcbiAgICAgICAgY29uc3QgcGFzc2VkVGFnID0gY2lwaGVydGV4dC5zdWJhcnJheSgtdGFnTGVuZ3RoKTtcbiAgICAgICAgY29uc3QgdGFnID0gX2NvbXB1dGVUYWcoYXV0aEtleSwgdGFnTWFzaywgZGF0YSk7XG4gICAgICAgIGlmICghZXF1YWxCeXRlcyh0YWcsIHBhc3NlZFRhZykpIHRocm93IG5ldyBFcnJvcignYWVzL2djbTogaW52YWxpZCBnaGFzaCB0YWcnKTtcbiAgICAgICAgY29uc3Qgb3V0ID0gY3RyMzIoeGssIGZhbHNlLCBjb3VudGVyLCBkYXRhKTtcbiAgICAgICAgYXV0aEtleS5maWxsKDApO1xuICAgICAgICB0YWdNYXNrLmZpbGwoMCk7XG4gICAgICAgIHhrLmZpbGwoMCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgICB9LFxuICAgIH07XG4gIH1cbik7XG5cbmNvbnN0IGxpbWl0ID0gKG5hbWU6IHN0cmluZywgbWluOiBudW1iZXIsIG1heDogbnVtYmVyKSA9PiAodmFsdWU6IG51bWJlcikgPT4ge1xuICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbHVlKSB8fCBtaW4gPiB2YWx1ZSB8fCB2YWx1ZSA+IG1heClcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bmFtZX06IGludmFsaWQgdmFsdWU9JHt2YWx1ZX0sIG11c3QgYmUgWyR7bWlufS4uJHttYXh9XWApO1xufTtcblxuLyoqXG4gKiBBRVMtR0NNLVNJVjogY2xhc3NpYyBBRVMtR0NNIHdpdGggbm9uY2UtbWlzdXNlIHJlc2lzdGFuY2UuXG4gKiBHdWFyYW50ZWVzIHRoYXQsIHdoZW4gYSBub25jZSBpcyByZXBlYXRlZCwgdGhlIG9ubHkgc2VjdXJpdHkgbG9zcyBpcyB0aGF0IGlkZW50aWNhbFxuICogcGxhaW50ZXh0cyB3aWxsIHByb2R1Y2UgaWRlbnRpY2FsIGNpcGhlcnRleHRzLlxuICogUkZDIDg0NTIsIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjODQ1MlxuICovXG5leHBvcnQgY29uc3Qgc2l2ID0gd3JhcENpcGhlcihcbiAgeyBibG9ja1NpemU6IDE2LCBub25jZUxlbmd0aDogMTIsIHRhZ0xlbmd0aDogMTYgfSxcbiAgZnVuY3Rpb24gc2l2KGtleTogVWludDhBcnJheSwgbm9uY2U6IFVpbnQ4QXJyYXksIEFBRD86IFVpbnQ4QXJyYXkpOiBDaXBoZXIge1xuICAgIGNvbnN0IHRhZ0xlbmd0aCA9IDE2O1xuICAgIC8vIEZyb20gUkZDIDg0NTI6IFNlY3Rpb24gNlxuICAgIGNvbnN0IEFBRF9MSU1JVCA9IGxpbWl0KCdBQUQnLCAwLCAyICoqIDM2KTtcbiAgICBjb25zdCBQTEFJTl9MSU1JVCA9IGxpbWl0KCdwbGFpbnRleHQnLCAwLCAyICoqIDM2KTtcbiAgICBjb25zdCBOT05DRV9MSU1JVCA9IGxpbWl0KCdub25jZScsIDEyLCAxMik7XG4gICAgY29uc3QgQ0lQSEVSX0xJTUlUID0gbGltaXQoJ2NpcGhlcnRleHQnLCAxNiwgMiAqKiAzNiArIDE2KTtcbiAgICBhYnl0ZXMobm9uY2UpO1xuICAgIE5PTkNFX0xJTUlUKG5vbmNlLmxlbmd0aCk7XG4gICAgaWYgKEFBRCkge1xuICAgICAgYWJ5dGVzKEFBRCk7XG4gICAgICBBQURfTElNSVQoQUFELmxlbmd0aCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlcml2ZUtleXMoKSB7XG4gICAgICBjb25zdCBsZW4gPSBrZXkubGVuZ3RoO1xuICAgICAgaWYgKGxlbiAhPT0gMTYgJiYgbGVuICE9PSAyNCAmJiBsZW4gIT09IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGtleSBsZW5ndGggbXVzdCBiZSAxNiwgMjQgb3IgMzIgYnl0ZXMsIGdvdDogJHtsZW59IGJ5dGVzYCk7XG4gICAgICBjb25zdCB4ayA9IGV4cGFuZEtleUxFKGtleSk7XG4gICAgICBjb25zdCBlbmNLZXkgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICAgICAgY29uc3QgYXV0aEtleSA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICAgIGNvbnN0IG4zMiA9IHUzMihub25jZSk7XG4gICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgIGxldCBzMCA9IDAsIHMxID0gbjMyWzBdLCBzMiA9IG4zMlsxXSwgczMgPSBuMzJbMl07XG4gICAgICBsZXQgY291bnRlciA9IDA7XG4gICAgICBmb3IgKGNvbnN0IGRlcml2ZWRLZXkgb2YgW2F1dGhLZXksIGVuY0tleV0ubWFwKHUzMikpIHtcbiAgICAgICAgY29uc3QgZDMyID0gdTMyKGRlcml2ZWRLZXkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGQzMi5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgIC8vIGFlcyh1MzJsZSgwKSB8fCBub25jZSlbOjhdIHx8IGFlcyh1MzJsZSgxKSB8fCBub25jZSlbOjhdIC4uLlxuICAgICAgICAgIGNvbnN0IHsgczA6IG8wLCBzMTogbzEgfSA9IGVuY3J5cHQoeGssIHMwLCBzMSwgczIsIHMzKTtcbiAgICAgICAgICBkMzJbaSArIDBdID0gbzA7XG4gICAgICAgICAgZDMyW2kgKyAxXSA9IG8xO1xuICAgICAgICAgIHMwID0gKytjb3VudGVyOyAvLyBpbmNyZW1lbnQgY291bnRlciBpbnNpZGUgc3RhdGVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgeGsuZmlsbCgwKTtcbiAgICAgIHJldHVybiB7IGF1dGhLZXksIGVuY0tleTogZXhwYW5kS2V5TEUoZW5jS2V5KSB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBfY29tcHV0ZVRhZyhlbmNLZXk6IFVpbnQzMkFycmF5LCBhdXRoS2V5OiBVaW50OEFycmF5LCBkYXRhOiBVaW50OEFycmF5KSB7XG4gICAgICBjb25zdCB0YWcgPSBjb21wdXRlVGFnKHBvbHl2YWwsIHRydWUsIGF1dGhLZXksIGRhdGEsIEFBRCk7XG4gICAgICAvLyBDb21wdXRlIHRoZSBleHBlY3RlZCB0YWcgYnkgWE9SaW5nIFNfcyBhbmQgdGhlIG5vbmNlLCBjbGVhcmluZyB0aGVcbiAgICAgIC8vIG1vc3Qgc2lnbmlmaWNhbnQgYml0IG9mIHRoZSBsYXN0IGJ5dGUgYW5kIGVuY3J5cHRpbmcgd2l0aCB0aGVcbiAgICAgIC8vIG1lc3NhZ2UtZW5jcnlwdGlvbiBrZXkuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEyOyBpKyspIHRhZ1tpXSBePSBub25jZVtpXTtcbiAgICAgIHRhZ1sxNV0gJj0gMHg3ZjsgLy8gQ2xlYXIgdGhlIGhpZ2hlc3QgYml0XG4gICAgICAvLyBlbmNyeXB0IHRhZyBhcyBibG9ja1xuICAgICAgY29uc3QgdDMyID0gdTMyKHRhZyk7XG4gICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgIGxldCBzMCA9IHQzMlswXSwgczEgPSB0MzJbMV0sIHMyID0gdDMyWzJdLCBzMyA9IHQzMlszXTtcbiAgICAgICh7IHMwLCBzMSwgczIsIHMzIH0gPSBlbmNyeXB0KGVuY0tleSwgczAsIHMxLCBzMiwgczMpKTtcbiAgICAgICh0MzJbMF0gPSBzMCksICh0MzJbMV0gPSBzMSksICh0MzJbMl0gPSBzMiksICh0MzJbM10gPSBzMyk7XG4gICAgICByZXR1cm4gdGFnO1xuICAgIH1cbiAgICAvLyBhY3R1YWwgZGVjcnlwdC9lbmNyeXB0IG9mIG1lc3NhZ2UuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc1NpdihlbmNLZXk6IFVpbnQzMkFycmF5LCB0YWc6IFVpbnQ4QXJyYXksIGlucHV0OiBVaW50OEFycmF5KSB7XG4gICAgICBsZXQgYmxvY2sgPSB0YWcuc2xpY2UoKTtcbiAgICAgIGJsb2NrWzE1XSB8PSAweDgwOyAvLyBGb3JjZSBoaWdoZXN0IGJpdFxuICAgICAgcmV0dXJuIGN0cjMyKGVuY0tleSwgdHJ1ZSwgYmxvY2ssIGlucHV0KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGVuY3J5cHQ6IChwbGFpbnRleHQ6IFVpbnQ4QXJyYXkpID0+IHtcbiAgICAgICAgYWJ5dGVzKHBsYWludGV4dCk7XG4gICAgICAgIFBMQUlOX0xJTUlUKHBsYWludGV4dC5sZW5ndGgpO1xuICAgICAgICBjb25zdCB7IGVuY0tleSwgYXV0aEtleSB9ID0gZGVyaXZlS2V5cygpO1xuICAgICAgICBjb25zdCB0YWcgPSBfY29tcHV0ZVRhZyhlbmNLZXksIGF1dGhLZXksIHBsYWludGV4dCk7XG4gICAgICAgIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KHBsYWludGV4dC5sZW5ndGggKyB0YWdMZW5ndGgpO1xuICAgICAgICBvdXQuc2V0KHRhZywgcGxhaW50ZXh0Lmxlbmd0aCk7XG4gICAgICAgIG91dC5zZXQocHJvY2Vzc1NpdihlbmNLZXksIHRhZywgcGxhaW50ZXh0KSk7XG4gICAgICAgIGVuY0tleS5maWxsKDApO1xuICAgICAgICBhdXRoS2V5LmZpbGwoMCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgICB9LFxuICAgICAgZGVjcnlwdDogKGNpcGhlcnRleHQ6IFVpbnQ4QXJyYXkpID0+IHtcbiAgICAgICAgYWJ5dGVzKGNpcGhlcnRleHQpO1xuICAgICAgICBDSVBIRVJfTElNSVQoY2lwaGVydGV4dC5sZW5ndGgpO1xuICAgICAgICBjb25zdCB0YWcgPSBjaXBoZXJ0ZXh0LnN1YmFycmF5KC10YWdMZW5ndGgpO1xuICAgICAgICBjb25zdCB7IGVuY0tleSwgYXV0aEtleSB9ID0gZGVyaXZlS2V5cygpO1xuICAgICAgICBjb25zdCBwbGFpbnRleHQgPSBwcm9jZXNzU2l2KGVuY0tleSwgdGFnLCBjaXBoZXJ0ZXh0LnN1YmFycmF5KDAsIC10YWdMZW5ndGgpKTtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRUYWcgPSBfY29tcHV0ZVRhZyhlbmNLZXksIGF1dGhLZXksIHBsYWludGV4dCk7XG4gICAgICAgIGVuY0tleS5maWxsKDApO1xuICAgICAgICBhdXRoS2V5LmZpbGwoMCk7XG4gICAgICAgIGlmICghZXF1YWxCeXRlcyh0YWcsIGV4cGVjdGVkVGFnKSkgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBvbHl2YWwgdGFnJyk7XG4gICAgICAgIHJldHVybiBwbGFpbnRleHQ7XG4gICAgICB9LFxuICAgIH07XG4gIH1cbik7XG5cbmZ1bmN0aW9uIGlzQnl0ZXMzMihhOiB1bmtub3duKTogYSBpcyBVaW50OEFycmF5IHtcbiAgcmV0dXJuIChcbiAgICBhICE9IG51bGwgJiZcbiAgICB0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiZcbiAgICAoYSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5IHx8IGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQzMkFycmF5JylcbiAgKTtcbn1cblxuZnVuY3Rpb24gZW5jcnlwdEJsb2NrKHhrOiBVaW50MzJBcnJheSwgYmxvY2s6IFVpbnQ4QXJyYXkpIHtcbiAgYWJ5dGVzKGJsb2NrLCAxNik7XG4gIGlmICghaXNCeXRlczMyKHhrKSkgdGhyb3cgbmV3IEVycm9yKCdfZW5jcnlwdEJsb2NrIGFjY2VwdHMgcmVzdWx0IG9mIGV4cGFuZEtleUxFJyk7XG4gIGNvbnN0IGIzMiA9IHUzMihibG9jayk7XG4gIGxldCB7IHMwLCBzMSwgczIsIHMzIH0gPSBlbmNyeXB0KHhrLCBiMzJbMF0sIGIzMlsxXSwgYjMyWzJdLCBiMzJbM10pO1xuICAoYjMyWzBdID0gczApLCAoYjMyWzFdID0gczEpLCAoYjMyWzJdID0gczIpLCAoYjMyWzNdID0gczMpO1xuICByZXR1cm4gYmxvY2s7XG59XG5cbmZ1bmN0aW9uIGRlY3J5cHRCbG9jayh4azogVWludDMyQXJyYXksIGJsb2NrOiBVaW50OEFycmF5KSB7XG4gIGFieXRlcyhibG9jaywgMTYpO1xuICBpZiAoIWlzQnl0ZXMzMih4aykpIHRocm93IG5ldyBFcnJvcignX2RlY3J5cHRCbG9jayBhY2NlcHRzIHJlc3VsdCBvZiBleHBhbmRLZXlMRScpO1xuICBjb25zdCBiMzIgPSB1MzIoYmxvY2spO1xuICBsZXQgeyBzMCwgczEsIHMyLCBzMyB9ID0gZGVjcnlwdCh4aywgYjMyWzBdLCBiMzJbMV0sIGIzMlsyXSwgYjMyWzNdKTtcbiAgKGIzMlswXSA9IHMwKSwgKGIzMlsxXSA9IHMxKSwgKGIzMlsyXSA9IHMyKSwgKGIzMlszXSA9IHMzKTtcbiAgcmV0dXJuIGJsb2NrO1xufVxuXG4vLyBIaWdobHkgdW5zYWZlIHByaXZhdGUgZnVuY3Rpb25zIGZvciBpbXBsZW1lbnRpbmcgbmV3IG1vZGVzIG9yIGNpcGhlcnMgYmFzZWQgb24gQUVTXG4vLyBDYW4gY2hhbmdlIGF0IGFueSB0aW1lLCBubyBBUEkgZ3VhcmFudGVlc1xuZXhwb3J0IGNvbnN0IHVuc2FmZSA9IHtcbiAgZXhwYW5kS2V5TEUsXG4gIGV4cGFuZEtleURlY0xFLFxuICBlbmNyeXB0LFxuICBkZWNyeXB0LFxuICBlbmNyeXB0QmxvY2ssXG4gIGRlY3J5cHRCbG9jayxcbiAgY3RyQ291bnRlcixcbiAgY3RyMzIsXG59O1xuIiwgImltcG9ydCB7IGV4aXN0cyBhcyBhZXhpc3RzLCBieXRlcyBhcyBhYnl0ZXMsIG91dHB1dCBhcyBhb3V0cHV0IH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IElucHV0LCB0b0J5dGVzLCBIYXNoIH0gZnJvbSAnLi91dGlscy5qcyc7XG5cbi8vIFBvbHkxMzA1IGlzIGEgZmFzdCBhbmQgcGFyYWxsZWwgc2VjcmV0LWtleSBtZXNzYWdlLWF1dGhlbnRpY2F0aW9uIGNvZGUuXG4vLyBodHRwczovL2NyLnlwLnRvL21hYy5odG1sLCBodHRwczovL2NyLnlwLnRvL21hYy9wb2x5MTMwNS0yMDA1MDMyOS5wZGZcbi8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjODQzOVxuXG4vLyBCYXNlZCBvbiBQdWJsaWMgRG9tYWluIHBvbHkxMzA1LWRvbm5hIGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9vZHliZXJyeS9wb2x5MTMwNS1kb25uYVxuY29uc3QgdTh0bzE2ID0gKGE6IFVpbnQ4QXJyYXksIGk6IG51bWJlcikgPT4gKGFbaSsrXSAmIDB4ZmYpIHwgKChhW2krK10gJiAweGZmKSA8PCA4KTtcbmNsYXNzIFBvbHkxMzA1IGltcGxlbWVudHMgSGFzaDxQb2x5MTMwNT4ge1xuICByZWFkb25seSBibG9ja0xlbiA9IDE2O1xuICByZWFkb25seSBvdXRwdXRMZW4gPSAxNjtcbiAgcHJpdmF0ZSBidWZmZXIgPSBuZXcgVWludDhBcnJheSgxNik7XG4gIHByaXZhdGUgciA9IG5ldyBVaW50MTZBcnJheSgxMCk7XG4gIHByaXZhdGUgaCA9IG5ldyBVaW50MTZBcnJheSgxMCk7XG4gIHByaXZhdGUgcGFkID0gbmV3IFVpbnQxNkFycmF5KDgpO1xuICBwcml2YXRlIHBvcyA9IDA7XG4gIHByb3RlY3RlZCBmaW5pc2hlZCA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKGtleTogSW5wdXQpIHtcbiAgICBrZXkgPSB0b0J5dGVzKGtleSk7XG4gICAgYWJ5dGVzKGtleSwgMzIpO1xuICAgIGNvbnN0IHQwID0gdTh0bzE2KGtleSwgMCk7XG4gICAgY29uc3QgdDEgPSB1OHRvMTYoa2V5LCAyKTtcbiAgICBjb25zdCB0MiA9IHU4dG8xNihrZXksIDQpO1xuICAgIGNvbnN0IHQzID0gdTh0bzE2KGtleSwgNik7XG4gICAgY29uc3QgdDQgPSB1OHRvMTYoa2V5LCA4KTtcbiAgICBjb25zdCB0NSA9IHU4dG8xNihrZXksIDEwKTtcbiAgICBjb25zdCB0NiA9IHU4dG8xNihrZXksIDEyKTtcbiAgICBjb25zdCB0NyA9IHU4dG8xNihrZXksIDE0KTtcblxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9vZHliZXJyeS9wb2x5MTMwNS1kb25uYS9ibG9iL2U2YWQ2ZTA5MWQzMGQ3ZjRlYzJkNGY5NzhiZTFmY2ZjYmNlNzI3ODEvcG9seTEzMDUtZG9ubmEtMTYuaCNMNDdcbiAgICB0aGlzLnJbMF0gPSB0MCAmIDB4MWZmZjtcbiAgICB0aGlzLnJbMV0gPSAoKHQwID4+PiAxMykgfCAodDEgPDwgMykpICYgMHgxZmZmO1xuICAgIHRoaXMuclsyXSA9ICgodDEgPj4+IDEwKSB8ICh0MiA8PCA2KSkgJiAweDFmMDM7XG4gICAgdGhpcy5yWzNdID0gKCh0MiA+Pj4gNykgfCAodDMgPDwgOSkpICYgMHgxZmZmO1xuICAgIHRoaXMucls0XSA9ICgodDMgPj4+IDQpIHwgKHQ0IDw8IDEyKSkgJiAweDAwZmY7XG4gICAgdGhpcy5yWzVdID0gKHQ0ID4+PiAxKSAmIDB4MWZmZTtcbiAgICB0aGlzLnJbNl0gPSAoKHQ0ID4+PiAxNCkgfCAodDUgPDwgMikpICYgMHgxZmZmO1xuICAgIHRoaXMucls3XSA9ICgodDUgPj4+IDExKSB8ICh0NiA8PCA1KSkgJiAweDFmODE7XG4gICAgdGhpcy5yWzhdID0gKCh0NiA+Pj4gOCkgfCAodDcgPDwgOCkpICYgMHgxZmZmO1xuICAgIHRoaXMucls5XSA9ICh0NyA+Pj4gNSkgJiAweDAwN2Y7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpKyspIHRoaXMucGFkW2ldID0gdTh0bzE2KGtleSwgMTYgKyAyICogaSk7XG4gIH1cblxuICBwcml2YXRlIHByb2Nlc3MoZGF0YTogVWludDhBcnJheSwgb2Zmc2V0OiBudW1iZXIsIGlzTGFzdCA9IGZhbHNlKSB7XG4gICAgY29uc3QgaGliaXQgPSBpc0xhc3QgPyAwIDogMSA8PCAxMTtcbiAgICBjb25zdCB7IGgsIHIgfSA9IHRoaXM7XG4gICAgY29uc3QgcjAgPSByWzBdO1xuICAgIGNvbnN0IHIxID0gclsxXTtcbiAgICBjb25zdCByMiA9IHJbMl07XG4gICAgY29uc3QgcjMgPSByWzNdO1xuICAgIGNvbnN0IHI0ID0gcls0XTtcbiAgICBjb25zdCByNSA9IHJbNV07XG4gICAgY29uc3QgcjYgPSByWzZdO1xuICAgIGNvbnN0IHI3ID0gcls3XTtcbiAgICBjb25zdCByOCA9IHJbOF07XG4gICAgY29uc3QgcjkgPSByWzldO1xuXG4gICAgY29uc3QgdDAgPSB1OHRvMTYoZGF0YSwgb2Zmc2V0ICsgMCk7XG4gICAgY29uc3QgdDEgPSB1OHRvMTYoZGF0YSwgb2Zmc2V0ICsgMik7XG4gICAgY29uc3QgdDIgPSB1OHRvMTYoZGF0YSwgb2Zmc2V0ICsgNCk7XG4gICAgY29uc3QgdDMgPSB1OHRvMTYoZGF0YSwgb2Zmc2V0ICsgNik7XG4gICAgY29uc3QgdDQgPSB1OHRvMTYoZGF0YSwgb2Zmc2V0ICsgOCk7XG4gICAgY29uc3QgdDUgPSB1OHRvMTYoZGF0YSwgb2Zmc2V0ICsgMTApO1xuICAgIGNvbnN0IHQ2ID0gdTh0bzE2KGRhdGEsIG9mZnNldCArIDEyKTtcbiAgICBjb25zdCB0NyA9IHU4dG8xNihkYXRhLCBvZmZzZXQgKyAxNCk7XG5cbiAgICBsZXQgaDAgPSBoWzBdICsgKHQwICYgMHgxZmZmKTtcbiAgICBsZXQgaDEgPSBoWzFdICsgKCgodDAgPj4+IDEzKSB8ICh0MSA8PCAzKSkgJiAweDFmZmYpO1xuICAgIGxldCBoMiA9IGhbMl0gKyAoKCh0MSA+Pj4gMTApIHwgKHQyIDw8IDYpKSAmIDB4MWZmZik7XG4gICAgbGV0IGgzID0gaFszXSArICgoKHQyID4+PiA3KSB8ICh0MyA8PCA5KSkgJiAweDFmZmYpO1xuICAgIGxldCBoNCA9IGhbNF0gKyAoKCh0MyA+Pj4gNCkgfCAodDQgPDwgMTIpKSAmIDB4MWZmZik7XG4gICAgbGV0IGg1ID0gaFs1XSArICgodDQgPj4+IDEpICYgMHgxZmZmKTtcbiAgICBsZXQgaDYgPSBoWzZdICsgKCgodDQgPj4+IDE0KSB8ICh0NSA8PCAyKSkgJiAweDFmZmYpO1xuICAgIGxldCBoNyA9IGhbN10gKyAoKCh0NSA+Pj4gMTEpIHwgKHQ2IDw8IDUpKSAmIDB4MWZmZik7XG4gICAgbGV0IGg4ID0gaFs4XSArICgoKHQ2ID4+PiA4KSB8ICh0NyA8PCA4KSkgJiAweDFmZmYpO1xuICAgIGxldCBoOSA9IGhbOV0gKyAoKHQ3ID4+PiA1KSB8IGhpYml0KTtcblxuICAgIGxldCBjID0gMDtcblxuICAgIGxldCBkMCA9IGMgKyBoMCAqIHIwICsgaDEgKiAoNSAqIHI5KSArIGgyICogKDUgKiByOCkgKyBoMyAqICg1ICogcjcpICsgaDQgKiAoNSAqIHI2KTtcbiAgICBjID0gZDAgPj4+IDEzO1xuICAgIGQwICY9IDB4MWZmZjtcbiAgICBkMCArPSBoNSAqICg1ICogcjUpICsgaDYgKiAoNSAqIHI0KSArIGg3ICogKDUgKiByMykgKyBoOCAqICg1ICogcjIpICsgaDkgKiAoNSAqIHIxKTtcbiAgICBjICs9IGQwID4+PiAxMztcbiAgICBkMCAmPSAweDFmZmY7XG5cbiAgICBsZXQgZDEgPSBjICsgaDAgKiByMSArIGgxICogcjAgKyBoMiAqICg1ICogcjkpICsgaDMgKiAoNSAqIHI4KSArIGg0ICogKDUgKiByNyk7XG4gICAgYyA9IGQxID4+PiAxMztcbiAgICBkMSAmPSAweDFmZmY7XG4gICAgZDEgKz0gaDUgKiAoNSAqIHI2KSArIGg2ICogKDUgKiByNSkgKyBoNyAqICg1ICogcjQpICsgaDggKiAoNSAqIHIzKSArIGg5ICogKDUgKiByMik7XG4gICAgYyArPSBkMSA+Pj4gMTM7XG4gICAgZDEgJj0gMHgxZmZmO1xuXG4gICAgbGV0IGQyID0gYyArIGgwICogcjIgKyBoMSAqIHIxICsgaDIgKiByMCArIGgzICogKDUgKiByOSkgKyBoNCAqICg1ICogcjgpO1xuICAgIGMgPSBkMiA+Pj4gMTM7XG4gICAgZDIgJj0gMHgxZmZmO1xuICAgIGQyICs9IGg1ICogKDUgKiByNykgKyBoNiAqICg1ICogcjYpICsgaDcgKiAoNSAqIHI1KSArIGg4ICogKDUgKiByNCkgKyBoOSAqICg1ICogcjMpO1xuICAgIGMgKz0gZDIgPj4+IDEzO1xuICAgIGQyICY9IDB4MWZmZjtcblxuICAgIGxldCBkMyA9IGMgKyBoMCAqIHIzICsgaDEgKiByMiArIGgyICogcjEgKyBoMyAqIHIwICsgaDQgKiAoNSAqIHI5KTtcbiAgICBjID0gZDMgPj4+IDEzO1xuICAgIGQzICY9IDB4MWZmZjtcbiAgICBkMyArPSBoNSAqICg1ICogcjgpICsgaDYgKiAoNSAqIHI3KSArIGg3ICogKDUgKiByNikgKyBoOCAqICg1ICogcjUpICsgaDkgKiAoNSAqIHI0KTtcbiAgICBjICs9IGQzID4+PiAxMztcbiAgICBkMyAmPSAweDFmZmY7XG5cbiAgICBsZXQgZDQgPSBjICsgaDAgKiByNCArIGgxICogcjMgKyBoMiAqIHIyICsgaDMgKiByMSArIGg0ICogcjA7XG4gICAgYyA9IGQ0ID4+PiAxMztcbiAgICBkNCAmPSAweDFmZmY7XG4gICAgZDQgKz0gaDUgKiAoNSAqIHI5KSArIGg2ICogKDUgKiByOCkgKyBoNyAqICg1ICogcjcpICsgaDggKiAoNSAqIHI2KSArIGg5ICogKDUgKiByNSk7XG4gICAgYyArPSBkNCA+Pj4gMTM7XG4gICAgZDQgJj0gMHgxZmZmO1xuXG4gICAgbGV0IGQ1ID0gYyArIGgwICogcjUgKyBoMSAqIHI0ICsgaDIgKiByMyArIGgzICogcjIgKyBoNCAqIHIxO1xuICAgIGMgPSBkNSA+Pj4gMTM7XG4gICAgZDUgJj0gMHgxZmZmO1xuICAgIGQ1ICs9IGg1ICogcjAgKyBoNiAqICg1ICogcjkpICsgaDcgKiAoNSAqIHI4KSArIGg4ICogKDUgKiByNykgKyBoOSAqICg1ICogcjYpO1xuICAgIGMgKz0gZDUgPj4+IDEzO1xuICAgIGQ1ICY9IDB4MWZmZjtcblxuICAgIGxldCBkNiA9IGMgKyBoMCAqIHI2ICsgaDEgKiByNSArIGgyICogcjQgKyBoMyAqIHIzICsgaDQgKiByMjtcbiAgICBjID0gZDYgPj4+IDEzO1xuICAgIGQ2ICY9IDB4MWZmZjtcbiAgICBkNiArPSBoNSAqIHIxICsgaDYgKiByMCArIGg3ICogKDUgKiByOSkgKyBoOCAqICg1ICogcjgpICsgaDkgKiAoNSAqIHI3KTtcbiAgICBjICs9IGQ2ID4+PiAxMztcbiAgICBkNiAmPSAweDFmZmY7XG5cbiAgICBsZXQgZDcgPSBjICsgaDAgKiByNyArIGgxICogcjYgKyBoMiAqIHI1ICsgaDMgKiByNCArIGg0ICogcjM7XG4gICAgYyA9IGQ3ID4+PiAxMztcbiAgICBkNyAmPSAweDFmZmY7XG4gICAgZDcgKz0gaDUgKiByMiArIGg2ICogcjEgKyBoNyAqIHIwICsgaDggKiAoNSAqIHI5KSArIGg5ICogKDUgKiByOCk7XG4gICAgYyArPSBkNyA+Pj4gMTM7XG4gICAgZDcgJj0gMHgxZmZmO1xuXG4gICAgbGV0IGQ4ID0gYyArIGgwICogcjggKyBoMSAqIHI3ICsgaDIgKiByNiArIGgzICogcjUgKyBoNCAqIHI0O1xuICAgIGMgPSBkOCA+Pj4gMTM7XG4gICAgZDggJj0gMHgxZmZmO1xuICAgIGQ4ICs9IGg1ICogcjMgKyBoNiAqIHIyICsgaDcgKiByMSArIGg4ICogcjAgKyBoOSAqICg1ICogcjkpO1xuICAgIGMgKz0gZDggPj4+IDEzO1xuICAgIGQ4ICY9IDB4MWZmZjtcblxuICAgIGxldCBkOSA9IGMgKyBoMCAqIHI5ICsgaDEgKiByOCArIGgyICogcjcgKyBoMyAqIHI2ICsgaDQgKiByNTtcbiAgICBjID0gZDkgPj4+IDEzO1xuICAgIGQ5ICY9IDB4MWZmZjtcbiAgICBkOSArPSBoNSAqIHI0ICsgaDYgKiByMyArIGg3ICogcjIgKyBoOCAqIHIxICsgaDkgKiByMDtcbiAgICBjICs9IGQ5ID4+PiAxMztcbiAgICBkOSAmPSAweDFmZmY7XG5cbiAgICBjID0gKChjIDw8IDIpICsgYykgfCAwO1xuICAgIGMgPSAoYyArIGQwKSB8IDA7XG4gICAgZDAgPSBjICYgMHgxZmZmO1xuICAgIGMgPSBjID4+PiAxMztcbiAgICBkMSArPSBjO1xuXG4gICAgaFswXSA9IGQwO1xuICAgIGhbMV0gPSBkMTtcbiAgICBoWzJdID0gZDI7XG4gICAgaFszXSA9IGQzO1xuICAgIGhbNF0gPSBkNDtcbiAgICBoWzVdID0gZDU7XG4gICAgaFs2XSA9IGQ2O1xuICAgIGhbN10gPSBkNztcbiAgICBoWzhdID0gZDg7XG4gICAgaFs5XSA9IGQ5O1xuICB9XG5cbiAgcHJpdmF0ZSBmaW5hbGl6ZSgpIHtcbiAgICBjb25zdCB7IGgsIHBhZCB9ID0gdGhpcztcbiAgICBjb25zdCBnID0gbmV3IFVpbnQxNkFycmF5KDEwKTtcbiAgICBsZXQgYyA9IGhbMV0gPj4+IDEzO1xuICAgIGhbMV0gJj0gMHgxZmZmO1xuICAgIGZvciAobGV0IGkgPSAyOyBpIDwgMTA7IGkrKykge1xuICAgICAgaFtpXSArPSBjO1xuICAgICAgYyA9IGhbaV0gPj4+IDEzO1xuICAgICAgaFtpXSAmPSAweDFmZmY7XG4gICAgfVxuICAgIGhbMF0gKz0gYyAqIDU7XG4gICAgYyA9IGhbMF0gPj4+IDEzO1xuICAgIGhbMF0gJj0gMHgxZmZmO1xuICAgIGhbMV0gKz0gYztcbiAgICBjID0gaFsxXSA+Pj4gMTM7XG4gICAgaFsxXSAmPSAweDFmZmY7XG4gICAgaFsyXSArPSBjO1xuXG4gICAgZ1swXSA9IGhbMF0gKyA1O1xuICAgIGMgPSBnWzBdID4+PiAxMztcbiAgICBnWzBdICY9IDB4MWZmZjtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IDEwOyBpKyspIHtcbiAgICAgIGdbaV0gPSBoW2ldICsgYztcbiAgICAgIGMgPSBnW2ldID4+PiAxMztcbiAgICAgIGdbaV0gJj0gMHgxZmZmO1xuICAgIH1cbiAgICBnWzldIC09IDEgPDwgMTM7XG5cbiAgICBsZXQgbWFzayA9IChjIF4gMSkgLSAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykgZ1tpXSAmPSBtYXNrO1xuICAgIG1hc2sgPSB+bWFzaztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIGhbaV0gPSAoaFtpXSAmIG1hc2spIHwgZ1tpXTtcbiAgICBoWzBdID0gKGhbMF0gfCAoaFsxXSA8PCAxMykpICYgMHhmZmZmO1xuICAgIGhbMV0gPSAoKGhbMV0gPj4+IDMpIHwgKGhbMl0gPDwgMTApKSAmIDB4ZmZmZjtcbiAgICBoWzJdID0gKChoWzJdID4+PiA2KSB8IChoWzNdIDw8IDcpKSAmIDB4ZmZmZjtcbiAgICBoWzNdID0gKChoWzNdID4+PiA5KSB8IChoWzRdIDw8IDQpKSAmIDB4ZmZmZjtcbiAgICBoWzRdID0gKChoWzRdID4+PiAxMikgfCAoaFs1XSA8PCAxKSB8IChoWzZdIDw8IDE0KSkgJiAweGZmZmY7XG4gICAgaFs1XSA9ICgoaFs2XSA+Pj4gMikgfCAoaFs3XSA8PCAxMSkpICYgMHhmZmZmO1xuICAgIGhbNl0gPSAoKGhbN10gPj4+IDUpIHwgKGhbOF0gPDwgOCkpICYgMHhmZmZmO1xuICAgIGhbN10gPSAoKGhbOF0gPj4+IDgpIHwgKGhbOV0gPDwgNSkpICYgMHhmZmZmO1xuXG4gICAgbGV0IGYgPSBoWzBdICsgcGFkWzBdO1xuICAgIGhbMF0gPSBmICYgMHhmZmZmO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgODsgaSsrKSB7XG4gICAgICBmID0gKCgoaFtpXSArIHBhZFtpXSkgfCAwKSArIChmID4+PiAxNikpIHwgMDtcbiAgICAgIGhbaV0gPSBmICYgMHhmZmZmO1xuICAgIH1cbiAgfVxuICB1cGRhdGUoZGF0YTogSW5wdXQpOiB0aGlzIHtcbiAgICBhZXhpc3RzKHRoaXMpO1xuICAgIGNvbnN0IHsgYnVmZmVyLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICBkYXRhID0gdG9CeXRlcyhkYXRhKTtcbiAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcblxuICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjsgKSB7XG4gICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgIC8vIEZhc3QgcGF0aDogd2UgaGF2ZSBhdCBsZWFzdCBvbmUgYmxvY2sgaW4gaW5wdXRcbiAgICAgIGlmICh0YWtlID09PSBibG9ja0xlbikge1xuICAgICAgICBmb3IgKDsgYmxvY2tMZW4gPD0gbGVuIC0gcG9zOyBwb3MgKz0gYmxvY2tMZW4pIHRoaXMucHJvY2VzcyhkYXRhLCBwb3MpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJ1ZmZlci5zZXQoZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIHRha2UpLCB0aGlzLnBvcyk7XG4gICAgICB0aGlzLnBvcyArPSB0YWtlO1xuICAgICAgcG9zICs9IHRha2U7XG4gICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgIHRoaXMucHJvY2VzcyhidWZmZXIsIDAsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuaC5maWxsKDApO1xuICAgIHRoaXMuci5maWxsKDApO1xuICAgIHRoaXMuYnVmZmVyLmZpbGwoMCk7XG4gICAgdGhpcy5wYWQuZmlsbCgwKTtcbiAgfVxuICBkaWdlc3RJbnRvKG91dDogVWludDhBcnJheSkge1xuICAgIGFleGlzdHModGhpcyk7XG4gICAgYW91dHB1dChvdXQsIHRoaXMpO1xuICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgIGNvbnN0IHsgYnVmZmVyLCBoIH0gPSB0aGlzO1xuICAgIGxldCB7IHBvcyB9ID0gdGhpcztcbiAgICBpZiAocG9zKSB7XG4gICAgICBidWZmZXJbcG9zKytdID0gMTtcbiAgICAgIC8vIGJ1ZmZlci5zdWJhcnJheShwb3MpLmZpbGwoMCk7XG4gICAgICBmb3IgKDsgcG9zIDwgMTY7IHBvcysrKSBidWZmZXJbcG9zXSA9IDA7XG4gICAgICB0aGlzLnByb2Nlc3MoYnVmZmVyLCAwLCB0cnVlKTtcbiAgICB9XG4gICAgdGhpcy5maW5hbGl6ZSgpO1xuICAgIGxldCBvcG9zID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkrKykge1xuICAgICAgb3V0W29wb3MrK10gPSBoW2ldID4+PiAwO1xuICAgICAgb3V0W29wb3MrK10gPSBoW2ldID4+PiA4O1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIGRpZ2VzdCgpOiBVaW50OEFycmF5IHtcbiAgICBjb25zdCB7IGJ1ZmZlciwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgIHRoaXMuZGlnZXN0SW50byhidWZmZXIpO1xuICAgIGNvbnN0IHJlcyA9IGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRMZW4pO1xuICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIHJldHVybiByZXM7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgQ0hhc2ggPSBSZXR1cm5UeXBlPHR5cGVvZiB3cmFwQ29uc3RydWN0b3JXaXRoS2V5PjtcbmV4cG9ydCBmdW5jdGlvbiB3cmFwQ29uc3RydWN0b3JXaXRoS2V5PEggZXh0ZW5kcyBIYXNoPEg+PihoYXNoQ29uczogKGtleTogSW5wdXQpID0+IEhhc2g8SD4pIHtcbiAgY29uc3QgaGFzaEMgPSAobXNnOiBJbnB1dCwga2V5OiBJbnB1dCk6IFVpbnQ4QXJyYXkgPT4gaGFzaENvbnMoa2V5KS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgY29uc3QgdG1wID0gaGFzaENvbnMobmV3IFVpbnQ4QXJyYXkoMzIpKTtcbiAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gIGhhc2hDLmNyZWF0ZSA9IChrZXk6IElucHV0KSA9PiBoYXNoQ29ucyhrZXkpO1xuICByZXR1cm4gaGFzaEM7XG59XG5cbmV4cG9ydCBjb25zdCBwb2x5MTMwNSA9IHdyYXBDb25zdHJ1Y3RvcldpdGhLZXkoKGtleSkgPT4gbmV3IFBvbHkxMzA1KGtleSkpO1xuIiwgIi8vIEJhc2ljIHV0aWxzIGZvciBBUlggKGFkZC1yb3RhdGUteG9yKSBzYWxzYSBhbmQgY2hhY2hhIGNpcGhlcnMuXG5pbXBvcnQgeyBudW1iZXIgYXMgYW51bWJlciwgYnl0ZXMgYXMgYWJ5dGVzLCBib29sIGFzIGFib29sIH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IFhvclN0cmVhbSwgY2hlY2tPcHRzLCB1MzIsIHV0ZjhUb0J5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG5cbi8qXG5SRkM4NDM5IHJlcXVpcmVzIG11bHRpLXN0ZXAgY2lwaGVyIHN0cmVhbSwgd2hlcmVcbmF1dGhLZXkgc3RhcnRzIHdpdGggY291bnRlcjogMCwgYWN0dWFsIG1zZyB3aXRoIGNvdW50ZXI6IDEuXG5cbkZvciB0aGlzLCB3ZSBuZWVkIGEgd2F5IHRvIHJlLXVzZSBub25jZSAvIGNvdW50ZXI6XG5cbiAgICBjb25zdCBjb3VudGVyID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgY2hhY2hhKC4uLiwgY291bnRlciwgLi4uKTsgLy8gY291bnRlciBpcyBub3cgMVxuICAgIGNoYWNoYSguLi4sIGNvdW50ZXIsIC4uLik7IC8vIGNvdW50ZXIgaXMgbm93IDJcblxuVGhpcyBpcyBjb21wbGljYXRlZDpcblxuLSAzMi1iaXQgY291bnRlcnMgYXJlIGVub3VnaCwgbm8gbmVlZCBmb3IgNjQtYml0OiBtYXggQXJyYXlCdWZmZXIgc2l6ZSBpbiBKUyBpcyA0R0Jcbi0gT3JpZ2luYWwgcGFwZXJzIGRvbid0IGFsbG93IG11dGF0aW5nIGNvdW50ZXJzXG4tIENvdW50ZXIgb3ZlcmZsb3cgaXMgdW5kZWZpbmVkIFteMV1cbi0gSWRlYSBBOiBhbGxvdyBwcm92aWRpbmcgKG5vbmNlIHwgY291bnRlcikgaW5zdGVhZCBvZiBqdXN0IG5vbmNlLCByZS11c2UgaXRcbi0gQ2F2ZWF0OiBDYW5ub3QgYmUgcmUtdXNlZCB0aHJvdWdoIGFsbCBjYXNlczpcbi0gKiBjaGFjaGEgaGFzIChjb3VudGVyIHwgbm9uY2UpXG4tICogeGNoYWNoYSBoYXMgKG5vbmNlMTYgfCBjb3VudGVyIHwgbm9uY2UxNilcbi0gSWRlYSBCOiBzZXBhcmF0ZSBub25jZSAvIGNvdW50ZXIgYW5kIHByb3ZpZGUgc2VwYXJhdGUgQVBJIGZvciBjb3VudGVyIHJlLXVzZVxuLSBDYXZlYXQ6IHRoZXJlIGFyZSBkaWZmZXJlbnQgY291bnRlciBzaXplcyBkZXBlbmRpbmcgb24gYW4gYWxnb3JpdGhtLlxuLSBzYWxzYSAmIGNoYWNoYSBhbHNvIGRpZmZlciBpbiBzdHJ1Y3R1cmVzIG9mIGtleSAmIHNpZ21hOlxuICBzYWxzYTIwOiAgICAgIHNbMF0gfCBrKDQpIHwgc1sxXSB8IG5vbmNlKDIpIHwgY3RyKDIpIHwgc1syXSB8IGsoNCkgfCBzWzNdXG4gIGNoYWNoYTogICAgICAgcyg0KSB8IGsoOCkgfCBjdHIoMSkgfCBub25jZSgzKVxuICBjaGFjaGEyMG9yaWc6IHMoNCkgfCBrKDgpIHwgY3RyKDIpIHwgbm9uY2UoMilcbi0gSWRlYSBDOiBoZWxwZXIgbWV0aG9kIHN1Y2ggYXMgYHNldFNhbHNhU3RhdGUoa2V5LCBub25jZSwgc2lnbWEsIGRhdGEpYFxuLSBDYXZlYXQ6IHdlIGNhbid0IHJlLXVzZSBjb3VudGVyIGFycmF5XG5cbnhjaGFjaGEgW14yXSB1c2VzIHRoZSBzdWJrZXkgYW5kIHJlbWFpbmluZyA4IGJ5dGUgbm9uY2Ugd2l0aCBDaGFDaGEyMCBhcyBub3JtYWxcbihwcmVmaXhlZCBieSA0IE5VTCBieXRlcywgc2luY2UgW1JGQzg0MzldIHNwZWNpZmllcyBhIDEyLWJ5dGUgbm9uY2UpLlxuXG5bXjFdOiBodHRwczovL21haWxhcmNoaXZlLmlldGYub3JnL2FyY2gvbXNnL2NmcmcvZ3NPblRKemNiZ0c2T3FEOFNjMEdPNWFSX3RVL1xuW14yXTogaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pcnRmLWNmcmcteGNoYWNoYSNhcHBlbmRpeC1BLjJcbiovXG5cbmNvbnN0IHNpZ21hMTYgPSB1dGY4VG9CeXRlcygnZXhwYW5kIDE2LWJ5dGUgaycpO1xuY29uc3Qgc2lnbWEzMiA9IHV0ZjhUb0J5dGVzKCdleHBhbmQgMzItYnl0ZSBrJyk7XG5jb25zdCBzaWdtYTE2XzMyID0gdTMyKHNpZ21hMTYpO1xuY29uc3Qgc2lnbWEzMl8zMiA9IHUzMihzaWdtYTMyKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGwoYTogbnVtYmVyLCBiOiBudW1iZXIpOiBudW1iZXIge1xuICByZXR1cm4gKGEgPDwgYikgfCAoYSA+Pj4gKDMyIC0gYikpO1xufVxuXG5leHBvcnQgdHlwZSBDaXBoZXJDb3JlRm4gPSAoXG4gIHNpZ21hOiBVaW50MzJBcnJheSxcbiAga2V5OiBVaW50MzJBcnJheSxcbiAgbm9uY2U6IFVpbnQzMkFycmF5LFxuICBvdXRwdXQ6IFVpbnQzMkFycmF5LFxuICBjb3VudGVyOiBudW1iZXIsXG4gIHJvdW5kcz86IG51bWJlclxuKSA9PiB2b2lkO1xuXG5leHBvcnQgdHlwZSBFeHRlbmROb25jZUZuID0gKFxuICBzaWdtYTogVWludDMyQXJyYXksXG4gIGtleTogVWludDMyQXJyYXksXG4gIGlucHV0OiBVaW50MzJBcnJheSxcbiAgb3V0cHV0OiBVaW50MzJBcnJheVxuKSA9PiB2b2lkO1xuXG5leHBvcnQgdHlwZSBDaXBoZXJPcHRzID0ge1xuICBhbGxvd1Nob3J0S2V5cz86IGJvb2xlYW47IC8vIE9yaWdpbmFsIHNhbHNhIC8gY2hhY2hhIGFsbG93IDE2LWJ5dGUga2V5c1xuICBleHRlbmROb25jZUZuPzogRXh0ZW5kTm9uY2VGbjtcbiAgY291bnRlckxlbmd0aD86IG51bWJlcjtcbiAgY291bnRlclJpZ2h0PzogYm9vbGVhbjsgLy8gcmlnaHQ6IG5vbmNlfGNvdW50ZXI7IGxlZnQ6IGNvdW50ZXJ8bm9uY2VcbiAgcm91bmRzPzogbnVtYmVyO1xufTtcblxuLy8gSXMgYnl0ZSBhcnJheSBhbGlnbmVkIHRvIDQgYnl0ZSBvZmZzZXQgKHUzMik/XG5mdW5jdGlvbiBpc0FsaWduZWQzMihiOiBVaW50OEFycmF5KSB7XG4gIHJldHVybiBiLmJ5dGVPZmZzZXQgJSA0ID09PSAwO1xufVxuXG4vLyBTYWxzYSBhbmQgQ2hhY2hhIGJsb2NrIGxlbmd0aCBpcyBhbHdheXMgNTEyLWJpdFxuY29uc3QgQkxPQ0tfTEVOID0gNjQ7XG5jb25zdCBCTE9DS19MRU4zMiA9IDE2O1xuXG4vLyBuZXcgVWludDMyQXJyYXkoWzIqKjMyXSkgICAvLyA9PiBVaW50MzJBcnJheSgxKSBbIDAgXVxuLy8gbmV3IFVpbnQzMkFycmF5KFsyKiozMi0xXSkgLy8gPT4gVWludDMyQXJyYXkoMSkgWyA0Mjk0OTY3Mjk1IF1cbmNvbnN0IE1BWF9DT1VOVEVSID0gMiAqKiAzMiAtIDE7XG5cbmNvbnN0IFUzMl9FTVBUWSA9IG5ldyBVaW50MzJBcnJheSgpO1xuZnVuY3Rpb24gcnVuQ2lwaGVyKFxuICBjb3JlOiBDaXBoZXJDb3JlRm4sXG4gIHNpZ21hOiBVaW50MzJBcnJheSxcbiAga2V5OiBVaW50MzJBcnJheSxcbiAgbm9uY2U6IFVpbnQzMkFycmF5LFxuICBkYXRhOiBVaW50OEFycmF5LFxuICBvdXRwdXQ6IFVpbnQ4QXJyYXksXG4gIGNvdW50ZXI6IG51bWJlcixcbiAgcm91bmRzOiBudW1iZXJcbik6IHZvaWQge1xuICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgY29uc3QgYmxvY2sgPSBuZXcgVWludDhBcnJheShCTE9DS19MRU4pO1xuICBjb25zdCBiMzIgPSB1MzIoYmxvY2spO1xuICAvLyBNYWtlIHN1cmUgdGhhdCBidWZmZXJzIGFsaWduZWQgdG8gNCBieXRlc1xuICBjb25zdCBpc0FsaWduZWQgPSBpc0FsaWduZWQzMihkYXRhKSAmJiBpc0FsaWduZWQzMihvdXRwdXQpO1xuICBjb25zdCBkMzIgPSBpc0FsaWduZWQgPyB1MzIoZGF0YSkgOiBVMzJfRU1QVFk7XG4gIGNvbnN0IG8zMiA9IGlzQWxpZ25lZCA/IHUzMihvdXRwdXQpIDogVTMyX0VNUFRZO1xuICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47IGNvdW50ZXIrKykge1xuICAgIGNvcmUoc2lnbWEsIGtleSwgbm9uY2UsIGIzMiwgY291bnRlciwgcm91bmRzKTtcbiAgICBpZiAoY291bnRlciA+PSBNQVhfQ09VTlRFUikgdGhyb3cgbmV3IEVycm9yKCdhcng6IGNvdW50ZXIgb3ZlcmZsb3cnKTtcbiAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oQkxPQ0tfTEVOLCBsZW4gLSBwb3MpO1xuICAgIC8vIGFsaWduZWQgdG8gNCBieXRlc1xuICAgIGlmIChpc0FsaWduZWQgJiYgdGFrZSA9PT0gQkxPQ0tfTEVOKSB7XG4gICAgICBjb25zdCBwb3MzMiA9IHBvcyAvIDQ7XG4gICAgICBpZiAocG9zICUgNCAhPT0gMCkgdGhyb3cgbmV3IEVycm9yKCdhcng6IGludmFsaWQgYmxvY2sgcG9zaXRpb24nKTtcbiAgICAgIGZvciAobGV0IGogPSAwLCBwb3NqOiBudW1iZXI7IGogPCBCTE9DS19MRU4zMjsgaisrKSB7XG4gICAgICAgIHBvc2ogPSBwb3MzMiArIGo7XG4gICAgICAgIG8zMltwb3NqXSA9IGQzMltwb3NqXSBeIGIzMltqXTtcbiAgICAgIH1cbiAgICAgIHBvcyArPSBCTE9DS19MRU47XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaiA9IDAsIHBvc2o7IGogPCB0YWtlOyBqKyspIHtcbiAgICAgIHBvc2ogPSBwb3MgKyBqO1xuICAgICAgb3V0cHV0W3Bvc2pdID0gZGF0YVtwb3NqXSBeIGJsb2NrW2pdO1xuICAgIH1cbiAgICBwb3MgKz0gdGFrZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2lwaGVyKGNvcmU6IENpcGhlckNvcmVGbiwgb3B0czogQ2lwaGVyT3B0cyk6IFhvclN0cmVhbSB7XG4gIGNvbnN0IHsgYWxsb3dTaG9ydEtleXMsIGV4dGVuZE5vbmNlRm4sIGNvdW50ZXJMZW5ndGgsIGNvdW50ZXJSaWdodCwgcm91bmRzIH0gPSBjaGVja09wdHMoXG4gICAgeyBhbGxvd1Nob3J0S2V5czogZmFsc2UsIGNvdW50ZXJMZW5ndGg6IDgsIGNvdW50ZXJSaWdodDogZmFsc2UsIHJvdW5kczogMjAgfSxcbiAgICBvcHRzXG4gICk7XG4gIGlmICh0eXBlb2YgY29yZSAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVycm9yKCdjb3JlIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICBhbnVtYmVyKGNvdW50ZXJMZW5ndGgpO1xuICBhbnVtYmVyKHJvdW5kcyk7XG4gIGFib29sKGNvdW50ZXJSaWdodCk7XG4gIGFib29sKGFsbG93U2hvcnRLZXlzKTtcbiAgcmV0dXJuIChcbiAgICBrZXk6IFVpbnQ4QXJyYXksXG4gICAgbm9uY2U6IFVpbnQ4QXJyYXksXG4gICAgZGF0YTogVWludDhBcnJheSxcbiAgICBvdXRwdXQ/OiBVaW50OEFycmF5LFxuICAgIGNvdW50ZXIgPSAwXG4gICk6IFVpbnQ4QXJyYXkgPT4ge1xuICAgIGFieXRlcyhrZXkpO1xuICAgIGFieXRlcyhub25jZSk7XG4gICAgYWJ5dGVzKGRhdGEpO1xuICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgIGlmICghb3V0cHV0KSBvdXRwdXQgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICAgIGFieXRlcyhvdXRwdXQpO1xuICAgIGFudW1iZXIoY291bnRlcik7XG4gICAgaWYgKGNvdW50ZXIgPCAwIHx8IGNvdW50ZXIgPj0gTUFYX0NPVU5URVIpIHRocm93IG5ldyBFcnJvcignYXJ4OiBjb3VudGVyIG92ZXJmbG93Jyk7XG4gICAgaWYgKG91dHB1dC5sZW5ndGggPCBsZW4pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGFyeDogb3V0cHV0ICgke291dHB1dC5sZW5ndGh9KSBpcyBzaG9ydGVyIHRoYW4gZGF0YSAoJHtsZW59KWApO1xuICAgIGNvbnN0IHRvQ2xlYW4gPSBbXTtcblxuICAgIC8vIEtleSAmIHNpZ21hXG4gICAgLy8ga2V5PTE2IC0+IHNpZ21hMTYsIGs9a2V5fGtleVxuICAgIC8vIGtleT0zMiAtPiBzaWdtYTMyLCBrPWtleVxuICAgIGxldCBsID0ga2V5Lmxlbmd0aCxcbiAgICAgIGs6IFVpbnQ4QXJyYXksXG4gICAgICBzaWdtYTogVWludDMyQXJyYXk7XG4gICAgaWYgKGwgPT09IDMyKSB7XG4gICAgICBrID0ga2V5LnNsaWNlKCk7XG4gICAgICB0b0NsZWFuLnB1c2goayk7XG4gICAgICBzaWdtYSA9IHNpZ21hMzJfMzI7XG4gICAgfSBlbHNlIGlmIChsID09PSAxNiAmJiBhbGxvd1Nob3J0S2V5cykge1xuICAgICAgayA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgICAgIGsuc2V0KGtleSk7XG4gICAgICBrLnNldChrZXksIDE2KTtcbiAgICAgIHNpZ21hID0gc2lnbWExNl8zMjtcbiAgICAgIHRvQ2xlYW4ucHVzaChrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBhcng6IGludmFsaWQgMzItYnl0ZSBrZXksIGdvdCBsZW5ndGg9JHtsfWApO1xuICAgIH1cblxuICAgIC8vIE5vbmNlXG4gICAgLy8gc2Fsc2EyMDogICAgICA4ICAgKDgtYnl0ZSBjb3VudGVyKVxuICAgIC8vIGNoYWNoYTIwb3JpZzogOCAgICg4LWJ5dGUgY291bnRlcilcbiAgICAvLyBjaGFjaGEyMDogICAgIDEyICAoNC1ieXRlIGNvdW50ZXIpXG4gICAgLy8geHNhbHNhMjA6ICAgICAyNCAgKDE2IC0+IGhzYWxzYSwgIDggLT4gb2xkIG5vbmNlKVxuICAgIC8vIHhjaGFjaGEyMDogICAgMjQgICgxNiAtPiBoY2hhY2hhLCA4IC0+IG9sZCBub25jZSlcbiAgICAvLyBBbGlnbiBub25jZSB0byA0IGJ5dGVzXG4gICAgaWYgKCFpc0FsaWduZWQzMihub25jZSkpIHtcbiAgICAgIG5vbmNlID0gbm9uY2Uuc2xpY2UoKTtcbiAgICAgIHRvQ2xlYW4ucHVzaChub25jZSk7XG4gICAgfVxuXG4gICAgY29uc3QgazMyID0gdTMyKGspO1xuICAgIC8vIGhzYWxzYSAmIGhjaGFjaGE6IGhhbmRsZSBleHRlbmRlZCBub25jZVxuICAgIGlmIChleHRlbmROb25jZUZuKSB7XG4gICAgICBpZiAobm9uY2UubGVuZ3RoICE9PSAyNCkgdGhyb3cgbmV3IEVycm9yKGBhcng6IGV4dGVuZGVkIG5vbmNlIG11c3QgYmUgMjQgYnl0ZXNgKTtcbiAgICAgIGV4dGVuZE5vbmNlRm4oc2lnbWEsIGszMiwgdTMyKG5vbmNlLnN1YmFycmF5KDAsIDE2KSksIGszMik7XG4gICAgICBub25jZSA9IG5vbmNlLnN1YmFycmF5KDE2KTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgbm9uY2UgY291bnRlclxuICAgIGNvbnN0IG5vbmNlTmNMZW4gPSAxNiAtIGNvdW50ZXJMZW5ndGg7XG4gICAgaWYgKG5vbmNlTmNMZW4gIT09IG5vbmNlLmxlbmd0aClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgYXJ4OiBub25jZSBtdXN0IGJlICR7bm9uY2VOY0xlbn0gb3IgMTYgYnl0ZXNgKTtcblxuICAgIC8vIFBhZCBjb3VudGVyIHdoZW4gbm9uY2UgaXMgNjQgYml0XG4gICAgaWYgKG5vbmNlTmNMZW4gIT09IDEyKSB7XG4gICAgICBjb25zdCBuYyA9IG5ldyBVaW50OEFycmF5KDEyKTtcbiAgICAgIG5jLnNldChub25jZSwgY291bnRlclJpZ2h0ID8gMCA6IDEyIC0gbm9uY2UubGVuZ3RoKTtcbiAgICAgIG5vbmNlID0gbmM7XG4gICAgICB0b0NsZWFuLnB1c2gobm9uY2UpO1xuICAgIH1cbiAgICBjb25zdCBuMzIgPSB1MzIobm9uY2UpO1xuICAgIHJ1bkNpcGhlcihjb3JlLCBzaWdtYSwgazMyLCBuMzIsIGRhdGEsIG91dHB1dCwgY291bnRlciwgcm91bmRzKTtcbiAgICB3aGlsZSAodG9DbGVhbi5sZW5ndGggPiAwKSB0b0NsZWFuLnBvcCgpIS5maWxsKDApO1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH07XG59XG4iLCAiLy8gcHJldHRpZXItaWdub3JlXG5pbXBvcnQge1xuICB3cmFwQ2lwaGVyLCBDaXBoZXJXaXRoT3V0cHV0LCBYb3JTdHJlYW0sIGNyZWF0ZVZpZXcsIGVxdWFsQnl0ZXMsIHNldEJpZ1VpbnQ2NCxcbn0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBwb2x5MTMwNSB9IGZyb20gJy4vX3BvbHkxMzA1LmpzJztcbmltcG9ydCB7IGNyZWF0ZUNpcGhlciwgcm90bCB9IGZyb20gJy4vX2FyeC5qcyc7XG5pbXBvcnQgeyBieXRlcyBhcyBhYnl0ZXMgfSBmcm9tICcuL19hc3NlcnQuanMnO1xuXG4vLyBDaGFDaGEyMCBzdHJlYW0gY2lwaGVyIHdhcyByZWxlYXNlZCBpbiAyMDA4LiBDaGFDaGEgYWltcyB0byBpbmNyZWFzZVxuLy8gdGhlIGRpZmZ1c2lvbiBwZXIgcm91bmQsIGJ1dCBoYWQgc2xpZ2h0bHkgbGVzcyBjcnlwdGFuYWx5c2lzLlxuLy8gaHR0cHM6Ly9jci55cC50by9jaGFjaGEuaHRtbCwgaHR0cDovL2NyLnlwLnRvL2NoYWNoYS9jaGFjaGEtMjAwODAxMjgucGRmXG5cbi8qKlxuICogQ2hhQ2hhIGNvcmUgZnVuY3Rpb24uXG4gKi9cbi8vIHByZXR0aWVyLWlnbm9yZVxuZnVuY3Rpb24gY2hhY2hhQ29yZShcbiAgczogVWludDMyQXJyYXksIGs6IFVpbnQzMkFycmF5LCBuOiBVaW50MzJBcnJheSwgb3V0OiBVaW50MzJBcnJheSwgY250OiBudW1iZXIsIHJvdW5kcyA9IDIwXG4pOiB2b2lkIHtcbiAgbGV0IHkwMCA9IHNbMF0sIHkwMSA9IHNbMV0sIHkwMiA9IHNbMl0sIHkwMyA9IHNbM10sIC8vIFwiZXhwYVwiICAgXCJuZCAzXCIgIFwiMi1ieVwiICBcInRlIGtcIlxuICAgICAgeTA0ID0ga1swXSwgeTA1ID0ga1sxXSwgeTA2ID0ga1syXSwgeTA3ID0ga1szXSwgLy8gS2V5ICAgICAgS2V5ICAgICBLZXkgICAgIEtleVxuICAgICAgeTA4ID0ga1s0XSwgeTA5ID0ga1s1XSwgeTEwID0ga1s2XSwgeTExID0ga1s3XSwgLy8gS2V5ICAgICAgS2V5ICAgICBLZXkgICAgIEtleVxuICAgICAgeTEyID0gY250LCAgeTEzID0gblswXSwgeTE0ID0gblsxXSwgeTE1ID0gblsyXTsgLy8gQ291bnRlciAgQ291bnRlclx0Tm9uY2UgICBOb25jZVxuICAvLyBTYXZlIHN0YXRlIHRvIHRlbXBvcmFyeSB2YXJpYWJsZXNcbiAgbGV0IHgwMCA9IHkwMCwgeDAxID0geTAxLCB4MDIgPSB5MDIsIHgwMyA9IHkwMyxcbiAgICAgIHgwNCA9IHkwNCwgeDA1ID0geTA1LCB4MDYgPSB5MDYsIHgwNyA9IHkwNyxcbiAgICAgIHgwOCA9IHkwOCwgeDA5ID0geTA5LCB4MTAgPSB5MTAsIHgxMSA9IHkxMSxcbiAgICAgIHgxMiA9IHkxMiwgeDEzID0geTEzLCB4MTQgPSB5MTQsIHgxNSA9IHkxNTtcbiAgZm9yIChsZXQgciA9IDA7IHIgPCByb3VuZHM7IHIgKz0gMikge1xuICAgIHgwMCA9ICh4MDAgKyB4MDQpIHwgMDsgeDEyID0gcm90bCh4MTIgXiB4MDAsIDE2KTtcbiAgICB4MDggPSAoeDA4ICsgeDEyKSB8IDA7IHgwNCA9IHJvdGwoeDA0IF4geDA4LCAxMik7XG4gICAgeDAwID0gKHgwMCArIHgwNCkgfCAwOyB4MTIgPSByb3RsKHgxMiBeIHgwMCwgOCk7XG4gICAgeDA4ID0gKHgwOCArIHgxMikgfCAwOyB4MDQgPSByb3RsKHgwNCBeIHgwOCwgNyk7XG5cbiAgICB4MDEgPSAoeDAxICsgeDA1KSB8IDA7IHgxMyA9IHJvdGwoeDEzIF4geDAxLCAxNik7XG4gICAgeDA5ID0gKHgwOSArIHgxMykgfCAwOyB4MDUgPSByb3RsKHgwNSBeIHgwOSwgMTIpO1xuICAgIHgwMSA9ICh4MDEgKyB4MDUpIHwgMDsgeDEzID0gcm90bCh4MTMgXiB4MDEsIDgpO1xuICAgIHgwOSA9ICh4MDkgKyB4MTMpIHwgMDsgeDA1ID0gcm90bCh4MDUgXiB4MDksIDcpO1xuXG4gICAgeDAyID0gKHgwMiArIHgwNikgfCAwOyB4MTQgPSByb3RsKHgxNCBeIHgwMiwgMTYpO1xuICAgIHgxMCA9ICh4MTAgKyB4MTQpIHwgMDsgeDA2ID0gcm90bCh4MDYgXiB4MTAsIDEyKTtcbiAgICB4MDIgPSAoeDAyICsgeDA2KSB8IDA7IHgxNCA9IHJvdGwoeDE0IF54MDIsIDgpO1xuICAgIHgxMCA9ICh4MTAgKyB4MTQpIHwgMDsgeDA2ID0gcm90bCh4MDYgXiB4MTAsIDcpO1xuXG4gICAgeDAzID0gKHgwMyArIHgwNykgfCAwOyB4MTUgPSByb3RsKHgxNSBeIHgwMywgMTYpO1xuICAgIHgxMSA9ICh4MTEgKyB4MTUpIHwgMDsgeDA3ID0gcm90bCh4MDcgXiB4MTEsIDEyKTtcbiAgICB4MDMgPSAoeDAzICsgeDA3KSB8IDA7IHgxNSA9IHJvdGwoeDE1IF4geDAzLCA4KVxuICAgIHgxMSA9ICh4MTEgKyB4MTUpIHwgMDsgeDA3ID0gcm90bCh4MDcgXiB4MTEsIDcpO1xuXG4gICAgeDAwID0gKHgwMCArIHgwNSkgfCAwOyB4MTUgPSByb3RsKHgxNSBeIHgwMCwgMTYpO1xuICAgIHgxMCA9ICh4MTAgKyB4MTUpIHwgMDsgeDA1ID0gcm90bCh4MDUgXiB4MTAsIDEyKTtcbiAgICB4MDAgPSAoeDAwICsgeDA1KSB8IDA7IHgxNSA9IHJvdGwoeDE1IF4geDAwLCA4KTtcbiAgICB4MTAgPSAoeDEwICsgeDE1KSB8IDA7IHgwNSA9IHJvdGwoeDA1IF4geDEwLCA3KTtcblxuICAgIHgwMSA9ICh4MDEgKyB4MDYpIHwgMDsgeDEyID0gcm90bCh4MTIgXiB4MDEsIDE2KTtcbiAgICB4MTEgPSAoeDExICsgeDEyKSB8IDA7IHgwNiA9IHJvdGwoeDA2IF4geDExLCAxMik7XG4gICAgeDAxID0gKHgwMSArIHgwNikgfCAwOyB4MTIgPSByb3RsKHgxMiBeIHgwMSwgOCk7XG4gICAgeDExID0gKHgxMSArIHgxMikgfCAwOyB4MDYgPSByb3RsKHgwNiBeIHgxMSwgNyk7XG5cbiAgICB4MDIgPSAoeDAyICsgeDA3KSB8IDA7IHgxMyA9IHJvdGwoeDEzIF4geDAyLCAxNik7XG4gICAgeDA4ID0gKHgwOCArIHgxMykgfCAwOyB4MDcgPSByb3RsKHgwNyBeIHgwOCwgMTIpO1xuICAgIHgwMiA9ICh4MDIgKyB4MDcpIHwgMDsgeDEzID0gcm90bCh4MTMgXiB4MDIsIDgpO1xuICAgIHgwOCA9ICh4MDggKyB4MTMpIHwgMDsgeDA3ID0gcm90bCh4MDcgXiB4MDgsIDcpO1xuXG4gICAgeDAzID0gKHgwMyArIHgwNCkgfCAwOyB4MTQgPSByb3RsKHgxNCBeIHgwMywgMTYpXG4gICAgeDA5ID0gKHgwOSArIHgxNCkgfCAwOyB4MDQgPSByb3RsKHgwNCBeIHgwOSwgMTIpO1xuICAgIHgwMyA9ICh4MDMgKyB4MDQpIHwgMDsgeDE0ID0gcm90bCh4MTQgXiB4MDMsIDgpO1xuICAgIHgwOSA9ICh4MDkgKyB4MTQpIHwgMDsgeDA0ID0gcm90bCh4MDQgXiB4MDksIDcpO1xuICB9XG4gIC8vIFdyaXRlIG91dHB1dFxuICBsZXQgb2kgPSAwO1xuICBvdXRbb2krK10gPSAoeTAwICsgeDAwKSB8IDA7IG91dFtvaSsrXSA9ICh5MDEgKyB4MDEpIHwgMDtcbiAgb3V0W29pKytdID0gKHkwMiArIHgwMikgfCAwOyBvdXRbb2krK10gPSAoeTAzICsgeDAzKSB8IDA7XG4gIG91dFtvaSsrXSA9ICh5MDQgKyB4MDQpIHwgMDsgb3V0W29pKytdID0gKHkwNSArIHgwNSkgfCAwO1xuICBvdXRbb2krK10gPSAoeTA2ICsgeDA2KSB8IDA7IG91dFtvaSsrXSA9ICh5MDcgKyB4MDcpIHwgMDtcbiAgb3V0W29pKytdID0gKHkwOCArIHgwOCkgfCAwOyBvdXRbb2krK10gPSAoeTA5ICsgeDA5KSB8IDA7XG4gIG91dFtvaSsrXSA9ICh5MTAgKyB4MTApIHwgMDsgb3V0W29pKytdID0gKHkxMSArIHgxMSkgfCAwO1xuICBvdXRbb2krK10gPSAoeTEyICsgeDEyKSB8IDA7IG91dFtvaSsrXSA9ICh5MTMgKyB4MTMpIHwgMDtcbiAgb3V0W29pKytdID0gKHkxNCArIHgxNCkgfCAwOyBvdXRbb2krK10gPSAoeTE1ICsgeDE1KSB8IDA7XG59XG4vKipcbiAqIGhjaGFjaGEgaGVscGVyIG1ldGhvZCwgdXNlZCBwcmltYXJpbHkgaW4geGNoYWNoYSwgdG8gaGFzaFxuICoga2V5IGFuZCBub25jZSBpbnRvIGtleScgYW5kIG5vbmNlJy5cbiAqIFNhbWUgYXMgY2hhY2hhQ29yZSwgYnV0IHRoZXJlIGRvZXNuJ3Qgc2VlbSB0byBiZSBhIHdheSB0byBtb3ZlIHRoZSBibG9ja1xuICogb3V0IHdpdGhvdXQgMjUlIHBlcmZvcm1hbmNlIGhpdC5cbiAqL1xuLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnQgZnVuY3Rpb24gaGNoYWNoYShcbiAgczogVWludDMyQXJyYXksIGs6IFVpbnQzMkFycmF5LCBpOiBVaW50MzJBcnJheSwgbzMyOiBVaW50MzJBcnJheVxuKSB7XG4gIGxldCB4MDAgPSBzWzBdLCB4MDEgPSBzWzFdLCB4MDIgPSBzWzJdLCB4MDMgPSBzWzNdLFxuICAgICAgeDA0ID0ga1swXSwgeDA1ID0ga1sxXSwgeDA2ID0ga1syXSwgeDA3ID0ga1szXSxcbiAgICAgIHgwOCA9IGtbNF0sIHgwOSA9IGtbNV0sIHgxMCA9IGtbNl0sIHgxMSA9IGtbN10sXG4gICAgICB4MTIgPSBpWzBdLCB4MTMgPSBpWzFdLCB4MTQgPSBpWzJdLCB4MTUgPSBpWzNdO1xuICBmb3IgKGxldCByID0gMDsgciA8IDIwOyByICs9IDIpIHtcbiAgICB4MDAgPSAoeDAwICsgeDA0KSB8IDA7IHgxMiA9IHJvdGwoeDEyIF4geDAwLCAxNik7XG4gICAgeDA4ID0gKHgwOCArIHgxMikgfCAwOyB4MDQgPSByb3RsKHgwNCBeIHgwOCwgMTIpO1xuICAgIHgwMCA9ICh4MDAgKyB4MDQpIHwgMDsgeDEyID0gcm90bCh4MTIgXiB4MDAsIDgpO1xuICAgIHgwOCA9ICh4MDggKyB4MTIpIHwgMDsgeDA0ID0gcm90bCh4MDQgXiB4MDgsIDcpO1xuXG4gICAgeDAxID0gKHgwMSArIHgwNSkgfCAwOyB4MTMgPSByb3RsKHgxMyBeIHgwMSwgMTYpO1xuICAgIHgwOSA9ICh4MDkgKyB4MTMpIHwgMDsgeDA1ID0gcm90bCh4MDUgXiB4MDksIDEyKTtcbiAgICB4MDEgPSAoeDAxICsgeDA1KSB8IDA7IHgxMyA9IHJvdGwoeDEzIF4geDAxLCA4KTtcbiAgICB4MDkgPSAoeDA5ICsgeDEzKSB8IDA7IHgwNSA9IHJvdGwoeDA1IF4geDA5LCA3KTtcblxuICAgIHgwMiA9ICh4MDIgKyB4MDYpIHwgMDsgeDE0ID0gcm90bCh4MTQgXiB4MDIsIDE2KTtcbiAgICB4MTAgPSAoeDEwICsgeDE0KSB8IDA7IHgwNiA9IHJvdGwoeDA2IF4geDEwLCAxMik7XG4gICAgeDAyID0gKHgwMiArIHgwNikgfCAwOyB4MTQgPSByb3RsKHgxNCBeIHgwMiwgOCk7XG4gICAgeDEwID0gKHgxMCArIHgxNCkgfCAwOyB4MDYgPSByb3RsKHgwNiBeIHgxMCwgNyk7XG5cbiAgICB4MDMgPSAoeDAzICsgeDA3KSB8IDA7IHgxNSA9IHJvdGwoeDE1IF4geDAzLCAxNik7XG4gICAgeDExID0gKHgxMSArIHgxNSkgfCAwOyB4MDcgPSByb3RsKHgwNyBeIHgxMSwgMTIpO1xuICAgIHgwMyA9ICh4MDMgKyB4MDcpIHwgMDsgeDE1ID0gcm90bCh4MTUgXiB4MDMsIDgpXG4gICAgeDExID0gKHgxMSArIHgxNSkgfCAwOyB4MDcgPSByb3RsKHgwNyBeIHgxMSwgNyk7XG5cbiAgICB4MDAgPSAoeDAwICsgeDA1KSB8IDA7IHgxNSA9IHJvdGwoeDE1IF4geDAwLCAxNik7XG4gICAgeDEwID0gKHgxMCArIHgxNSkgfCAwOyB4MDUgPSByb3RsKHgwNSBeIHgxMCwgMTIpO1xuICAgIHgwMCA9ICh4MDAgKyB4MDUpIHwgMDsgeDE1ID0gcm90bCh4MTUgXiB4MDAsIDgpO1xuICAgIHgxMCA9ICh4MTAgKyB4MTUpIHwgMDsgeDA1ID0gcm90bCh4MDUgXiB4MTAsIDcpO1xuXG4gICAgeDAxID0gKHgwMSArIHgwNikgfCAwOyB4MTIgPSByb3RsKHgxMiBeIHgwMSwgMTYpO1xuICAgIHgxMSA9ICh4MTEgKyB4MTIpIHwgMDsgeDA2ID0gcm90bCh4MDYgXiB4MTEsIDEyKTtcbiAgICB4MDEgPSAoeDAxICsgeDA2KSB8IDA7IHgxMiA9IHJvdGwoeDEyIF4geDAxLCA4KTtcbiAgICB4MTEgPSAoeDExICsgeDEyKSB8IDA7IHgwNiA9IHJvdGwoeDA2IF4geDExLCA3KTtcblxuICAgIHgwMiA9ICh4MDIgKyB4MDcpIHwgMDsgeDEzID0gcm90bCh4MTMgXiB4MDIsIDE2KTtcbiAgICB4MDggPSAoeDA4ICsgeDEzKSB8IDA7IHgwNyA9IHJvdGwoeDA3IF4geDA4LCAxMik7XG4gICAgeDAyID0gKHgwMiArIHgwNykgfCAwOyB4MTMgPSByb3RsKHgxMyBeIHgwMiwgOCk7XG4gICAgeDA4ID0gKHgwOCArIHgxMykgfCAwOyB4MDcgPSByb3RsKHgwNyBeIHgwOCwgNyk7XG5cbiAgICB4MDMgPSAoeDAzICsgeDA0KSB8IDA7IHgxNCA9IHJvdGwoeDE0IF4geDAzLCAxNilcbiAgICB4MDkgPSAoeDA5ICsgeDE0KSB8IDA7IHgwNCA9IHJvdGwoeDA0IF4geDA5LCAxMik7XG4gICAgeDAzID0gKHgwMyArIHgwNCkgfCAwOyB4MTQgPSByb3RsKHgxNCBeIHgwMywgOCk7XG4gICAgeDA5ID0gKHgwOSArIHgxNCkgfCAwOyB4MDQgPSByb3RsKHgwNCBeIHgwOSwgNyk7XG4gIH1cbiAgbGV0IG9pID0gMDtcbiAgbzMyW29pKytdID0geDAwOyBvMzJbb2krK10gPSB4MDE7XG4gIG8zMltvaSsrXSA9IHgwMjsgbzMyW29pKytdID0geDAzO1xuICBvMzJbb2krK10gPSB4MTI7IG8zMltvaSsrXSA9IHgxMztcbiAgbzMyW29pKytdID0geDE0OyBvMzJbb2krK10gPSB4MTU7XG59XG4vKipcbiAqIE9yaWdpbmFsLCBub24tUkZDIGNoYWNoYTIwIGZyb20gREpCLiA4LWJ5dGUgbm9uY2UsIDgtYnl0ZSBjb3VudGVyLlxuICovXG5leHBvcnQgY29uc3QgY2hhY2hhMjBvcmlnID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUNpcGhlcihjaGFjaGFDb3JlLCB7XG4gIGNvdW50ZXJSaWdodDogZmFsc2UsXG4gIGNvdW50ZXJMZW5ndGg6IDgsXG4gIGFsbG93U2hvcnRLZXlzOiB0cnVlLFxufSk7XG4vKipcbiAqIENoYUNoYSBzdHJlYW0gY2lwaGVyLiBDb25mb3JtcyB0byBSRkMgODQzOSAoSUVURiwgVExTKS4gMTItYnl0ZSBub25jZSwgNC1ieXRlIGNvdW50ZXIuXG4gKiBXaXRoIDEyLWJ5dGUgbm9uY2UsIGl0J3Mgbm90IHNhZmUgdG8gdXNlIGZpbGwgaXQgd2l0aCByYW5kb20gKENTUFJORyksIGR1ZSB0byBjb2xsaXNpb24gY2hhbmNlLlxuICovXG5leHBvcnQgY29uc3QgY2hhY2hhMjAgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlQ2lwaGVyKGNoYWNoYUNvcmUsIHtcbiAgY291bnRlclJpZ2h0OiBmYWxzZSxcbiAgY291bnRlckxlbmd0aDogNCxcbiAgYWxsb3dTaG9ydEtleXM6IGZhbHNlLFxufSk7XG5cbi8qKlxuICogWENoYUNoYSBlWHRlbmRlZC1ub25jZSBDaGFDaGEuIDI0LWJ5dGUgbm9uY2UuXG4gKiBXaXRoIDI0LWJ5dGUgbm9uY2UsIGl0J3Mgc2FmZSB0byB1c2UgZmlsbCBpdCB3aXRoIHJhbmRvbSAoQ1NQUk5HKS5cbiAqIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaXJ0Zi1jZnJnLXhjaGFjaGFcbiAqL1xuZXhwb3J0IGNvbnN0IHhjaGFjaGEyMCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVDaXBoZXIoY2hhY2hhQ29yZSwge1xuICBjb3VudGVyUmlnaHQ6IGZhbHNlLFxuICBjb3VudGVyTGVuZ3RoOiA4LFxuICBleHRlbmROb25jZUZuOiBoY2hhY2hhLFxuICBhbGxvd1Nob3J0S2V5czogZmFsc2UsXG59KTtcblxuLyoqXG4gKiBSZWR1Y2VkIDgtcm91bmQgY2hhY2hhLCBkZXNjcmliZWQgaW4gb3JpZ2luYWwgcGFwZXIuXG4gKi9cbmV4cG9ydCBjb25zdCBjaGFjaGE4ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUNpcGhlcihjaGFjaGFDb3JlLCB7XG4gIGNvdW50ZXJSaWdodDogZmFsc2UsXG4gIGNvdW50ZXJMZW5ndGg6IDQsXG4gIHJvdW5kczogOCxcbn0pO1xuXG4vKipcbiAqIFJlZHVjZWQgMTItcm91bmQgY2hhY2hhLCBkZXNjcmliZWQgaW4gb3JpZ2luYWwgcGFwZXIuXG4gKi9cbmV4cG9ydCBjb25zdCBjaGFjaGExMiA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVDaXBoZXIoY2hhY2hhQ29yZSwge1xuICBjb3VudGVyUmlnaHQ6IGZhbHNlLFxuICBjb3VudGVyTGVuZ3RoOiA0LFxuICByb3VuZHM6IDEyLFxufSk7XG5cbmNvbnN0IFpFUk9TMTYgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuLy8gUGFkIHRvIGRpZ2VzdCBzaXplIHdpdGggemVyb3NcbmNvbnN0IHVwZGF0ZVBhZGRlZCA9IChoOiBSZXR1cm5UeXBlPHR5cGVvZiBwb2x5MTMwNS5jcmVhdGU+LCBtc2c6IFVpbnQ4QXJyYXkpID0+IHtcbiAgaC51cGRhdGUobXNnKTtcbiAgY29uc3QgbGVmdCA9IG1zZy5sZW5ndGggJSAxNjtcbiAgaWYgKGxlZnQpIGgudXBkYXRlKFpFUk9TMTYuc3ViYXJyYXkobGVmdCkpO1xufTtcblxuY29uc3QgWkVST1MzMiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDhBcnJheSgzMik7XG5mdW5jdGlvbiBjb21wdXRlVGFnKFxuICBmbjogWG9yU3RyZWFtLFxuICBrZXk6IFVpbnQ4QXJyYXksXG4gIG5vbmNlOiBVaW50OEFycmF5LFxuICBkYXRhOiBVaW50OEFycmF5LFxuICBBQUQ/OiBVaW50OEFycmF5XG4pOiBVaW50OEFycmF5IHtcbiAgY29uc3QgYXV0aEtleSA9IGZuKGtleSwgbm9uY2UsIFpFUk9TMzIpO1xuICBjb25zdCBoID0gcG9seTEzMDUuY3JlYXRlKGF1dGhLZXkpO1xuICBpZiAoQUFEKSB1cGRhdGVQYWRkZWQoaCwgQUFEKTtcbiAgdXBkYXRlUGFkZGVkKGgsIGRhdGEpO1xuICBjb25zdCBudW0gPSBuZXcgVWludDhBcnJheSgxNik7XG4gIGNvbnN0IHZpZXcgPSBjcmVhdGVWaWV3KG51bSk7XG4gIHNldEJpZ1VpbnQ2NCh2aWV3LCAwLCBCaWdJbnQoQUFEID8gQUFELmxlbmd0aCA6IDApLCB0cnVlKTtcbiAgc2V0QmlnVWludDY0KHZpZXcsIDgsIEJpZ0ludChkYXRhLmxlbmd0aCksIHRydWUpO1xuICBoLnVwZGF0ZShudW0pO1xuICBjb25zdCByZXMgPSBoLmRpZ2VzdCgpO1xuICBhdXRoS2V5LmZpbGwoMCk7XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogQUVBRCBhbGdvcml0aG0gZnJvbSBSRkMgODQzOS5cbiAqIFNhbHNhMjAgYW5kIGNoYWNoYSAoUkZDIDg0MzkpIHVzZSBwb2x5MTMwNSBkaWZmZXJlbnRseS5cbiAqIFdlIGNvdWxkIGhhdmUgY29tcG9zZWQgdGhlbSBzaW1pbGFyIHRvOlxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhdWxtaWxsci9zY3VyZS1iYXNlL2Jsb2IvYjI2NmM3M2RkZTk3N2IxZGQ3ZWY0MGVmN2EyM2NjMTVhYWI1MjZiMy9pbmRleC50cyNMMjUwXG4gKiBCdXQgaXQncyBoYXJkIGJlY2F1c2Ugb2YgYXV0aEtleTpcbiAqIEluIHNhbHNhMjAsIGF1dGhLZXkgY2hhbmdlcyBwb3NpdGlvbiBpbiBzYWxzYSBzdHJlYW0uXG4gKiBJbiBjaGFjaGEsIGF1dGhLZXkgY2FuJ3QgYmUgY29tcHV0ZWQgaW5zaWRlIGNvbXB1dGVUYWcsIGl0IG1vZGlmaWVzIHRoZSBjb3VudGVyLlxuICovXG5leHBvcnQgY29uc3QgX3BvbHkxMzA1X2FlYWQgPVxuICAoeG9yU3RyZWFtOiBYb3JTdHJlYW0pID0+XG4gIChrZXk6IFVpbnQ4QXJyYXksIG5vbmNlOiBVaW50OEFycmF5LCBBQUQ/OiBVaW50OEFycmF5KTogQ2lwaGVyV2l0aE91dHB1dCA9PiB7XG4gICAgY29uc3QgdGFnTGVuZ3RoID0gMTY7XG4gICAgYWJ5dGVzKGtleSwgMzIpO1xuICAgIGFieXRlcyhub25jZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVuY3J5cHQ6IChwbGFpbnRleHQ6IFVpbnQ4QXJyYXksIG91dHB1dD86IFVpbnQ4QXJyYXkpID0+IHtcbiAgICAgICAgY29uc3QgcGxlbmd0aCA9IHBsYWludGV4dC5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGNsZW5ndGggPSBwbGVuZ3RoICsgdGFnTGVuZ3RoO1xuICAgICAgICBpZiAob3V0cHV0KSB7XG4gICAgICAgICAgYWJ5dGVzKG91dHB1dCwgY2xlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkoY2xlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgeG9yU3RyZWFtKGtleSwgbm9uY2UsIHBsYWludGV4dCwgb3V0cHV0LCAxKTtcbiAgICAgICAgY29uc3QgdGFnID0gY29tcHV0ZVRhZyh4b3JTdHJlYW0sIGtleSwgbm9uY2UsIG91dHB1dC5zdWJhcnJheSgwLCAtdGFnTGVuZ3RoKSwgQUFEKTtcbiAgICAgICAgb3V0cHV0LnNldCh0YWcsIHBsZW5ndGgpOyAvLyBhcHBlbmQgdGFnXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICB9LFxuICAgICAgZGVjcnlwdDogKGNpcGhlcnRleHQ6IFVpbnQ4QXJyYXksIG91dHB1dD86IFVpbnQ4QXJyYXkpID0+IHtcbiAgICAgICAgY29uc3QgY2xlbmd0aCA9IGNpcGhlcnRleHQubGVuZ3RoO1xuICAgICAgICBjb25zdCBwbGVuZ3RoID0gY2xlbmd0aCAtIHRhZ0xlbmd0aDtcbiAgICAgICAgaWYgKGNsZW5ndGggPCB0YWdMZW5ndGgpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBlbmNyeXB0ZWQgZGF0YSBtdXN0IGJlIGF0IGxlYXN0ICR7dGFnTGVuZ3RofSBieXRlc2ApO1xuICAgICAgICBpZiAob3V0cHV0KSB7XG4gICAgICAgICAgYWJ5dGVzKG91dHB1dCwgcGxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkocGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IGNpcGhlcnRleHQuc3ViYXJyYXkoMCwgLXRhZ0xlbmd0aCk7XG4gICAgICAgIGNvbnN0IHBhc3NlZFRhZyA9IGNpcGhlcnRleHQuc3ViYXJyYXkoLXRhZ0xlbmd0aCk7XG4gICAgICAgIGNvbnN0IHRhZyA9IGNvbXB1dGVUYWcoeG9yU3RyZWFtLCBrZXksIG5vbmNlLCBkYXRhLCBBQUQpO1xuICAgICAgICBpZiAoIWVxdWFsQnl0ZXMocGFzc2VkVGFnLCB0YWcpKSB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdGFnJyk7XG4gICAgICAgIHhvclN0cmVhbShrZXksIG5vbmNlLCBkYXRhLCBvdXRwdXQsIDEpO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgfSxcbiAgICB9O1xuICB9O1xuXG4vKipcbiAqIENoYUNoYTIwLVBvbHkxMzA1IGZyb20gUkZDIDg0MzkuXG4gKiBXaXRoIDEyLWJ5dGUgbm9uY2UsIGl0J3Mgbm90IHNhZmUgdG8gdXNlIGZpbGwgaXQgd2l0aCByYW5kb20gKENTUFJORyksIGR1ZSB0byBjb2xsaXNpb24gY2hhbmNlLlxuICovXG5leHBvcnQgY29uc3QgY2hhY2hhMjBwb2x5MTMwNSA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ2lwaGVyKFxuICB7IGJsb2NrU2l6ZTogNjQsIG5vbmNlTGVuZ3RoOiAxMiwgdGFnTGVuZ3RoOiAxNiB9LFxuICBfcG9seTEzMDVfYWVhZChjaGFjaGEyMClcbik7XG4vKipcbiAqIFhDaGFDaGEyMC1Qb2x5MTMwNSBleHRlbmRlZC1ub25jZSBjaGFjaGEuXG4gKiBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlydGYtY2ZyZy14Y2hhY2hhXG4gKiBXaXRoIDI0LWJ5dGUgbm9uY2UsIGl0J3Mgc2FmZSB0byB1c2UgZmlsbCBpdCB3aXRoIHJhbmRvbSAoQ1NQUk5HKS5cbiAqL1xuZXhwb3J0IGNvbnN0IHhjaGFjaGEyMHBvbHkxMzA1ID0gLyogQF9fUFVSRV9fICovIHdyYXBDaXBoZXIoXG4gIHsgYmxvY2tTaXplOiA2NCwgbm9uY2VMZW5ndGg6IDI0LCB0YWdMZW5ndGg6IDE2IH0sXG4gIF9wb2x5MTMwNV9hZWFkKHhjaGFjaGEyMClcbik7XG4iLCAiaW1wb3J0IGFzc2VydCBmcm9tICcuL19hc3NlcnQuanMnO1xuaW1wb3J0IHsgSGFzaCwgQ0hhc2gsIElucHV0LCB0b0J5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBITUFDIChSRkMgMjEwNClcbmV4cG9ydCBjbGFzcyBITUFDPFQgZXh0ZW5kcyBIYXNoPFQ+PiBleHRlbmRzIEhhc2g8SE1BQzxUPj4ge1xuICBvSGFzaDogVDtcbiAgaUhhc2g6IFQ7XG4gIGJsb2NrTGVuOiBudW1iZXI7XG4gIG91dHB1dExlbjogbnVtYmVyO1xuICBwcml2YXRlIGZpbmlzaGVkID0gZmFsc2U7XG4gIHByaXZhdGUgZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IoaGFzaDogQ0hhc2gsIF9rZXk6IElucHV0KSB7XG4gICAgc3VwZXIoKTtcbiAgICBhc3NlcnQuaGFzaChoYXNoKTtcbiAgICBjb25zdCBrZXkgPSB0b0J5dGVzKF9rZXkpO1xuICAgIHRoaXMuaUhhc2ggPSBoYXNoLmNyZWF0ZSgpIGFzIFQ7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmlIYXNoLnVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgaW5zdGFuY2Ugb2YgY2xhc3Mgd2hpY2ggZXh0ZW5kcyB1dGlscy5IYXNoJyk7XG4gICAgdGhpcy5ibG9ja0xlbiA9IHRoaXMuaUhhc2guYmxvY2tMZW47XG4gICAgdGhpcy5vdXRwdXRMZW4gPSB0aGlzLmlIYXNoLm91dHB1dExlbjtcbiAgICBjb25zdCBibG9ja0xlbiA9IHRoaXMuYmxvY2tMZW47XG4gICAgY29uc3QgcGFkID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgIC8vIGJsb2NrTGVuIGNhbiBiZSBiaWdnZXIgdGhhbiBvdXRwdXRMZW5cbiAgICBwYWQuc2V0KGtleS5sZW5ndGggPiBibG9ja0xlbiA/IGhhc2guY3JlYXRlKCkudXBkYXRlKGtleSkuZGlnZXN0KCkgOiBrZXkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKSBwYWRbaV0gXj0gMHgzNjtcbiAgICB0aGlzLmlIYXNoLnVwZGF0ZShwYWQpO1xuICAgIC8vIEJ5IGRvaW5nIHVwZGF0ZSAocHJvY2Vzc2luZyBvZiBmaXJzdCBibG9jaykgb2Ygb3V0ZXIgaGFzaCBoZXJlIHdlIGNhbiByZS11c2UgaXQgYmV0d2VlbiBtdWx0aXBsZSBjYWxscyB2aWEgY2xvbmVcbiAgICB0aGlzLm9IYXNoID0gaGFzaC5jcmVhdGUoKSBhcyBUO1xuICAgIC8vIFVuZG8gaW50ZXJuYWwgWE9SICYmIGFwcGx5IG91dGVyIFhPUlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKSBwYWRbaV0gXj0gMHgzNiBeIDB4NWM7XG4gICAgdGhpcy5vSGFzaC51cGRhdGUocGFkKTtcbiAgICBwYWQuZmlsbCgwKTtcbiAgfVxuICB1cGRhdGUoYnVmOiBJbnB1dCkge1xuICAgIGFzc2VydC5leGlzdHModGhpcyk7XG4gICAgdGhpcy5pSGFzaC51cGRhdGUoYnVmKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBkaWdlc3RJbnRvKG91dDogVWludDhBcnJheSkge1xuICAgIGFzc2VydC5leGlzdHModGhpcyk7XG4gICAgYXNzZXJ0LmJ5dGVzKG91dCwgdGhpcy5vdXRwdXRMZW4pO1xuICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgIHRoaXMuaUhhc2guZGlnZXN0SW50byhvdXQpO1xuICAgIHRoaXMub0hhc2gudXBkYXRlKG91dCk7XG4gICAgdGhpcy5vSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgdGhpcy5kZXN0cm95KCk7XG4gIH1cbiAgZGlnZXN0KCkge1xuICAgIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KHRoaXMub0hhc2gub3V0cHV0TGVuKTtcbiAgICB0aGlzLmRpZ2VzdEludG8ob3V0KTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIF9jbG9uZUludG8odG8/OiBITUFDPFQ+KTogSE1BQzxUPiB7XG4gICAgLy8gQ3JlYXRlIG5ldyBpbnN0YW5jZSB3aXRob3V0IGNhbGxpbmcgY29uc3RydWN0b3Igc2luY2Uga2V5IGFscmVhZHkgaW4gc3RhdGUgYW5kIHdlIGRvbid0IGtub3cgaXQuXG4gICAgdG8gfHw9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLCB7fSk7XG4gICAgY29uc3QgeyBvSGFzaCwgaUhhc2gsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIGJsb2NrTGVuLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgdG8gPSB0byBhcyB0aGlzO1xuICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgIHRvLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgdG8ub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgIHRvLm9IYXNoID0gb0hhc2guX2Nsb25lSW50byh0by5vSGFzaCk7XG4gICAgdG8uaUhhc2ggPSBpSGFzaC5fY2xvbmVJbnRvKHRvLmlIYXNoKTtcbiAgICByZXR1cm4gdG87XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgdGhpcy5vSGFzaC5kZXN0cm95KCk7XG4gICAgdGhpcy5pSGFzaC5kZXN0cm95KCk7XG4gIH1cbn1cblxuLyoqXG4gKiBITUFDOiBSRkMyMTA0IG1lc3NhZ2UgYXV0aGVudGljYXRpb24gY29kZS5cbiAqIEBwYXJhbSBoYXNoIC0gZnVuY3Rpb24gdGhhdCB3b3VsZCBiZSB1c2VkIGUuZy4gc2hhMjU2XG4gKiBAcGFyYW0ga2V5IC0gbWVzc2FnZSBrZXlcbiAqIEBwYXJhbSBtZXNzYWdlIC0gbWVzc2FnZSBkYXRhXG4gKi9cbmV4cG9ydCBjb25zdCBobWFjID0gKGhhc2g6IENIYXNoLCBrZXk6IElucHV0LCBtZXNzYWdlOiBJbnB1dCk6IFVpbnQ4QXJyYXkgPT5cbiAgbmV3IEhNQUM8YW55PihoYXNoLCBrZXkpLnVwZGF0ZShtZXNzYWdlKS5kaWdlc3QoKTtcbmhtYWMuY3JlYXRlID0gKGhhc2g6IENIYXNoLCBrZXk6IElucHV0KSA9PiBuZXcgSE1BQzxhbnk+KGhhc2gsIGtleSk7XG4iLCAiaW1wb3J0IGFzc2VydCBmcm9tICcuL19hc3NlcnQuanMnO1xuaW1wb3J0IHsgQ0hhc2gsIElucHV0LCB0b0J5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBobWFjIH0gZnJvbSAnLi9obWFjLmpzJztcblxuLy8gSEtERiAoUkZDIDU4NjkpXG4vLyBodHRwczovL3NvYXRvay5ibG9nLzIwMjEvMTEvMTcvdW5kZXJzdGFuZGluZy1oa2RmL1xuXG4vKipcbiAqIEhLREYtRXh0cmFjdChJS00sIHNhbHQpIC0+IFBSS1xuICogQXJndW1lbnRzIHBvc2l0aW9uIGRpZmZlcnMgZnJvbSBzcGVjIChJS00gaXMgZmlyc3Qgb25lLCBzaW5jZSBpdCBpcyBub3Qgb3B0aW9uYWwpXG4gKiBAcGFyYW0gaGFzaFxuICogQHBhcmFtIGlrbVxuICogQHBhcmFtIHNhbHRcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0KGhhc2g6IENIYXNoLCBpa206IElucHV0LCBzYWx0PzogSW5wdXQpIHtcbiAgYXNzZXJ0Lmhhc2goaGFzaCk7XG4gIC8vIE5PVEU6IHNvbWUgbGlicmFyaWVzIHRyZWF0IHplcm8tbGVuZ3RoIGFycmF5IGFzICdub3QgcHJvdmlkZWQnO1xuICAvLyB3ZSBkb24ndCwgc2luY2Ugd2UgaGF2ZSB1bmRlZmluZWQgYXMgJ25vdCBwcm92aWRlZCdcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL1J1c3RDcnlwdG8vS0RGcy9pc3N1ZXMvMTVcbiAgaWYgKHNhbHQgPT09IHVuZGVmaW5lZCkgc2FsdCA9IG5ldyBVaW50OEFycmF5KGhhc2gub3V0cHV0TGVuKTsgLy8gaWYgbm90IHByb3ZpZGVkLCBpdCBpcyBzZXQgdG8gYSBzdHJpbmcgb2YgSGFzaExlbiB6ZXJvc1xuICByZXR1cm4gaG1hYyhoYXNoLCB0b0J5dGVzKHNhbHQpLCB0b0J5dGVzKGlrbSkpO1xufVxuXG4vLyBIS0RGLUV4cGFuZChQUkssIGluZm8sIEwpIC0+IE9LTVxuY29uc3QgSEtERl9DT1VOVEVSID0gbmV3IFVpbnQ4QXJyYXkoWzBdKTtcbmNvbnN0IEVNUFRZX0JVRkZFUiA9IG5ldyBVaW50OEFycmF5KCk7XG5cbi8qKlxuICogSEtERi1leHBhbmQgZnJvbSB0aGUgc3BlYy5cbiAqIEBwYXJhbSBwcmsgLSBhIHBzZXVkb3JhbmRvbSBrZXkgb2YgYXQgbGVhc3QgSGFzaExlbiBvY3RldHMgKHVzdWFsbHksIHRoZSBvdXRwdXQgZnJvbSB0aGUgZXh0cmFjdCBzdGVwKVxuICogQHBhcmFtIGluZm8gLSBvcHRpb25hbCBjb250ZXh0IGFuZCBhcHBsaWNhdGlvbiBzcGVjaWZpYyBpbmZvcm1hdGlvbiAoY2FuIGJlIGEgemVyby1sZW5ndGggc3RyaW5nKVxuICogQHBhcmFtIGxlbmd0aCAtIGxlbmd0aCBvZiBvdXRwdXQga2V5aW5nIG1hdGVyaWFsIGluIG9jdGV0c1xuICovXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kKGhhc2g6IENIYXNoLCBwcms6IElucHV0LCBpbmZvPzogSW5wdXQsIGxlbmd0aDogbnVtYmVyID0gMzIpIHtcbiAgYXNzZXJ0Lmhhc2goaGFzaCk7XG4gIGFzc2VydC5udW1iZXIobGVuZ3RoKTtcbiAgaWYgKGxlbmd0aCA+IDI1NSAqIGhhc2gub3V0cHV0TGVuKSB0aHJvdyBuZXcgRXJyb3IoJ0xlbmd0aCBzaG91bGQgYmUgPD0gMjU1Kkhhc2hMZW4nKTtcbiAgY29uc3QgYmxvY2tzID0gTWF0aC5jZWlsKGxlbmd0aCAvIGhhc2gub3V0cHV0TGVuKTtcbiAgaWYgKGluZm8gPT09IHVuZGVmaW5lZCkgaW5mbyA9IEVNUFRZX0JVRkZFUjtcbiAgLy8gZmlyc3QgTChlbmd0aCkgb2N0ZXRzIG9mIFRcbiAgY29uc3Qgb2ttID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tzICogaGFzaC5vdXRwdXRMZW4pO1xuICAvLyBSZS11c2UgSE1BQyBpbnN0YW5jZSBiZXR3ZWVuIGJsb2Nrc1xuICBjb25zdCBITUFDID0gaG1hYy5jcmVhdGUoaGFzaCwgcHJrKTtcbiAgY29uc3QgSE1BQ1RtcCA9IEhNQUMuX2Nsb25lSW50bygpO1xuICBjb25zdCBUID0gbmV3IFVpbnQ4QXJyYXkoSE1BQy5vdXRwdXRMZW4pO1xuICBmb3IgKGxldCBjb3VudGVyID0gMDsgY291bnRlciA8IGJsb2NrczsgY291bnRlcisrKSB7XG4gICAgSEtERl9DT1VOVEVSWzBdID0gY291bnRlciArIDE7XG4gICAgLy8gVCgwKSA9IGVtcHR5IHN0cmluZyAoemVybyBsZW5ndGgpXG4gICAgLy8gVChOKSA9IEhNQUMtSGFzaChQUkssIFQoTi0xKSB8IGluZm8gfCBOKVxuICAgIEhNQUNUbXAudXBkYXRlKGNvdW50ZXIgPT09IDAgPyBFTVBUWV9CVUZGRVIgOiBUKVxuICAgICAgLnVwZGF0ZShpbmZvKVxuICAgICAgLnVwZGF0ZShIS0RGX0NPVU5URVIpXG4gICAgICAuZGlnZXN0SW50byhUKTtcbiAgICBva20uc2V0KFQsIGhhc2gub3V0cHV0TGVuICogY291bnRlcik7XG4gICAgSE1BQy5fY2xvbmVJbnRvKEhNQUNUbXApO1xuICB9XG4gIEhNQUMuZGVzdHJveSgpO1xuICBITUFDVG1wLmRlc3Ryb3koKTtcbiAgVC5maWxsKDApO1xuICBIS0RGX0NPVU5URVIuZmlsbCgwKTtcbiAgcmV0dXJuIG9rbS5zbGljZSgwLCBsZW5ndGgpO1xufVxuXG4vKipcbiAqIEhLREYgKFJGQyA1ODY5KTogZXh0cmFjdCArIGV4cGFuZCBpbiBvbmUgc3RlcC5cbiAqIEBwYXJhbSBoYXNoIC0gaGFzaCBmdW5jdGlvbiB0aGF0IHdvdWxkIGJlIHVzZWQgKGUuZy4gc2hhMjU2KVxuICogQHBhcmFtIGlrbSAtIGlucHV0IGtleWluZyBtYXRlcmlhbCwgdGhlIGluaXRpYWwga2V5XG4gKiBAcGFyYW0gc2FsdCAtIG9wdGlvbmFsIHNhbHQgdmFsdWUgKGEgbm9uLXNlY3JldCByYW5kb20gdmFsdWUpXG4gKiBAcGFyYW0gaW5mbyAtIG9wdGlvbmFsIGNvbnRleHQgYW5kIGFwcGxpY2F0aW9uIHNwZWNpZmljIGluZm9ybWF0aW9uXG4gKiBAcGFyYW0gbGVuZ3RoIC0gbGVuZ3RoIG9mIG91dHB1dCBrZXlpbmcgbWF0ZXJpYWwgaW4gb2N0ZXRzXG4gKi9cbmV4cG9ydCBjb25zdCBoa2RmID0gKFxuICBoYXNoOiBDSGFzaCxcbiAgaWttOiBJbnB1dCxcbiAgc2FsdDogSW5wdXQgfCB1bmRlZmluZWQsXG4gIGluZm86IElucHV0IHwgdW5kZWZpbmVkLFxuICBsZW5ndGg6IG51bWJlclxuKSA9PiBleHBhbmQoaGFzaCwgZXh0cmFjdChoYXNoLCBpa20sIHNhbHQpLCBpbmZvLCBsZW5ndGgpO1xuIiwgInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG5cbi8vIHB1cmUudHNcbmltcG9ydCB7IHNjaG5vcnIgfSBmcm9tIFwiQG5vYmxlL2N1cnZlcy9zZWNwMjU2azFcIjtcbmltcG9ydCB7IGJ5dGVzVG9IZXggfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiO1xuXG4vLyBjb3JlLnRzXG52YXIgdmVyaWZpZWRTeW1ib2wgPSBTeW1ib2woXCJ2ZXJpZmllZFwiKTtcbnZhciBpc1JlY29yZCA9IChvYmopID0+IG9iaiBpbnN0YW5jZW9mIE9iamVjdDtcbmZ1bmN0aW9uIHZhbGlkYXRlRXZlbnQoZXZlbnQpIHtcbiAgaWYgKCFpc1JlY29yZChldmVudCkpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIGV2ZW50LmtpbmQgIT09IFwibnVtYmVyXCIpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIGV2ZW50LmNvbnRlbnQgIT09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIGV2ZW50LmNyZWF0ZWRfYXQgIT09IFwibnVtYmVyXCIpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIGV2ZW50LnB1YmtleSAhPT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmICghZXZlbnQucHVia2V5Lm1hdGNoKC9eW2EtZjAtOV17NjR9JC8pKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGV2ZW50LnRhZ3MpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IGV2ZW50LnRhZ3MubGVuZ3RoOyBpMisrKSB7XG4gICAgbGV0IHRhZyA9IGV2ZW50LnRhZ3NbaTJdO1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0YWcpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGFnLmxlbmd0aDsgaisrKSB7XG4gICAgICBpZiAodHlwZW9mIHRhZ1tqXSA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gcHVyZS50c1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvc2hhMjU2XCI7XG5cbi8vIHV0aWxzLnRzXG52YXIgdXRpbHNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodXRpbHNfZXhwb3J0cywge1xuICBRdWV1ZTogKCkgPT4gUXVldWUsXG4gIFF1ZXVlTm9kZTogKCkgPT4gUXVldWVOb2RlLFxuICBiaW5hcnlTZWFyY2g6ICgpID0+IGJpbmFyeVNlYXJjaCxcbiAgaW5zZXJ0RXZlbnRJbnRvQXNjZW5kaW5nTGlzdDogKCkgPT4gaW5zZXJ0RXZlbnRJbnRvQXNjZW5kaW5nTGlzdCxcbiAgaW5zZXJ0RXZlbnRJbnRvRGVzY2VuZGluZ0xpc3Q6ICgpID0+IGluc2VydEV2ZW50SW50b0Rlc2NlbmRpbmdMaXN0LFxuICBub3JtYWxpemVVUkw6ICgpID0+IG5vcm1hbGl6ZVVSTCxcbiAgdXRmOERlY29kZXI6ICgpID0+IHV0ZjhEZWNvZGVyLFxuICB1dGY4RW5jb2RlcjogKCkgPT4gdXRmOEVuY29kZXJcbn0pO1xudmFyIHV0ZjhEZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKFwidXRmLThcIik7XG52YXIgdXRmOEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZVVSTCh1cmwpIHtcbiAgaWYgKHVybC5pbmRleE9mKFwiOi8vXCIpID09PSAtMSlcbiAgICB1cmwgPSBcIndzczovL1wiICsgdXJsO1xuICBsZXQgcCA9IG5ldyBVUkwodXJsKTtcbiAgcC5wYXRobmFtZSA9IHAucGF0aG5hbWUucmVwbGFjZSgvXFwvKy9nLCBcIi9cIik7XG4gIGlmIChwLnBhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKSlcbiAgICBwLnBhdGhuYW1lID0gcC5wYXRobmFtZS5zbGljZSgwLCAtMSk7XG4gIGlmIChwLnBvcnQgPT09IFwiODBcIiAmJiBwLnByb3RvY29sID09PSBcIndzOlwiIHx8IHAucG9ydCA9PT0gXCI0NDNcIiAmJiBwLnByb3RvY29sID09PSBcIndzczpcIilcbiAgICBwLnBvcnQgPSBcIlwiO1xuICBwLnNlYXJjaFBhcmFtcy5zb3J0KCk7XG4gIHAuaGFzaCA9IFwiXCI7XG4gIHJldHVybiBwLnRvU3RyaW5nKCk7XG59XG5mdW5jdGlvbiBpbnNlcnRFdmVudEludG9EZXNjZW5kaW5nTGlzdChzb3J0ZWRBcnJheSwgZXZlbnQpIHtcbiAgY29uc3QgW2lkeCwgZm91bmRdID0gYmluYXJ5U2VhcmNoKHNvcnRlZEFycmF5LCAoYikgPT4ge1xuICAgIGlmIChldmVudC5pZCA9PT0gYi5pZClcbiAgICAgIHJldHVybiAwO1xuICAgIGlmIChldmVudC5jcmVhdGVkX2F0ID09PSBiLmNyZWF0ZWRfYXQpXG4gICAgICByZXR1cm4gLTE7XG4gICAgcmV0dXJuIGIuY3JlYXRlZF9hdCAtIGV2ZW50LmNyZWF0ZWRfYXQ7XG4gIH0pO1xuICBpZiAoIWZvdW5kKSB7XG4gICAgc29ydGVkQXJyYXkuc3BsaWNlKGlkeCwgMCwgZXZlbnQpO1xuICB9XG4gIHJldHVybiBzb3J0ZWRBcnJheTtcbn1cbmZ1bmN0aW9uIGluc2VydEV2ZW50SW50b0FzY2VuZGluZ0xpc3Qoc29ydGVkQXJyYXksIGV2ZW50KSB7XG4gIGNvbnN0IFtpZHgsIGZvdW5kXSA9IGJpbmFyeVNlYXJjaChzb3J0ZWRBcnJheSwgKGIpID0+IHtcbiAgICBpZiAoZXZlbnQuaWQgPT09IGIuaWQpXG4gICAgICByZXR1cm4gMDtcbiAgICBpZiAoZXZlbnQuY3JlYXRlZF9hdCA9PT0gYi5jcmVhdGVkX2F0KVxuICAgICAgcmV0dXJuIC0xO1xuICAgIHJldHVybiBldmVudC5jcmVhdGVkX2F0IC0gYi5jcmVhdGVkX2F0O1xuICB9KTtcbiAgaWYgKCFmb3VuZCkge1xuICAgIHNvcnRlZEFycmF5LnNwbGljZShpZHgsIDAsIGV2ZW50KTtcbiAgfVxuICByZXR1cm4gc29ydGVkQXJyYXk7XG59XG5mdW5jdGlvbiBiaW5hcnlTZWFyY2goYXJyLCBjb21wYXJlKSB7XG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgd2hpbGUgKHN0YXJ0IDw9IGVuZCkge1xuICAgIGNvbnN0IG1pZCA9IE1hdGguZmxvb3IoKHN0YXJ0ICsgZW5kKSAvIDIpO1xuICAgIGNvbnN0IGNtcCA9IGNvbXBhcmUoYXJyW21pZF0pO1xuICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgIHJldHVybiBbbWlkLCB0cnVlXTtcbiAgICB9XG4gICAgaWYgKGNtcCA8IDApIHtcbiAgICAgIGVuZCA9IG1pZCAtIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0ID0gbWlkICsgMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtzdGFydCwgZmFsc2VdO1xufVxudmFyIFF1ZXVlTm9kZSA9IGNsYXNzIHtcbiAgdmFsdWU7XG4gIG5leHQgPSBudWxsO1xuICBwcmV2ID0gbnVsbDtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHRoaXMudmFsdWUgPSBtZXNzYWdlO1xuICB9XG59O1xudmFyIFF1ZXVlID0gY2xhc3Mge1xuICBmaXJzdDtcbiAgbGFzdDtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5maXJzdCA9IG51bGw7XG4gICAgdGhpcy5sYXN0ID0gbnVsbDtcbiAgfVxuICBlbnF1ZXVlKHZhbHVlKSB7XG4gICAgY29uc3QgbmV3Tm9kZSA9IG5ldyBRdWV1ZU5vZGUodmFsdWUpO1xuICAgIGlmICghdGhpcy5sYXN0KSB7XG4gICAgICB0aGlzLmZpcnN0ID0gbmV3Tm9kZTtcbiAgICAgIHRoaXMubGFzdCA9IG5ld05vZGU7XG4gICAgfSBlbHNlIGlmICh0aGlzLmxhc3QgPT09IHRoaXMuZmlyc3QpIHtcbiAgICAgIHRoaXMubGFzdCA9IG5ld05vZGU7XG4gICAgICB0aGlzLmxhc3QucHJldiA9IHRoaXMuZmlyc3Q7XG4gICAgICB0aGlzLmZpcnN0Lm5leHQgPSBuZXdOb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdOb2RlLnByZXYgPSB0aGlzLmxhc3Q7XG4gICAgICB0aGlzLmxhc3QubmV4dCA9IG5ld05vZGU7XG4gICAgICB0aGlzLmxhc3QgPSBuZXdOb2RlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBkZXF1ZXVlKCkge1xuICAgIGlmICghdGhpcy5maXJzdClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGlmICh0aGlzLmZpcnN0ID09PSB0aGlzLmxhc3QpIHtcbiAgICAgIGNvbnN0IHRhcmdldDIgPSB0aGlzLmZpcnN0O1xuICAgICAgdGhpcy5maXJzdCA9IG51bGw7XG4gICAgICB0aGlzLmxhc3QgPSBudWxsO1xuICAgICAgcmV0dXJuIHRhcmdldDIudmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuZmlyc3Q7XG4gICAgdGhpcy5maXJzdCA9IHRhcmdldC5uZXh0O1xuICAgIHJldHVybiB0YXJnZXQudmFsdWU7XG4gIH1cbn07XG5cbi8vIHB1cmUudHNcbnZhciBKUyA9IGNsYXNzIHtcbiAgZ2VuZXJhdGVTZWNyZXRLZXkoKSB7XG4gICAgcmV0dXJuIHNjaG5vcnIudXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpO1xuICB9XG4gIGdldFB1YmxpY0tleShzZWNyZXRLZXkpIHtcbiAgICByZXR1cm4gYnl0ZXNUb0hleChzY2hub3JyLmdldFB1YmxpY0tleShzZWNyZXRLZXkpKTtcbiAgfVxuICBmaW5hbGl6ZUV2ZW50KHQsIHNlY3JldEtleSkge1xuICAgIGNvbnN0IGV2ZW50ID0gdDtcbiAgICBldmVudC5wdWJrZXkgPSBieXRlc1RvSGV4KHNjaG5vcnIuZ2V0UHVibGljS2V5KHNlY3JldEtleSkpO1xuICAgIGV2ZW50LmlkID0gZ2V0RXZlbnRIYXNoKGV2ZW50KTtcbiAgICBldmVudC5zaWcgPSBieXRlc1RvSGV4KHNjaG5vcnIuc2lnbihnZXRFdmVudEhhc2goZXZlbnQpLCBzZWNyZXRLZXkpKTtcbiAgICBldmVudFt2ZXJpZmllZFN5bWJvbF0gPSB0cnVlO1xuICAgIHJldHVybiBldmVudDtcbiAgfVxuICB2ZXJpZnlFdmVudChldmVudCkge1xuICAgIGlmICh0eXBlb2YgZXZlbnRbdmVyaWZpZWRTeW1ib2xdID09PSBcImJvb2xlYW5cIilcbiAgICAgIHJldHVybiBldmVudFt2ZXJpZmllZFN5bWJvbF07XG4gICAgY29uc3QgaGFzaCA9IGdldEV2ZW50SGFzaChldmVudCk7XG4gICAgaWYgKGhhc2ggIT09IGV2ZW50LmlkKSB7XG4gICAgICBldmVudFt2ZXJpZmllZFN5bWJvbF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHZhbGlkID0gc2Nobm9yci52ZXJpZnkoZXZlbnQuc2lnLCBoYXNoLCBldmVudC5wdWJrZXkpO1xuICAgICAgZXZlbnRbdmVyaWZpZWRTeW1ib2xdID0gdmFsaWQ7XG4gICAgICByZXR1cm4gdmFsaWQ7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBldmVudFt2ZXJpZmllZFN5bWJvbF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBzZXJpYWxpemVFdmVudChldnQpIHtcbiAgaWYgKCF2YWxpZGF0ZUV2ZW50KGV2dCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY2FuJ3Qgc2VyaWFsaXplIGV2ZW50IHdpdGggd3Jvbmcgb3IgbWlzc2luZyBwcm9wZXJ0aWVzXCIpO1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoWzAsIGV2dC5wdWJrZXksIGV2dC5jcmVhdGVkX2F0LCBldnQua2luZCwgZXZ0LnRhZ3MsIGV2dC5jb250ZW50XSk7XG59XG5mdW5jdGlvbiBnZXRFdmVudEhhc2goZXZlbnQpIHtcbiAgbGV0IGV2ZW50SGFzaCA9IHNoYTI1Nih1dGY4RW5jb2Rlci5lbmNvZGUoc2VyaWFsaXplRXZlbnQoZXZlbnQpKSk7XG4gIHJldHVybiBieXRlc1RvSGV4KGV2ZW50SGFzaCk7XG59XG52YXIgaSA9IG5ldyBKUygpO1xudmFyIGdlbmVyYXRlU2VjcmV0S2V5ID0gaS5nZW5lcmF0ZVNlY3JldEtleTtcbnZhciBnZXRQdWJsaWNLZXkgPSBpLmdldFB1YmxpY0tleTtcbnZhciBmaW5hbGl6ZUV2ZW50ID0gaS5maW5hbGl6ZUV2ZW50O1xudmFyIHZlcmlmeUV2ZW50ID0gaS52ZXJpZnlFdmVudDtcblxuLy8ga2luZHMudHNcbnZhciBraW5kc19leHBvcnRzID0ge307XG5fX2V4cG9ydChraW5kc19leHBvcnRzLCB7XG4gIEFwcGxpY2F0aW9uOiAoKSA9PiBBcHBsaWNhdGlvbixcbiAgQmFkZ2VBd2FyZDogKCkgPT4gQmFkZ2VBd2FyZCxcbiAgQmFkZ2VEZWZpbml0aW9uOiAoKSA9PiBCYWRnZURlZmluaXRpb24sXG4gIEJsb2NrZWRSZWxheXNMaXN0OiAoKSA9PiBCbG9ja2VkUmVsYXlzTGlzdCxcbiAgQm9va21hcmtMaXN0OiAoKSA9PiBCb29rbWFya0xpc3QsXG4gIEJvb2ttYXJrc2V0czogKCkgPT4gQm9va21hcmtzZXRzLFxuICBDYWxlbmRhcjogKCkgPT4gQ2FsZW5kYXIsXG4gIENhbGVuZGFyRXZlbnRSU1ZQOiAoKSA9PiBDYWxlbmRhckV2ZW50UlNWUCxcbiAgQ2hhbm5lbENyZWF0aW9uOiAoKSA9PiBDaGFubmVsQ3JlYXRpb24sXG4gIENoYW5uZWxIaWRlTWVzc2FnZTogKCkgPT4gQ2hhbm5lbEhpZGVNZXNzYWdlLFxuICBDaGFubmVsTWVzc2FnZTogKCkgPT4gQ2hhbm5lbE1lc3NhZ2UsXG4gIENoYW5uZWxNZXRhZGF0YTogKCkgPT4gQ2hhbm5lbE1ldGFkYXRhLFxuICBDaGFubmVsTXV0ZVVzZXI6ICgpID0+IENoYW5uZWxNdXRlVXNlcixcbiAgQ2xhc3NpZmllZExpc3Rpbmc6ICgpID0+IENsYXNzaWZpZWRMaXN0aW5nLFxuICBDbGllbnRBdXRoOiAoKSA9PiBDbGllbnRBdXRoLFxuICBDb21tdW5pdGllc0xpc3Q6ICgpID0+IENvbW11bml0aWVzTGlzdCxcbiAgQ29tbXVuaXR5RGVmaW5pdGlvbjogKCkgPT4gQ29tbXVuaXR5RGVmaW5pdGlvbixcbiAgQ29tbXVuaXR5UG9zdEFwcHJvdmFsOiAoKSA9PiBDb21tdW5pdHlQb3N0QXBwcm92YWwsXG4gIENvbnRhY3RzOiAoKSA9PiBDb250YWN0cyxcbiAgQ3JlYXRlT3JVcGRhdGVQcm9kdWN0OiAoKSA9PiBDcmVhdGVPclVwZGF0ZVByb2R1Y3QsXG4gIENyZWF0ZU9yVXBkYXRlU3RhbGw6ICgpID0+IENyZWF0ZU9yVXBkYXRlU3RhbGwsXG4gIEN1cmF0aW9uc2V0czogKCkgPT4gQ3VyYXRpb25zZXRzLFxuICBEYXRlOiAoKSA9PiBEYXRlMixcbiAgRHJhZnRDbGFzc2lmaWVkTGlzdGluZzogKCkgPT4gRHJhZnRDbGFzc2lmaWVkTGlzdGluZyxcbiAgRHJhZnRMb25nOiAoKSA9PiBEcmFmdExvbmcsXG4gIEVtb2ppc2V0czogKCkgPT4gRW1vamlzZXRzLFxuICBFbmNyeXB0ZWREaXJlY3RNZXNzYWdlOiAoKSA9PiBFbmNyeXB0ZWREaXJlY3RNZXNzYWdlLFxuICBFbmNyeXB0ZWREaXJlY3RNZXNzYWdlczogKCkgPT4gRW5jcnlwdGVkRGlyZWN0TWVzc2FnZXMsXG4gIEV2ZW50RGVsZXRpb246ICgpID0+IEV2ZW50RGVsZXRpb24sXG4gIEZpbGVNZXRhZGF0YTogKCkgPT4gRmlsZU1ldGFkYXRhLFxuICBGaWxlU2VydmVyUHJlZmVyZW5jZTogKCkgPT4gRmlsZVNlcnZlclByZWZlcmVuY2UsXG4gIEZvbGxvd3NldHM6ICgpID0+IEZvbGxvd3NldHMsXG4gIEdlbmVyaWNSZXBvc3Q6ICgpID0+IEdlbmVyaWNSZXBvc3QsXG4gIEdlbmVyaWNsaXN0czogKCkgPT4gR2VuZXJpY2xpc3RzLFxuICBIVFRQQXV0aDogKCkgPT4gSFRUUEF1dGgsXG4gIEhhbmRsZXJpbmZvcm1hdGlvbjogKCkgPT4gSGFuZGxlcmluZm9ybWF0aW9uLFxuICBIYW5kbGVycmVjb21tZW5kYXRpb246ICgpID0+IEhhbmRsZXJyZWNvbW1lbmRhdGlvbixcbiAgSGlnaGxpZ2h0czogKCkgPT4gSGlnaGxpZ2h0cyxcbiAgSW50ZXJlc3RzTGlzdDogKCkgPT4gSW50ZXJlc3RzTGlzdCxcbiAgSW50ZXJlc3RzZXRzOiAoKSA9PiBJbnRlcmVzdHNldHMsXG4gIEpvYkZlZWRiYWNrOiAoKSA9PiBKb2JGZWVkYmFjayxcbiAgSm9iUmVxdWVzdDogKCkgPT4gSm9iUmVxdWVzdCxcbiAgSm9iUmVzdWx0OiAoKSA9PiBKb2JSZXN1bHQsXG4gIExhYmVsOiAoKSA9PiBMYWJlbCxcbiAgTGlnaHRuaW5nUHViUlBDOiAoKSA9PiBMaWdodG5pbmdQdWJSUEMsXG4gIExpdmVDaGF0TWVzc2FnZTogKCkgPT4gTGl2ZUNoYXRNZXNzYWdlLFxuICBMaXZlRXZlbnQ6ICgpID0+IExpdmVFdmVudCxcbiAgTG9uZ0Zvcm1BcnRpY2xlOiAoKSA9PiBMb25nRm9ybUFydGljbGUsXG4gIE1ldGFkYXRhOiAoKSA9PiBNZXRhZGF0YSxcbiAgTXV0ZWxpc3Q6ICgpID0+IE11dGVsaXN0LFxuICBOV0NXYWxsZXRJbmZvOiAoKSA9PiBOV0NXYWxsZXRJbmZvLFxuICBOV0NXYWxsZXRSZXF1ZXN0OiAoKSA9PiBOV0NXYWxsZXRSZXF1ZXN0LFxuICBOV0NXYWxsZXRSZXNwb25zZTogKCkgPT4gTldDV2FsbGV0UmVzcG9uc2UsXG4gIE5vc3RyQ29ubmVjdDogKCkgPT4gTm9zdHJDb25uZWN0LFxuICBPcGVuVGltZXN0YW1wczogKCkgPT4gT3BlblRpbWVzdGFtcHMsXG4gIFBpbmxpc3Q6ICgpID0+IFBpbmxpc3QsXG4gIFByb2JsZW1UcmFja2VyOiAoKSA9PiBQcm9ibGVtVHJhY2tlcixcbiAgUHJvZmlsZUJhZGdlczogKCkgPT4gUHJvZmlsZUJhZGdlcyxcbiAgUHVibGljQ2hhdHNMaXN0OiAoKSA9PiBQdWJsaWNDaGF0c0xpc3QsXG4gIFJlYWN0aW9uOiAoKSA9PiBSZWFjdGlvbixcbiAgUmVjb21tZW5kUmVsYXk6ICgpID0+IFJlY29tbWVuZFJlbGF5LFxuICBSZWxheUxpc3Q6ICgpID0+IFJlbGF5TGlzdCxcbiAgUmVsYXlzZXRzOiAoKSA9PiBSZWxheXNldHMsXG4gIFJlcG9ydDogKCkgPT4gUmVwb3J0LFxuICBSZXBvcnRpbmc6ICgpID0+IFJlcG9ydGluZyxcbiAgUmVwb3N0OiAoKSA9PiBSZXBvc3QsXG4gIFNlYXJjaFJlbGF5c0xpc3Q6ICgpID0+IFNlYXJjaFJlbGF5c0xpc3QsXG4gIFNob3J0VGV4dE5vdGU6ICgpID0+IFNob3J0VGV4dE5vdGUsXG4gIFRpbWU6ICgpID0+IFRpbWUsXG4gIFVzZXJFbW9qaUxpc3Q6ICgpID0+IFVzZXJFbW9qaUxpc3QsXG4gIFVzZXJTdGF0dXNlczogKCkgPT4gVXNlclN0YXR1c2VzLFxuICBaYXA6ICgpID0+IFphcCxcbiAgWmFwR29hbDogKCkgPT4gWmFwR29hbCxcbiAgWmFwUmVxdWVzdDogKCkgPT4gWmFwUmVxdWVzdCxcbiAgY2xhc3NpZnlLaW5kOiAoKSA9PiBjbGFzc2lmeUtpbmQsXG4gIGlzRXBoZW1lcmFsS2luZDogKCkgPT4gaXNFcGhlbWVyYWxLaW5kLFxuICBpc1BhcmFtZXRlcml6ZWRSZXBsYWNlYWJsZUtpbmQ6ICgpID0+IGlzUGFyYW1ldGVyaXplZFJlcGxhY2VhYmxlS2luZCxcbiAgaXNSZWd1bGFyS2luZDogKCkgPT4gaXNSZWd1bGFyS2luZCxcbiAgaXNSZXBsYWNlYWJsZUtpbmQ6ICgpID0+IGlzUmVwbGFjZWFibGVLaW5kXG59KTtcbmZ1bmN0aW9uIGlzUmVndWxhcktpbmQoa2luZCkge1xuICByZXR1cm4gMWUzIDw9IGtpbmQgJiYga2luZCA8IDFlNCB8fCBbMSwgMiwgNCwgNSwgNiwgNywgOCwgMTYsIDQwLCA0MSwgNDIsIDQzLCA0NF0uaW5jbHVkZXMoa2luZCk7XG59XG5mdW5jdGlvbiBpc1JlcGxhY2VhYmxlS2luZChraW5kKSB7XG4gIHJldHVybiBbMCwgM10uaW5jbHVkZXMoa2luZCkgfHwgMWU0IDw9IGtpbmQgJiYga2luZCA8IDJlNDtcbn1cbmZ1bmN0aW9uIGlzRXBoZW1lcmFsS2luZChraW5kKSB7XG4gIHJldHVybiAyZTQgPD0ga2luZCAmJiBraW5kIDwgM2U0O1xufVxuZnVuY3Rpb24gaXNQYXJhbWV0ZXJpemVkUmVwbGFjZWFibGVLaW5kKGtpbmQpIHtcbiAgcmV0dXJuIDNlNCA8PSBraW5kICYmIGtpbmQgPCA0ZTQ7XG59XG5mdW5jdGlvbiBjbGFzc2lmeUtpbmQoa2luZCkge1xuICBpZiAoaXNSZWd1bGFyS2luZChraW5kKSlcbiAgICByZXR1cm4gXCJyZWd1bGFyXCI7XG4gIGlmIChpc1JlcGxhY2VhYmxlS2luZChraW5kKSlcbiAgICByZXR1cm4gXCJyZXBsYWNlYWJsZVwiO1xuICBpZiAoaXNFcGhlbWVyYWxLaW5kKGtpbmQpKVxuICAgIHJldHVybiBcImVwaGVtZXJhbFwiO1xuICBpZiAoaXNQYXJhbWV0ZXJpemVkUmVwbGFjZWFibGVLaW5kKGtpbmQpKVxuICAgIHJldHVybiBcInBhcmFtZXRlcml6ZWRcIjtcbiAgcmV0dXJuIFwidW5rbm93blwiO1xufVxudmFyIE1ldGFkYXRhID0gMDtcbnZhciBTaG9ydFRleHROb3RlID0gMTtcbnZhciBSZWNvbW1lbmRSZWxheSA9IDI7XG52YXIgQ29udGFjdHMgPSAzO1xudmFyIEVuY3J5cHRlZERpcmVjdE1lc3NhZ2UgPSA0O1xudmFyIEVuY3J5cHRlZERpcmVjdE1lc3NhZ2VzID0gNDtcbnZhciBFdmVudERlbGV0aW9uID0gNTtcbnZhciBSZXBvc3QgPSA2O1xudmFyIFJlYWN0aW9uID0gNztcbnZhciBCYWRnZUF3YXJkID0gODtcbnZhciBHZW5lcmljUmVwb3N0ID0gMTY7XG52YXIgQ2hhbm5lbENyZWF0aW9uID0gNDA7XG52YXIgQ2hhbm5lbE1ldGFkYXRhID0gNDE7XG52YXIgQ2hhbm5lbE1lc3NhZ2UgPSA0MjtcbnZhciBDaGFubmVsSGlkZU1lc3NhZ2UgPSA0MztcbnZhciBDaGFubmVsTXV0ZVVzZXIgPSA0NDtcbnZhciBPcGVuVGltZXN0YW1wcyA9IDEwNDA7XG52YXIgRmlsZU1ldGFkYXRhID0gMTA2MztcbnZhciBMaXZlQ2hhdE1lc3NhZ2UgPSAxMzExO1xudmFyIFByb2JsZW1UcmFja2VyID0gMTk3MTtcbnZhciBSZXBvcnQgPSAxOTg0O1xudmFyIFJlcG9ydGluZyA9IDE5ODQ7XG52YXIgTGFiZWwgPSAxOTg1O1xudmFyIENvbW11bml0eVBvc3RBcHByb3ZhbCA9IDQ1NTA7XG52YXIgSm9iUmVxdWVzdCA9IDU5OTk7XG52YXIgSm9iUmVzdWx0ID0gNjk5OTtcbnZhciBKb2JGZWVkYmFjayA9IDdlMztcbnZhciBaYXBHb2FsID0gOTA0MTtcbnZhciBaYXBSZXF1ZXN0ID0gOTczNDtcbnZhciBaYXAgPSA5NzM1O1xudmFyIEhpZ2hsaWdodHMgPSA5ODAyO1xudmFyIE11dGVsaXN0ID0gMWU0O1xudmFyIFBpbmxpc3QgPSAxMDAwMTtcbnZhciBSZWxheUxpc3QgPSAxMDAwMjtcbnZhciBCb29rbWFya0xpc3QgPSAxMDAwMztcbnZhciBDb21tdW5pdGllc0xpc3QgPSAxMDAwNDtcbnZhciBQdWJsaWNDaGF0c0xpc3QgPSAxMDAwNTtcbnZhciBCbG9ja2VkUmVsYXlzTGlzdCA9IDEwMDA2O1xudmFyIFNlYXJjaFJlbGF5c0xpc3QgPSAxMDAwNztcbnZhciBJbnRlcmVzdHNMaXN0ID0gMTAwMTU7XG52YXIgVXNlckVtb2ppTGlzdCA9IDEwMDMwO1xudmFyIEZpbGVTZXJ2ZXJQcmVmZXJlbmNlID0gMTAwOTY7XG52YXIgTldDV2FsbGV0SW5mbyA9IDEzMTk0O1xudmFyIExpZ2h0bmluZ1B1YlJQQyA9IDIxZTM7XG52YXIgQ2xpZW50QXV0aCA9IDIyMjQyO1xudmFyIE5XQ1dhbGxldFJlcXVlc3QgPSAyMzE5NDtcbnZhciBOV0NXYWxsZXRSZXNwb25zZSA9IDIzMTk1O1xudmFyIE5vc3RyQ29ubmVjdCA9IDI0MTMzO1xudmFyIEhUVFBBdXRoID0gMjcyMzU7XG52YXIgRm9sbG93c2V0cyA9IDNlNDtcbnZhciBHZW5lcmljbGlzdHMgPSAzMDAwMTtcbnZhciBSZWxheXNldHMgPSAzMDAwMjtcbnZhciBCb29rbWFya3NldHMgPSAzMDAwMztcbnZhciBDdXJhdGlvbnNldHMgPSAzMDAwNDtcbnZhciBQcm9maWxlQmFkZ2VzID0gMzAwMDg7XG52YXIgQmFkZ2VEZWZpbml0aW9uID0gMzAwMDk7XG52YXIgSW50ZXJlc3RzZXRzID0gMzAwMTU7XG52YXIgQ3JlYXRlT3JVcGRhdGVTdGFsbCA9IDMwMDE3O1xudmFyIENyZWF0ZU9yVXBkYXRlUHJvZHVjdCA9IDMwMDE4O1xudmFyIExvbmdGb3JtQXJ0aWNsZSA9IDMwMDIzO1xudmFyIERyYWZ0TG9uZyA9IDMwMDI0O1xudmFyIEVtb2ppc2V0cyA9IDMwMDMwO1xudmFyIEFwcGxpY2F0aW9uID0gMzAwNzg7XG52YXIgTGl2ZUV2ZW50ID0gMzAzMTE7XG52YXIgVXNlclN0YXR1c2VzID0gMzAzMTU7XG52YXIgQ2xhc3NpZmllZExpc3RpbmcgPSAzMDQwMjtcbnZhciBEcmFmdENsYXNzaWZpZWRMaXN0aW5nID0gMzA0MDM7XG52YXIgRGF0ZTIgPSAzMTkyMjtcbnZhciBUaW1lID0gMzE5MjM7XG52YXIgQ2FsZW5kYXIgPSAzMTkyNDtcbnZhciBDYWxlbmRhckV2ZW50UlNWUCA9IDMxOTI1O1xudmFyIEhhbmRsZXJyZWNvbW1lbmRhdGlvbiA9IDMxOTg5O1xudmFyIEhhbmRsZXJpbmZvcm1hdGlvbiA9IDMxOTkwO1xudmFyIENvbW11bml0eURlZmluaXRpb24gPSAzNDU1MDtcblxuLy8gZmlsdGVyLnRzXG5mdW5jdGlvbiBtYXRjaEZpbHRlcihmaWx0ZXIsIGV2ZW50KSB7XG4gIGlmIChmaWx0ZXIuaWRzICYmIGZpbHRlci5pZHMuaW5kZXhPZihldmVudC5pZCkgPT09IC0xKSB7XG4gICAgaWYgKCFmaWx0ZXIuaWRzLnNvbWUoKHByZWZpeCkgPT4gZXZlbnQuaWQuc3RhcnRzV2l0aChwcmVmaXgpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoZmlsdGVyLmtpbmRzICYmIGZpbHRlci5raW5kcy5pbmRleE9mKGV2ZW50LmtpbmQpID09PSAtMSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChmaWx0ZXIuYXV0aG9ycyAmJiBmaWx0ZXIuYXV0aG9ycy5pbmRleE9mKGV2ZW50LnB1YmtleSkgPT09IC0xKSB7XG4gICAgaWYgKCFmaWx0ZXIuYXV0aG9ycy5zb21lKChwcmVmaXgpID0+IGV2ZW50LnB1YmtleS5zdGFydHNXaXRoKHByZWZpeCkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZvciAobGV0IGYgaW4gZmlsdGVyKSB7XG4gICAgaWYgKGZbMF0gPT09IFwiI1wiKSB7XG4gICAgICBsZXQgdGFnTmFtZSA9IGYuc2xpY2UoMSk7XG4gICAgICBsZXQgdmFsdWVzID0gZmlsdGVyW2AjJHt0YWdOYW1lfWBdO1xuICAgICAgaWYgKHZhbHVlcyAmJiAhZXZlbnQudGFncy5maW5kKChbdCwgdl0pID0+IHQgPT09IGYuc2xpY2UoMSkgJiYgdmFsdWVzLmluZGV4T2YodikgIT09IC0xKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoZmlsdGVyLnNpbmNlICYmIGV2ZW50LmNyZWF0ZWRfYXQgPCBmaWx0ZXIuc2luY2UpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoZmlsdGVyLnVudGlsICYmIGV2ZW50LmNyZWF0ZWRfYXQgPiBmaWx0ZXIudW50aWwpXG4gICAgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG1hdGNoRmlsdGVycyhmaWx0ZXJzLCBldmVudCkge1xuICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgZmlsdGVycy5sZW5ndGg7IGkyKyspIHtcbiAgICBpZiAobWF0Y2hGaWx0ZXIoZmlsdGVyc1tpMl0sIGV2ZW50KSlcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIG1lcmdlRmlsdGVycyguLi5maWx0ZXJzKSB7XG4gIGxldCByZXN1bHQgPSB7fTtcbiAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IGZpbHRlcnMubGVuZ3RoOyBpMisrKSB7XG4gICAgbGV0IGZpbHRlciA9IGZpbHRlcnNbaTJdO1xuICAgIE9iamVjdC5lbnRyaWVzKGZpbHRlcikuZm9yRWFjaCgoW3Byb3BlcnR5LCB2YWx1ZXNdKSA9PiB7XG4gICAgICBpZiAocHJvcGVydHkgPT09IFwia2luZHNcIiB8fCBwcm9wZXJ0eSA9PT0gXCJpZHNcIiB8fCBwcm9wZXJ0eSA9PT0gXCJhdXRob3JzXCIgfHwgcHJvcGVydHlbMF0gPT09IFwiI1wiKSB7XG4gICAgICAgIHJlc3VsdFtwcm9wZXJ0eV0gPSByZXN1bHRbcHJvcGVydHldIHx8IFtdO1xuICAgICAgICBmb3IgKGxldCB2ID0gMDsgdiA8IHZhbHVlcy5sZW5ndGg7IHYrKykge1xuICAgICAgICAgIGxldCB2YWx1ZSA9IHZhbHVlc1t2XTtcbiAgICAgICAgICBpZiAoIXJlc3VsdFtwcm9wZXJ0eV0uaW5jbHVkZXModmFsdWUpKVxuICAgICAgICAgICAgcmVzdWx0W3Byb3BlcnR5XS5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChmaWx0ZXIubGltaXQgJiYgKCFyZXN1bHQubGltaXQgfHwgZmlsdGVyLmxpbWl0ID4gcmVzdWx0LmxpbWl0KSlcbiAgICAgIHJlc3VsdC5saW1pdCA9IGZpbHRlci5saW1pdDtcbiAgICBpZiAoZmlsdGVyLnVudGlsICYmICghcmVzdWx0LnVudGlsIHx8IGZpbHRlci51bnRpbCA+IHJlc3VsdC51bnRpbCkpXG4gICAgICByZXN1bHQudW50aWwgPSBmaWx0ZXIudW50aWw7XG4gICAgaWYgKGZpbHRlci5zaW5jZSAmJiAoIXJlc3VsdC5zaW5jZSB8fCBmaWx0ZXIuc2luY2UgPCByZXN1bHQuc2luY2UpKVxuICAgICAgcmVzdWx0LnNpbmNlID0gZmlsdGVyLnNpbmNlO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRGaWx0ZXJMaW1pdChmaWx0ZXIpIHtcbiAgaWYgKGZpbHRlci5pZHMgJiYgIWZpbHRlci5pZHMubGVuZ3RoKVxuICAgIHJldHVybiAwO1xuICBpZiAoZmlsdGVyLmtpbmRzICYmICFmaWx0ZXIua2luZHMubGVuZ3RoKVxuICAgIHJldHVybiAwO1xuICBpZiAoZmlsdGVyLmF1dGhvcnMgJiYgIWZpbHRlci5hdXRob3JzLmxlbmd0aClcbiAgICByZXR1cm4gMDtcbiAgcmV0dXJuIE1hdGgubWluKFxuICAgIE1hdGgubWF4KDAsIGZpbHRlci5saW1pdCA/PyBJbmZpbml0eSksXG4gICAgZmlsdGVyLmlkcz8ubGVuZ3RoID8/IEluZmluaXR5LFxuICAgIGZpbHRlci5hdXRob3JzPy5sZW5ndGggJiYgZmlsdGVyLmtpbmRzPy5ldmVyeSgoa2luZCkgPT4gaXNSZXBsYWNlYWJsZUtpbmQoa2luZCkpID8gZmlsdGVyLmF1dGhvcnMubGVuZ3RoICogZmlsdGVyLmtpbmRzLmxlbmd0aCA6IEluZmluaXR5XG4gICk7XG59XG5cbi8vIGZha2Vqc29uLnRzXG52YXIgZmFrZWpzb25fZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoZmFrZWpzb25fZXhwb3J0cywge1xuICBnZXRIZXg2NDogKCkgPT4gZ2V0SGV4NjQsXG4gIGdldEludDogKCkgPT4gZ2V0SW50LFxuICBnZXRTdWJzY3JpcHRpb25JZDogKCkgPT4gZ2V0U3Vic2NyaXB0aW9uSWQsXG4gIG1hdGNoRXZlbnRJZDogKCkgPT4gbWF0Y2hFdmVudElkLFxuICBtYXRjaEV2ZW50S2luZDogKCkgPT4gbWF0Y2hFdmVudEtpbmQsXG4gIG1hdGNoRXZlbnRQdWJrZXk6ICgpID0+IG1hdGNoRXZlbnRQdWJrZXlcbn0pO1xuZnVuY3Rpb24gZ2V0SGV4NjQoanNvbiwgZmllbGQpIHtcbiAgbGV0IGxlbiA9IGZpZWxkLmxlbmd0aCArIDM7XG4gIGxldCBpZHggPSBqc29uLmluZGV4T2YoYFwiJHtmaWVsZH1cIjpgKSArIGxlbjtcbiAgbGV0IHMgPSBqc29uLnNsaWNlKGlkeCkuaW5kZXhPZihgXCJgKSArIGlkeCArIDE7XG4gIHJldHVybiBqc29uLnNsaWNlKHMsIHMgKyA2NCk7XG59XG5mdW5jdGlvbiBnZXRJbnQoanNvbiwgZmllbGQpIHtcbiAgbGV0IGxlbiA9IGZpZWxkLmxlbmd0aDtcbiAgbGV0IGlkeCA9IGpzb24uaW5kZXhPZihgXCIke2ZpZWxkfVwiOmApICsgbGVuICsgMztcbiAgbGV0IHNsaWNlZCA9IGpzb24uc2xpY2UoaWR4KTtcbiAgbGV0IGVuZCA9IE1hdGgubWluKHNsaWNlZC5pbmRleE9mKFwiLFwiKSwgc2xpY2VkLmluZGV4T2YoXCJ9XCIpKTtcbiAgcmV0dXJuIHBhcnNlSW50KHNsaWNlZC5zbGljZSgwLCBlbmQpLCAxMCk7XG59XG5mdW5jdGlvbiBnZXRTdWJzY3JpcHRpb25JZChqc29uKSB7XG4gIGxldCBpZHggPSBqc29uLnNsaWNlKDAsIDIyKS5pbmRleE9mKGBcIkVWRU5UXCJgKTtcbiAgaWYgKGlkeCA9PT0gLTEpXG4gICAgcmV0dXJuIG51bGw7XG4gIGxldCBwc3RhcnQgPSBqc29uLnNsaWNlKGlkeCArIDcgKyAxKS5pbmRleE9mKGBcImApO1xuICBpZiAocHN0YXJ0ID09PSAtMSlcbiAgICByZXR1cm4gbnVsbDtcbiAgbGV0IHN0YXJ0ID0gaWR4ICsgNyArIDEgKyBwc3RhcnQ7XG4gIGxldCBwZW5kID0ganNvbi5zbGljZShzdGFydCArIDEsIDgwKS5pbmRleE9mKGBcImApO1xuICBpZiAocGVuZCA9PT0gLTEpXG4gICAgcmV0dXJuIG51bGw7XG4gIGxldCBlbmQgPSBzdGFydCArIDEgKyBwZW5kO1xuICByZXR1cm4ganNvbi5zbGljZShzdGFydCArIDEsIGVuZCk7XG59XG5mdW5jdGlvbiBtYXRjaEV2ZW50SWQoanNvbiwgaWQpIHtcbiAgcmV0dXJuIGlkID09PSBnZXRIZXg2NChqc29uLCBcImlkXCIpO1xufVxuZnVuY3Rpb24gbWF0Y2hFdmVudFB1YmtleShqc29uLCBwdWJrZXkpIHtcbiAgcmV0dXJuIHB1YmtleSA9PT0gZ2V0SGV4NjQoanNvbiwgXCJwdWJrZXlcIik7XG59XG5mdW5jdGlvbiBtYXRjaEV2ZW50S2luZChqc29uLCBraW5kKSB7XG4gIHJldHVybiBraW5kID09PSBnZXRJbnQoanNvbiwgXCJraW5kXCIpO1xufVxuXG4vLyBuaXA0Mi50c1xudmFyIG5pcDQyX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDQyX2V4cG9ydHMsIHtcbiAgbWFrZUF1dGhFdmVudDogKCkgPT4gbWFrZUF1dGhFdmVudFxufSk7XG5mdW5jdGlvbiBtYWtlQXV0aEV2ZW50KHJlbGF5VVJMLCBjaGFsbGVuZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBDbGllbnRBdXRoLFxuICAgIGNyZWF0ZWRfYXQ6IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDFlMyksXG4gICAgdGFnczogW1xuICAgICAgW1wicmVsYXlcIiwgcmVsYXlVUkxdLFxuICAgICAgW1wiY2hhbGxlbmdlXCIsIGNoYWxsZW5nZV1cbiAgICBdLFxuICAgIGNvbnRlbnQ6IFwiXCJcbiAgfTtcbn1cblxuLy8gaGVscGVycy50c1xuYXN5bmMgZnVuY3Rpb24geWllbGRUaHJlYWQoKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGNvbnN0IGNoID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgY29uc3QgaGFuZGxlciA9ICgpID0+IHtcbiAgICAgIGNoLnBvcnQxLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGhhbmRsZXIpO1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH07XG4gICAgY2gucG9ydDEuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgaGFuZGxlcik7XG4gICAgY2gucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG4gICAgY2gucG9ydDEuc3RhcnQoKTtcbiAgfSk7XG59XG52YXIgYWx3YXlzVHJ1ZSA9ICh0KSA9PiB7XG4gIHRbdmVyaWZpZWRTeW1ib2xdID0gdHJ1ZTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBhYnN0cmFjdC1yZWxheS50c1xudmFyIF9XZWJTb2NrZXQ7XG50cnkge1xuICBfV2ViU29ja2V0ID0gV2ViU29ja2V0O1xufSBjYXRjaCB7XG59XG5mdW5jdGlvbiB1c2VXZWJTb2NrZXRJbXBsZW1lbnRhdGlvbih3ZWJzb2NrZXRJbXBsZW1lbnRhdGlvbikge1xuICBfV2ViU29ja2V0ID0gd2Vic29ja2V0SW1wbGVtZW50YXRpb247XG59XG52YXIgQWJzdHJhY3RSZWxheSA9IGNsYXNzIHtcbiAgdXJsO1xuICBfY29ubmVjdGVkID0gZmFsc2U7XG4gIG9uY2xvc2UgPSBudWxsO1xuICBvbm5vdGljZSA9IChtc2cpID0+IGNvbnNvbGUuZGVidWcoYE5PVElDRSBmcm9tICR7dGhpcy51cmx9OiAke21zZ31gKTtcbiAgYmFzZUVvc2VUaW1lb3V0ID0gNDQwMDtcbiAgY29ubmVjdGlvblRpbWVvdXQgPSA0NDAwO1xuICBvcGVuU3VicyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbm5lY3Rpb25UaW1lb3V0SGFuZGxlO1xuICBjb25uZWN0aW9uUHJvbWlzZTtcbiAgb3BlbkNvdW50UmVxdWVzdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBvcGVuRXZlbnRQdWJsaXNoZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB3cztcbiAgaW5jb21pbmdNZXNzYWdlUXVldWUgPSBuZXcgUXVldWUoKTtcbiAgcXVldWVSdW5uaW5nID0gZmFsc2U7XG4gIGNoYWxsZW5nZTtcbiAgc2VyaWFsID0gMDtcbiAgdmVyaWZ5RXZlbnQ7XG4gIGNvbnN0cnVjdG9yKHVybCwgb3B0cykge1xuICAgIHRoaXMudXJsID0gbm9ybWFsaXplVVJMKHVybCk7XG4gICAgdGhpcy52ZXJpZnlFdmVudCA9IG9wdHMudmVyaWZ5RXZlbnQ7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGNvbm5lY3QodXJsLCBvcHRzKSB7XG4gICAgY29uc3QgcmVsYXkgPSBuZXcgQWJzdHJhY3RSZWxheSh1cmwsIG9wdHMpO1xuICAgIGF3YWl0IHJlbGF5LmNvbm5lY3QoKTtcbiAgICByZXR1cm4gcmVsYXk7XG4gIH1cbiAgY2xvc2VBbGxTdWJzY3JpcHRpb25zKHJlYXNvbikge1xuICAgIGZvciAobGV0IFtfLCBzdWJdIG9mIHRoaXMub3BlblN1YnMpIHtcbiAgICAgIHN1Yi5jbG9zZShyZWFzb24pO1xuICAgIH1cbiAgICB0aGlzLm9wZW5TdWJzLmNsZWFyKCk7XG4gICAgZm9yIChsZXQgW18sIGVwXSBvZiB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcykge1xuICAgICAgZXAucmVqZWN0KG5ldyBFcnJvcihyZWFzb24pKTtcbiAgICB9XG4gICAgdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMuY2xlYXIoKTtcbiAgICBmb3IgKGxldCBbXywgY3JdIG9mIHRoaXMub3BlbkNvdW50UmVxdWVzdHMpIHtcbiAgICAgIGNyLnJlamVjdChuZXcgRXJyb3IocmVhc29uKSk7XG4gICAgfVxuICAgIHRoaXMub3BlbkNvdW50UmVxdWVzdHMuY2xlYXIoKTtcbiAgfVxuICBnZXQgY29ubmVjdGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25uZWN0ZWQ7XG4gIH1cbiAgYXN5bmMgY29ubmVjdCgpIHtcbiAgICBpZiAodGhpcy5jb25uZWN0aW9uUHJvbWlzZSlcbiAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlO1xuICAgIHRoaXMuY2hhbGxlbmdlID0gdm9pZCAwO1xuICAgIHRoaXMuY29ubmVjdGlvblByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLmNvbm5lY3Rpb25UaW1lb3V0SGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHJlamVjdChcImNvbm5lY3Rpb24gdGltZWQgb3V0XCIpO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlID0gdm9pZCAwO1xuICAgICAgICB0aGlzLm9uY2xvc2U/LigpO1xuICAgICAgICB0aGlzLmNsb3NlQWxsU3Vic2NyaXB0aW9ucyhcInJlbGF5IGNvbm5lY3Rpb24gdGltZWQgb3V0XCIpO1xuICAgICAgfSwgdGhpcy5jb25uZWN0aW9uVGltZW91dCk7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLndzID0gbmV3IF9XZWJTb2NrZXQodGhpcy51cmwpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLndzLm9ub3BlbiA9ICgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY29ubmVjdGlvblRpbWVvdXRIYW5kbGUpO1xuICAgICAgICB0aGlzLl9jb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9O1xuICAgICAgdGhpcy53cy5vbmVycm9yID0gKGV2KSA9PiB7XG4gICAgICAgIHJlamVjdChldi5tZXNzYWdlKTtcbiAgICAgICAgaWYgKHRoaXMuX2Nvbm5lY3RlZCkge1xuICAgICAgICAgIHRoaXMub25jbG9zZT8uKCk7XG4gICAgICAgICAgdGhpcy5jbG9zZUFsbFN1YnNjcmlwdGlvbnMoXCJyZWxheSBjb25uZWN0aW9uIGVycm9yZWRcIik7XG4gICAgICAgICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLndzLm9uY2xvc2UgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvblByb21pc2UgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMub25jbG9zZT8uKCk7XG4gICAgICAgIHRoaXMuY2xvc2VBbGxTdWJzY3JpcHRpb25zKFwicmVsYXkgY29ubmVjdGlvbiBjbG9zZWRcIik7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgfTtcbiAgICAgIHRoaXMud3Mub25tZXNzYWdlID0gdGhpcy5fb25tZXNzYWdlLmJpbmQodGhpcyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvblByb21pc2U7XG4gIH1cbiAgYXN5bmMgcnVuUXVldWUoKSB7XG4gICAgdGhpcy5xdWV1ZVJ1bm5pbmcgPSB0cnVlO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoZmFsc2UgPT09IHRoaXMuaGFuZGxlTmV4dCgpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgYXdhaXQgeWllbGRUaHJlYWQoKTtcbiAgICB9XG4gICAgdGhpcy5xdWV1ZVJ1bm5pbmcgPSBmYWxzZTtcbiAgfVxuICBoYW5kbGVOZXh0KCkge1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmluY29taW5nTWVzc2FnZVF1ZXVlLmRlcXVldWUoKTtcbiAgICBpZiAoIWpzb24pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgc3ViaWQgPSBnZXRTdWJzY3JpcHRpb25JZChqc29uKTtcbiAgICBpZiAoc3ViaWQpIHtcbiAgICAgIGNvbnN0IHNvID0gdGhpcy5vcGVuU3Vicy5nZXQoc3ViaWQpO1xuICAgICAgaWYgKCFzbykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpZCA9IGdldEhleDY0KGpzb24sIFwiaWRcIik7XG4gICAgICBjb25zdCBhbHJlYWR5SGF2ZSA9IHNvLmFscmVhZHlIYXZlRXZlbnQ/LihpZCk7XG4gICAgICBzby5yZWNlaXZlZEV2ZW50Py4odGhpcywgaWQpO1xuICAgICAgaWYgKGFscmVhZHlIYXZlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGxldCBkYXRhID0gSlNPTi5wYXJzZShqc29uKTtcbiAgICAgIHN3aXRjaCAoZGF0YVswXSkge1xuICAgICAgICBjYXNlIFwiRVZFTlRcIjoge1xuICAgICAgICAgIGNvbnN0IHNvID0gdGhpcy5vcGVuU3Vicy5nZXQoZGF0YVsxXSk7XG4gICAgICAgICAgY29uc3QgZXZlbnQgPSBkYXRhWzJdO1xuICAgICAgICAgIGlmICh0aGlzLnZlcmlmeUV2ZW50KGV2ZW50KSAmJiBtYXRjaEZpbHRlcnMoc28uZmlsdGVycywgZXZlbnQpKSB7XG4gICAgICAgICAgICBzby5vbmV2ZW50KGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJDT1VOVFwiOiB7XG4gICAgICAgICAgY29uc3QgaWQgPSBkYXRhWzFdO1xuICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBkYXRhWzJdO1xuICAgICAgICAgIGNvbnN0IGNyID0gdGhpcy5vcGVuQ291bnRSZXF1ZXN0cy5nZXQoaWQpO1xuICAgICAgICAgIGlmIChjcikge1xuICAgICAgICAgICAgY3IucmVzb2x2ZShwYXlsb2FkLmNvdW50KTtcbiAgICAgICAgICAgIHRoaXMub3BlbkNvdW50UmVxdWVzdHMuZGVsZXRlKGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJFT1NFXCI6IHtcbiAgICAgICAgICBjb25zdCBzbyA9IHRoaXMub3BlblN1YnMuZ2V0KGRhdGFbMV0pO1xuICAgICAgICAgIGlmICghc28pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgc28ucmVjZWl2ZWRFb3NlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJPS1wiOiB7XG4gICAgICAgICAgY29uc3QgaWQgPSBkYXRhWzFdO1xuICAgICAgICAgIGNvbnN0IG9rID0gZGF0YVsyXTtcbiAgICAgICAgICBjb25zdCByZWFzb24gPSBkYXRhWzNdO1xuICAgICAgICAgIGNvbnN0IGVwID0gdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMuZ2V0KGlkKTtcbiAgICAgICAgICBpZiAob2spXG4gICAgICAgICAgICBlcC5yZXNvbHZlKHJlYXNvbik7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZXAucmVqZWN0KG5ldyBFcnJvcihyZWFzb24pKTtcbiAgICAgICAgICB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcy5kZWxldGUoaWQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiQ0xPU0VEXCI6IHtcbiAgICAgICAgICBjb25zdCBpZCA9IGRhdGFbMV07XG4gICAgICAgICAgY29uc3Qgc28gPSB0aGlzLm9wZW5TdWJzLmdldChpZCk7XG4gICAgICAgICAgaWYgKCFzbylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBzby5jbG9zZWQgPSB0cnVlO1xuICAgICAgICAgIHNvLmNsb3NlKGRhdGFbMl0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiTk9USUNFXCI6XG4gICAgICAgICAgdGhpcy5vbm5vdGljZShkYXRhWzFdKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgXCJBVVRIXCI6IHtcbiAgICAgICAgICB0aGlzLmNoYWxsZW5nZSA9IGRhdGFbMV07XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGFzeW5jIHNlbmQobWVzc2FnZSkge1xuICAgIGlmICghdGhpcy5jb25uZWN0aW9uUHJvbWlzZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInNlbmRpbmcgb24gY2xvc2VkIGNvbm5lY3Rpb25cIik7XG4gICAgdGhpcy5jb25uZWN0aW9uUHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMud3M/LnNlbmQobWVzc2FnZSk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgYXV0aChzaWduQXV0aEV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmNoYWxsZW5nZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbid0IHBlcmZvcm0gYXV0aCwgbm8gY2hhbGxlbmdlIHdhcyByZWNlaXZlZFwiKTtcbiAgICBjb25zdCBldnQgPSBhd2FpdCBzaWduQXV0aEV2ZW50KG1ha2VBdXRoRXZlbnQodGhpcy51cmwsIHRoaXMuY2hhbGxlbmdlKSk7XG4gICAgY29uc3QgcmV0ID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMuc2V0KGV2dC5pZCwgeyByZXNvbHZlLCByZWplY3QgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5zZW5kKCdbXCJBVVRIXCIsJyArIEpTT04uc3RyaW5naWZ5KGV2dCkgKyBcIl1cIik7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBhc3luYyBwdWJsaXNoKGV2ZW50KSB7XG4gICAgY29uc3QgcmV0ID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMuc2V0KGV2ZW50LmlkLCB7IHJlc29sdmUsIHJlamVjdCB9KTtcbiAgICB9KTtcbiAgICB0aGlzLnNlbmQoJ1tcIkVWRU5UXCIsJyArIEpTT04uc3RyaW5naWZ5KGV2ZW50KSArIFwiXVwiKTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGFzeW5jIGNvdW50KGZpbHRlcnMsIHBhcmFtcykge1xuICAgIHRoaXMuc2VyaWFsKys7XG4gICAgY29uc3QgaWQgPSBwYXJhbXM/LmlkIHx8IFwiY291bnQ6XCIgKyB0aGlzLnNlcmlhbDtcbiAgICBjb25zdCByZXQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLm9wZW5Db3VudFJlcXVlc3RzLnNldChpZCwgeyByZXNvbHZlLCByZWplY3QgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5zZW5kKCdbXCJDT1VOVFwiLFwiJyArIGlkICsgJ1wiLCcgKyBKU09OLnN0cmluZ2lmeShmaWx0ZXJzKSArIFwiXVwiKTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIHN1YnNjcmliZShmaWx0ZXJzLCBwYXJhbXMpIHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSB0aGlzLnByZXBhcmVTdWJzY3JpcHRpb24oZmlsdGVycywgcGFyYW1zKTtcbiAgICBzdWJzY3JpcHRpb24uZmlyZSgpO1xuICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gIH1cbiAgcHJlcGFyZVN1YnNjcmlwdGlvbihmaWx0ZXJzLCBwYXJhbXMpIHtcbiAgICB0aGlzLnNlcmlhbCsrO1xuICAgIGNvbnN0IGlkID0gcGFyYW1zLmlkIHx8IFwic3ViOlwiICsgdGhpcy5zZXJpYWw7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbih0aGlzLCBpZCwgZmlsdGVycywgcGFyYW1zKTtcbiAgICB0aGlzLm9wZW5TdWJzLnNldChpZCwgc3Vic2NyaXB0aW9uKTtcbiAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICB9XG4gIGNsb3NlKCkge1xuICAgIHRoaXMuY2xvc2VBbGxTdWJzY3JpcHRpb25zKFwicmVsYXkgY29ubmVjdGlvbiBjbG9zZWQgYnkgdXNcIik7XG4gICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy53cz8uY2xvc2UoKTtcbiAgfVxuICBfb25tZXNzYWdlKGV2KSB7XG4gICAgdGhpcy5pbmNvbWluZ01lc3NhZ2VRdWV1ZS5lbnF1ZXVlKGV2LmRhdGEpO1xuICAgIGlmICghdGhpcy5xdWV1ZVJ1bm5pbmcpIHtcbiAgICAgIHRoaXMucnVuUXVldWUoKTtcbiAgICB9XG4gIH1cbn07XG52YXIgU3Vic2NyaXB0aW9uID0gY2xhc3Mge1xuICByZWxheTtcbiAgaWQ7XG4gIGNsb3NlZCA9IGZhbHNlO1xuICBlb3NlZCA9IGZhbHNlO1xuICBmaWx0ZXJzO1xuICBhbHJlYWR5SGF2ZUV2ZW50O1xuICByZWNlaXZlZEV2ZW50O1xuICBvbmV2ZW50O1xuICBvbmVvc2U7XG4gIG9uY2xvc2U7XG4gIGVvc2VUaW1lb3V0O1xuICBlb3NlVGltZW91dEhhbmRsZTtcbiAgY29uc3RydWN0b3IocmVsYXksIGlkLCBmaWx0ZXJzLCBwYXJhbXMpIHtcbiAgICB0aGlzLnJlbGF5ID0gcmVsYXk7XG4gICAgdGhpcy5maWx0ZXJzID0gZmlsdGVycztcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5hbHJlYWR5SGF2ZUV2ZW50ID0gcGFyYW1zLmFscmVhZHlIYXZlRXZlbnQ7XG4gICAgdGhpcy5yZWNlaXZlZEV2ZW50ID0gcGFyYW1zLnJlY2VpdmVkRXZlbnQ7XG4gICAgdGhpcy5lb3NlVGltZW91dCA9IHBhcmFtcy5lb3NlVGltZW91dCB8fCByZWxheS5iYXNlRW9zZVRpbWVvdXQ7XG4gICAgdGhpcy5vbmVvc2UgPSBwYXJhbXMub25lb3NlO1xuICAgIHRoaXMub25jbG9zZSA9IHBhcmFtcy5vbmNsb3NlO1xuICAgIHRoaXMub25ldmVudCA9IHBhcmFtcy5vbmV2ZW50IHx8ICgoZXZlbnQpID0+IHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYG9uZXZlbnQoKSBjYWxsYmFjayBub3QgZGVmaW5lZCBmb3Igc3Vic2NyaXB0aW9uICcke3RoaXMuaWR9JyBpbiByZWxheSAke3RoaXMucmVsYXkudXJsfS4gZXZlbnQgcmVjZWl2ZWQ6YCxcbiAgICAgICAgZXZlbnRcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgZmlyZSgpIHtcbiAgICB0aGlzLnJlbGF5LnNlbmQoJ1tcIlJFUVwiLFwiJyArIHRoaXMuaWQgKyAnXCIsJyArIEpTT04uc3RyaW5naWZ5KHRoaXMuZmlsdGVycykuc3Vic3RyaW5nKDEpKTtcbiAgICB0aGlzLmVvc2VUaW1lb3V0SGFuZGxlID0gc2V0VGltZW91dCh0aGlzLnJlY2VpdmVkRW9zZS5iaW5kKHRoaXMpLCB0aGlzLmVvc2VUaW1lb3V0KTtcbiAgfVxuICByZWNlaXZlZEVvc2UoKSB7XG4gICAgaWYgKHRoaXMuZW9zZWQpXG4gICAgICByZXR1cm47XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuZW9zZVRpbWVvdXRIYW5kbGUpO1xuICAgIHRoaXMuZW9zZWQgPSB0cnVlO1xuICAgIHRoaXMub25lb3NlPy4oKTtcbiAgfVxuICBjbG9zZShyZWFzb24gPSBcImNsb3NlZCBieSBjYWxsZXJcIikge1xuICAgIGlmICghdGhpcy5jbG9zZWQpIHtcbiAgICAgIHRoaXMucmVsYXkuc2VuZCgnW1wiQ0xPU0VcIiwnICsgSlNPTi5zdHJpbmdpZnkodGhpcy5pZCkgKyBcIl1cIik7XG4gICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMucmVsYXkub3BlblN1YnMuZGVsZXRlKHRoaXMuaWQpO1xuICAgIHRoaXMub25jbG9zZT8uKHJlYXNvbik7XG4gIH1cbn07XG5cbi8vIHJlbGF5LnRzXG5mdW5jdGlvbiByZWxheUNvbm5lY3QodXJsKSB7XG4gIHJldHVybiBSZWxheS5jb25uZWN0KHVybCk7XG59XG52YXIgUmVsYXkgPSBjbGFzcyBleHRlbmRzIEFic3RyYWN0UmVsYXkge1xuICBjb25zdHJ1Y3Rvcih1cmwpIHtcbiAgICBzdXBlcih1cmwsIHsgdmVyaWZ5RXZlbnQgfSk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGNvbm5lY3QodXJsKSB7XG4gICAgY29uc3QgcmVsYXkgPSBuZXcgUmVsYXkodXJsKTtcbiAgICBhd2FpdCByZWxheS5jb25uZWN0KCk7XG4gICAgcmV0dXJuIHJlbGF5O1xuICB9XG59O1xuXG4vLyBhYnN0cmFjdC1wb29sLnRzXG52YXIgQWJzdHJhY3RTaW1wbGVQb29sID0gY2xhc3Mge1xuICByZWxheXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBzZWVuT24gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB0cmFja1JlbGF5cyA9IGZhbHNlO1xuICB2ZXJpZnlFdmVudDtcbiAgdHJ1c3RlZFJlbGF5VVJMcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICB0aGlzLnZlcmlmeUV2ZW50ID0gb3B0cy52ZXJpZnlFdmVudDtcbiAgfVxuICBhc3luYyBlbnN1cmVSZWxheSh1cmwsIHBhcmFtcykge1xuICAgIHVybCA9IG5vcm1hbGl6ZVVSTCh1cmwpO1xuICAgIGxldCByZWxheSA9IHRoaXMucmVsYXlzLmdldCh1cmwpO1xuICAgIGlmICghcmVsYXkpIHtcbiAgICAgIHJlbGF5ID0gbmV3IEFic3RyYWN0UmVsYXkodXJsLCB7XG4gICAgICAgIHZlcmlmeUV2ZW50OiB0aGlzLnRydXN0ZWRSZWxheVVSTHMuaGFzKHVybCkgPyBhbHdheXNUcnVlIDogdGhpcy52ZXJpZnlFdmVudFxuICAgICAgfSk7XG4gICAgICBpZiAocGFyYW1zPy5jb25uZWN0aW9uVGltZW91dClcbiAgICAgICAgcmVsYXkuY29ubmVjdGlvblRpbWVvdXQgPSBwYXJhbXMuY29ubmVjdGlvblRpbWVvdXQ7XG4gICAgICB0aGlzLnJlbGF5cy5zZXQodXJsLCByZWxheSk7XG4gICAgfVxuICAgIGF3YWl0IHJlbGF5LmNvbm5lY3QoKTtcbiAgICByZXR1cm4gcmVsYXk7XG4gIH1cbiAgY2xvc2UocmVsYXlzKSB7XG4gICAgcmVsYXlzLm1hcChub3JtYWxpemVVUkwpLmZvckVhY2goKHVybCkgPT4ge1xuICAgICAgdGhpcy5yZWxheXMuZ2V0KHVybCk/LmNsb3NlKCk7XG4gICAgfSk7XG4gIH1cbiAgc3Vic2NyaWJlTWFueShyZWxheXMsIGZpbHRlcnMsIHBhcmFtcykge1xuICAgIGlmICh0aGlzLnRyYWNrUmVsYXlzKSB7XG4gICAgICBwYXJhbXMucmVjZWl2ZWRFdmVudCA9IChyZWxheSwgaWQpID0+IHtcbiAgICAgICAgbGV0IHNldCA9IHRoaXMuc2Vlbk9uLmdldChpZCk7XG4gICAgICAgIGlmICghc2V0KSB7XG4gICAgICAgICAgc2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgICAgICB0aGlzLnNlZW5Pbi5zZXQoaWQsIHNldCk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0LmFkZChyZWxheSk7XG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBfa25vd25JZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGNvbnN0IHN1YnMgPSBbXTtcbiAgICBjb25zdCBlb3Nlc1JlY2VpdmVkID0gW107XG4gICAgbGV0IGhhbmRsZUVvc2UgPSAoaTIpID0+IHtcbiAgICAgIGVvc2VzUmVjZWl2ZWRbaTJdID0gdHJ1ZTtcbiAgICAgIGlmIChlb3Nlc1JlY2VpdmVkLmZpbHRlcigoYSkgPT4gYSkubGVuZ3RoID09PSByZWxheXMubGVuZ3RoKSB7XG4gICAgICAgIHBhcmFtcy5vbmVvc2U/LigpO1xuICAgICAgICBoYW5kbGVFb3NlID0gKCkgPT4ge1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgY2xvc2VzUmVjZWl2ZWQgPSBbXTtcbiAgICBsZXQgaGFuZGxlQ2xvc2UgPSAoaTIsIHJlYXNvbikgPT4ge1xuICAgICAgaGFuZGxlRW9zZShpMik7XG4gICAgICBjbG9zZXNSZWNlaXZlZFtpMl0gPSByZWFzb247XG4gICAgICBpZiAoY2xvc2VzUmVjZWl2ZWQuZmlsdGVyKChhKSA9PiBhKS5sZW5ndGggPT09IHJlbGF5cy5sZW5ndGgpIHtcbiAgICAgICAgcGFyYW1zLm9uY2xvc2U/LihjbG9zZXNSZWNlaXZlZCk7XG4gICAgICAgIGhhbmRsZUNsb3NlID0gKCkgPT4ge1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbG9jYWxBbHJlYWR5SGF2ZUV2ZW50SGFuZGxlciA9IChpZCkgPT4ge1xuICAgICAgaWYgKHBhcmFtcy5hbHJlYWR5SGF2ZUV2ZW50Py4oaWQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgaGF2ZSA9IF9rbm93bklkcy5oYXMoaWQpO1xuICAgICAgX2tub3duSWRzLmFkZChpZCk7XG4gICAgICByZXR1cm4gaGF2ZTtcbiAgICB9O1xuICAgIGNvbnN0IGFsbE9wZW5lZCA9IFByb21pc2UuYWxsKFxuICAgICAgcmVsYXlzLm1hcChub3JtYWxpemVVUkwpLm1hcChhc3luYyAodXJsLCBpMiwgYXJyKSA9PiB7XG4gICAgICAgIGlmIChhcnIuaW5kZXhPZih1cmwpICE9PSBpMikge1xuICAgICAgICAgIGhhbmRsZUNsb3NlKGkyLCBcImR1cGxpY2F0ZSB1cmxcIik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZWxheTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZWxheSA9IGF3YWl0IHRoaXMuZW5zdXJlUmVsYXkodXJsLCB7XG4gICAgICAgICAgICBjb25uZWN0aW9uVGltZW91dDogcGFyYW1zLm1heFdhaXQgPyBNYXRoLm1heChwYXJhbXMubWF4V2FpdCAqIDAuOCwgcGFyYW1zLm1heFdhaXQgLSAxZTMpIDogdm9pZCAwXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGhhbmRsZUNsb3NlKGkyLCBlcnI/Lm1lc3NhZ2UgfHwgU3RyaW5nKGVycikpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3Vic2NyaXB0aW9uID0gcmVsYXkuc3Vic2NyaWJlKGZpbHRlcnMsIHtcbiAgICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgICAgb25lb3NlOiAoKSA9PiBoYW5kbGVFb3NlKGkyKSxcbiAgICAgICAgICBvbmNsb3NlOiAocmVhc29uKSA9PiBoYW5kbGVDbG9zZShpMiwgcmVhc29uKSxcbiAgICAgICAgICBhbHJlYWR5SGF2ZUV2ZW50OiBsb2NhbEFscmVhZHlIYXZlRXZlbnRIYW5kbGVyLFxuICAgICAgICAgIGVvc2VUaW1lb3V0OiBwYXJhbXMubWF4V2FpdFxuICAgICAgICB9KTtcbiAgICAgICAgc3Vicy5wdXNoKHN1YnNjcmlwdGlvbik7XG4gICAgICB9KVxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFzeW5jIGNsb3NlKCkge1xuICAgICAgICBhd2FpdCBhbGxPcGVuZWQ7XG4gICAgICAgIHN1YnMuZm9yRWFjaCgoc3ViKSA9PiB7XG4gICAgICAgICAgc3ViLmNsb3NlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgc3Vic2NyaWJlTWFueUVvc2UocmVsYXlzLCBmaWx0ZXJzLCBwYXJhbXMpIHtcbiAgICBjb25zdCBzdWJjbG9zZXIgPSB0aGlzLnN1YnNjcmliZU1hbnkocmVsYXlzLCBmaWx0ZXJzLCB7XG4gICAgICAuLi5wYXJhbXMsXG4gICAgICBvbmVvc2UoKSB7XG4gICAgICAgIHN1YmNsb3Nlci5jbG9zZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzdWJjbG9zZXI7XG4gIH1cbiAgYXN5bmMgcXVlcnlTeW5jKHJlbGF5cywgZmlsdGVyLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUpID0+IHtcbiAgICAgIGNvbnN0IGV2ZW50cyA9IFtdO1xuICAgICAgdGhpcy5zdWJzY3JpYmVNYW55RW9zZShyZWxheXMsIFtmaWx0ZXJdLCB7XG4gICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgb25ldmVudChldmVudCkge1xuICAgICAgICAgIGV2ZW50cy5wdXNoKGV2ZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25jbG9zZShfKSB7XG4gICAgICAgICAgcmVzb2x2ZShldmVudHMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBnZXQocmVsYXlzLCBmaWx0ZXIsIHBhcmFtcykge1xuICAgIGZpbHRlci5saW1pdCA9IDE7XG4gICAgY29uc3QgZXZlbnRzID0gYXdhaXQgdGhpcy5xdWVyeVN5bmMocmVsYXlzLCBmaWx0ZXIsIHBhcmFtcyk7XG4gICAgZXZlbnRzLnNvcnQoKGEsIGIpID0+IGIuY3JlYXRlZF9hdCAtIGEuY3JlYXRlZF9hdCk7XG4gICAgcmV0dXJuIGV2ZW50c1swXSB8fCBudWxsO1xuICB9XG4gIHB1Ymxpc2gocmVsYXlzLCBldmVudCkge1xuICAgIHJldHVybiByZWxheXMubWFwKG5vcm1hbGl6ZVVSTCkubWFwKGFzeW5jICh1cmwsIGkyLCBhcnIpID0+IHtcbiAgICAgIGlmIChhcnIuaW5kZXhPZih1cmwpICE9PSBpMikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJkdXBsaWNhdGUgdXJsXCIpO1xuICAgICAgfVxuICAgICAgbGV0IHIgPSBhd2FpdCB0aGlzLmVuc3VyZVJlbGF5KHVybCk7XG4gICAgICByZXR1cm4gci5wdWJsaXNoKGV2ZW50KTtcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gcG9vbC50c1xudmFyIFNpbXBsZVBvb2wgPSBjbGFzcyBleHRlbmRzIEFic3RyYWN0U2ltcGxlUG9vbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHsgdmVyaWZ5RXZlbnQgfSk7XG4gIH1cbn07XG5cbi8vIG5pcDE5LnRzXG52YXIgbmlwMTlfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwMTlfZXhwb3J0cywge1xuICBCRUNIMzJfUkVHRVg6ICgpID0+IEJFQ0gzMl9SRUdFWCxcbiAgQmVjaDMyTWF4U2l6ZTogKCkgPT4gQmVjaDMyTWF4U2l6ZSxcbiAgZGVjb2RlOiAoKSA9PiBkZWNvZGUsXG4gIGVuY29kZUJ5dGVzOiAoKSA9PiBlbmNvZGVCeXRlcyxcbiAgbmFkZHJFbmNvZGU6ICgpID0+IG5hZGRyRW5jb2RlLFxuICBuZXZlbnRFbmNvZGU6ICgpID0+IG5ldmVudEVuY29kZSxcbiAgbm90ZUVuY29kZTogKCkgPT4gbm90ZUVuY29kZSxcbiAgbnByb2ZpbGVFbmNvZGU6ICgpID0+IG5wcm9maWxlRW5jb2RlLFxuICBucHViRW5jb2RlOiAoKSA9PiBucHViRW5jb2RlLFxuICBucmVsYXlFbmNvZGU6ICgpID0+IG5yZWxheUVuY29kZSxcbiAgbnNlY0VuY29kZTogKCkgPT4gbnNlY0VuY29kZVxufSk7XG5pbXBvcnQgeyBieXRlc1RvSGV4IGFzIGJ5dGVzVG9IZXgyLCBjb25jYXRCeXRlcywgaGV4VG9CeXRlcyB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCI7XG5pbXBvcnQgeyBiZWNoMzIgfSBmcm9tIFwiQHNjdXJlL2Jhc2VcIjtcbnZhciBCZWNoMzJNYXhTaXplID0gNWUzO1xudmFyIEJFQ0gzMl9SRUdFWCA9IC9bXFx4MjEtXFx4N0VdezEsODN9MVswMjM0NTY3ODlhY2RlZmdoamtsbW5wcXJzdHV2d3h5el17Nix9LztcbmZ1bmN0aW9uIGludGVnZXJUb1VpbnQ4QXJyYXkobnVtYmVyKSB7XG4gIGNvbnN0IHVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgdWludDhBcnJheVswXSA9IG51bWJlciA+PiAyNCAmIDI1NTtcbiAgdWludDhBcnJheVsxXSA9IG51bWJlciA+PiAxNiAmIDI1NTtcbiAgdWludDhBcnJheVsyXSA9IG51bWJlciA+PiA4ICYgMjU1O1xuICB1aW50OEFycmF5WzNdID0gbnVtYmVyICYgMjU1O1xuICByZXR1cm4gdWludDhBcnJheTtcbn1cbmZ1bmN0aW9uIGRlY29kZShuaXAxOSkge1xuICBsZXQgeyBwcmVmaXgsIHdvcmRzIH0gPSBiZWNoMzIuZGVjb2RlKG5pcDE5LCBCZWNoMzJNYXhTaXplKTtcbiAgbGV0IGRhdGEgPSBuZXcgVWludDhBcnJheShiZWNoMzIuZnJvbVdvcmRzKHdvcmRzKSk7XG4gIHN3aXRjaCAocHJlZml4KSB7XG4gICAgY2FzZSBcIm5wcm9maWxlXCI6IHtcbiAgICAgIGxldCB0bHYgPSBwYXJzZVRMVihkYXRhKTtcbiAgICAgIGlmICghdGx2WzBdPy5bMF0pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgVExWIDAgZm9yIG5wcm9maWxlXCIpO1xuICAgICAgaWYgKHRsdlswXVswXS5sZW5ndGggIT09IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUTFYgMCBzaG91bGQgYmUgMzIgYnl0ZXNcIik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm5wcm9maWxlXCIsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBwdWJrZXk6IGJ5dGVzVG9IZXgyKHRsdlswXVswXSksXG4gICAgICAgICAgcmVsYXlzOiB0bHZbMV0gPyB0bHZbMV0ubWFwKChkKSA9PiB1dGY4RGVjb2Rlci5kZWNvZGUoZCkpIDogW11cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcIm5ldmVudFwiOiB7XG4gICAgICBsZXQgdGx2ID0gcGFyc2VUTFYoZGF0YSk7XG4gICAgICBpZiAoIXRsdlswXT8uWzBdKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIFRMViAwIGZvciBuZXZlbnRcIik7XG4gICAgICBpZiAodGx2WzBdWzBdLmxlbmd0aCAhPT0gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRMViAwIHNob3VsZCBiZSAzMiBieXRlc1wiKTtcbiAgICAgIGlmICh0bHZbMl0gJiYgdGx2WzJdWzBdLmxlbmd0aCAhPT0gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRMViAyIHNob3VsZCBiZSAzMiBieXRlc1wiKTtcbiAgICAgIGlmICh0bHZbM10gJiYgdGx2WzNdWzBdLmxlbmd0aCAhPT0gNClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVExWIDMgc2hvdWxkIGJlIDQgYnl0ZXNcIik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm5ldmVudFwiLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgaWQ6IGJ5dGVzVG9IZXgyKHRsdlswXVswXSksXG4gICAgICAgICAgcmVsYXlzOiB0bHZbMV0gPyB0bHZbMV0ubWFwKChkKSA9PiB1dGY4RGVjb2Rlci5kZWNvZGUoZCkpIDogW10sXG4gICAgICAgICAgYXV0aG9yOiB0bHZbMl0/LlswXSA/IGJ5dGVzVG9IZXgyKHRsdlsyXVswXSkgOiB2b2lkIDAsXG4gICAgICAgICAga2luZDogdGx2WzNdPy5bMF0gPyBwYXJzZUludChieXRlc1RvSGV4Mih0bHZbM11bMF0pLCAxNikgOiB2b2lkIDBcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcIm5hZGRyXCI6IHtcbiAgICAgIGxldCB0bHYgPSBwYXJzZVRMVihkYXRhKTtcbiAgICAgIGlmICghdGx2WzBdPy5bMF0pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgVExWIDAgZm9yIG5hZGRyXCIpO1xuICAgICAgaWYgKCF0bHZbMl0/LlswXSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBUTFYgMiBmb3IgbmFkZHJcIik7XG4gICAgICBpZiAodGx2WzJdWzBdLmxlbmd0aCAhPT0gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRMViAyIHNob3VsZCBiZSAzMiBieXRlc1wiKTtcbiAgICAgIGlmICghdGx2WzNdPy5bMF0pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgVExWIDMgZm9yIG5hZGRyXCIpO1xuICAgICAgaWYgKHRsdlszXVswXS5sZW5ndGggIT09IDQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRMViAzIHNob3VsZCBiZSA0IGJ5dGVzXCIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJuYWRkclwiLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgaWRlbnRpZmllcjogdXRmOERlY29kZXIuZGVjb2RlKHRsdlswXVswXSksXG4gICAgICAgICAgcHVia2V5OiBieXRlc1RvSGV4Mih0bHZbMl1bMF0pLFxuICAgICAgICAgIGtpbmQ6IHBhcnNlSW50KGJ5dGVzVG9IZXgyKHRsdlszXVswXSksIDE2KSxcbiAgICAgICAgICByZWxheXM6IHRsdlsxXSA/IHRsdlsxXS5tYXAoKGQpID0+IHV0ZjhEZWNvZGVyLmRlY29kZShkKSkgOiBbXVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwibnJlbGF5XCI6IHtcbiAgICAgIGxldCB0bHYgPSBwYXJzZVRMVihkYXRhKTtcbiAgICAgIGlmICghdGx2WzBdPy5bMF0pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgVExWIDAgZm9yIG5yZWxheVwiKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibnJlbGF5XCIsXG4gICAgICAgIGRhdGE6IHV0ZjhEZWNvZGVyLmRlY29kZSh0bHZbMF1bMF0pXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwibnNlY1wiOlxuICAgICAgcmV0dXJuIHsgdHlwZTogcHJlZml4LCBkYXRhIH07XG4gICAgY2FzZSBcIm5wdWJcIjpcbiAgICBjYXNlIFwibm90ZVwiOlxuICAgICAgcmV0dXJuIHsgdHlwZTogcHJlZml4LCBkYXRhOiBieXRlc1RvSGV4MihkYXRhKSB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gcHJlZml4ICR7cHJlZml4fWApO1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZVRMVihkYXRhKSB7XG4gIGxldCByZXN1bHQgPSB7fTtcbiAgbGV0IHJlc3QgPSBkYXRhO1xuICB3aGlsZSAocmVzdC5sZW5ndGggPiAwKSB7XG4gICAgbGV0IHQgPSByZXN0WzBdO1xuICAgIGxldCBsID0gcmVzdFsxXTtcbiAgICBsZXQgdiA9IHJlc3Quc2xpY2UoMiwgMiArIGwpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDIgKyBsKTtcbiAgICBpZiAodi5sZW5ndGggPCBsKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBub3QgZW5vdWdoIGRhdGEgdG8gcmVhZCBvbiBUTFYgJHt0fWApO1xuICAgIHJlc3VsdFt0XSA9IHJlc3VsdFt0XSB8fCBbXTtcbiAgICByZXN1bHRbdF0ucHVzaCh2KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbnNlY0VuY29kZShrZXkpIHtcbiAgcmV0dXJuIGVuY29kZUJ5dGVzKFwibnNlY1wiLCBrZXkpO1xufVxuZnVuY3Rpb24gbnB1YkVuY29kZShoZXgpIHtcbiAgcmV0dXJuIGVuY29kZUJ5dGVzKFwibnB1YlwiLCBoZXhUb0J5dGVzKGhleCkpO1xufVxuZnVuY3Rpb24gbm90ZUVuY29kZShoZXgpIHtcbiAgcmV0dXJuIGVuY29kZUJ5dGVzKFwibm90ZVwiLCBoZXhUb0J5dGVzKGhleCkpO1xufVxuZnVuY3Rpb24gZW5jb2RlQmVjaDMyKHByZWZpeCwgZGF0YSkge1xuICBsZXQgd29yZHMgPSBiZWNoMzIudG9Xb3JkcyhkYXRhKTtcbiAgcmV0dXJuIGJlY2gzMi5lbmNvZGUocHJlZml4LCB3b3JkcywgQmVjaDMyTWF4U2l6ZSk7XG59XG5mdW5jdGlvbiBlbmNvZGVCeXRlcyhwcmVmaXgsIGJ5dGVzKSB7XG4gIHJldHVybiBlbmNvZGVCZWNoMzIocHJlZml4LCBieXRlcyk7XG59XG5mdW5jdGlvbiBucHJvZmlsZUVuY29kZShwcm9maWxlKSB7XG4gIGxldCBkYXRhID0gZW5jb2RlVExWKHtcbiAgICAwOiBbaGV4VG9CeXRlcyhwcm9maWxlLnB1YmtleSldLFxuICAgIDE6IChwcm9maWxlLnJlbGF5cyB8fCBbXSkubWFwKCh1cmwpID0+IHV0ZjhFbmNvZGVyLmVuY29kZSh1cmwpKVxuICB9KTtcbiAgcmV0dXJuIGVuY29kZUJlY2gzMihcIm5wcm9maWxlXCIsIGRhdGEpO1xufVxuZnVuY3Rpb24gbmV2ZW50RW5jb2RlKGV2ZW50KSB7XG4gIGxldCBraW5kQXJyYXk7XG4gIGlmIChldmVudC5raW5kICE9PSB2b2lkIDApIHtcbiAgICBraW5kQXJyYXkgPSBpbnRlZ2VyVG9VaW50OEFycmF5KGV2ZW50LmtpbmQpO1xuICB9XG4gIGxldCBkYXRhID0gZW5jb2RlVExWKHtcbiAgICAwOiBbaGV4VG9CeXRlcyhldmVudC5pZCldLFxuICAgIDE6IChldmVudC5yZWxheXMgfHwgW10pLm1hcCgodXJsKSA9PiB1dGY4RW5jb2Rlci5lbmNvZGUodXJsKSksXG4gICAgMjogZXZlbnQuYXV0aG9yID8gW2hleFRvQnl0ZXMoZXZlbnQuYXV0aG9yKV0gOiBbXSxcbiAgICAzOiBraW5kQXJyYXkgPyBbbmV3IFVpbnQ4QXJyYXkoa2luZEFycmF5KV0gOiBbXVxuICB9KTtcbiAgcmV0dXJuIGVuY29kZUJlY2gzMihcIm5ldmVudFwiLCBkYXRhKTtcbn1cbmZ1bmN0aW9uIG5hZGRyRW5jb2RlKGFkZHIpIHtcbiAgbGV0IGtpbmQgPSBuZXcgQXJyYXlCdWZmZXIoNCk7XG4gIG5ldyBEYXRhVmlldyhraW5kKS5zZXRVaW50MzIoMCwgYWRkci5raW5kLCBmYWxzZSk7XG4gIGxldCBkYXRhID0gZW5jb2RlVExWKHtcbiAgICAwOiBbdXRmOEVuY29kZXIuZW5jb2RlKGFkZHIuaWRlbnRpZmllcildLFxuICAgIDE6IChhZGRyLnJlbGF5cyB8fCBbXSkubWFwKCh1cmwpID0+IHV0ZjhFbmNvZGVyLmVuY29kZSh1cmwpKSxcbiAgICAyOiBbaGV4VG9CeXRlcyhhZGRyLnB1YmtleSldLFxuICAgIDM6IFtuZXcgVWludDhBcnJheShraW5kKV1cbiAgfSk7XG4gIHJldHVybiBlbmNvZGVCZWNoMzIoXCJuYWRkclwiLCBkYXRhKTtcbn1cbmZ1bmN0aW9uIG5yZWxheUVuY29kZSh1cmwpIHtcbiAgbGV0IGRhdGEgPSBlbmNvZGVUTFYoe1xuICAgIDA6IFt1dGY4RW5jb2Rlci5lbmNvZGUodXJsKV1cbiAgfSk7XG4gIHJldHVybiBlbmNvZGVCZWNoMzIoXCJucmVsYXlcIiwgZGF0YSk7XG59XG5mdW5jdGlvbiBlbmNvZGVUTFYodGx2KSB7XG4gIGxldCBlbnRyaWVzID0gW107XG4gIE9iamVjdC5lbnRyaWVzKHRsdikucmV2ZXJzZSgpLmZvckVhY2goKFt0LCB2c10pID0+IHtcbiAgICB2cy5mb3JFYWNoKCh2KSA9PiB7XG4gICAgICBsZXQgZW50cnkgPSBuZXcgVWludDhBcnJheSh2Lmxlbmd0aCArIDIpO1xuICAgICAgZW50cnkuc2V0KFtwYXJzZUludCh0KV0sIDApO1xuICAgICAgZW50cnkuc2V0KFt2Lmxlbmd0aF0sIDEpO1xuICAgICAgZW50cnkuc2V0KHYsIDIpO1xuICAgICAgZW50cmllcy5wdXNoKGVudHJ5KTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBjb25jYXRCeXRlcyguLi5lbnRyaWVzKTtcbn1cblxuLy8gcmVmZXJlbmNlcy50c1xudmFyIG1lbnRpb25SZWdleCA9IC9cXGJub3N0cjooKG5vdGV8bnB1YnxuYWRkcnxuZXZlbnR8bnByb2ZpbGUpMVxcdyspXFxifCNcXFsoXFxkKylcXF0vZztcbmZ1bmN0aW9uIHBhcnNlUmVmZXJlbmNlcyhldnQpIHtcbiAgbGV0IHJlZmVyZW5jZXMgPSBbXTtcbiAgZm9yIChsZXQgcmVmIG9mIGV2dC5jb250ZW50Lm1hdGNoQWxsKG1lbnRpb25SZWdleCkpIHtcbiAgICBpZiAocmVmWzJdKSB7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgeyB0eXBlLCBkYXRhIH0gPSBkZWNvZGUocmVmWzFdKTtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBcIm5wdWJcIjoge1xuICAgICAgICAgICAgcmVmZXJlbmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgdGV4dDogcmVmWzBdLFxuICAgICAgICAgICAgICBwcm9maWxlOiB7IHB1YmtleTogZGF0YSwgcmVsYXlzOiBbXSB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwibnByb2ZpbGVcIjoge1xuICAgICAgICAgICAgcmVmZXJlbmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgdGV4dDogcmVmWzBdLFxuICAgICAgICAgICAgICBwcm9maWxlOiBkYXRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwibm90ZVwiOiB7XG4gICAgICAgICAgICByZWZlcmVuY2VzLnB1c2goe1xuICAgICAgICAgICAgICB0ZXh0OiByZWZbMF0sXG4gICAgICAgICAgICAgIGV2ZW50OiB7IGlkOiBkYXRhLCByZWxheXM6IFtdIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJuZXZlbnRcIjoge1xuICAgICAgICAgICAgcmVmZXJlbmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgdGV4dDogcmVmWzBdLFxuICAgICAgICAgICAgICBldmVudDogZGF0YVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIm5hZGRyXCI6IHtcbiAgICAgICAgICAgIHJlZmVyZW5jZXMucHVzaCh7XG4gICAgICAgICAgICAgIHRleHQ6IHJlZlswXSxcbiAgICAgICAgICAgICAgYWRkcmVzczogZGF0YVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmVmWzNdKSB7XG4gICAgICBsZXQgaWR4ID0gcGFyc2VJbnQocmVmWzNdLCAxMCk7XG4gICAgICBsZXQgdGFnID0gZXZ0LnRhZ3NbaWR4XTtcbiAgICAgIGlmICghdGFnKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHN3aXRjaCAodGFnWzBdKSB7XG4gICAgICAgIGNhc2UgXCJwXCI6IHtcbiAgICAgICAgICByZWZlcmVuY2VzLnB1c2goe1xuICAgICAgICAgICAgdGV4dDogcmVmWzBdLFxuICAgICAgICAgICAgcHJvZmlsZTogeyBwdWJrZXk6IHRhZ1sxXSwgcmVsYXlzOiB0YWdbMl0gPyBbdGFnWzJdXSA6IFtdIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZVwiOiB7XG4gICAgICAgICAgcmVmZXJlbmNlcy5wdXNoKHtcbiAgICAgICAgICAgIHRleHQ6IHJlZlswXSxcbiAgICAgICAgICAgIGV2ZW50OiB7IGlkOiB0YWdbMV0sIHJlbGF5czogdGFnWzJdID8gW3RhZ1syXV0gOiBbXSB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImFcIjoge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgW2tpbmQsIHB1YmtleSwgaWRlbnRpZmllcl0gPSB0YWdbMV0uc3BsaXQoXCI6XCIpO1xuICAgICAgICAgICAgcmVmZXJlbmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgdGV4dDogcmVmWzBdLFxuICAgICAgICAgICAgICBhZGRyZXNzOiB7XG4gICAgICAgICAgICAgICAgaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICBwdWJrZXksXG4gICAgICAgICAgICAgICAga2luZDogcGFyc2VJbnQoa2luZCwgMTApLFxuICAgICAgICAgICAgICAgIHJlbGF5czogdGFnWzJdID8gW3RhZ1syXV0gOiBbXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlZmVyZW5jZXM7XG59XG5cbi8vIG5pcDA0LnRzXG52YXIgbmlwMDRfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwMDRfZXhwb3J0cywge1xuICBkZWNyeXB0OiAoKSA9PiBkZWNyeXB0LFxuICBlbmNyeXB0OiAoKSA9PiBlbmNyeXB0XG59KTtcbmltcG9ydCB7IGJ5dGVzVG9IZXggYXMgYnl0ZXNUb0hleDMsIHJhbmRvbUJ5dGVzIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvdXRpbHNcIjtcbmltcG9ydCB7IHNlY3AyNTZrMSB9IGZyb20gXCJAbm9ibGUvY3VydmVzL3NlY3AyNTZrMVwiO1xuaW1wb3J0IHsgY2JjIH0gZnJvbSBcIkBub2JsZS9jaXBoZXJzL2Flc1wiO1xuaW1wb3J0IHsgYmFzZTY0IH0gZnJvbSBcIkBzY3VyZS9iYXNlXCI7XG5hc3luYyBmdW5jdGlvbiBlbmNyeXB0KHNlY3JldEtleSwgcHVia2V5LCB0ZXh0KSB7XG4gIGNvbnN0IHByaXZrZXkgPSBzZWNyZXRLZXkgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gYnl0ZXNUb0hleDMoc2VjcmV0S2V5KSA6IHNlY3JldEtleTtcbiAgY29uc3Qga2V5ID0gc2VjcDI1NmsxLmdldFNoYXJlZFNlY3JldChwcml2a2V5LCBcIjAyXCIgKyBwdWJrZXkpO1xuICBjb25zdCBub3JtYWxpemVkS2V5ID0gZ2V0Tm9ybWFsaXplZFgoa2V5KTtcbiAgbGV0IGl2ID0gVWludDhBcnJheS5mcm9tKHJhbmRvbUJ5dGVzKDE2KSk7XG4gIGxldCBwbGFpbnRleHQgPSB1dGY4RW5jb2Rlci5lbmNvZGUodGV4dCk7XG4gIGxldCBjaXBoZXJ0ZXh0ID0gY2JjKG5vcm1hbGl6ZWRLZXksIGl2KS5lbmNyeXB0KHBsYWludGV4dCk7XG4gIGxldCBjdGI2NCA9IGJhc2U2NC5lbmNvZGUobmV3IFVpbnQ4QXJyYXkoY2lwaGVydGV4dCkpO1xuICBsZXQgaXZiNjQgPSBiYXNlNjQuZW5jb2RlKG5ldyBVaW50OEFycmF5KGl2LmJ1ZmZlcikpO1xuICByZXR1cm4gYCR7Y3RiNjR9P2l2PSR7aXZiNjR9YDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGRlY3J5cHQoc2VjcmV0S2V5LCBwdWJrZXksIGRhdGEpIHtcbiAgY29uc3QgcHJpdmtleSA9IHNlY3JldEtleSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBieXRlc1RvSGV4MyhzZWNyZXRLZXkpIDogc2VjcmV0S2V5O1xuICBsZXQgW2N0YjY0LCBpdmI2NF0gPSBkYXRhLnNwbGl0KFwiP2l2PVwiKTtcbiAgbGV0IGtleSA9IHNlY3AyNTZrMS5nZXRTaGFyZWRTZWNyZXQocHJpdmtleSwgXCIwMlwiICsgcHVia2V5KTtcbiAgbGV0IG5vcm1hbGl6ZWRLZXkgPSBnZXROb3JtYWxpemVkWChrZXkpO1xuICBsZXQgaXYgPSBiYXNlNjQuZGVjb2RlKGl2YjY0KTtcbiAgbGV0IGNpcGhlcnRleHQgPSBiYXNlNjQuZGVjb2RlKGN0YjY0KTtcbiAgbGV0IHBsYWludGV4dCA9IGNiYyhub3JtYWxpemVkS2V5LCBpdikuZGVjcnlwdChjaXBoZXJ0ZXh0KTtcbiAgcmV0dXJuIHV0ZjhEZWNvZGVyLmRlY29kZShwbGFpbnRleHQpO1xufVxuZnVuY3Rpb24gZ2V0Tm9ybWFsaXplZFgoa2V5KSB7XG4gIHJldHVybiBrZXkuc2xpY2UoMSwgMzMpO1xufVxuXG4vLyBuaXAwNS50c1xudmFyIG5pcDA1X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDA1X2V4cG9ydHMsIHtcbiAgTklQMDVfUkVHRVg6ICgpID0+IE5JUDA1X1JFR0VYLFxuICBpc1ZhbGlkOiAoKSA9PiBpc1ZhbGlkLFxuICBxdWVyeVByb2ZpbGU6ICgpID0+IHF1ZXJ5UHJvZmlsZSxcbiAgc2VhcmNoRG9tYWluOiAoKSA9PiBzZWFyY2hEb21haW4sXG4gIHVzZUZldGNoSW1wbGVtZW50YXRpb246ICgpID0+IHVzZUZldGNoSW1wbGVtZW50YXRpb25cbn0pO1xudmFyIE5JUDA1X1JFR0VYID0gL14oPzooW1xcdy4rLV0rKUApPyhbXFx3Xy1dKyhcXC5bXFx3Xy1dKykrKSQvO1xudmFyIF9mZXRjaDtcbnRyeSB7XG4gIF9mZXRjaCA9IGZldGNoO1xufSBjYXRjaCB7XG59XG5mdW5jdGlvbiB1c2VGZXRjaEltcGxlbWVudGF0aW9uKGZldGNoSW1wbGVtZW50YXRpb24pIHtcbiAgX2ZldGNoID0gZmV0Y2hJbXBsZW1lbnRhdGlvbjtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNlYXJjaERvbWFpbihkb21haW4sIHF1ZXJ5ID0gXCJcIikge1xuICB0cnkge1xuICAgIGNvbnN0IHVybCA9IGBodHRwczovLyR7ZG9tYWlufS8ud2VsbC1rbm93bi9ub3N0ci5qc29uP25hbWU9JHtxdWVyeX1gO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IF9mZXRjaCh1cmwsIHsgcmVkaXJlY3Q6IFwiZXJyb3JcIiB9KTtcbiAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICByZXR1cm4ganNvbi5uYW1lcztcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiB7fTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gcXVlcnlQcm9maWxlKGZ1bGxuYW1lKSB7XG4gIGNvbnN0IG1hdGNoID0gZnVsbG5hbWUubWF0Y2goTklQMDVfUkVHRVgpO1xuICBpZiAoIW1hdGNoKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCBbXywgbmFtZSA9IFwiX1wiLCBkb21haW5dID0gbWF0Y2g7XG4gIHRyeSB7XG4gICAgY29uc3QgdXJsID0gYGh0dHBzOi8vJHtkb21haW59Ly53ZWxsLWtub3duL25vc3RyLmpzb24/bmFtZT0ke25hbWV9YDtcbiAgICBjb25zdCByZXMgPSBhd2FpdCAoYXdhaXQgX2ZldGNoKHVybCwgeyByZWRpcmVjdDogXCJlcnJvclwiIH0pKS5qc29uKCk7XG4gICAgbGV0IHB1YmtleSA9IHJlcy5uYW1lc1tuYW1lXTtcbiAgICByZXR1cm4gcHVia2V5ID8geyBwdWJrZXksIHJlbGF5czogcmVzLnJlbGF5cz8uW3B1YmtleV0gfSA6IG51bGw7XG4gIH0gY2F0Y2ggKF9lKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGlzVmFsaWQocHVia2V5LCBuaXAwNSkge1xuICBsZXQgcmVzID0gYXdhaXQgcXVlcnlQcm9maWxlKG5pcDA1KTtcbiAgcmV0dXJuIHJlcyA/IHJlcy5wdWJrZXkgPT09IHB1YmtleSA6IGZhbHNlO1xufVxuXG4vLyBuaXAxMC50c1xudmFyIG5pcDEwX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDEwX2V4cG9ydHMsIHtcbiAgcGFyc2U6ICgpID0+IHBhcnNlXG59KTtcbmZ1bmN0aW9uIHBhcnNlKGV2ZW50KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICByZXBseTogdm9pZCAwLFxuICAgIHJvb3Q6IHZvaWQgMCxcbiAgICBtZW50aW9uczogW10sXG4gICAgcHJvZmlsZXM6IFtdXG4gIH07XG4gIGNvbnN0IGVUYWdzID0gW107XG4gIGZvciAoY29uc3QgdGFnIG9mIGV2ZW50LnRhZ3MpIHtcbiAgICBpZiAodGFnWzBdID09PSBcImVcIiAmJiB0YWdbMV0pIHtcbiAgICAgIGVUYWdzLnB1c2godGFnKTtcbiAgICB9XG4gICAgaWYgKHRhZ1swXSA9PT0gXCJwXCIgJiYgdGFnWzFdKSB7XG4gICAgICByZXN1bHQucHJvZmlsZXMucHVzaCh7XG4gICAgICAgIHB1YmtleTogdGFnWzFdLFxuICAgICAgICByZWxheXM6IHRhZ1syXSA/IFt0YWdbMl1dIDogW11cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCBlVGFnSW5kZXggPSAwOyBlVGFnSW5kZXggPCBlVGFncy5sZW5ndGg7IGVUYWdJbmRleCsrKSB7XG4gICAgY29uc3QgZVRhZyA9IGVUYWdzW2VUYWdJbmRleF07XG4gICAgY29uc3QgW18sIGVUYWdFdmVudElkLCBlVGFnUmVsYXlVcmwsIGVUYWdNYXJrZXJdID0gZVRhZztcbiAgICBjb25zdCBldmVudFBvaW50ZXIgPSB7XG4gICAgICBpZDogZVRhZ0V2ZW50SWQsXG4gICAgICByZWxheXM6IGVUYWdSZWxheVVybCA/IFtlVGFnUmVsYXlVcmxdIDogW11cbiAgICB9O1xuICAgIGNvbnN0IGlzRmlyc3RFVGFnID0gZVRhZ0luZGV4ID09PSAwO1xuICAgIGNvbnN0IGlzTGFzdEVUYWcgPSBlVGFnSW5kZXggPT09IGVUYWdzLmxlbmd0aCAtIDE7XG4gICAgaWYgKGVUYWdNYXJrZXIgPT09IFwicm9vdFwiKSB7XG4gICAgICByZXN1bHQucm9vdCA9IGV2ZW50UG9pbnRlcjtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoZVRhZ01hcmtlciA9PT0gXCJyZXBseVwiKSB7XG4gICAgICByZXN1bHQucmVwbHkgPSBldmVudFBvaW50ZXI7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGVUYWdNYXJrZXIgPT09IFwibWVudGlvblwiKSB7XG4gICAgICByZXN1bHQubWVudGlvbnMucHVzaChldmVudFBvaW50ZXIpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChpc0ZpcnN0RVRhZykge1xuICAgICAgcmVzdWx0LnJvb3QgPSBldmVudFBvaW50ZXI7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGlzTGFzdEVUYWcpIHtcbiAgICAgIHJlc3VsdC5yZXBseSA9IGV2ZW50UG9pbnRlcjtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXN1bHQubWVudGlvbnMucHVzaChldmVudFBvaW50ZXIpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIG5pcDExLnRzXG52YXIgbmlwMTFfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwMTFfZXhwb3J0cywge1xuICBmZXRjaFJlbGF5SW5mb3JtYXRpb246ICgpID0+IGZldGNoUmVsYXlJbmZvcm1hdGlvbixcbiAgdXNlRmV0Y2hJbXBsZW1lbnRhdGlvbjogKCkgPT4gdXNlRmV0Y2hJbXBsZW1lbnRhdGlvbjJcbn0pO1xudmFyIF9mZXRjaDI7XG50cnkge1xuICBfZmV0Y2gyID0gZmV0Y2g7XG59IGNhdGNoIHtcbn1cbmZ1bmN0aW9uIHVzZUZldGNoSW1wbGVtZW50YXRpb24yKGZldGNoSW1wbGVtZW50YXRpb24pIHtcbiAgX2ZldGNoMiA9IGZldGNoSW1wbGVtZW50YXRpb247XG59XG5hc3luYyBmdW5jdGlvbiBmZXRjaFJlbGF5SW5mb3JtYXRpb24odXJsKSB7XG4gIHJldHVybiBhd2FpdCAoYXdhaXQgZmV0Y2godXJsLnJlcGxhY2UoXCJ3czovL1wiLCBcImh0dHA6Ly9cIikucmVwbGFjZShcIndzczovL1wiLCBcImh0dHBzOi8vXCIpLCB7XG4gICAgaGVhZGVyczogeyBBY2NlcHQ6IFwiYXBwbGljYXRpb24vbm9zdHIranNvblwiIH1cbiAgfSkpLmpzb24oKTtcbn1cblxuLy8gbmlwMTMudHNcbnZhciBuaXAxM19leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXAxM19leHBvcnRzLCB7XG4gIGdldFBvdzogKCkgPT4gZ2V0UG93LFxuICBtaW5lUG93OiAoKSA9PiBtaW5lUG93XG59KTtcbmZ1bmN0aW9uIGdldFBvdyhoZXgpIHtcbiAgbGV0IGNvdW50ID0gMDtcbiAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IGhleC5sZW5ndGg7IGkyKyspIHtcbiAgICBjb25zdCBuaWJibGUgPSBwYXJzZUludChoZXhbaTJdLCAxNik7XG4gICAgaWYgKG5pYmJsZSA9PT0gMCkge1xuICAgICAgY291bnQgKz0gNDtcbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgKz0gTWF0aC5jbHozMihuaWJibGUpIC0gMjg7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufVxuZnVuY3Rpb24gbWluZVBvdyh1bnNpZ25lZCwgZGlmZmljdWx0eSkge1xuICBsZXQgY291bnQgPSAwO1xuICBjb25zdCBldmVudCA9IHVuc2lnbmVkO1xuICBjb25zdCB0YWcgPSBbXCJub25jZVwiLCBjb3VudC50b1N0cmluZygpLCBkaWZmaWN1bHR5LnRvU3RyaW5nKCldO1xuICBldmVudC50YWdzLnB1c2godGFnKTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCBub3cgPSBNYXRoLmZsb29yKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMWUzKTtcbiAgICBpZiAobm93ICE9PSBldmVudC5jcmVhdGVkX2F0KSB7XG4gICAgICBjb3VudCA9IDA7XG4gICAgICBldmVudC5jcmVhdGVkX2F0ID0gbm93O1xuICAgIH1cbiAgICB0YWdbMV0gPSAoKytjb3VudCkudG9TdHJpbmcoKTtcbiAgICBldmVudC5pZCA9IGdldEV2ZW50SGFzaChldmVudCk7XG4gICAgaWYgKGdldFBvdyhldmVudC5pZCkgPj0gZGlmZmljdWx0eSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBldmVudDtcbn1cblxuLy8gbmlwMTgudHNcbnZhciBuaXAxOF9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXAxOF9leHBvcnRzLCB7XG4gIGZpbmlzaFJlcG9zdEV2ZW50OiAoKSA9PiBmaW5pc2hSZXBvc3RFdmVudCxcbiAgZ2V0UmVwb3N0ZWRFdmVudDogKCkgPT4gZ2V0UmVwb3N0ZWRFdmVudCxcbiAgZ2V0UmVwb3N0ZWRFdmVudFBvaW50ZXI6ICgpID0+IGdldFJlcG9zdGVkRXZlbnRQb2ludGVyXG59KTtcbmZ1bmN0aW9uIGZpbmlzaFJlcG9zdEV2ZW50KHQsIHJlcG9zdGVkLCByZWxheVVybCwgcHJpdmF0ZUtleSkge1xuICByZXR1cm4gZmluYWxpemVFdmVudChcbiAgICB7XG4gICAgICBraW5kOiBSZXBvc3QsXG4gICAgICB0YWdzOiBbLi4udC50YWdzID8/IFtdLCBbXCJlXCIsIHJlcG9zdGVkLmlkLCByZWxheVVybF0sIFtcInBcIiwgcmVwb3N0ZWQucHVia2V5XV0sXG4gICAgICBjb250ZW50OiB0LmNvbnRlbnQgPT09IFwiXCIgPyBcIlwiIDogSlNPTi5zdHJpbmdpZnkocmVwb3N0ZWQpLFxuICAgICAgY3JlYXRlZF9hdDogdC5jcmVhdGVkX2F0XG4gICAgfSxcbiAgICBwcml2YXRlS2V5XG4gICk7XG59XG5mdW5jdGlvbiBnZXRSZXBvc3RlZEV2ZW50UG9pbnRlcihldmVudCkge1xuICBpZiAoZXZlbnQua2luZCAhPT0gUmVwb3N0KSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBsZXQgbGFzdEVUYWc7XG4gIGxldCBsYXN0UFRhZztcbiAgZm9yIChsZXQgaTIgPSBldmVudC50YWdzLmxlbmd0aCAtIDE7IGkyID49IDAgJiYgKGxhc3RFVGFnID09PSB2b2lkIDAgfHwgbGFzdFBUYWcgPT09IHZvaWQgMCk7IGkyLS0pIHtcbiAgICBjb25zdCB0YWcgPSBldmVudC50YWdzW2kyXTtcbiAgICBpZiAodGFnLmxlbmd0aCA+PSAyKSB7XG4gICAgICBpZiAodGFnWzBdID09PSBcImVcIiAmJiBsYXN0RVRhZyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGxhc3RFVGFnID0gdGFnO1xuICAgICAgfSBlbHNlIGlmICh0YWdbMF0gPT09IFwicFwiICYmIGxhc3RQVGFnID09PSB2b2lkIDApIHtcbiAgICAgICAgbGFzdFBUYWcgPSB0YWc7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChsYXN0RVRhZyA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4ge1xuICAgIGlkOiBsYXN0RVRhZ1sxXSxcbiAgICByZWxheXM6IFtsYXN0RVRhZ1syXSwgbGFzdFBUYWc/LlsyXV0uZmlsdGVyKCh4KSA9PiB0eXBlb2YgeCA9PT0gXCJzdHJpbmdcIiksXG4gICAgYXV0aG9yOiBsYXN0UFRhZz8uWzFdXG4gIH07XG59XG5mdW5jdGlvbiBnZXRSZXBvc3RlZEV2ZW50KGV2ZW50LCB7IHNraXBWZXJpZmljYXRpb24gfSA9IHt9KSB7XG4gIGNvbnN0IHBvaW50ZXIgPSBnZXRSZXBvc3RlZEV2ZW50UG9pbnRlcihldmVudCk7XG4gIGlmIChwb2ludGVyID09PSB2b2lkIDAgfHwgZXZlbnQuY29udGVudCA9PT0gXCJcIikge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgbGV0IHJlcG9zdGVkRXZlbnQ7XG4gIHRyeSB7XG4gICAgcmVwb3N0ZWRFdmVudCA9IEpTT04ucGFyc2UoZXZlbnQuY29udGVudCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBpZiAocmVwb3N0ZWRFdmVudC5pZCAhPT0gcG9pbnRlci5pZCkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgaWYgKCFza2lwVmVyaWZpY2F0aW9uICYmICF2ZXJpZnlFdmVudChyZXBvc3RlZEV2ZW50KSkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIHJlcG9zdGVkRXZlbnQ7XG59XG5cbi8vIG5pcDIxLnRzXG52YXIgbmlwMjFfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwMjFfZXhwb3J0cywge1xuICBOT1NUUl9VUklfUkVHRVg6ICgpID0+IE5PU1RSX1VSSV9SRUdFWCxcbiAgcGFyc2U6ICgpID0+IHBhcnNlMixcbiAgdGVzdDogKCkgPT4gdGVzdFxufSk7XG52YXIgTk9TVFJfVVJJX1JFR0VYID0gbmV3IFJlZ0V4cChgbm9zdHI6KCR7QkVDSDMyX1JFR0VYLnNvdXJjZX0pYCk7XG5mdW5jdGlvbiB0ZXN0KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgbmV3IFJlZ0V4cChgXiR7Tk9TVFJfVVJJX1JFR0VYLnNvdXJjZX0kYCkudGVzdCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBwYXJzZTIodXJpKSB7XG4gIGNvbnN0IG1hdGNoID0gdXJpLm1hdGNoKG5ldyBSZWdFeHAoYF4ke05PU1RSX1VSSV9SRUdFWC5zb3VyY2V9JGApKTtcbiAgaWYgKCFtYXRjaClcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgTm9zdHIgVVJJOiAke3VyaX1gKTtcbiAgcmV0dXJuIHtcbiAgICB1cmk6IG1hdGNoWzBdLFxuICAgIHZhbHVlOiBtYXRjaFsxXSxcbiAgICBkZWNvZGVkOiBkZWNvZGUobWF0Y2hbMV0pXG4gIH07XG59XG5cbi8vIG5pcDI1LnRzXG52YXIgbmlwMjVfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwMjVfZXhwb3J0cywge1xuICBmaW5pc2hSZWFjdGlvbkV2ZW50OiAoKSA9PiBmaW5pc2hSZWFjdGlvbkV2ZW50LFxuICBnZXRSZWFjdGVkRXZlbnRQb2ludGVyOiAoKSA9PiBnZXRSZWFjdGVkRXZlbnRQb2ludGVyXG59KTtcbmZ1bmN0aW9uIGZpbmlzaFJlYWN0aW9uRXZlbnQodCwgcmVhY3RlZCwgcHJpdmF0ZUtleSkge1xuICBjb25zdCBpbmhlcml0ZWRUYWdzID0gcmVhY3RlZC50YWdzLmZpbHRlcigodGFnKSA9PiB0YWcubGVuZ3RoID49IDIgJiYgKHRhZ1swXSA9PT0gXCJlXCIgfHwgdGFnWzBdID09PSBcInBcIikpO1xuICByZXR1cm4gZmluYWxpemVFdmVudChcbiAgICB7XG4gICAgICAuLi50LFxuICAgICAga2luZDogUmVhY3Rpb24sXG4gICAgICB0YWdzOiBbLi4udC50YWdzID8/IFtdLCAuLi5pbmhlcml0ZWRUYWdzLCBbXCJlXCIsIHJlYWN0ZWQuaWRdLCBbXCJwXCIsIHJlYWN0ZWQucHVia2V5XV0sXG4gICAgICBjb250ZW50OiB0LmNvbnRlbnQgPz8gXCIrXCJcbiAgICB9LFxuICAgIHByaXZhdGVLZXlcbiAgKTtcbn1cbmZ1bmN0aW9uIGdldFJlYWN0ZWRFdmVudFBvaW50ZXIoZXZlbnQpIHtcbiAgaWYgKGV2ZW50LmtpbmQgIT09IFJlYWN0aW9uKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBsZXQgbGFzdEVUYWc7XG4gIGxldCBsYXN0UFRhZztcbiAgZm9yIChsZXQgaTIgPSBldmVudC50YWdzLmxlbmd0aCAtIDE7IGkyID49IDAgJiYgKGxhc3RFVGFnID09PSB2b2lkIDAgfHwgbGFzdFBUYWcgPT09IHZvaWQgMCk7IGkyLS0pIHtcbiAgICBjb25zdCB0YWcgPSBldmVudC50YWdzW2kyXTtcbiAgICBpZiAodGFnLmxlbmd0aCA+PSAyKSB7XG4gICAgICBpZiAodGFnWzBdID09PSBcImVcIiAmJiBsYXN0RVRhZyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGxhc3RFVGFnID0gdGFnO1xuICAgICAgfSBlbHNlIGlmICh0YWdbMF0gPT09IFwicFwiICYmIGxhc3RQVGFnID09PSB2b2lkIDApIHtcbiAgICAgICAgbGFzdFBUYWcgPSB0YWc7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChsYXN0RVRhZyA9PT0gdm9pZCAwIHx8IGxhc3RQVGFnID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiB7XG4gICAgaWQ6IGxhc3RFVGFnWzFdLFxuICAgIHJlbGF5czogW2xhc3RFVGFnWzJdLCBsYXN0UFRhZ1syXV0uZmlsdGVyKCh4KSA9PiB4ICE9PSB2b2lkIDApLFxuICAgIGF1dGhvcjogbGFzdFBUYWdbMV1cbiAgfTtcbn1cblxuLy8gbmlwMjcudHNcbnZhciBuaXAyN19leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXAyN19leHBvcnRzLCB7XG4gIG1hdGNoQWxsOiAoKSA9PiBtYXRjaEFsbCxcbiAgcmVnZXg6ICgpID0+IHJlZ2V4LFxuICByZXBsYWNlQWxsOiAoKSA9PiByZXBsYWNlQWxsXG59KTtcbnZhciByZWdleCA9ICgpID0+IG5ldyBSZWdFeHAoYFxcXFxiJHtOT1NUUl9VUklfUkVHRVguc291cmNlfVxcXFxiYCwgXCJnXCIpO1xuZnVuY3Rpb24qIG1hdGNoQWxsKGNvbnRlbnQpIHtcbiAgY29uc3QgbWF0Y2hlcyA9IGNvbnRlbnQubWF0Y2hBbGwocmVnZXgoKSk7XG4gIGZvciAoY29uc3QgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBbdXJpLCB2YWx1ZV0gPSBtYXRjaDtcbiAgICAgIHlpZWxkIHtcbiAgICAgICAgdXJpLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgZGVjb2RlZDogZGVjb2RlKHZhbHVlKSxcbiAgICAgICAgc3RhcnQ6IG1hdGNoLmluZGV4LFxuICAgICAgICBlbmQ6IG1hdGNoLmluZGV4ICsgdXJpLmxlbmd0aFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChfZSkge1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVwbGFjZUFsbChjb250ZW50LCByZXBsYWNlcikge1xuICByZXR1cm4gY29udGVudC5yZXBsYWNlQWxsKHJlZ2V4KCksICh1cmksIHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIHJlcGxhY2VyKHtcbiAgICAgIHVyaSxcbiAgICAgIHZhbHVlLFxuICAgICAgZGVjb2RlZDogZGVjb2RlKHZhbHVlKVxuICAgIH0pO1xuICB9KTtcbn1cblxuLy8gbmlwMjgudHNcbnZhciBuaXAyOF9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXAyOF9leHBvcnRzLCB7XG4gIGNoYW5uZWxDcmVhdGVFdmVudDogKCkgPT4gY2hhbm5lbENyZWF0ZUV2ZW50LFxuICBjaGFubmVsSGlkZU1lc3NhZ2VFdmVudDogKCkgPT4gY2hhbm5lbEhpZGVNZXNzYWdlRXZlbnQsXG4gIGNoYW5uZWxNZXNzYWdlRXZlbnQ6ICgpID0+IGNoYW5uZWxNZXNzYWdlRXZlbnQsXG4gIGNoYW5uZWxNZXRhZGF0YUV2ZW50OiAoKSA9PiBjaGFubmVsTWV0YWRhdGFFdmVudCxcbiAgY2hhbm5lbE11dGVVc2VyRXZlbnQ6ICgpID0+IGNoYW5uZWxNdXRlVXNlckV2ZW50XG59KTtcbnZhciBjaGFubmVsQ3JlYXRlRXZlbnQgPSAodCwgcHJpdmF0ZUtleSkgPT4ge1xuICBsZXQgY29udGVudDtcbiAgaWYgKHR5cGVvZiB0LmNvbnRlbnQgPT09IFwib2JqZWN0XCIpIHtcbiAgICBjb250ZW50ID0gSlNPTi5zdHJpbmdpZnkodC5jb250ZW50KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdC5jb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgY29udGVudCA9IHQuY29udGVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiBmaW5hbGl6ZUV2ZW50KFxuICAgIHtcbiAgICAgIGtpbmQ6IENoYW5uZWxDcmVhdGlvbixcbiAgICAgIHRhZ3M6IFsuLi50LnRhZ3MgPz8gW11dLFxuICAgICAgY29udGVudCxcbiAgICAgIGNyZWF0ZWRfYXQ6IHQuY3JlYXRlZF9hdFxuICAgIH0sXG4gICAgcHJpdmF0ZUtleVxuICApO1xufTtcbnZhciBjaGFubmVsTWV0YWRhdGFFdmVudCA9ICh0LCBwcml2YXRlS2V5KSA9PiB7XG4gIGxldCBjb250ZW50O1xuICBpZiAodHlwZW9mIHQuY29udGVudCA9PT0gXCJvYmplY3RcIikge1xuICAgIGNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeSh0LmNvbnRlbnQpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0LmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb250ZW50ID0gdC5jb250ZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIGZpbmFsaXplRXZlbnQoXG4gICAge1xuICAgICAga2luZDogQ2hhbm5lbE1ldGFkYXRhLFxuICAgICAgdGFnczogW1tcImVcIiwgdC5jaGFubmVsX2NyZWF0ZV9ldmVudF9pZF0sIC4uLnQudGFncyA/PyBbXV0sXG4gICAgICBjb250ZW50LFxuICAgICAgY3JlYXRlZF9hdDogdC5jcmVhdGVkX2F0XG4gICAgfSxcbiAgICBwcml2YXRlS2V5XG4gICk7XG59O1xudmFyIGNoYW5uZWxNZXNzYWdlRXZlbnQgPSAodCwgcHJpdmF0ZUtleSkgPT4ge1xuICBjb25zdCB0YWdzID0gW1tcImVcIiwgdC5jaGFubmVsX2NyZWF0ZV9ldmVudF9pZCwgdC5yZWxheV91cmwsIFwicm9vdFwiXV07XG4gIGlmICh0LnJlcGx5X3RvX2NoYW5uZWxfbWVzc2FnZV9ldmVudF9pZCkge1xuICAgIHRhZ3MucHVzaChbXCJlXCIsIHQucmVwbHlfdG9fY2hhbm5lbF9tZXNzYWdlX2V2ZW50X2lkLCB0LnJlbGF5X3VybCwgXCJyZXBseVwiXSk7XG4gIH1cbiAgcmV0dXJuIGZpbmFsaXplRXZlbnQoXG4gICAge1xuICAgICAga2luZDogQ2hhbm5lbE1lc3NhZ2UsXG4gICAgICB0YWdzOiBbLi4udGFncywgLi4udC50YWdzID8/IFtdXSxcbiAgICAgIGNvbnRlbnQ6IHQuY29udGVudCxcbiAgICAgIGNyZWF0ZWRfYXQ6IHQuY3JlYXRlZF9hdFxuICAgIH0sXG4gICAgcHJpdmF0ZUtleVxuICApO1xufTtcbnZhciBjaGFubmVsSGlkZU1lc3NhZ2VFdmVudCA9ICh0LCBwcml2YXRlS2V5KSA9PiB7XG4gIGxldCBjb250ZW50O1xuICBpZiAodHlwZW9mIHQuY29udGVudCA9PT0gXCJvYmplY3RcIikge1xuICAgIGNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeSh0LmNvbnRlbnQpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0LmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb250ZW50ID0gdC5jb250ZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIGZpbmFsaXplRXZlbnQoXG4gICAge1xuICAgICAga2luZDogQ2hhbm5lbEhpZGVNZXNzYWdlLFxuICAgICAgdGFnczogW1tcImVcIiwgdC5jaGFubmVsX21lc3NhZ2VfZXZlbnRfaWRdLCAuLi50LnRhZ3MgPz8gW11dLFxuICAgICAgY29udGVudCxcbiAgICAgIGNyZWF0ZWRfYXQ6IHQuY3JlYXRlZF9hdFxuICAgIH0sXG4gICAgcHJpdmF0ZUtleVxuICApO1xufTtcbnZhciBjaGFubmVsTXV0ZVVzZXJFdmVudCA9ICh0LCBwcml2YXRlS2V5KSA9PiB7XG4gIGxldCBjb250ZW50O1xuICBpZiAodHlwZW9mIHQuY29udGVudCA9PT0gXCJvYmplY3RcIikge1xuICAgIGNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeSh0LmNvbnRlbnQpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0LmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb250ZW50ID0gdC5jb250ZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIGZpbmFsaXplRXZlbnQoXG4gICAge1xuICAgICAga2luZDogQ2hhbm5lbE11dGVVc2VyLFxuICAgICAgdGFnczogW1tcInBcIiwgdC5wdWJrZXlfdG9fbXV0ZV0sIC4uLnQudGFncyA/PyBbXV0sXG4gICAgICBjb250ZW50LFxuICAgICAgY3JlYXRlZF9hdDogdC5jcmVhdGVkX2F0XG4gICAgfSxcbiAgICBwcml2YXRlS2V5XG4gICk7XG59O1xuXG4vLyBuaXAzMC50c1xudmFyIG5pcDMwX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDMwX2V4cG9ydHMsIHtcbiAgRU1PSklfU0hPUlRDT0RFX1JFR0VYOiAoKSA9PiBFTU9KSV9TSE9SVENPREVfUkVHRVgsXG4gIG1hdGNoQWxsOiAoKSA9PiBtYXRjaEFsbDIsXG4gIHJlZ2V4OiAoKSA9PiByZWdleDIsXG4gIHJlcGxhY2VBbGw6ICgpID0+IHJlcGxhY2VBbGwyXG59KTtcbnZhciBFTU9KSV9TSE9SVENPREVfUkVHRVggPSAvOihcXHcrKTovO1xudmFyIHJlZ2V4MiA9ICgpID0+IG5ldyBSZWdFeHAoYFxcXFxCJHtFTU9KSV9TSE9SVENPREVfUkVHRVguc291cmNlfVxcXFxCYCwgXCJnXCIpO1xuZnVuY3Rpb24qIG1hdGNoQWxsMihjb250ZW50KSB7XG4gIGNvbnN0IG1hdGNoZXMgPSBjb250ZW50Lm1hdGNoQWxsKHJlZ2V4MigpKTtcbiAgZm9yIChjb25zdCBtYXRjaCBvZiBtYXRjaGVzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IFtzaG9ydGNvZGUsIG5hbWVdID0gbWF0Y2g7XG4gICAgICB5aWVsZCB7XG4gICAgICAgIHNob3J0Y29kZSxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgc3RhcnQ6IG1hdGNoLmluZGV4LFxuICAgICAgICBlbmQ6IG1hdGNoLmluZGV4ICsgc2hvcnRjb2RlLmxlbmd0aFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChfZSkge1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVwbGFjZUFsbDIoY29udGVudCwgcmVwbGFjZXIpIHtcbiAgcmV0dXJuIGNvbnRlbnQucmVwbGFjZUFsbChyZWdleDIoKSwgKHNob3J0Y29kZSwgbmFtZSkgPT4ge1xuICAgIHJldHVybiByZXBsYWNlcih7XG4gICAgICBzaG9ydGNvZGUsXG4gICAgICBuYW1lXG4gICAgfSk7XG4gIH0pO1xufVxuXG4vLyBuaXAzOS50c1xudmFyIG5pcDM5X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDM5X2V4cG9ydHMsIHtcbiAgdXNlRmV0Y2hJbXBsZW1lbnRhdGlvbjogKCkgPT4gdXNlRmV0Y2hJbXBsZW1lbnRhdGlvbjMsXG4gIHZhbGlkYXRlR2l0aHViOiAoKSA9PiB2YWxpZGF0ZUdpdGh1YlxufSk7XG52YXIgX2ZldGNoMztcbnRyeSB7XG4gIF9mZXRjaDMgPSBmZXRjaDtcbn0gY2F0Y2gge1xufVxuZnVuY3Rpb24gdXNlRmV0Y2hJbXBsZW1lbnRhdGlvbjMoZmV0Y2hJbXBsZW1lbnRhdGlvbikge1xuICBfZmV0Y2gzID0gZmV0Y2hJbXBsZW1lbnRhdGlvbjtcbn1cbmFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlR2l0aHViKHB1YmtleSwgdXNlcm5hbWUsIHByb29mKSB7XG4gIHRyeSB7XG4gICAgbGV0IHJlcyA9IGF3YWl0IChhd2FpdCBfZmV0Y2gzKGBodHRwczovL2dpc3QuZ2l0aHViLmNvbS8ke3VzZXJuYW1lfS8ke3Byb29mfS9yYXdgKSkudGV4dCgpO1xuICAgIHJldHVybiByZXMgPT09IGBWZXJpZnlpbmcgdGhhdCBJIGNvbnRyb2wgdGhlIGZvbGxvd2luZyBOb3N0ciBwdWJsaWMga2V5OiAke3B1YmtleX1gO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8vIG5pcDQ0LnRzXG52YXIgbmlwNDRfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwNDRfZXhwb3J0cywge1xuICBkZWZhdWx0OiAoKSA9PiBuaXA0NF9kZWZhdWx0LFxuICB2MjogKCkgPT4gdjJcbn0pO1xuaW1wb3J0IHsgY2hhY2hhMjAgfSBmcm9tIFwiQG5vYmxlL2NpcGhlcnMvY2hhY2hhXCI7XG5pbXBvcnQgeyBlcXVhbEJ5dGVzIH0gZnJvbSBcIkBub2JsZS9jaXBoZXJzL3V0aWxzXCI7XG5pbXBvcnQgeyBzZWNwMjU2azEgYXMgc2VjcDI1NmsxMiB9IGZyb20gXCJAbm9ibGUvY3VydmVzL3NlY3AyNTZrMVwiO1xuaW1wb3J0IHsgZXh0cmFjdCBhcyBoa2RmX2V4dHJhY3QsIGV4cGFuZCBhcyBoa2RmX2V4cGFuZCB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL2hrZGZcIjtcbmltcG9ydCB7IGhtYWMgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9obWFjXCI7XG5pbXBvcnQgeyBzaGEyNTYgYXMgc2hhMjU2MiB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3NoYTI1NlwiO1xuaW1wb3J0IHsgY29uY2F0Qnl0ZXMgYXMgY29uY2F0Qnl0ZXMyLCByYW5kb21CeXRlcyBhcyByYW5kb21CeXRlczIsIHV0ZjhUb0J5dGVzIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvdXRpbHNcIjtcbmltcG9ydCB7IGJhc2U2NCBhcyBiYXNlNjQyIH0gZnJvbSBcIkBzY3VyZS9iYXNlXCI7XG52YXIgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xudmFyIHUgPSB7XG4gIG1pblBsYWludGV4dFNpemU6IDEsXG4gIG1heFBsYWludGV4dFNpemU6IDY1NTM1LFxuICB1dGY4RW5jb2RlOiB1dGY4VG9CeXRlcyxcbiAgdXRmOERlY29kZShieXRlcykge1xuICAgIHJldHVybiBkZWNvZGVyLmRlY29kZShieXRlcyk7XG4gIH0sXG4gIGdldENvbnZlcnNhdGlvbktleShwcml2a2V5QSwgcHVia2V5Qikge1xuICAgIGNvbnN0IHNoYXJlZFggPSBzZWNwMjU2azEyLmdldFNoYXJlZFNlY3JldChwcml2a2V5QSwgXCIwMlwiICsgcHVia2V5Qikuc3ViYXJyYXkoMSwgMzMpO1xuICAgIHJldHVybiBoa2RmX2V4dHJhY3Qoc2hhMjU2Miwgc2hhcmVkWCwgXCJuaXA0NC12MlwiKTtcbiAgfSxcbiAgZ2V0TWVzc2FnZUtleXMoY29udmVyc2F0aW9uS2V5LCBub25jZSkge1xuICAgIGNvbnN0IGtleXMgPSBoa2RmX2V4cGFuZChzaGEyNTYyLCBjb252ZXJzYXRpb25LZXksIG5vbmNlLCA3Nik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNoYWNoYV9rZXk6IGtleXMuc3ViYXJyYXkoMCwgMzIpLFxuICAgICAgY2hhY2hhX25vbmNlOiBrZXlzLnN1YmFycmF5KDMyLCA0NCksXG4gICAgICBobWFjX2tleToga2V5cy5zdWJhcnJheSg0NCwgNzYpXG4gICAgfTtcbiAgfSxcbiAgY2FsY1BhZGRlZExlbihsZW4pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGxlbikgfHwgbGVuIDwgMSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImV4cGVjdGVkIHBvc2l0aXZlIGludGVnZXJcIik7XG4gICAgaWYgKGxlbiA8PSAzMilcbiAgICAgIHJldHVybiAzMjtcbiAgICBjb25zdCBuZXh0UG93ZXIgPSAxIDw8IE1hdGguZmxvb3IoTWF0aC5sb2cyKGxlbiAtIDEpKSArIDE7XG4gICAgY29uc3QgY2h1bmsgPSBuZXh0UG93ZXIgPD0gMjU2ID8gMzIgOiBuZXh0UG93ZXIgLyA4O1xuICAgIHJldHVybiBjaHVuayAqIChNYXRoLmZsb29yKChsZW4gLSAxKSAvIGNodW5rKSArIDEpO1xuICB9LFxuICB3cml0ZVUxNkJFKG51bSkge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobnVtKSB8fCBudW0gPCB1Lm1pblBsYWludGV4dFNpemUgfHwgbnVtID4gdS5tYXhQbGFpbnRleHRTaXplKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwbGFpbnRleHQgc2l6ZTogbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDY1NTM1IGJ5dGVzXCIpO1xuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KDIpO1xuICAgIG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyKS5zZXRVaW50MTYoMCwgbnVtLCBmYWxzZSk7XG4gICAgcmV0dXJuIGFycjtcbiAgfSxcbiAgcGFkKHBsYWludGV4dCkge1xuICAgIGNvbnN0IHVucGFkZGVkID0gdS51dGY4RW5jb2RlKHBsYWludGV4dCk7XG4gICAgY29uc3QgdW5wYWRkZWRMZW4gPSB1bnBhZGRlZC5sZW5ndGg7XG4gICAgY29uc3QgcHJlZml4ID0gdS53cml0ZVUxNkJFKHVucGFkZGVkTGVuKTtcbiAgICBjb25zdCBzdWZmaXggPSBuZXcgVWludDhBcnJheSh1LmNhbGNQYWRkZWRMZW4odW5wYWRkZWRMZW4pIC0gdW5wYWRkZWRMZW4pO1xuICAgIHJldHVybiBjb25jYXRCeXRlczIocHJlZml4LCB1bnBhZGRlZCwgc3VmZml4KTtcbiAgfSxcbiAgdW5wYWQocGFkZGVkKSB7XG4gICAgY29uc3QgdW5wYWRkZWRMZW4gPSBuZXcgRGF0YVZpZXcocGFkZGVkLmJ1ZmZlcikuZ2V0VWludDE2KDApO1xuICAgIGNvbnN0IHVucGFkZGVkID0gcGFkZGVkLnN1YmFycmF5KDIsIDIgKyB1bnBhZGRlZExlbik7XG4gICAgaWYgKHVucGFkZGVkTGVuIDwgdS5taW5QbGFpbnRleHRTaXplIHx8IHVucGFkZGVkTGVuID4gdS5tYXhQbGFpbnRleHRTaXplIHx8IHVucGFkZGVkLmxlbmd0aCAhPT0gdW5wYWRkZWRMZW4gfHwgcGFkZGVkLmxlbmd0aCAhPT0gMiArIHUuY2FsY1BhZGRlZExlbih1bnBhZGRlZExlbikpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBhZGRpbmdcIik7XG4gICAgcmV0dXJuIHUudXRmOERlY29kZSh1bnBhZGRlZCk7XG4gIH0sXG4gIGhtYWNBYWQoa2V5LCBtZXNzYWdlLCBhYWQpIHtcbiAgICBpZiAoYWFkLmxlbmd0aCAhPT0gMzIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBQUQgYXNzb2NpYXRlZCBkYXRhIG11c3QgYmUgMzIgYnl0ZXNcIik7XG4gICAgY29uc3QgY29tYmluZWQgPSBjb25jYXRCeXRlczIoYWFkLCBtZXNzYWdlKTtcbiAgICByZXR1cm4gaG1hYyhzaGEyNTYyLCBrZXksIGNvbWJpbmVkKTtcbiAgfSxcbiAgZGVjb2RlUGF5bG9hZChwYXlsb2FkKSB7XG4gICAgaWYgKHR5cGVvZiBwYXlsb2FkICE9PSBcInN0cmluZ1wiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicGF5bG9hZCBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nXCIpO1xuICAgIGNvbnN0IHBsZW4gPSBwYXlsb2FkLmxlbmd0aDtcbiAgICBpZiAocGxlbiA8IDEzMiB8fCBwbGVuID4gODc0NzIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBheWxvYWQgbGVuZ3RoOiBcIiArIHBsZW4pO1xuICAgIGlmIChwYXlsb2FkWzBdID09PSBcIiNcIilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gZW5jcnlwdGlvbiB2ZXJzaW9uXCIpO1xuICAgIGxldCBkYXRhO1xuICAgIHRyeSB7XG4gICAgICBkYXRhID0gYmFzZTY0Mi5kZWNvZGUocGF5bG9hZCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYmFzZTY0OiBcIiArIGVycm9yLm1lc3NhZ2UpO1xuICAgIH1cbiAgICBjb25zdCBkbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgaWYgKGRsZW4gPCA5OSB8fCBkbGVuID4gNjU2MDMpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGRhdGEgbGVuZ3RoOiBcIiArIGRsZW4pO1xuICAgIGNvbnN0IHZlcnMgPSBkYXRhWzBdO1xuICAgIGlmICh2ZXJzICE9PSAyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biBlbmNyeXB0aW9uIHZlcnNpb24gXCIgKyB2ZXJzKTtcbiAgICByZXR1cm4ge1xuICAgICAgbm9uY2U6IGRhdGEuc3ViYXJyYXkoMSwgMzMpLFxuICAgICAgY2lwaGVydGV4dDogZGF0YS5zdWJhcnJheSgzMywgLTMyKSxcbiAgICAgIG1hYzogZGF0YS5zdWJhcnJheSgtMzIpXG4gICAgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIGVuY3J5cHQyKHBsYWludGV4dCwgY29udmVyc2F0aW9uS2V5LCBub25jZSA9IHJhbmRvbUJ5dGVzMigzMikpIHtcbiAgY29uc3QgeyBjaGFjaGFfa2V5LCBjaGFjaGFfbm9uY2UsIGhtYWNfa2V5IH0gPSB1LmdldE1lc3NhZ2VLZXlzKGNvbnZlcnNhdGlvbktleSwgbm9uY2UpO1xuICBjb25zdCBwYWRkZWQgPSB1LnBhZChwbGFpbnRleHQpO1xuICBjb25zdCBjaXBoZXJ0ZXh0ID0gY2hhY2hhMjAoY2hhY2hhX2tleSwgY2hhY2hhX25vbmNlLCBwYWRkZWQpO1xuICBjb25zdCBtYWMgPSB1LmhtYWNBYWQoaG1hY19rZXksIGNpcGhlcnRleHQsIG5vbmNlKTtcbiAgcmV0dXJuIGJhc2U2NDIuZW5jb2RlKGNvbmNhdEJ5dGVzMihuZXcgVWludDhBcnJheShbMl0pLCBub25jZSwgY2lwaGVydGV4dCwgbWFjKSk7XG59XG5mdW5jdGlvbiBkZWNyeXB0MihwYXlsb2FkLCBjb252ZXJzYXRpb25LZXkpIHtcbiAgY29uc3QgeyBub25jZSwgY2lwaGVydGV4dCwgbWFjIH0gPSB1LmRlY29kZVBheWxvYWQocGF5bG9hZCk7XG4gIGNvbnN0IHsgY2hhY2hhX2tleSwgY2hhY2hhX25vbmNlLCBobWFjX2tleSB9ID0gdS5nZXRNZXNzYWdlS2V5cyhjb252ZXJzYXRpb25LZXksIG5vbmNlKTtcbiAgY29uc3QgY2FsY3VsYXRlZE1hYyA9IHUuaG1hY0FhZChobWFjX2tleSwgY2lwaGVydGV4dCwgbm9uY2UpO1xuICBpZiAoIWVxdWFsQnl0ZXMoY2FsY3VsYXRlZE1hYywgbWFjKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIE1BQ1wiKTtcbiAgY29uc3QgcGFkZGVkID0gY2hhY2hhMjAoY2hhY2hhX2tleSwgY2hhY2hhX25vbmNlLCBjaXBoZXJ0ZXh0KTtcbiAgcmV0dXJuIHUudW5wYWQocGFkZGVkKTtcbn1cbnZhciB2MiA9IHtcbiAgdXRpbHM6IHUsXG4gIGVuY3J5cHQ6IGVuY3J5cHQyLFxuICBkZWNyeXB0OiBkZWNyeXB0MlxufTtcbnZhciBuaXA0NF9kZWZhdWx0ID0geyB2MiB9O1xuXG4vLyBuaXA0Ny50c1xudmFyIG5pcDQ3X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDQ3X2V4cG9ydHMsIHtcbiAgbWFrZU53Y1JlcXVlc3RFdmVudDogKCkgPT4gbWFrZU53Y1JlcXVlc3RFdmVudCxcbiAgcGFyc2VDb25uZWN0aW9uU3RyaW5nOiAoKSA9PiBwYXJzZUNvbm5lY3Rpb25TdHJpbmdcbn0pO1xuZnVuY3Rpb24gcGFyc2VDb25uZWN0aW9uU3RyaW5nKGNvbm5lY3Rpb25TdHJpbmcpIHtcbiAgY29uc3QgeyBwYXRobmFtZSwgc2VhcmNoUGFyYW1zIH0gPSBuZXcgVVJMKGNvbm5lY3Rpb25TdHJpbmcpO1xuICBjb25zdCBwdWJrZXkgPSBwYXRobmFtZTtcbiAgY29uc3QgcmVsYXkgPSBzZWFyY2hQYXJhbXMuZ2V0KFwicmVsYXlcIik7XG4gIGNvbnN0IHNlY3JldCA9IHNlYXJjaFBhcmFtcy5nZXQoXCJzZWNyZXRcIik7XG4gIGlmICghcHVia2V5IHx8ICFyZWxheSB8fCAhc2VjcmV0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBjb25uZWN0aW9uIHN0cmluZ1wiKTtcbiAgfVxuICByZXR1cm4geyBwdWJrZXksIHJlbGF5LCBzZWNyZXQgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIG1ha2VOd2NSZXF1ZXN0RXZlbnQocHVia2V5LCBzZWNyZXRLZXksIGludm9pY2UpIHtcbiAgY29uc3QgY29udGVudCA9IHtcbiAgICBtZXRob2Q6IFwicGF5X2ludm9pY2VcIixcbiAgICBwYXJhbXM6IHtcbiAgICAgIGludm9pY2VcbiAgICB9XG4gIH07XG4gIGNvbnN0IGVuY3J5cHRlZENvbnRlbnQgPSBhd2FpdCBlbmNyeXB0KHNlY3JldEtleSwgcHVia2V5LCBKU09OLnN0cmluZ2lmeShjb250ZW50KSk7XG4gIGNvbnN0IGV2ZW50VGVtcGxhdGUgPSB7XG4gICAga2luZDogTldDV2FsbGV0UmVxdWVzdCxcbiAgICBjcmVhdGVkX2F0OiBNYXRoLnJvdW5kKERhdGUubm93KCkgLyAxZTMpLFxuICAgIGNvbnRlbnQ6IGVuY3J5cHRlZENvbnRlbnQsXG4gICAgdGFnczogW1tcInBcIiwgcHVia2V5XV1cbiAgfTtcbiAgcmV0dXJuIGZpbmFsaXplRXZlbnQoZXZlbnRUZW1wbGF0ZSwgc2VjcmV0S2V5KTtcbn1cblxuLy8gbmlwNTcudHNcbnZhciBuaXA1N19leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXA1N19leHBvcnRzLCB7XG4gIGdldFphcEVuZHBvaW50OiAoKSA9PiBnZXRaYXBFbmRwb2ludCxcbiAgbWFrZVphcFJlY2VpcHQ6ICgpID0+IG1ha2VaYXBSZWNlaXB0LFxuICBtYWtlWmFwUmVxdWVzdDogKCkgPT4gbWFrZVphcFJlcXVlc3QsXG4gIHVzZUZldGNoSW1wbGVtZW50YXRpb246ICgpID0+IHVzZUZldGNoSW1wbGVtZW50YXRpb240LFxuICB2YWxpZGF0ZVphcFJlcXVlc3Q6ICgpID0+IHZhbGlkYXRlWmFwUmVxdWVzdFxufSk7XG5pbXBvcnQgeyBiZWNoMzIgYXMgYmVjaDMyMiB9IGZyb20gXCJAc2N1cmUvYmFzZVwiO1xudmFyIF9mZXRjaDQ7XG50cnkge1xuICBfZmV0Y2g0ID0gZmV0Y2g7XG59IGNhdGNoIHtcbn1cbmZ1bmN0aW9uIHVzZUZldGNoSW1wbGVtZW50YXRpb240KGZldGNoSW1wbGVtZW50YXRpb24pIHtcbiAgX2ZldGNoNCA9IGZldGNoSW1wbGVtZW50YXRpb247XG59XG5hc3luYyBmdW5jdGlvbiBnZXRaYXBFbmRwb2ludChtZXRhZGF0YSkge1xuICB0cnkge1xuICAgIGxldCBsbnVybCA9IFwiXCI7XG4gICAgbGV0IHsgbHVkMDYsIGx1ZDE2IH0gPSBKU09OLnBhcnNlKG1ldGFkYXRhLmNvbnRlbnQpO1xuICAgIGlmIChsdWQwNikge1xuICAgICAgbGV0IHsgd29yZHMgfSA9IGJlY2gzMjIuZGVjb2RlKGx1ZDA2LCAxZTMpO1xuICAgICAgbGV0IGRhdGEgPSBiZWNoMzIyLmZyb21Xb3Jkcyh3b3Jkcyk7XG4gICAgICBsbnVybCA9IHV0ZjhEZWNvZGVyLmRlY29kZShkYXRhKTtcbiAgICB9IGVsc2UgaWYgKGx1ZDE2KSB7XG4gICAgICBsZXQgW25hbWUsIGRvbWFpbl0gPSBsdWQxNi5zcGxpdChcIkBcIik7XG4gICAgICBsbnVybCA9IG5ldyBVUkwoYC8ud2VsbC1rbm93bi9sbnVybHAvJHtuYW1lfWAsIGBodHRwczovLyR7ZG9tYWlufWApLnRvU3RyaW5nKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgcmVzID0gYXdhaXQgX2ZldGNoNChsbnVybCk7XG4gICAgbGV0IGJvZHkgPSBhd2FpdCByZXMuanNvbigpO1xuICAgIGlmIChib2R5LmFsbG93c05vc3RyICYmIGJvZHkubm9zdHJQdWJrZXkpIHtcbiAgICAgIHJldHVybiBib2R5LmNhbGxiYWNrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBtYWtlWmFwUmVxdWVzdCh7XG4gIHByb2ZpbGUsXG4gIGV2ZW50LFxuICBhbW91bnQsXG4gIHJlbGF5cyxcbiAgY29tbWVudCA9IFwiXCJcbn0pIHtcbiAgaWYgKCFhbW91bnQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYW1vdW50IG5vdCBnaXZlblwiKTtcbiAgaWYgKCFwcm9maWxlKVxuICAgIHRocm93IG5ldyBFcnJvcihcInByb2ZpbGUgbm90IGdpdmVuXCIpO1xuICBsZXQgenIgPSB7XG4gICAga2luZDogOTczNCxcbiAgICBjcmVhdGVkX2F0OiBNYXRoLnJvdW5kKERhdGUubm93KCkgLyAxZTMpLFxuICAgIGNvbnRlbnQ6IGNvbW1lbnQsXG4gICAgdGFnczogW1xuICAgICAgW1wicFwiLCBwcm9maWxlXSxcbiAgICAgIFtcImFtb3VudFwiLCBhbW91bnQudG9TdHJpbmcoKV0sXG4gICAgICBbXCJyZWxheXNcIiwgLi4ucmVsYXlzXVxuICAgIF1cbiAgfTtcbiAgaWYgKGV2ZW50KSB7XG4gICAgenIudGFncy5wdXNoKFtcImVcIiwgZXZlbnRdKTtcbiAgfVxuICByZXR1cm4genI7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVphcFJlcXVlc3QoemFwUmVxdWVzdFN0cmluZykge1xuICBsZXQgemFwUmVxdWVzdDtcbiAgdHJ5IHtcbiAgICB6YXBSZXF1ZXN0ID0gSlNPTi5wYXJzZSh6YXBSZXF1ZXN0U3RyaW5nKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFwiSW52YWxpZCB6YXAgcmVxdWVzdCBKU09OLlwiO1xuICB9XG4gIGlmICghdmFsaWRhdGVFdmVudCh6YXBSZXF1ZXN0KSlcbiAgICByZXR1cm4gXCJaYXAgcmVxdWVzdCBpcyBub3QgYSB2YWxpZCBOb3N0ciBldmVudC5cIjtcbiAgaWYgKCF2ZXJpZnlFdmVudCh6YXBSZXF1ZXN0KSlcbiAgICByZXR1cm4gXCJJbnZhbGlkIHNpZ25hdHVyZSBvbiB6YXAgcmVxdWVzdC5cIjtcbiAgbGV0IHAgPSB6YXBSZXF1ZXN0LnRhZ3MuZmluZCgoW3QsIHZdKSA9PiB0ID09PSBcInBcIiAmJiB2KTtcbiAgaWYgKCFwKVxuICAgIHJldHVybiBcIlphcCByZXF1ZXN0IGRvZXNuJ3QgaGF2ZSBhICdwJyB0YWcuXCI7XG4gIGlmICghcFsxXS5tYXRjaCgvXlthLWYwLTldezY0fSQvKSlcbiAgICByZXR1cm4gXCJaYXAgcmVxdWVzdCAncCcgdGFnIGlzIG5vdCB2YWxpZCBoZXguXCI7XG4gIGxldCBlID0gemFwUmVxdWVzdC50YWdzLmZpbmQoKFt0LCB2XSkgPT4gdCA9PT0gXCJlXCIgJiYgdik7XG4gIGlmIChlICYmICFlWzFdLm1hdGNoKC9eW2EtZjAtOV17NjR9JC8pKVxuICAgIHJldHVybiBcIlphcCByZXF1ZXN0ICdlJyB0YWcgaXMgbm90IHZhbGlkIGhleC5cIjtcbiAgbGV0IHJlbGF5cyA9IHphcFJlcXVlc3QudGFncy5maW5kKChbdCwgdl0pID0+IHQgPT09IFwicmVsYXlzXCIgJiYgdik7XG4gIGlmICghcmVsYXlzKVxuICAgIHJldHVybiBcIlphcCByZXF1ZXN0IGRvZXNuJ3QgaGF2ZSBhICdyZWxheXMnIHRhZy5cIjtcbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBtYWtlWmFwUmVjZWlwdCh7XG4gIHphcFJlcXVlc3QsXG4gIHByZWltYWdlLFxuICBib2x0MTEsXG4gIHBhaWRBdFxufSkge1xuICBsZXQgenIgPSBKU09OLnBhcnNlKHphcFJlcXVlc3QpO1xuICBsZXQgdGFnc0Zyb21aYXBSZXF1ZXN0ID0genIudGFncy5maWx0ZXIoKFt0XSkgPT4gdCA9PT0gXCJlXCIgfHwgdCA9PT0gXCJwXCIgfHwgdCA9PT0gXCJhXCIpO1xuICBsZXQgemFwID0ge1xuICAgIGtpbmQ6IDk3MzUsXG4gICAgY3JlYXRlZF9hdDogTWF0aC5yb3VuZChwYWlkQXQuZ2V0VGltZSgpIC8gMWUzKSxcbiAgICBjb250ZW50OiBcIlwiLFxuICAgIHRhZ3M6IFsuLi50YWdzRnJvbVphcFJlcXVlc3QsIFtcIlBcIiwgenIucHVia2V5XSwgW1wiYm9sdDExXCIsIGJvbHQxMV0sIFtcImRlc2NyaXB0aW9uXCIsIHphcFJlcXVlc3RdXVxuICB9O1xuICBpZiAocHJlaW1hZ2UpIHtcbiAgICB6YXAudGFncy5wdXNoKFtcInByZWltYWdlXCIsIHByZWltYWdlXSk7XG4gIH1cbiAgcmV0dXJuIHphcDtcbn1cblxuLy8gbmlwOTgudHNcbnZhciBuaXA5OF9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXA5OF9leHBvcnRzLCB7XG4gIGdldFRva2VuOiAoKSA9PiBnZXRUb2tlbixcbiAgaGFzaFBheWxvYWQ6ICgpID0+IGhhc2hQYXlsb2FkLFxuICB1bnBhY2tFdmVudEZyb21Ub2tlbjogKCkgPT4gdW5wYWNrRXZlbnRGcm9tVG9rZW4sXG4gIHZhbGlkYXRlRXZlbnQ6ICgpID0+IHZhbGlkYXRlRXZlbnQyLFxuICB2YWxpZGF0ZUV2ZW50S2luZDogKCkgPT4gdmFsaWRhdGVFdmVudEtpbmQsXG4gIHZhbGlkYXRlRXZlbnRNZXRob2RUYWc6ICgpID0+IHZhbGlkYXRlRXZlbnRNZXRob2RUYWcsXG4gIHZhbGlkYXRlRXZlbnRQYXlsb2FkVGFnOiAoKSA9PiB2YWxpZGF0ZUV2ZW50UGF5bG9hZFRhZyxcbiAgdmFsaWRhdGVFdmVudFRpbWVzdGFtcDogKCkgPT4gdmFsaWRhdGVFdmVudFRpbWVzdGFtcCxcbiAgdmFsaWRhdGVFdmVudFVybFRhZzogKCkgPT4gdmFsaWRhdGVFdmVudFVybFRhZyxcbiAgdmFsaWRhdGVUb2tlbjogKCkgPT4gdmFsaWRhdGVUb2tlblxufSk7XG5pbXBvcnQgeyBzaGEyNTYgYXMgc2hhMjU2MyB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3NoYTI1NlwiO1xuaW1wb3J0IHsgYnl0ZXNUb0hleCBhcyBieXRlc1RvSGV4NCB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCI7XG5pbXBvcnQgeyBiYXNlNjQgYXMgYmFzZTY0MyB9IGZyb20gXCJAc2N1cmUvYmFzZVwiO1xudmFyIF9hdXRob3JpemF0aW9uU2NoZW1lID0gXCJOb3N0ciBcIjtcbmFzeW5jIGZ1bmN0aW9uIGdldFRva2VuKGxvZ2luVXJsLCBodHRwTWV0aG9kLCBzaWduLCBpbmNsdWRlQXV0aG9yaXphdGlvblNjaGVtZSA9IGZhbHNlLCBwYXlsb2FkKSB7XG4gIGNvbnN0IGV2ZW50ID0ge1xuICAgIGtpbmQ6IEhUVFBBdXRoLFxuICAgIHRhZ3M6IFtcbiAgICAgIFtcInVcIiwgbG9naW5VcmxdLFxuICAgICAgW1wibWV0aG9kXCIsIGh0dHBNZXRob2RdXG4gICAgXSxcbiAgICBjcmVhdGVkX2F0OiBNYXRoLnJvdW5kKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMWUzKSxcbiAgICBjb250ZW50OiBcIlwiXG4gIH07XG4gIGlmIChwYXlsb2FkKSB7XG4gICAgZXZlbnQudGFncy5wdXNoKFtcInBheWxvYWRcIiwgaGFzaFBheWxvYWQocGF5bG9hZCldKTtcbiAgfVxuICBjb25zdCBzaWduZWRFdmVudCA9IGF3YWl0IHNpZ24oZXZlbnQpO1xuICBjb25zdCBhdXRob3JpemF0aW9uU2NoZW1lID0gaW5jbHVkZUF1dGhvcml6YXRpb25TY2hlbWUgPyBfYXV0aG9yaXphdGlvblNjaGVtZSA6IFwiXCI7XG4gIHJldHVybiBhdXRob3JpemF0aW9uU2NoZW1lICsgYmFzZTY0My5lbmNvZGUodXRmOEVuY29kZXIuZW5jb2RlKEpTT04uc3RyaW5naWZ5KHNpZ25lZEV2ZW50KSkpO1xufVxuYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVUb2tlbih0b2tlbiwgdXJsLCBtZXRob2QpIHtcbiAgY29uc3QgZXZlbnQgPSBhd2FpdCB1bnBhY2tFdmVudEZyb21Ub2tlbih0b2tlbikuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH0pO1xuICBjb25zdCB2YWxpZCA9IGF3YWl0IHZhbGlkYXRlRXZlbnQyKGV2ZW50LCB1cmwsIG1ldGhvZCkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH0pO1xuICByZXR1cm4gdmFsaWQ7XG59XG5hc3luYyBmdW5jdGlvbiB1bnBhY2tFdmVudEZyb21Ub2tlbih0b2tlbikge1xuICBpZiAoIXRva2VuKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB0b2tlblwiKTtcbiAgfVxuICB0b2tlbiA9IHRva2VuLnJlcGxhY2UoX2F1dGhvcml6YXRpb25TY2hlbWUsIFwiXCIpO1xuICBjb25zdCBldmVudEI2NCA9IHV0ZjhEZWNvZGVyLmRlY29kZShiYXNlNjQzLmRlY29kZSh0b2tlbikpO1xuICBpZiAoIWV2ZW50QjY0IHx8IGV2ZW50QjY0Lmxlbmd0aCA9PT0gMCB8fCAhZXZlbnRCNjQuc3RhcnRzV2l0aChcIntcIikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHRva2VuXCIpO1xuICB9XG4gIGNvbnN0IGV2ZW50ID0gSlNPTi5wYXJzZShldmVudEI2NCk7XG4gIHJldHVybiBldmVudDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlRXZlbnRUaW1lc3RhbXAoZXZlbnQpIHtcbiAgaWYgKCFldmVudC5jcmVhdGVkX2F0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBNYXRoLnJvdW5kKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMWUzKSAtIGV2ZW50LmNyZWF0ZWRfYXQgPCA2MDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlRXZlbnRLaW5kKGV2ZW50KSB7XG4gIHJldHVybiBldmVudC5raW5kID09PSBIVFRQQXV0aDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlRXZlbnRVcmxUYWcoZXZlbnQsIHVybCkge1xuICBjb25zdCB1cmxUYWcgPSBldmVudC50YWdzLmZpbmQoKHQpID0+IHRbMF0gPT09IFwidVwiKTtcbiAgaWYgKCF1cmxUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHVybFRhZy5sZW5ndGggPiAwICYmIHVybFRhZ1sxXSA9PT0gdXJsO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVFdmVudE1ldGhvZFRhZyhldmVudCwgbWV0aG9kKSB7XG4gIGNvbnN0IG1ldGhvZFRhZyA9IGV2ZW50LnRhZ3MuZmluZCgodCkgPT4gdFswXSA9PT0gXCJtZXRob2RcIik7XG4gIGlmICghbWV0aG9kVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBtZXRob2RUYWcubGVuZ3RoID4gMCAmJiBtZXRob2RUYWdbMV0udG9Mb3dlckNhc2UoKSA9PT0gbWV0aG9kLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBoYXNoUGF5bG9hZChwYXlsb2FkKSB7XG4gIGNvbnN0IGhhc2ggPSBzaGEyNTYzKHV0ZjhFbmNvZGVyLmVuY29kZShKU09OLnN0cmluZ2lmeShwYXlsb2FkKSkpO1xuICByZXR1cm4gYnl0ZXNUb0hleDQoaGFzaCk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUV2ZW50UGF5bG9hZFRhZyhldmVudCwgcGF5bG9hZCkge1xuICBjb25zdCBwYXlsb2FkVGFnID0gZXZlbnQudGFncy5maW5kKCh0KSA9PiB0WzBdID09PSBcInBheWxvYWRcIik7XG4gIGlmICghcGF5bG9hZFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBwYXlsb2FkSGFzaCA9IGhhc2hQYXlsb2FkKHBheWxvYWQpO1xuICByZXR1cm4gcGF5bG9hZFRhZy5sZW5ndGggPiAwICYmIHBheWxvYWRUYWdbMV0gPT09IHBheWxvYWRIYXNoO1xufVxuYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVFdmVudDIoZXZlbnQsIHVybCwgbWV0aG9kLCBib2R5KSB7XG4gIGlmICghdmVyaWZ5RXZlbnQoZXZlbnQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBub3N0ciBldmVudCwgc2lnbmF0dXJlIGludmFsaWRcIik7XG4gIH1cbiAgaWYgKCF2YWxpZGF0ZUV2ZW50S2luZChldmVudCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG5vc3RyIGV2ZW50LCBraW5kIGludmFsaWRcIik7XG4gIH1cbiAgaWYgKCF2YWxpZGF0ZUV2ZW50VGltZXN0YW1wKGV2ZW50KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbm9zdHIgZXZlbnQsIGNyZWF0ZWRfYXQgdGltZXN0YW1wIGludmFsaWRcIik7XG4gIH1cbiAgaWYgKCF2YWxpZGF0ZUV2ZW50VXJsVGFnKGV2ZW50LCB1cmwpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBub3N0ciBldmVudCwgdXJsIHRhZyBpbnZhbGlkXCIpO1xuICB9XG4gIGlmICghdmFsaWRhdGVFdmVudE1ldGhvZFRhZyhldmVudCwgbWV0aG9kKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbm9zdHIgZXZlbnQsIG1ldGhvZCB0YWcgaW52YWxpZFwiKTtcbiAgfVxuICBpZiAoQm9vbGVhbihib2R5KSAmJiB0eXBlb2YgYm9keSA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3Qua2V5cyhib2R5KS5sZW5ndGggPiAwKSB7XG4gICAgaWYgKCF2YWxpZGF0ZUV2ZW50UGF5bG9hZFRhZyhldmVudCwgYm9keSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbm9zdHIgZXZlbnQsIHBheWxvYWQgdGFnIGRvZXMgbm90IG1hdGNoIHJlcXVlc3QgYm9keSBoYXNoXCIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydCB7XG4gIEFic3RyYWN0UmVsYXksXG4gIEFic3RyYWN0U2ltcGxlUG9vbCxcbiAgUmVsYXksXG4gIFNpbXBsZVBvb2wsXG4gIFN1YnNjcmlwdGlvbixcbiAgZmluYWxpemVFdmVudCxcbiAgZmFrZWpzb25fZXhwb3J0cyBhcyBmaixcbiAgZ2VuZXJhdGVTZWNyZXRLZXksXG4gIGdldEV2ZW50SGFzaCxcbiAgZ2V0RmlsdGVyTGltaXQsXG4gIGdldFB1YmxpY0tleSxcbiAga2luZHNfZXhwb3J0cyBhcyBraW5kcyxcbiAgbWF0Y2hGaWx0ZXIsXG4gIG1hdGNoRmlsdGVycyxcbiAgbWVyZ2VGaWx0ZXJzLFxuICBuaXAwNF9leHBvcnRzIGFzIG5pcDA0LFxuICBuaXAwNV9leHBvcnRzIGFzIG5pcDA1LFxuICBuaXAxMF9leHBvcnRzIGFzIG5pcDEwLFxuICBuaXAxMV9leHBvcnRzIGFzIG5pcDExLFxuICBuaXAxM19leHBvcnRzIGFzIG5pcDEzLFxuICBuaXAxOF9leHBvcnRzIGFzIG5pcDE4LFxuICBuaXAxOV9leHBvcnRzIGFzIG5pcDE5LFxuICBuaXAyMV9leHBvcnRzIGFzIG5pcDIxLFxuICBuaXAyNV9leHBvcnRzIGFzIG5pcDI1LFxuICBuaXAyN19leHBvcnRzIGFzIG5pcDI3LFxuICBuaXAyOF9leHBvcnRzIGFzIG5pcDI4LFxuICBuaXAzMF9leHBvcnRzIGFzIG5pcDMwLFxuICBuaXAzOV9leHBvcnRzIGFzIG5pcDM5LFxuICBuaXA0Ml9leHBvcnRzIGFzIG5pcDQyLFxuICBuaXA0NF9leHBvcnRzIGFzIG5pcDQ0LFxuICBuaXA0N19leHBvcnRzIGFzIG5pcDQ3LFxuICBuaXA1N19leHBvcnRzIGFzIG5pcDU3LFxuICBuaXA5OF9leHBvcnRzIGFzIG5pcDk4LFxuICBwYXJzZVJlZmVyZW5jZXMsXG4gIHJlbGF5Q29ubmVjdCxcbiAgc2VyaWFsaXplRXZlbnQsXG4gIHVzZVdlYlNvY2tldEltcGxlbWVudGF0aW9uLFxuICB1dGlsc19leHBvcnRzIGFzIHV0aWxzLFxuICB2YWxpZGF0ZUV2ZW50LFxuICB2ZXJpZmllZFN5bWJvbCxcbiAgdmVyaWZ5RXZlbnRcbn07XG4iLCAiLy8gcHVyZS50c1xuaW1wb3J0IHsgc2Nobm9yciB9IGZyb20gXCJAbm9ibGUvY3VydmVzL3NlY3AyNTZrMVwiO1xuaW1wb3J0IHsgYnl0ZXNUb0hleCB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCI7XG5cbi8vIGNvcmUudHNcbnZhciB2ZXJpZmllZFN5bWJvbCA9IFN5bWJvbChcInZlcmlmaWVkXCIpO1xudmFyIGlzUmVjb3JkID0gKG9iaikgPT4gb2JqIGluc3RhbmNlb2YgT2JqZWN0O1xuZnVuY3Rpb24gdmFsaWRhdGVFdmVudChldmVudCkge1xuICBpZiAoIWlzUmVjb3JkKGV2ZW50KSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgZXZlbnQua2luZCAhPT0gXCJudW1iZXJcIilcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgZXZlbnQuY29udGVudCAhPT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgZXZlbnQuY3JlYXRlZF9hdCAhPT0gXCJudW1iZXJcIilcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgZXZlbnQucHVia2V5ICE9PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKCFldmVudC5wdWJrZXkubWF0Y2goL15bYS1mMC05XXs2NH0kLykpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZXZlbnQudGFncykpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgZXZlbnQudGFncy5sZW5ndGg7IGkyKyspIHtcbiAgICBsZXQgdGFnID0gZXZlbnQudGFnc1tpMl07XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHRhZykpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCB0YWcubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmICh0eXBlb2YgdGFnW2pdID09PSBcIm9iamVjdFwiKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBwdXJlLnRzXG5pbXBvcnQgeyBzaGEyNTYgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9zaGEyNTZcIjtcblxuLy8gdXRpbHMudHNcbnZhciB1dGY4RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcihcInV0Zi04XCIpO1xudmFyIHV0ZjhFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG5mdW5jdGlvbiBub3JtYWxpemVVUkwodXJsKSB7XG4gIGlmICh1cmwuaW5kZXhPZihcIjovL1wiKSA9PT0gLTEpXG4gICAgdXJsID0gXCJ3c3M6Ly9cIiArIHVybDtcbiAgbGV0IHAgPSBuZXcgVVJMKHVybCk7XG4gIHAucGF0aG5hbWUgPSBwLnBhdGhuYW1lLnJlcGxhY2UoL1xcLysvZywgXCIvXCIpO1xuICBpZiAocC5wYXRobmFtZS5lbmRzV2l0aChcIi9cIikpXG4gICAgcC5wYXRobmFtZSA9IHAucGF0aG5hbWUuc2xpY2UoMCwgLTEpO1xuICBpZiAocC5wb3J0ID09PSBcIjgwXCIgJiYgcC5wcm90b2NvbCA9PT0gXCJ3czpcIiB8fCBwLnBvcnQgPT09IFwiNDQzXCIgJiYgcC5wcm90b2NvbCA9PT0gXCJ3c3M6XCIpXG4gICAgcC5wb3J0ID0gXCJcIjtcbiAgcC5zZWFyY2hQYXJhbXMuc29ydCgpO1xuICBwLmhhc2ggPSBcIlwiO1xuICByZXR1cm4gcC50b1N0cmluZygpO1xufVxudmFyIFF1ZXVlTm9kZSA9IGNsYXNzIHtcbiAgdmFsdWU7XG4gIG5leHQgPSBudWxsO1xuICBwcmV2ID0gbnVsbDtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHRoaXMudmFsdWUgPSBtZXNzYWdlO1xuICB9XG59O1xudmFyIFF1ZXVlID0gY2xhc3Mge1xuICBmaXJzdDtcbiAgbGFzdDtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5maXJzdCA9IG51bGw7XG4gICAgdGhpcy5sYXN0ID0gbnVsbDtcbiAgfVxuICBlbnF1ZXVlKHZhbHVlKSB7XG4gICAgY29uc3QgbmV3Tm9kZSA9IG5ldyBRdWV1ZU5vZGUodmFsdWUpO1xuICAgIGlmICghdGhpcy5sYXN0KSB7XG4gICAgICB0aGlzLmZpcnN0ID0gbmV3Tm9kZTtcbiAgICAgIHRoaXMubGFzdCA9IG5ld05vZGU7XG4gICAgfSBlbHNlIGlmICh0aGlzLmxhc3QgPT09IHRoaXMuZmlyc3QpIHtcbiAgICAgIHRoaXMubGFzdCA9IG5ld05vZGU7XG4gICAgICB0aGlzLmxhc3QucHJldiA9IHRoaXMuZmlyc3Q7XG4gICAgICB0aGlzLmZpcnN0Lm5leHQgPSBuZXdOb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdOb2RlLnByZXYgPSB0aGlzLmxhc3Q7XG4gICAgICB0aGlzLmxhc3QubmV4dCA9IG5ld05vZGU7XG4gICAgICB0aGlzLmxhc3QgPSBuZXdOb2RlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBkZXF1ZXVlKCkge1xuICAgIGlmICghdGhpcy5maXJzdClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGlmICh0aGlzLmZpcnN0ID09PSB0aGlzLmxhc3QpIHtcbiAgICAgIGNvbnN0IHRhcmdldDIgPSB0aGlzLmZpcnN0O1xuICAgICAgdGhpcy5maXJzdCA9IG51bGw7XG4gICAgICB0aGlzLmxhc3QgPSBudWxsO1xuICAgICAgcmV0dXJuIHRhcmdldDIudmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuZmlyc3Q7XG4gICAgdGhpcy5maXJzdCA9IHRhcmdldC5uZXh0O1xuICAgIHJldHVybiB0YXJnZXQudmFsdWU7XG4gIH1cbn07XG5cbi8vIHB1cmUudHNcbnZhciBKUyA9IGNsYXNzIHtcbiAgZ2VuZXJhdGVTZWNyZXRLZXkoKSB7XG4gICAgcmV0dXJuIHNjaG5vcnIudXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpO1xuICB9XG4gIGdldFB1YmxpY0tleShzZWNyZXRLZXkpIHtcbiAgICByZXR1cm4gYnl0ZXNUb0hleChzY2hub3JyLmdldFB1YmxpY0tleShzZWNyZXRLZXkpKTtcbiAgfVxuICBmaW5hbGl6ZUV2ZW50KHQsIHNlY3JldEtleSkge1xuICAgIGNvbnN0IGV2ZW50ID0gdDtcbiAgICBldmVudC5wdWJrZXkgPSBieXRlc1RvSGV4KHNjaG5vcnIuZ2V0UHVibGljS2V5KHNlY3JldEtleSkpO1xuICAgIGV2ZW50LmlkID0gZ2V0RXZlbnRIYXNoKGV2ZW50KTtcbiAgICBldmVudC5zaWcgPSBieXRlc1RvSGV4KHNjaG5vcnIuc2lnbihnZXRFdmVudEhhc2goZXZlbnQpLCBzZWNyZXRLZXkpKTtcbiAgICBldmVudFt2ZXJpZmllZFN5bWJvbF0gPSB0cnVlO1xuICAgIHJldHVybiBldmVudDtcbiAgfVxuICB2ZXJpZnlFdmVudChldmVudCkge1xuICAgIGlmICh0eXBlb2YgZXZlbnRbdmVyaWZpZWRTeW1ib2xdID09PSBcImJvb2xlYW5cIilcbiAgICAgIHJldHVybiBldmVudFt2ZXJpZmllZFN5bWJvbF07XG4gICAgY29uc3QgaGFzaCA9IGdldEV2ZW50SGFzaChldmVudCk7XG4gICAgaWYgKGhhc2ggIT09IGV2ZW50LmlkKSB7XG4gICAgICBldmVudFt2ZXJpZmllZFN5bWJvbF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHZhbGlkID0gc2Nobm9yci52ZXJpZnkoZXZlbnQuc2lnLCBoYXNoLCBldmVudC5wdWJrZXkpO1xuICAgICAgZXZlbnRbdmVyaWZpZWRTeW1ib2xdID0gdmFsaWQ7XG4gICAgICByZXR1cm4gdmFsaWQ7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBldmVudFt2ZXJpZmllZFN5bWJvbF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBzZXJpYWxpemVFdmVudChldnQpIHtcbiAgaWYgKCF2YWxpZGF0ZUV2ZW50KGV2dCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY2FuJ3Qgc2VyaWFsaXplIGV2ZW50IHdpdGggd3Jvbmcgb3IgbWlzc2luZyBwcm9wZXJ0aWVzXCIpO1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoWzAsIGV2dC5wdWJrZXksIGV2dC5jcmVhdGVkX2F0LCBldnQua2luZCwgZXZ0LnRhZ3MsIGV2dC5jb250ZW50XSk7XG59XG5mdW5jdGlvbiBnZXRFdmVudEhhc2goZXZlbnQpIHtcbiAgbGV0IGV2ZW50SGFzaCA9IHNoYTI1Nih1dGY4RW5jb2Rlci5lbmNvZGUoc2VyaWFsaXplRXZlbnQoZXZlbnQpKSk7XG4gIHJldHVybiBieXRlc1RvSGV4KGV2ZW50SGFzaCk7XG59XG52YXIgaSA9IG5ldyBKUygpO1xudmFyIGdlbmVyYXRlU2VjcmV0S2V5ID0gaS5nZW5lcmF0ZVNlY3JldEtleTtcbnZhciBnZXRQdWJsaWNLZXkgPSBpLmdldFB1YmxpY0tleTtcbnZhciBmaW5hbGl6ZUV2ZW50ID0gaS5maW5hbGl6ZUV2ZW50O1xudmFyIHZlcmlmeUV2ZW50ID0gaS52ZXJpZnlFdmVudDtcblxuLy8ga2luZHMudHNcbnZhciBDbGllbnRBdXRoID0gMjIyNDI7XG5cbi8vIGZpbHRlci50c1xuZnVuY3Rpb24gbWF0Y2hGaWx0ZXIoZmlsdGVyLCBldmVudCkge1xuICBpZiAoZmlsdGVyLmlkcyAmJiBmaWx0ZXIuaWRzLmluZGV4T2YoZXZlbnQuaWQpID09PSAtMSkge1xuICAgIGlmICghZmlsdGVyLmlkcy5zb21lKChwcmVmaXgpID0+IGV2ZW50LmlkLnN0YXJ0c1dpdGgocHJlZml4KSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKGZpbHRlci5raW5kcyAmJiBmaWx0ZXIua2luZHMuaW5kZXhPZihldmVudC5raW5kKSA9PT0gLTEpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoZmlsdGVyLmF1dGhvcnMgJiYgZmlsdGVyLmF1dGhvcnMuaW5kZXhPZihldmVudC5wdWJrZXkpID09PSAtMSkge1xuICAgIGlmICghZmlsdGVyLmF1dGhvcnMuc29tZSgocHJlZml4KSA9PiBldmVudC5wdWJrZXkuc3RhcnRzV2l0aChwcmVmaXgpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCBmIGluIGZpbHRlcikge1xuICAgIGlmIChmWzBdID09PSBcIiNcIikge1xuICAgICAgbGV0IHRhZ05hbWUgPSBmLnNsaWNlKDEpO1xuICAgICAgbGV0IHZhbHVlcyA9IGZpbHRlcltgIyR7dGFnTmFtZX1gXTtcbiAgICAgIGlmICh2YWx1ZXMgJiYgIWV2ZW50LnRhZ3MuZmluZCgoW3QsIHZdKSA9PiB0ID09PSBmLnNsaWNlKDEpICYmIHZhbHVlcy5pbmRleE9mKHYpICE9PSAtMSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKGZpbHRlci5zaW5jZSAmJiBldmVudC5jcmVhdGVkX2F0IDwgZmlsdGVyLnNpbmNlKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKGZpbHRlci51bnRpbCAmJiBldmVudC5jcmVhdGVkX2F0ID4gZmlsdGVyLnVudGlsKVxuICAgIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBtYXRjaEZpbHRlcnMoZmlsdGVycywgZXZlbnQpIHtcbiAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IGZpbHRlcnMubGVuZ3RoOyBpMisrKSB7XG4gICAgaWYgKG1hdGNoRmlsdGVyKGZpbHRlcnNbaTJdLCBldmVudCkpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIGZha2Vqc29uLnRzXG5mdW5jdGlvbiBnZXRIZXg2NChqc29uLCBmaWVsZCkge1xuICBsZXQgbGVuID0gZmllbGQubGVuZ3RoICsgMztcbiAgbGV0IGlkeCA9IGpzb24uaW5kZXhPZihgXCIke2ZpZWxkfVwiOmApICsgbGVuO1xuICBsZXQgcyA9IGpzb24uc2xpY2UoaWR4KS5pbmRleE9mKGBcImApICsgaWR4ICsgMTtcbiAgcmV0dXJuIGpzb24uc2xpY2UocywgcyArIDY0KTtcbn1cbmZ1bmN0aW9uIGdldFN1YnNjcmlwdGlvbklkKGpzb24pIHtcbiAgbGV0IGlkeCA9IGpzb24uc2xpY2UoMCwgMjIpLmluZGV4T2YoYFwiRVZFTlRcImApO1xuICBpZiAoaWR4ID09PSAtMSlcbiAgICByZXR1cm4gbnVsbDtcbiAgbGV0IHBzdGFydCA9IGpzb24uc2xpY2UoaWR4ICsgNyArIDEpLmluZGV4T2YoYFwiYCk7XG4gIGlmIChwc3RhcnQgPT09IC0xKVxuICAgIHJldHVybiBudWxsO1xuICBsZXQgc3RhcnQgPSBpZHggKyA3ICsgMSArIHBzdGFydDtcbiAgbGV0IHBlbmQgPSBqc29uLnNsaWNlKHN0YXJ0ICsgMSwgODApLmluZGV4T2YoYFwiYCk7XG4gIGlmIChwZW5kID09PSAtMSlcbiAgICByZXR1cm4gbnVsbDtcbiAgbGV0IGVuZCA9IHN0YXJ0ICsgMSArIHBlbmQ7XG4gIHJldHVybiBqc29uLnNsaWNlKHN0YXJ0ICsgMSwgZW5kKTtcbn1cblxuLy8gbmlwNDIudHNcbmZ1bmN0aW9uIG1ha2VBdXRoRXZlbnQocmVsYXlVUkwsIGNoYWxsZW5nZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IENsaWVudEF1dGgsXG4gICAgY3JlYXRlZF9hdDogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMWUzKSxcbiAgICB0YWdzOiBbXG4gICAgICBbXCJyZWxheVwiLCByZWxheVVSTF0sXG4gICAgICBbXCJjaGFsbGVuZ2VcIiwgY2hhbGxlbmdlXVxuICAgIF0sXG4gICAgY29udGVudDogXCJcIlxuICB9O1xufVxuXG4vLyBoZWxwZXJzLnRzXG5hc3luYyBmdW5jdGlvbiB5aWVsZFRocmVhZCgpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgY29uc3QgY2ggPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBjb25zdCBoYW5kbGVyID0gKCkgPT4ge1xuICAgICAgY2gucG9ydDEucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgaGFuZGxlcik7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfTtcbiAgICBjaC5wb3J0MS5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBoYW5kbGVyKTtcbiAgICBjaC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcbiAgICBjaC5wb3J0MS5zdGFydCgpO1xuICB9KTtcbn1cbnZhciBhbHdheXNUcnVlID0gKHQpID0+IHtcbiAgdFt2ZXJpZmllZFN5bWJvbF0gPSB0cnVlO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIGFic3RyYWN0LXJlbGF5LnRzXG52YXIgX1dlYlNvY2tldDtcbnRyeSB7XG4gIF9XZWJTb2NrZXQgPSBXZWJTb2NrZXQ7XG59IGNhdGNoIHtcbn1cbnZhciBBYnN0cmFjdFJlbGF5ID0gY2xhc3Mge1xuICB1cmw7XG4gIF9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgb25jbG9zZSA9IG51bGw7XG4gIG9ubm90aWNlID0gKG1zZykgPT4gY29uc29sZS5kZWJ1ZyhgTk9USUNFIGZyb20gJHt0aGlzLnVybH06ICR7bXNnfWApO1xuICBiYXNlRW9zZVRpbWVvdXQgPSA0NDAwO1xuICBjb25uZWN0aW9uVGltZW91dCA9IDQ0MDA7XG4gIG9wZW5TdWJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29ubmVjdGlvblRpbWVvdXRIYW5kbGU7XG4gIGNvbm5lY3Rpb25Qcm9taXNlO1xuICBvcGVuQ291bnRSZXF1ZXN0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIG9wZW5FdmVudFB1Ymxpc2hlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHdzO1xuICBpbmNvbWluZ01lc3NhZ2VRdWV1ZSA9IG5ldyBRdWV1ZSgpO1xuICBxdWV1ZVJ1bm5pbmcgPSBmYWxzZTtcbiAgY2hhbGxlbmdlO1xuICBzZXJpYWwgPSAwO1xuICB2ZXJpZnlFdmVudDtcbiAgY29uc3RydWN0b3IodXJsLCBvcHRzKSB7XG4gICAgdGhpcy51cmwgPSBub3JtYWxpemVVUkwodXJsKTtcbiAgICB0aGlzLnZlcmlmeUV2ZW50ID0gb3B0cy52ZXJpZnlFdmVudDtcbiAgfVxuICBzdGF0aWMgYXN5bmMgY29ubmVjdCh1cmwsIG9wdHMpIHtcbiAgICBjb25zdCByZWxheSA9IG5ldyBBYnN0cmFjdFJlbGF5KHVybCwgb3B0cyk7XG4gICAgYXdhaXQgcmVsYXkuY29ubmVjdCgpO1xuICAgIHJldHVybiByZWxheTtcbiAgfVxuICBjbG9zZUFsbFN1YnNjcmlwdGlvbnMocmVhc29uKSB7XG4gICAgZm9yIChsZXQgW18sIHN1Yl0gb2YgdGhpcy5vcGVuU3Vicykge1xuICAgICAgc3ViLmNsb3NlKHJlYXNvbik7XG4gICAgfVxuICAgIHRoaXMub3BlblN1YnMuY2xlYXIoKTtcbiAgICBmb3IgKGxldCBbXywgZXBdIG9mIHRoaXMub3BlbkV2ZW50UHVibGlzaGVzKSB7XG4gICAgICBlcC5yZWplY3QobmV3IEVycm9yKHJlYXNvbikpO1xuICAgIH1cbiAgICB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcy5jbGVhcigpO1xuICAgIGZvciAobGV0IFtfLCBjcl0gb2YgdGhpcy5vcGVuQ291bnRSZXF1ZXN0cykge1xuICAgICAgY3IucmVqZWN0KG5ldyBFcnJvcihyZWFzb24pKTtcbiAgICB9XG4gICAgdGhpcy5vcGVuQ291bnRSZXF1ZXN0cy5jbGVhcigpO1xuICB9XG4gIGdldCBjb25uZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3RlZDtcbiAgfVxuICBhc3luYyBjb25uZWN0KCkge1xuICAgIGlmICh0aGlzLmNvbm5lY3Rpb25Qcm9taXNlKVxuICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvblByb21pc2U7XG4gICAgdGhpcy5jaGFsbGVuZ2UgPSB2b2lkIDA7XG4gICAgdGhpcy5jb25uZWN0aW9uUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuY29ubmVjdGlvblRpbWVvdXRIYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgcmVqZWN0KFwiY29ubmVjdGlvbiB0aW1lZCBvdXRcIik7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvblByb21pc2UgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMub25jbG9zZT8uKCk7XG4gICAgICAgIHRoaXMuY2xvc2VBbGxTdWJzY3JpcHRpb25zKFwicmVsYXkgY29ubmVjdGlvbiB0aW1lZCBvdXRcIik7XG4gICAgICB9LCB0aGlzLmNvbm5lY3Rpb25UaW1lb3V0KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMud3MgPSBuZXcgX1dlYlNvY2tldCh0aGlzLnVybCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMud3Mub25vcGVuID0gKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0aW9uVGltZW91dEhhbmRsZSk7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH07XG4gICAgICB0aGlzLndzLm9uZXJyb3IgPSAoZXYpID0+IHtcbiAgICAgICAgcmVqZWN0KGV2Lm1lc3NhZ2UpO1xuICAgICAgICBpZiAodGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICAgICAgdGhpcy5vbmNsb3NlPy4oKTtcbiAgICAgICAgICB0aGlzLmNsb3NlQWxsU3Vic2NyaXB0aW9ucyhcInJlbGF5IGNvbm5lY3Rpb24gZXJyb3JlZFwiKTtcbiAgICAgICAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRoaXMud3Mub25jbG9zZSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uUHJvbWlzZSA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5vbmNsb3NlPy4oKTtcbiAgICAgICAgdGhpcy5jbG9zZUFsbFN1YnNjcmlwdGlvbnMoXCJyZWxheSBjb25uZWN0aW9uIGNsb3NlZFwiKTtcbiAgICAgICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICB9O1xuICAgICAgdGhpcy53cy5vbm1lc3NhZ2UgPSB0aGlzLl9vbm1lc3NhZ2UuYmluZCh0aGlzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uUHJvbWlzZTtcbiAgfVxuICBhc3luYyBydW5RdWV1ZSgpIHtcbiAgICB0aGlzLnF1ZXVlUnVubmluZyA9IHRydWU7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChmYWxzZSA9PT0gdGhpcy5oYW5kbGVOZXh0KCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBhd2FpdCB5aWVsZFRocmVhZCgpO1xuICAgIH1cbiAgICB0aGlzLnF1ZXVlUnVubmluZyA9IGZhbHNlO1xuICB9XG4gIGhhbmRsZU5leHQoKSB7XG4gICAgY29uc3QganNvbiA9IHRoaXMuaW5jb21pbmdNZXNzYWdlUXVldWUuZGVxdWV1ZSgpO1xuICAgIGlmICghanNvbikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBzdWJpZCA9IGdldFN1YnNjcmlwdGlvbklkKGpzb24pO1xuICAgIGlmIChzdWJpZCkge1xuICAgICAgY29uc3Qgc28gPSB0aGlzLm9wZW5TdWJzLmdldChzdWJpZCk7XG4gICAgICBpZiAoIXNvKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlkID0gZ2V0SGV4NjQoanNvbiwgXCJpZFwiKTtcbiAgICAgIGNvbnN0IGFscmVhZHlIYXZlID0gc28uYWxyZWFkeUhhdmVFdmVudD8uKGlkKTtcbiAgICAgIHNvLnJlY2VpdmVkRXZlbnQ/Lih0aGlzLCBpZCk7XG4gICAgICBpZiAoYWxyZWFkeUhhdmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgbGV0IGRhdGEgPSBKU09OLnBhcnNlKGpzb24pO1xuICAgICAgc3dpdGNoIChkYXRhWzBdKSB7XG4gICAgICAgIGNhc2UgXCJFVkVOVFwiOiB7XG4gICAgICAgICAgY29uc3Qgc28gPSB0aGlzLm9wZW5TdWJzLmdldChkYXRhWzFdKTtcbiAgICAgICAgICBjb25zdCBldmVudCA9IGRhdGFbMl07XG4gICAgICAgICAgaWYgKHRoaXMudmVyaWZ5RXZlbnQoZXZlbnQpICYmIG1hdGNoRmlsdGVycyhzby5maWx0ZXJzLCBldmVudCkpIHtcbiAgICAgICAgICAgIHNvLm9uZXZlbnQoZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIkNPVU5UXCI6IHtcbiAgICAgICAgICBjb25zdCBpZCA9IGRhdGFbMV07XG4gICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGRhdGFbMl07XG4gICAgICAgICAgY29uc3QgY3IgPSB0aGlzLm9wZW5Db3VudFJlcXVlc3RzLmdldChpZCk7XG4gICAgICAgICAgaWYgKGNyKSB7XG4gICAgICAgICAgICBjci5yZXNvbHZlKHBheWxvYWQuY291bnQpO1xuICAgICAgICAgICAgdGhpcy5vcGVuQ291bnRSZXF1ZXN0cy5kZWxldGUoaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIkVPU0VcIjoge1xuICAgICAgICAgIGNvbnN0IHNvID0gdGhpcy5vcGVuU3Vicy5nZXQoZGF0YVsxXSk7XG4gICAgICAgICAgaWYgKCFzbylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBzby5yZWNlaXZlZEVvc2UoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIk9LXCI6IHtcbiAgICAgICAgICBjb25zdCBpZCA9IGRhdGFbMV07XG4gICAgICAgICAgY29uc3Qgb2sgPSBkYXRhWzJdO1xuICAgICAgICAgIGNvbnN0IHJlYXNvbiA9IGRhdGFbM107XG4gICAgICAgICAgY29uc3QgZXAgPSB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcy5nZXQoaWQpO1xuICAgICAgICAgIGlmIChvaylcbiAgICAgICAgICAgIGVwLnJlc29sdmUocmVhc29uKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBlcC5yZWplY3QobmV3IEVycm9yKHJlYXNvbikpO1xuICAgICAgICAgIHRoaXMub3BlbkV2ZW50UHVibGlzaGVzLmRlbGV0ZShpZCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJDTE9TRURcIjoge1xuICAgICAgICAgIGNvbnN0IGlkID0gZGF0YVsxXTtcbiAgICAgICAgICBjb25zdCBzbyA9IHRoaXMub3BlblN1YnMuZ2V0KGlkKTtcbiAgICAgICAgICBpZiAoIXNvKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIHNvLmNsb3NlZCA9IHRydWU7XG4gICAgICAgICAgc28uY2xvc2UoZGF0YVsyXSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJOT1RJQ0VcIjpcbiAgICAgICAgICB0aGlzLm9ubm90aWNlKGRhdGFbMV0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSBcIkFVVEhcIjoge1xuICAgICAgICAgIHRoaXMuY2hhbGxlbmdlID0gZGF0YVsxXTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgc2VuZChtZXNzYWdlKSB7XG4gICAgaWYgKCF0aGlzLmNvbm5lY3Rpb25Qcm9taXNlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2VuZGluZyBvbiBjbG9zZWQgY29ubmVjdGlvblwiKTtcbiAgICB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy53cz8uc2VuZChtZXNzYWdlKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBhdXRoKHNpZ25BdXRoRXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuY2hhbGxlbmdlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2FuJ3QgcGVyZm9ybSBhdXRoLCBubyBjaGFsbGVuZ2Ugd2FzIHJlY2VpdmVkXCIpO1xuICAgIGNvbnN0IGV2dCA9IGF3YWl0IHNpZ25BdXRoRXZlbnQobWFrZUF1dGhFdmVudCh0aGlzLnVybCwgdGhpcy5jaGFsbGVuZ2UpKTtcbiAgICBjb25zdCByZXQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcy5zZXQoZXZ0LmlkLCB7IHJlc29sdmUsIHJlamVjdCB9KTtcbiAgICB9KTtcbiAgICB0aGlzLnNlbmQoJ1tcIkFVVEhcIiwnICsgSlNPTi5zdHJpbmdpZnkoZXZ0KSArIFwiXVwiKTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGFzeW5jIHB1Ymxpc2goZXZlbnQpIHtcbiAgICBjb25zdCByZXQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcy5zZXQoZXZlbnQuaWQsIHsgcmVzb2x2ZSwgcmVqZWN0IH0pO1xuICAgIH0pO1xuICAgIHRoaXMuc2VuZCgnW1wiRVZFTlRcIiwnICsgSlNPTi5zdHJpbmdpZnkoZXZlbnQpICsgXCJdXCIpO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgYXN5bmMgY291bnQoZmlsdGVycywgcGFyYW1zKSB7XG4gICAgdGhpcy5zZXJpYWwrKztcbiAgICBjb25zdCBpZCA9IHBhcmFtcz8uaWQgfHwgXCJjb3VudDpcIiArIHRoaXMuc2VyaWFsO1xuICAgIGNvbnN0IHJldCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMub3BlbkNvdW50UmVxdWVzdHMuc2V0KGlkLCB7IHJlc29sdmUsIHJlamVjdCB9KTtcbiAgICB9KTtcbiAgICB0aGlzLnNlbmQoJ1tcIkNPVU5UXCIsXCInICsgaWQgKyAnXCIsJyArIEpTT04uc3RyaW5naWZ5KGZpbHRlcnMpICsgXCJdXCIpO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgc3Vic2NyaWJlKGZpbHRlcnMsIHBhcmFtcykge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHRoaXMucHJlcGFyZVN1YnNjcmlwdGlvbihmaWx0ZXJzLCBwYXJhbXMpO1xuICAgIHN1YnNjcmlwdGlvbi5maXJlKCk7XG4gICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgfVxuICBwcmVwYXJlU3Vic2NyaXB0aW9uKGZpbHRlcnMsIHBhcmFtcykge1xuICAgIHRoaXMuc2VyaWFsKys7XG4gICAgY29uc3QgaWQgPSBwYXJhbXMuaWQgfHwgXCJzdWI6XCIgKyB0aGlzLnNlcmlhbDtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKHRoaXMsIGlkLCBmaWx0ZXJzLCBwYXJhbXMpO1xuICAgIHRoaXMub3BlblN1YnMuc2V0KGlkLCBzdWJzY3JpcHRpb24pO1xuICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5jbG9zZUFsbFN1YnNjcmlwdGlvbnMoXCJyZWxheSBjb25uZWN0aW9uIGNsb3NlZCBieSB1c1wiKTtcbiAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLndzPy5jbG9zZSgpO1xuICB9XG4gIF9vbm1lc3NhZ2UoZXYpIHtcbiAgICB0aGlzLmluY29taW5nTWVzc2FnZVF1ZXVlLmVucXVldWUoZXYuZGF0YSk7XG4gICAgaWYgKCF0aGlzLnF1ZXVlUnVubmluZykge1xuICAgICAgdGhpcy5ydW5RdWV1ZSgpO1xuICAgIH1cbiAgfVxufTtcbnZhciBTdWJzY3JpcHRpb24gPSBjbGFzcyB7XG4gIHJlbGF5O1xuICBpZDtcbiAgY2xvc2VkID0gZmFsc2U7XG4gIGVvc2VkID0gZmFsc2U7XG4gIGZpbHRlcnM7XG4gIGFscmVhZHlIYXZlRXZlbnQ7XG4gIHJlY2VpdmVkRXZlbnQ7XG4gIG9uZXZlbnQ7XG4gIG9uZW9zZTtcbiAgb25jbG9zZTtcbiAgZW9zZVRpbWVvdXQ7XG4gIGVvc2VUaW1lb3V0SGFuZGxlO1xuICBjb25zdHJ1Y3RvcihyZWxheSwgaWQsIGZpbHRlcnMsIHBhcmFtcykge1xuICAgIHRoaXMucmVsYXkgPSByZWxheTtcbiAgICB0aGlzLmZpbHRlcnMgPSBmaWx0ZXJzO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLmFscmVhZHlIYXZlRXZlbnQgPSBwYXJhbXMuYWxyZWFkeUhhdmVFdmVudDtcbiAgICB0aGlzLnJlY2VpdmVkRXZlbnQgPSBwYXJhbXMucmVjZWl2ZWRFdmVudDtcbiAgICB0aGlzLmVvc2VUaW1lb3V0ID0gcGFyYW1zLmVvc2VUaW1lb3V0IHx8IHJlbGF5LmJhc2VFb3NlVGltZW91dDtcbiAgICB0aGlzLm9uZW9zZSA9IHBhcmFtcy5vbmVvc2U7XG4gICAgdGhpcy5vbmNsb3NlID0gcGFyYW1zLm9uY2xvc2U7XG4gICAgdGhpcy5vbmV2ZW50ID0gcGFyYW1zLm9uZXZlbnQgfHwgKChldmVudCkgPT4ge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgb25ldmVudCgpIGNhbGxiYWNrIG5vdCBkZWZpbmVkIGZvciBzdWJzY3JpcHRpb24gJyR7dGhpcy5pZH0nIGluIHJlbGF5ICR7dGhpcy5yZWxheS51cmx9LiBldmVudCByZWNlaXZlZDpgLFxuICAgICAgICBldmVudFxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICBmaXJlKCkge1xuICAgIHRoaXMucmVsYXkuc2VuZCgnW1wiUkVRXCIsXCInICsgdGhpcy5pZCArICdcIiwnICsgSlNPTi5zdHJpbmdpZnkodGhpcy5maWx0ZXJzKS5zdWJzdHJpbmcoMSkpO1xuICAgIHRoaXMuZW9zZVRpbWVvdXRIYW5kbGUgPSBzZXRUaW1lb3V0KHRoaXMucmVjZWl2ZWRFb3NlLmJpbmQodGhpcyksIHRoaXMuZW9zZVRpbWVvdXQpO1xuICB9XG4gIHJlY2VpdmVkRW9zZSgpIHtcbiAgICBpZiAodGhpcy5lb3NlZClcbiAgICAgIHJldHVybjtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5lb3NlVGltZW91dEhhbmRsZSk7XG4gICAgdGhpcy5lb3NlZCA9IHRydWU7XG4gICAgdGhpcy5vbmVvc2U/LigpO1xuICB9XG4gIGNsb3NlKHJlYXNvbiA9IFwiY2xvc2VkIGJ5IGNhbGxlclwiKSB7XG4gICAgaWYgKCF0aGlzLmNsb3NlZCkge1xuICAgICAgdGhpcy5yZWxheS5zZW5kKCdbXCJDTE9TRVwiLCcgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmlkKSArIFwiXVwiKTtcbiAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5yZWxheS5vcGVuU3Vicy5kZWxldGUodGhpcy5pZCk7XG4gICAgdGhpcy5vbmNsb3NlPy4ocmVhc29uKTtcbiAgfVxufTtcblxuLy8gYWJzdHJhY3QtcG9vbC50c1xudmFyIEFic3RyYWN0U2ltcGxlUG9vbCA9IGNsYXNzIHtcbiAgcmVsYXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgc2Vlbk9uID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgdHJhY2tSZWxheXMgPSBmYWxzZTtcbiAgdmVyaWZ5RXZlbnQ7XG4gIHRydXN0ZWRSZWxheVVSTHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgdGhpcy52ZXJpZnlFdmVudCA9IG9wdHMudmVyaWZ5RXZlbnQ7XG4gIH1cbiAgYXN5bmMgZW5zdXJlUmVsYXkodXJsLCBwYXJhbXMpIHtcbiAgICB1cmwgPSBub3JtYWxpemVVUkwodXJsKTtcbiAgICBsZXQgcmVsYXkgPSB0aGlzLnJlbGF5cy5nZXQodXJsKTtcbiAgICBpZiAoIXJlbGF5KSB7XG4gICAgICByZWxheSA9IG5ldyBBYnN0cmFjdFJlbGF5KHVybCwge1xuICAgICAgICB2ZXJpZnlFdmVudDogdGhpcy50cnVzdGVkUmVsYXlVUkxzLmhhcyh1cmwpID8gYWx3YXlzVHJ1ZSA6IHRoaXMudmVyaWZ5RXZlbnRcbiAgICAgIH0pO1xuICAgICAgaWYgKHBhcmFtcz8uY29ubmVjdGlvblRpbWVvdXQpXG4gICAgICAgIHJlbGF5LmNvbm5lY3Rpb25UaW1lb3V0ID0gcGFyYW1zLmNvbm5lY3Rpb25UaW1lb3V0O1xuICAgICAgdGhpcy5yZWxheXMuc2V0KHVybCwgcmVsYXkpO1xuICAgIH1cbiAgICBhd2FpdCByZWxheS5jb25uZWN0KCk7XG4gICAgcmV0dXJuIHJlbGF5O1xuICB9XG4gIGNsb3NlKHJlbGF5cykge1xuICAgIHJlbGF5cy5tYXAobm9ybWFsaXplVVJMKS5mb3JFYWNoKCh1cmwpID0+IHtcbiAgICAgIHRoaXMucmVsYXlzLmdldCh1cmwpPy5jbG9zZSgpO1xuICAgIH0pO1xuICB9XG4gIHN1YnNjcmliZU1hbnkocmVsYXlzLCBmaWx0ZXJzLCBwYXJhbXMpIHtcbiAgICBpZiAodGhpcy50cmFja1JlbGF5cykge1xuICAgICAgcGFyYW1zLnJlY2VpdmVkRXZlbnQgPSAocmVsYXksIGlkKSA9PiB7XG4gICAgICAgIGxldCBzZXQgPSB0aGlzLnNlZW5Pbi5nZXQoaWQpO1xuICAgICAgICBpZiAoIXNldCkge1xuICAgICAgICAgIHNldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICAgICAgdGhpcy5zZWVuT24uc2V0KGlkLCBzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHNldC5hZGQocmVsYXkpO1xuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgX2tub3duSWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb25zdCBzdWJzID0gW107XG4gICAgY29uc3QgZW9zZXNSZWNlaXZlZCA9IFtdO1xuICAgIGxldCBoYW5kbGVFb3NlID0gKGkyKSA9PiB7XG4gICAgICBlb3Nlc1JlY2VpdmVkW2kyXSA9IHRydWU7XG4gICAgICBpZiAoZW9zZXNSZWNlaXZlZC5maWx0ZXIoKGEpID0+IGEpLmxlbmd0aCA9PT0gcmVsYXlzLmxlbmd0aCkge1xuICAgICAgICBwYXJhbXMub25lb3NlPy4oKTtcbiAgICAgICAgaGFuZGxlRW9zZSA9ICgpID0+IHtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGNsb3Nlc1JlY2VpdmVkID0gW107XG4gICAgbGV0IGhhbmRsZUNsb3NlID0gKGkyLCByZWFzb24pID0+IHtcbiAgICAgIGhhbmRsZUVvc2UoaTIpO1xuICAgICAgY2xvc2VzUmVjZWl2ZWRbaTJdID0gcmVhc29uO1xuICAgICAgaWYgKGNsb3Nlc1JlY2VpdmVkLmZpbHRlcigoYSkgPT4gYSkubGVuZ3RoID09PSByZWxheXMubGVuZ3RoKSB7XG4gICAgICAgIHBhcmFtcy5vbmNsb3NlPy4oY2xvc2VzUmVjZWl2ZWQpO1xuICAgICAgICBoYW5kbGVDbG9zZSA9ICgpID0+IHtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGxvY2FsQWxyZWFkeUhhdmVFdmVudEhhbmRsZXIgPSAoaWQpID0+IHtcbiAgICAgIGlmIChwYXJhbXMuYWxyZWFkeUhhdmVFdmVudD8uKGlkKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGhhdmUgPSBfa25vd25JZHMuaGFzKGlkKTtcbiAgICAgIF9rbm93bklkcy5hZGQoaWQpO1xuICAgICAgcmV0dXJuIGhhdmU7XG4gICAgfTtcbiAgICBjb25zdCBhbGxPcGVuZWQgPSBQcm9taXNlLmFsbChcbiAgICAgIHJlbGF5cy5tYXAobm9ybWFsaXplVVJMKS5tYXAoYXN5bmMgKHVybCwgaTIsIGFycikgPT4ge1xuICAgICAgICBpZiAoYXJyLmluZGV4T2YodXJsKSAhPT0gaTIpIHtcbiAgICAgICAgICBoYW5kbGVDbG9zZShpMiwgXCJkdXBsaWNhdGUgdXJsXCIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVsYXk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVsYXkgPSBhd2FpdCB0aGlzLmVuc3VyZVJlbGF5KHVybCwge1xuICAgICAgICAgICAgY29ubmVjdGlvblRpbWVvdXQ6IHBhcmFtcy5tYXhXYWl0ID8gTWF0aC5tYXgocGFyYW1zLm1heFdhaXQgKiAwLjgsIHBhcmFtcy5tYXhXYWl0IC0gMWUzKSA6IHZvaWQgMFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBoYW5kbGVDbG9zZShpMiwgZXJyPy5tZXNzYWdlIHx8IFN0cmluZyhlcnIpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN1YnNjcmlwdGlvbiA9IHJlbGF5LnN1YnNjcmliZShmaWx0ZXJzLCB7XG4gICAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICAgIG9uZW9zZTogKCkgPT4gaGFuZGxlRW9zZShpMiksXG4gICAgICAgICAgb25jbG9zZTogKHJlYXNvbikgPT4gaGFuZGxlQ2xvc2UoaTIsIHJlYXNvbiksXG4gICAgICAgICAgYWxyZWFkeUhhdmVFdmVudDogbG9jYWxBbHJlYWR5SGF2ZUV2ZW50SGFuZGxlcixcbiAgICAgICAgICBlb3NlVGltZW91dDogcGFyYW1zLm1heFdhaXRcbiAgICAgICAgfSk7XG4gICAgICAgIHN1YnMucHVzaChzdWJzY3JpcHRpb24pO1xuICAgICAgfSlcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICBhc3luYyBjbG9zZSgpIHtcbiAgICAgICAgYXdhaXQgYWxsT3BlbmVkO1xuICAgICAgICBzdWJzLmZvckVhY2goKHN1YikgPT4ge1xuICAgICAgICAgIHN1Yi5jbG9zZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHN1YnNjcmliZU1hbnlFb3NlKHJlbGF5cywgZmlsdGVycywgcGFyYW1zKSB7XG4gICAgY29uc3Qgc3ViY2xvc2VyID0gdGhpcy5zdWJzY3JpYmVNYW55KHJlbGF5cywgZmlsdGVycywge1xuICAgICAgLi4ucGFyYW1zLFxuICAgICAgb25lb3NlKCkge1xuICAgICAgICBzdWJjbG9zZXIuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc3ViY2xvc2VyO1xuICB9XG4gIGFzeW5jIHF1ZXJ5U3luYyhyZWxheXMsIGZpbHRlciwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlKSA9PiB7XG4gICAgICBjb25zdCBldmVudHMgPSBbXTtcbiAgICAgIHRoaXMuc3Vic2NyaWJlTWFueUVvc2UocmVsYXlzLCBbZmlsdGVyXSwge1xuICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgIG9uZXZlbnQoZXZlbnQpIHtcbiAgICAgICAgICBldmVudHMucHVzaChldmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uY2xvc2UoXykge1xuICAgICAgICAgIHJlc29sdmUoZXZlbnRzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZ2V0KHJlbGF5cywgZmlsdGVyLCBwYXJhbXMpIHtcbiAgICBmaWx0ZXIubGltaXQgPSAxO1xuICAgIGNvbnN0IGV2ZW50cyA9IGF3YWl0IHRoaXMucXVlcnlTeW5jKHJlbGF5cywgZmlsdGVyLCBwYXJhbXMpO1xuICAgIGV2ZW50cy5zb3J0KChhLCBiKSA9PiBiLmNyZWF0ZWRfYXQgLSBhLmNyZWF0ZWRfYXQpO1xuICAgIHJldHVybiBldmVudHNbMF0gfHwgbnVsbDtcbiAgfVxuICBwdWJsaXNoKHJlbGF5cywgZXZlbnQpIHtcbiAgICByZXR1cm4gcmVsYXlzLm1hcChub3JtYWxpemVVUkwpLm1hcChhc3luYyAodXJsLCBpMiwgYXJyKSA9PiB7XG4gICAgICBpZiAoYXJyLmluZGV4T2YodXJsKSAhPT0gaTIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFwiZHVwbGljYXRlIHVybFwiKTtcbiAgICAgIH1cbiAgICAgIGxldCByID0gYXdhaXQgdGhpcy5lbnN1cmVSZWxheSh1cmwpO1xuICAgICAgcmV0dXJuIHIucHVibGlzaChldmVudCk7XG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHBvb2wudHNcbnZhciBTaW1wbGVQb29sID0gY2xhc3MgZXh0ZW5kcyBBYnN0cmFjdFNpbXBsZVBvb2wge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcih7IHZlcmlmeUV2ZW50IH0pO1xuICB9XG59O1xuZXhwb3J0IHtcbiAgQWJzdHJhY3RTaW1wbGVQb29sLFxuICBTaW1wbGVQb29sXG59O1xuIiwgIi8vIHB1cmUudHNcbmltcG9ydCB7IHNjaG5vcnIgfSBmcm9tIFwiQG5vYmxlL2N1cnZlcy9zZWNwMjU2azFcIjtcbmltcG9ydCB7IGJ5dGVzVG9IZXggfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiO1xuXG4vLyBjb3JlLnRzXG52YXIgdmVyaWZpZWRTeW1ib2wgPSBTeW1ib2woXCJ2ZXJpZmllZFwiKTtcbnZhciBpc1JlY29yZCA9IChvYmopID0+IG9iaiBpbnN0YW5jZW9mIE9iamVjdDtcbmZ1bmN0aW9uIHZhbGlkYXRlRXZlbnQoZXZlbnQpIHtcbiAgaWYgKCFpc1JlY29yZChldmVudCkpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIGV2ZW50LmtpbmQgIT09IFwibnVtYmVyXCIpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIGV2ZW50LmNvbnRlbnQgIT09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIGV2ZW50LmNyZWF0ZWRfYXQgIT09IFwibnVtYmVyXCIpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIGV2ZW50LnB1YmtleSAhPT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmICghZXZlbnQucHVia2V5Lm1hdGNoKC9eW2EtZjAtOV17NjR9JC8pKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGV2ZW50LnRhZ3MpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IGV2ZW50LnRhZ3MubGVuZ3RoOyBpMisrKSB7XG4gICAgbGV0IHRhZyA9IGV2ZW50LnRhZ3NbaTJdO1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0YWcpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGFnLmxlbmd0aDsgaisrKSB7XG4gICAgICBpZiAodHlwZW9mIHRhZ1tqXSA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gcHVyZS50c1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvc2hhMjU2XCI7XG5cbi8vIHV0aWxzLnRzXG52YXIgdXRmOERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoXCJ1dGYtOFwiKTtcbnZhciB1dGY4RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuXG4vLyBwdXJlLnRzXG52YXIgSlMgPSBjbGFzcyB7XG4gIGdlbmVyYXRlU2VjcmV0S2V5KCkge1xuICAgIHJldHVybiBzY2hub3JyLnV0aWxzLnJhbmRvbVByaXZhdGVLZXkoKTtcbiAgfVxuICBnZXRQdWJsaWNLZXkoc2VjcmV0S2V5KSB7XG4gICAgcmV0dXJuIGJ5dGVzVG9IZXgoc2Nobm9yci5nZXRQdWJsaWNLZXkoc2VjcmV0S2V5KSk7XG4gIH1cbiAgZmluYWxpemVFdmVudCh0LCBzZWNyZXRLZXkpIHtcbiAgICBjb25zdCBldmVudCA9IHQ7XG4gICAgZXZlbnQucHVia2V5ID0gYnl0ZXNUb0hleChzY2hub3JyLmdldFB1YmxpY0tleShzZWNyZXRLZXkpKTtcbiAgICBldmVudC5pZCA9IGdldEV2ZW50SGFzaChldmVudCk7XG4gICAgZXZlbnQuc2lnID0gYnl0ZXNUb0hleChzY2hub3JyLnNpZ24oZ2V0RXZlbnRIYXNoKGV2ZW50KSwgc2VjcmV0S2V5KSk7XG4gICAgZXZlbnRbdmVyaWZpZWRTeW1ib2xdID0gdHJ1ZTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cbiAgdmVyaWZ5RXZlbnQoZXZlbnQpIHtcbiAgICBpZiAodHlwZW9mIGV2ZW50W3ZlcmlmaWVkU3ltYm9sXSA9PT0gXCJib29sZWFuXCIpXG4gICAgICByZXR1cm4gZXZlbnRbdmVyaWZpZWRTeW1ib2xdO1xuICAgIGNvbnN0IGhhc2ggPSBnZXRFdmVudEhhc2goZXZlbnQpO1xuICAgIGlmIChoYXNoICE9PSBldmVudC5pZCkge1xuICAgICAgZXZlbnRbdmVyaWZpZWRTeW1ib2xdID0gZmFsc2U7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCB2YWxpZCA9IHNjaG5vcnIudmVyaWZ5KGV2ZW50LnNpZywgaGFzaCwgZXZlbnQucHVia2V5KTtcbiAgICAgIGV2ZW50W3ZlcmlmaWVkU3ltYm9sXSA9IHZhbGlkO1xuICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgZXZlbnRbdmVyaWZpZWRTeW1ib2xdID0gZmFsc2U7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gc2VyaWFsaXplRXZlbnQoZXZ0KSB7XG4gIGlmICghdmFsaWRhdGVFdmVudChldnQpKVxuICAgIHRocm93IG5ldyBFcnJvcihcImNhbid0IHNlcmlhbGl6ZSBldmVudCB3aXRoIHdyb25nIG9yIG1pc3NpbmcgcHJvcGVydGllc1wiKTtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFswLCBldnQucHVia2V5LCBldnQuY3JlYXRlZF9hdCwgZXZ0LmtpbmQsIGV2dC50YWdzLCBldnQuY29udGVudF0pO1xufVxuZnVuY3Rpb24gZ2V0RXZlbnRIYXNoKGV2ZW50KSB7XG4gIGxldCBldmVudEhhc2ggPSBzaGEyNTYodXRmOEVuY29kZXIuZW5jb2RlKHNlcmlhbGl6ZUV2ZW50KGV2ZW50KSkpO1xuICByZXR1cm4gYnl0ZXNUb0hleChldmVudEhhc2gpO1xufVxudmFyIGkgPSBuZXcgSlMoKTtcbnZhciBnZW5lcmF0ZVNlY3JldEtleSA9IGkuZ2VuZXJhdGVTZWNyZXRLZXk7XG52YXIgZ2V0UHVibGljS2V5ID0gaS5nZXRQdWJsaWNLZXk7XG52YXIgZmluYWxpemVFdmVudCA9IGkuZmluYWxpemVFdmVudDtcbnZhciB2ZXJpZnlFdmVudCA9IGkudmVyaWZ5RXZlbnQ7XG5leHBvcnQge1xuICBmaW5hbGl6ZUV2ZW50LFxuICBnZW5lcmF0ZVNlY3JldEtleSxcbiAgZ2V0RXZlbnRIYXNoLFxuICBnZXRQdWJsaWNLZXksXG4gIHNlcmlhbGl6ZUV2ZW50LFxuICB2YWxpZGF0ZUV2ZW50LFxuICB2ZXJpZmllZFN5bWJvbCxcbiAgdmVyaWZ5RXZlbnRcbn07XG4iLCAiLy8gcHVyZS50c1xuaW1wb3J0IHsgc2Nobm9yciB9IGZyb20gXCJAbm9ibGUvY3VydmVzL3NlY3AyNTZrMVwiO1xuaW1wb3J0IHsgYnl0ZXNUb0hleCB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCI7XG5cbi8vIGNvcmUudHNcbnZhciB2ZXJpZmllZFN5bWJvbCA9IFN5bWJvbChcInZlcmlmaWVkXCIpO1xudmFyIGlzUmVjb3JkID0gKG9iaikgPT4gb2JqIGluc3RhbmNlb2YgT2JqZWN0O1xuZnVuY3Rpb24gdmFsaWRhdGVFdmVudChldmVudCkge1xuICBpZiAoIWlzUmVjb3JkKGV2ZW50KSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgZXZlbnQua2luZCAhPT0gXCJudW1iZXJcIilcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgZXZlbnQuY29udGVudCAhPT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgZXZlbnQuY3JlYXRlZF9hdCAhPT0gXCJudW1iZXJcIilcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgZXZlbnQucHVia2V5ICE9PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKCFldmVudC5wdWJrZXkubWF0Y2goL15bYS1mMC05XXs2NH0kLykpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZXZlbnQudGFncykpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgZXZlbnQudGFncy5sZW5ndGg7IGkyKyspIHtcbiAgICBsZXQgdGFnID0gZXZlbnQudGFnc1tpMl07XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHRhZykpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCB0YWcubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmICh0eXBlb2YgdGFnW2pdID09PSBcIm9iamVjdFwiKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBwdXJlLnRzXG5pbXBvcnQgeyBzaGEyNTYgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9zaGEyNTZcIjtcblxuLy8gdXRpbHMudHNcbnZhciB1dGY4RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcihcInV0Zi04XCIpO1xudmFyIHV0ZjhFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG5mdW5jdGlvbiBub3JtYWxpemVVUkwodXJsKSB7XG4gIGlmICh1cmwuaW5kZXhPZihcIjovL1wiKSA9PT0gLTEpXG4gICAgdXJsID0gXCJ3c3M6Ly9cIiArIHVybDtcbiAgbGV0IHAgPSBuZXcgVVJMKHVybCk7XG4gIHAucGF0aG5hbWUgPSBwLnBhdGhuYW1lLnJlcGxhY2UoL1xcLysvZywgXCIvXCIpO1xuICBpZiAocC5wYXRobmFtZS5lbmRzV2l0aChcIi9cIikpXG4gICAgcC5wYXRobmFtZSA9IHAucGF0aG5hbWUuc2xpY2UoMCwgLTEpO1xuICBpZiAocC5wb3J0ID09PSBcIjgwXCIgJiYgcC5wcm90b2NvbCA9PT0gXCJ3czpcIiB8fCBwLnBvcnQgPT09IFwiNDQzXCIgJiYgcC5wcm90b2NvbCA9PT0gXCJ3c3M6XCIpXG4gICAgcC5wb3J0ID0gXCJcIjtcbiAgcC5zZWFyY2hQYXJhbXMuc29ydCgpO1xuICBwLmhhc2ggPSBcIlwiO1xuICByZXR1cm4gcC50b1N0cmluZygpO1xufVxudmFyIFF1ZXVlTm9kZSA9IGNsYXNzIHtcbiAgdmFsdWU7XG4gIG5leHQgPSBudWxsO1xuICBwcmV2ID0gbnVsbDtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHRoaXMudmFsdWUgPSBtZXNzYWdlO1xuICB9XG59O1xudmFyIFF1ZXVlID0gY2xhc3Mge1xuICBmaXJzdDtcbiAgbGFzdDtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5maXJzdCA9IG51bGw7XG4gICAgdGhpcy5sYXN0ID0gbnVsbDtcbiAgfVxuICBlbnF1ZXVlKHZhbHVlKSB7XG4gICAgY29uc3QgbmV3Tm9kZSA9IG5ldyBRdWV1ZU5vZGUodmFsdWUpO1xuICAgIGlmICghdGhpcy5sYXN0KSB7XG4gICAgICB0aGlzLmZpcnN0ID0gbmV3Tm9kZTtcbiAgICAgIHRoaXMubGFzdCA9IG5ld05vZGU7XG4gICAgfSBlbHNlIGlmICh0aGlzLmxhc3QgPT09IHRoaXMuZmlyc3QpIHtcbiAgICAgIHRoaXMubGFzdCA9IG5ld05vZGU7XG4gICAgICB0aGlzLmxhc3QucHJldiA9IHRoaXMuZmlyc3Q7XG4gICAgICB0aGlzLmZpcnN0Lm5leHQgPSBuZXdOb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdOb2RlLnByZXYgPSB0aGlzLmxhc3Q7XG4gICAgICB0aGlzLmxhc3QubmV4dCA9IG5ld05vZGU7XG4gICAgICB0aGlzLmxhc3QgPSBuZXdOb2RlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBkZXF1ZXVlKCkge1xuICAgIGlmICghdGhpcy5maXJzdClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGlmICh0aGlzLmZpcnN0ID09PSB0aGlzLmxhc3QpIHtcbiAgICAgIGNvbnN0IHRhcmdldDIgPSB0aGlzLmZpcnN0O1xuICAgICAgdGhpcy5maXJzdCA9IG51bGw7XG4gICAgICB0aGlzLmxhc3QgPSBudWxsO1xuICAgICAgcmV0dXJuIHRhcmdldDIudmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuZmlyc3Q7XG4gICAgdGhpcy5maXJzdCA9IHRhcmdldC5uZXh0O1xuICAgIHJldHVybiB0YXJnZXQudmFsdWU7XG4gIH1cbn07XG5cbi8vIHB1cmUudHNcbnZhciBKUyA9IGNsYXNzIHtcbiAgZ2VuZXJhdGVTZWNyZXRLZXkoKSB7XG4gICAgcmV0dXJuIHNjaG5vcnIudXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpO1xuICB9XG4gIGdldFB1YmxpY0tleShzZWNyZXRLZXkpIHtcbiAgICByZXR1cm4gYnl0ZXNUb0hleChzY2hub3JyLmdldFB1YmxpY0tleShzZWNyZXRLZXkpKTtcbiAgfVxuICBmaW5hbGl6ZUV2ZW50KHQsIHNlY3JldEtleSkge1xuICAgIGNvbnN0IGV2ZW50ID0gdDtcbiAgICBldmVudC5wdWJrZXkgPSBieXRlc1RvSGV4KHNjaG5vcnIuZ2V0UHVibGljS2V5KHNlY3JldEtleSkpO1xuICAgIGV2ZW50LmlkID0gZ2V0RXZlbnRIYXNoKGV2ZW50KTtcbiAgICBldmVudC5zaWcgPSBieXRlc1RvSGV4KHNjaG5vcnIuc2lnbihnZXRFdmVudEhhc2goZXZlbnQpLCBzZWNyZXRLZXkpKTtcbiAgICBldmVudFt2ZXJpZmllZFN5bWJvbF0gPSB0cnVlO1xuICAgIHJldHVybiBldmVudDtcbiAgfVxuICB2ZXJpZnlFdmVudChldmVudCkge1xuICAgIGlmICh0eXBlb2YgZXZlbnRbdmVyaWZpZWRTeW1ib2xdID09PSBcImJvb2xlYW5cIilcbiAgICAgIHJldHVybiBldmVudFt2ZXJpZmllZFN5bWJvbF07XG4gICAgY29uc3QgaGFzaCA9IGdldEV2ZW50SGFzaChldmVudCk7XG4gICAgaWYgKGhhc2ggIT09IGV2ZW50LmlkKSB7XG4gICAgICBldmVudFt2ZXJpZmllZFN5bWJvbF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHZhbGlkID0gc2Nobm9yci52ZXJpZnkoZXZlbnQuc2lnLCBoYXNoLCBldmVudC5wdWJrZXkpO1xuICAgICAgZXZlbnRbdmVyaWZpZWRTeW1ib2xdID0gdmFsaWQ7XG4gICAgICByZXR1cm4gdmFsaWQ7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBldmVudFt2ZXJpZmllZFN5bWJvbF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBzZXJpYWxpemVFdmVudChldnQpIHtcbiAgaWYgKCF2YWxpZGF0ZUV2ZW50KGV2dCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY2FuJ3Qgc2VyaWFsaXplIGV2ZW50IHdpdGggd3Jvbmcgb3IgbWlzc2luZyBwcm9wZXJ0aWVzXCIpO1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoWzAsIGV2dC5wdWJrZXksIGV2dC5jcmVhdGVkX2F0LCBldnQua2luZCwgZXZ0LnRhZ3MsIGV2dC5jb250ZW50XSk7XG59XG5mdW5jdGlvbiBnZXRFdmVudEhhc2goZXZlbnQpIHtcbiAgbGV0IGV2ZW50SGFzaCA9IHNoYTI1Nih1dGY4RW5jb2Rlci5lbmNvZGUoc2VyaWFsaXplRXZlbnQoZXZlbnQpKSk7XG4gIHJldHVybiBieXRlc1RvSGV4KGV2ZW50SGFzaCk7XG59XG52YXIgaSA9IG5ldyBKUygpO1xudmFyIGdlbmVyYXRlU2VjcmV0S2V5ID0gaS5nZW5lcmF0ZVNlY3JldEtleTtcbnZhciBnZXRQdWJsaWNLZXkgPSBpLmdldFB1YmxpY0tleTtcbnZhciBmaW5hbGl6ZUV2ZW50ID0gaS5maW5hbGl6ZUV2ZW50O1xudmFyIHZlcmlmeUV2ZW50ID0gaS52ZXJpZnlFdmVudDtcblxuLy8ga2luZHMudHNcbnZhciBDbGllbnRBdXRoID0gMjIyNDI7XG5cbi8vIGZpbHRlci50c1xuZnVuY3Rpb24gbWF0Y2hGaWx0ZXIoZmlsdGVyLCBldmVudCkge1xuICBpZiAoZmlsdGVyLmlkcyAmJiBmaWx0ZXIuaWRzLmluZGV4T2YoZXZlbnQuaWQpID09PSAtMSkge1xuICAgIGlmICghZmlsdGVyLmlkcy5zb21lKChwcmVmaXgpID0+IGV2ZW50LmlkLnN0YXJ0c1dpdGgocHJlZml4KSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKGZpbHRlci5raW5kcyAmJiBmaWx0ZXIua2luZHMuaW5kZXhPZihldmVudC5raW5kKSA9PT0gLTEpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoZmlsdGVyLmF1dGhvcnMgJiYgZmlsdGVyLmF1dGhvcnMuaW5kZXhPZihldmVudC5wdWJrZXkpID09PSAtMSkge1xuICAgIGlmICghZmlsdGVyLmF1dGhvcnMuc29tZSgocHJlZml4KSA9PiBldmVudC5wdWJrZXkuc3RhcnRzV2l0aChwcmVmaXgpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCBmIGluIGZpbHRlcikge1xuICAgIGlmIChmWzBdID09PSBcIiNcIikge1xuICAgICAgbGV0IHRhZ05hbWUgPSBmLnNsaWNlKDEpO1xuICAgICAgbGV0IHZhbHVlcyA9IGZpbHRlcltgIyR7dGFnTmFtZX1gXTtcbiAgICAgIGlmICh2YWx1ZXMgJiYgIWV2ZW50LnRhZ3MuZmluZCgoW3QsIHZdKSA9PiB0ID09PSBmLnNsaWNlKDEpICYmIHZhbHVlcy5pbmRleE9mKHYpICE9PSAtMSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKGZpbHRlci5zaW5jZSAmJiBldmVudC5jcmVhdGVkX2F0IDwgZmlsdGVyLnNpbmNlKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKGZpbHRlci51bnRpbCAmJiBldmVudC5jcmVhdGVkX2F0ID4gZmlsdGVyLnVudGlsKVxuICAgIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBtYXRjaEZpbHRlcnMoZmlsdGVycywgZXZlbnQpIHtcbiAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IGZpbHRlcnMubGVuZ3RoOyBpMisrKSB7XG4gICAgaWYgKG1hdGNoRmlsdGVyKGZpbHRlcnNbaTJdLCBldmVudCkpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIGZha2Vqc29uLnRzXG5mdW5jdGlvbiBnZXRIZXg2NChqc29uLCBmaWVsZCkge1xuICBsZXQgbGVuID0gZmllbGQubGVuZ3RoICsgMztcbiAgbGV0IGlkeCA9IGpzb24uaW5kZXhPZihgXCIke2ZpZWxkfVwiOmApICsgbGVuO1xuICBsZXQgcyA9IGpzb24uc2xpY2UoaWR4KS5pbmRleE9mKGBcImApICsgaWR4ICsgMTtcbiAgcmV0dXJuIGpzb24uc2xpY2UocywgcyArIDY0KTtcbn1cbmZ1bmN0aW9uIGdldFN1YnNjcmlwdGlvbklkKGpzb24pIHtcbiAgbGV0IGlkeCA9IGpzb24uc2xpY2UoMCwgMjIpLmluZGV4T2YoYFwiRVZFTlRcImApO1xuICBpZiAoaWR4ID09PSAtMSlcbiAgICByZXR1cm4gbnVsbDtcbiAgbGV0IHBzdGFydCA9IGpzb24uc2xpY2UoaWR4ICsgNyArIDEpLmluZGV4T2YoYFwiYCk7XG4gIGlmIChwc3RhcnQgPT09IC0xKVxuICAgIHJldHVybiBudWxsO1xuICBsZXQgc3RhcnQgPSBpZHggKyA3ICsgMSArIHBzdGFydDtcbiAgbGV0IHBlbmQgPSBqc29uLnNsaWNlKHN0YXJ0ICsgMSwgODApLmluZGV4T2YoYFwiYCk7XG4gIGlmIChwZW5kID09PSAtMSlcbiAgICByZXR1cm4gbnVsbDtcbiAgbGV0IGVuZCA9IHN0YXJ0ICsgMSArIHBlbmQ7XG4gIHJldHVybiBqc29uLnNsaWNlKHN0YXJ0ICsgMSwgZW5kKTtcbn1cblxuLy8gbmlwNDIudHNcbmZ1bmN0aW9uIG1ha2VBdXRoRXZlbnQocmVsYXlVUkwsIGNoYWxsZW5nZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IENsaWVudEF1dGgsXG4gICAgY3JlYXRlZF9hdDogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMWUzKSxcbiAgICB0YWdzOiBbXG4gICAgICBbXCJyZWxheVwiLCByZWxheVVSTF0sXG4gICAgICBbXCJjaGFsbGVuZ2VcIiwgY2hhbGxlbmdlXVxuICAgIF0sXG4gICAgY29udGVudDogXCJcIlxuICB9O1xufVxuXG4vLyBoZWxwZXJzLnRzXG5hc3luYyBmdW5jdGlvbiB5aWVsZFRocmVhZCgpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgY29uc3QgY2ggPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBjb25zdCBoYW5kbGVyID0gKCkgPT4ge1xuICAgICAgY2gucG9ydDEucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgaGFuZGxlcik7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfTtcbiAgICBjaC5wb3J0MS5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBoYW5kbGVyKTtcbiAgICBjaC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcbiAgICBjaC5wb3J0MS5zdGFydCgpO1xuICB9KTtcbn1cblxuLy8gYWJzdHJhY3QtcmVsYXkudHNcbnZhciBfV2ViU29ja2V0O1xudHJ5IHtcbiAgX1dlYlNvY2tldCA9IFdlYlNvY2tldDtcbn0gY2F0Y2gge1xufVxuZnVuY3Rpb24gdXNlV2ViU29ja2V0SW1wbGVtZW50YXRpb24od2Vic29ja2V0SW1wbGVtZW50YXRpb24pIHtcbiAgX1dlYlNvY2tldCA9IHdlYnNvY2tldEltcGxlbWVudGF0aW9uO1xufVxudmFyIEFic3RyYWN0UmVsYXkgPSBjbGFzcyB7XG4gIHVybDtcbiAgX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICBvbmNsb3NlID0gbnVsbDtcbiAgb25ub3RpY2UgPSAobXNnKSA9PiBjb25zb2xlLmRlYnVnKGBOT1RJQ0UgZnJvbSAke3RoaXMudXJsfTogJHttc2d9YCk7XG4gIGJhc2VFb3NlVGltZW91dCA9IDQ0MDA7XG4gIGNvbm5lY3Rpb25UaW1lb3V0ID0gNDQwMDtcbiAgb3BlblN1YnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25uZWN0aW9uVGltZW91dEhhbmRsZTtcbiAgY29ubmVjdGlvblByb21pc2U7XG4gIG9wZW5Db3VudFJlcXVlc3RzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgb3BlbkV2ZW50UHVibGlzaGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgd3M7XG4gIGluY29taW5nTWVzc2FnZVF1ZXVlID0gbmV3IFF1ZXVlKCk7XG4gIHF1ZXVlUnVubmluZyA9IGZhbHNlO1xuICBjaGFsbGVuZ2U7XG4gIHNlcmlhbCA9IDA7XG4gIHZlcmlmeUV2ZW50O1xuICBjb25zdHJ1Y3Rvcih1cmwsIG9wdHMpIHtcbiAgICB0aGlzLnVybCA9IG5vcm1hbGl6ZVVSTCh1cmwpO1xuICAgIHRoaXMudmVyaWZ5RXZlbnQgPSBvcHRzLnZlcmlmeUV2ZW50O1xuICB9XG4gIHN0YXRpYyBhc3luYyBjb25uZWN0KHVybCwgb3B0cykge1xuICAgIGNvbnN0IHJlbGF5ID0gbmV3IEFic3RyYWN0UmVsYXkodXJsLCBvcHRzKTtcbiAgICBhd2FpdCByZWxheS5jb25uZWN0KCk7XG4gICAgcmV0dXJuIHJlbGF5O1xuICB9XG4gIGNsb3NlQWxsU3Vic2NyaXB0aW9ucyhyZWFzb24pIHtcbiAgICBmb3IgKGxldCBbXywgc3ViXSBvZiB0aGlzLm9wZW5TdWJzKSB7XG4gICAgICBzdWIuY2xvc2UocmVhc29uKTtcbiAgICB9XG4gICAgdGhpcy5vcGVuU3Vicy5jbGVhcigpO1xuICAgIGZvciAobGV0IFtfLCBlcF0gb2YgdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMpIHtcbiAgICAgIGVwLnJlamVjdChuZXcgRXJyb3IocmVhc29uKSk7XG4gICAgfVxuICAgIHRoaXMub3BlbkV2ZW50UHVibGlzaGVzLmNsZWFyKCk7XG4gICAgZm9yIChsZXQgW18sIGNyXSBvZiB0aGlzLm9wZW5Db3VudFJlcXVlc3RzKSB7XG4gICAgICBjci5yZWplY3QobmV3IEVycm9yKHJlYXNvbikpO1xuICAgIH1cbiAgICB0aGlzLm9wZW5Db3VudFJlcXVlc3RzLmNsZWFyKCk7XG4gIH1cbiAgZ2V0IGNvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29ubmVjdGVkO1xuICB9XG4gIGFzeW5jIGNvbm5lY3QoKSB7XG4gICAgaWYgKHRoaXMuY29ubmVjdGlvblByb21pc2UpXG4gICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uUHJvbWlzZTtcbiAgICB0aGlzLmNoYWxsZW5nZSA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5jb25uZWN0aW9uVGltZW91dEhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICByZWplY3QoXCJjb25uZWN0aW9uIHRpbWVkIG91dFwiKTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uUHJvbWlzZSA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5vbmNsb3NlPy4oKTtcbiAgICAgICAgdGhpcy5jbG9zZUFsbFN1YnNjcmlwdGlvbnMoXCJyZWxheSBjb25uZWN0aW9uIHRpbWVkIG91dFwiKTtcbiAgICAgIH0sIHRoaXMuY29ubmVjdGlvblRpbWVvdXQpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy53cyA9IG5ldyBfV2ViU29ja2V0KHRoaXMudXJsKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy53cy5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5lY3Rpb25UaW1lb3V0SGFuZGxlKTtcbiAgICAgICAgdGhpcy5fY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfTtcbiAgICAgIHRoaXMud3Mub25lcnJvciA9IChldikgPT4ge1xuICAgICAgICByZWplY3QoZXYubWVzc2FnZSk7XG4gICAgICAgIGlmICh0aGlzLl9jb25uZWN0ZWQpIHtcbiAgICAgICAgICB0aGlzLm9uY2xvc2U/LigpO1xuICAgICAgICAgIHRoaXMuY2xvc2VBbGxTdWJzY3JpcHRpb25zKFwicmVsYXkgY29ubmVjdGlvbiBlcnJvcmVkXCIpO1xuICAgICAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy53cy5vbmNsb3NlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlID0gdm9pZCAwO1xuICAgICAgICB0aGlzLm9uY2xvc2U/LigpO1xuICAgICAgICB0aGlzLmNsb3NlQWxsU3Vic2NyaXB0aW9ucyhcInJlbGF5IGNvbm5lY3Rpb24gY2xvc2VkXCIpO1xuICAgICAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgIH07XG4gICAgICB0aGlzLndzLm9ubWVzc2FnZSA9IHRoaXMuX29ubWVzc2FnZS5iaW5kKHRoaXMpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlO1xuICB9XG4gIGFzeW5jIHJ1blF1ZXVlKCkge1xuICAgIHRoaXMucXVldWVSdW5uaW5nID0gdHJ1ZTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKGZhbHNlID09PSB0aGlzLmhhbmRsZU5leHQoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGF3YWl0IHlpZWxkVGhyZWFkKCk7XG4gICAgfVxuICAgIHRoaXMucXVldWVSdW5uaW5nID0gZmFsc2U7XG4gIH1cbiAgaGFuZGxlTmV4dCgpIHtcbiAgICBjb25zdCBqc29uID0gdGhpcy5pbmNvbWluZ01lc3NhZ2VRdWV1ZS5kZXF1ZXVlKCk7XG4gICAgaWYgKCFqc29uKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHN1YmlkID0gZ2V0U3Vic2NyaXB0aW9uSWQoanNvbik7XG4gICAgaWYgKHN1YmlkKSB7XG4gICAgICBjb25zdCBzbyA9IHRoaXMub3BlblN1YnMuZ2V0KHN1YmlkKTtcbiAgICAgIGlmICghc28pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaWQgPSBnZXRIZXg2NChqc29uLCBcImlkXCIpO1xuICAgICAgY29uc3QgYWxyZWFkeUhhdmUgPSBzby5hbHJlYWR5SGF2ZUV2ZW50Py4oaWQpO1xuICAgICAgc28ucmVjZWl2ZWRFdmVudD8uKHRoaXMsIGlkKTtcbiAgICAgIGlmIChhbHJlYWR5SGF2ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBsZXQgZGF0YSA9IEpTT04ucGFyc2UoanNvbik7XG4gICAgICBzd2l0Y2ggKGRhdGFbMF0pIHtcbiAgICAgICAgY2FzZSBcIkVWRU5UXCI6IHtcbiAgICAgICAgICBjb25zdCBzbyA9IHRoaXMub3BlblN1YnMuZ2V0KGRhdGFbMV0pO1xuICAgICAgICAgIGNvbnN0IGV2ZW50ID0gZGF0YVsyXTtcbiAgICAgICAgICBpZiAodGhpcy52ZXJpZnlFdmVudChldmVudCkgJiYgbWF0Y2hGaWx0ZXJzKHNvLmZpbHRlcnMsIGV2ZW50KSkge1xuICAgICAgICAgICAgc28ub25ldmVudChldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiQ09VTlRcIjoge1xuICAgICAgICAgIGNvbnN0IGlkID0gZGF0YVsxXTtcbiAgICAgICAgICBjb25zdCBwYXlsb2FkID0gZGF0YVsyXTtcbiAgICAgICAgICBjb25zdCBjciA9IHRoaXMub3BlbkNvdW50UmVxdWVzdHMuZ2V0KGlkKTtcbiAgICAgICAgICBpZiAoY3IpIHtcbiAgICAgICAgICAgIGNyLnJlc29sdmUocGF5bG9hZC5jb3VudCk7XG4gICAgICAgICAgICB0aGlzLm9wZW5Db3VudFJlcXVlc3RzLmRlbGV0ZShpZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiRU9TRVwiOiB7XG4gICAgICAgICAgY29uc3Qgc28gPSB0aGlzLm9wZW5TdWJzLmdldChkYXRhWzFdKTtcbiAgICAgICAgICBpZiAoIXNvKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIHNvLnJlY2VpdmVkRW9zZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiT0tcIjoge1xuICAgICAgICAgIGNvbnN0IGlkID0gZGF0YVsxXTtcbiAgICAgICAgICBjb25zdCBvayA9IGRhdGFbMl07XG4gICAgICAgICAgY29uc3QgcmVhc29uID0gZGF0YVszXTtcbiAgICAgICAgICBjb25zdCBlcCA9IHRoaXMub3BlbkV2ZW50UHVibGlzaGVzLmdldChpZCk7XG4gICAgICAgICAgaWYgKG9rKVxuICAgICAgICAgICAgZXAucmVzb2x2ZShyZWFzb24pO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGVwLnJlamVjdChuZXcgRXJyb3IocmVhc29uKSk7XG4gICAgICAgICAgdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMuZGVsZXRlKGlkKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIkNMT1NFRFwiOiB7XG4gICAgICAgICAgY29uc3QgaWQgPSBkYXRhWzFdO1xuICAgICAgICAgIGNvbnN0IHNvID0gdGhpcy5vcGVuU3Vicy5nZXQoaWQpO1xuICAgICAgICAgIGlmICghc28pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgc28uY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgICBzby5jbG9zZShkYXRhWzJdKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIk5PVElDRVwiOlxuICAgICAgICAgIHRoaXMub25ub3RpY2UoZGF0YVsxXSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIFwiQVVUSFwiOiB7XG4gICAgICAgICAgdGhpcy5jaGFsbGVuZ2UgPSBkYXRhWzFdO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBhc3luYyBzZW5kKG1lc3NhZ2UpIHtcbiAgICBpZiAoIXRoaXMuY29ubmVjdGlvblByb21pc2UpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzZW5kaW5nIG9uIGNsb3NlZCBjb25uZWN0aW9uXCIpO1xuICAgIHRoaXMuY29ubmVjdGlvblByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICB0aGlzLndzPy5zZW5kKG1lc3NhZ2UpO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGF1dGgoc2lnbkF1dGhFdmVudCkge1xuICAgIGlmICghdGhpcy5jaGFsbGVuZ2UpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW4ndCBwZXJmb3JtIGF1dGgsIG5vIGNoYWxsZW5nZSB3YXMgcmVjZWl2ZWRcIik7XG4gICAgY29uc3QgZXZ0ID0gYXdhaXQgc2lnbkF1dGhFdmVudChtYWtlQXV0aEV2ZW50KHRoaXMudXJsLCB0aGlzLmNoYWxsZW5nZSkpO1xuICAgIGNvbnN0IHJldCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMub3BlbkV2ZW50UHVibGlzaGVzLnNldChldnQuaWQsIHsgcmVzb2x2ZSwgcmVqZWN0IH0pO1xuICAgIH0pO1xuICAgIHRoaXMuc2VuZCgnW1wiQVVUSFwiLCcgKyBKU09OLnN0cmluZ2lmeShldnQpICsgXCJdXCIpO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgYXN5bmMgcHVibGlzaChldmVudCkge1xuICAgIGNvbnN0IHJldCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMub3BlbkV2ZW50UHVibGlzaGVzLnNldChldmVudC5pZCwgeyByZXNvbHZlLCByZWplY3QgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5zZW5kKCdbXCJFVkVOVFwiLCcgKyBKU09OLnN0cmluZ2lmeShldmVudCkgKyBcIl1cIik7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBhc3luYyBjb3VudChmaWx0ZXJzLCBwYXJhbXMpIHtcbiAgICB0aGlzLnNlcmlhbCsrO1xuICAgIGNvbnN0IGlkID0gcGFyYW1zPy5pZCB8fCBcImNvdW50OlwiICsgdGhpcy5zZXJpYWw7XG4gICAgY29uc3QgcmV0ID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5vcGVuQ291bnRSZXF1ZXN0cy5zZXQoaWQsIHsgcmVzb2x2ZSwgcmVqZWN0IH0pO1xuICAgIH0pO1xuICAgIHRoaXMuc2VuZCgnW1wiQ09VTlRcIixcIicgKyBpZCArICdcIiwnICsgSlNPTi5zdHJpbmdpZnkoZmlsdGVycykgKyBcIl1cIik7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBzdWJzY3JpYmUoZmlsdGVycywgcGFyYW1zKSB7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gdGhpcy5wcmVwYXJlU3Vic2NyaXB0aW9uKGZpbHRlcnMsIHBhcmFtcyk7XG4gICAgc3Vic2NyaXB0aW9uLmZpcmUoKTtcbiAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICB9XG4gIHByZXBhcmVTdWJzY3JpcHRpb24oZmlsdGVycywgcGFyYW1zKSB7XG4gICAgdGhpcy5zZXJpYWwrKztcbiAgICBjb25zdCBpZCA9IHBhcmFtcy5pZCB8fCBcInN1YjpcIiArIHRoaXMuc2VyaWFsO1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24odGhpcywgaWQsIGZpbHRlcnMsIHBhcmFtcyk7XG4gICAgdGhpcy5vcGVuU3Vicy5zZXQoaWQsIHN1YnNjcmlwdGlvbik7XG4gICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgfVxuICBjbG9zZSgpIHtcbiAgICB0aGlzLmNsb3NlQWxsU3Vic2NyaXB0aW9ucyhcInJlbGF5IGNvbm5lY3Rpb24gY2xvc2VkIGJ5IHVzXCIpO1xuICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMud3M/LmNsb3NlKCk7XG4gIH1cbiAgX29ubWVzc2FnZShldikge1xuICAgIHRoaXMuaW5jb21pbmdNZXNzYWdlUXVldWUuZW5xdWV1ZShldi5kYXRhKTtcbiAgICBpZiAoIXRoaXMucXVldWVSdW5uaW5nKSB7XG4gICAgICB0aGlzLnJ1blF1ZXVlKCk7XG4gICAgfVxuICB9XG59O1xudmFyIFN1YnNjcmlwdGlvbiA9IGNsYXNzIHtcbiAgcmVsYXk7XG4gIGlkO1xuICBjbG9zZWQgPSBmYWxzZTtcbiAgZW9zZWQgPSBmYWxzZTtcbiAgZmlsdGVycztcbiAgYWxyZWFkeUhhdmVFdmVudDtcbiAgcmVjZWl2ZWRFdmVudDtcbiAgb25ldmVudDtcbiAgb25lb3NlO1xuICBvbmNsb3NlO1xuICBlb3NlVGltZW91dDtcbiAgZW9zZVRpbWVvdXRIYW5kbGU7XG4gIGNvbnN0cnVjdG9yKHJlbGF5LCBpZCwgZmlsdGVycywgcGFyYW1zKSB7XG4gICAgdGhpcy5yZWxheSA9IHJlbGF5O1xuICAgIHRoaXMuZmlsdGVycyA9IGZpbHRlcnM7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuYWxyZWFkeUhhdmVFdmVudCA9IHBhcmFtcy5hbHJlYWR5SGF2ZUV2ZW50O1xuICAgIHRoaXMucmVjZWl2ZWRFdmVudCA9IHBhcmFtcy5yZWNlaXZlZEV2ZW50O1xuICAgIHRoaXMuZW9zZVRpbWVvdXQgPSBwYXJhbXMuZW9zZVRpbWVvdXQgfHwgcmVsYXkuYmFzZUVvc2VUaW1lb3V0O1xuICAgIHRoaXMub25lb3NlID0gcGFyYW1zLm9uZW9zZTtcbiAgICB0aGlzLm9uY2xvc2UgPSBwYXJhbXMub25jbG9zZTtcbiAgICB0aGlzLm9uZXZlbnQgPSBwYXJhbXMub25ldmVudCB8fCAoKGV2ZW50KSA9PiB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBvbmV2ZW50KCkgY2FsbGJhY2sgbm90IGRlZmluZWQgZm9yIHN1YnNjcmlwdGlvbiAnJHt0aGlzLmlkfScgaW4gcmVsYXkgJHt0aGlzLnJlbGF5LnVybH0uIGV2ZW50IHJlY2VpdmVkOmAsXG4gICAgICAgIGV2ZW50XG4gICAgICApO1xuICAgIH0pO1xuICB9XG4gIGZpcmUoKSB7XG4gICAgdGhpcy5yZWxheS5zZW5kKCdbXCJSRVFcIixcIicgKyB0aGlzLmlkICsgJ1wiLCcgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmZpbHRlcnMpLnN1YnN0cmluZygxKSk7XG4gICAgdGhpcy5lb3NlVGltZW91dEhhbmRsZSA9IHNldFRpbWVvdXQodGhpcy5yZWNlaXZlZEVvc2UuYmluZCh0aGlzKSwgdGhpcy5lb3NlVGltZW91dCk7XG4gIH1cbiAgcmVjZWl2ZWRFb3NlKCkge1xuICAgIGlmICh0aGlzLmVvc2VkKVxuICAgICAgcmV0dXJuO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmVvc2VUaW1lb3V0SGFuZGxlKTtcbiAgICB0aGlzLmVvc2VkID0gdHJ1ZTtcbiAgICB0aGlzLm9uZW9zZT8uKCk7XG4gIH1cbiAgY2xvc2UocmVhc29uID0gXCJjbG9zZWQgYnkgY2FsbGVyXCIpIHtcbiAgICBpZiAoIXRoaXMuY2xvc2VkKSB7XG4gICAgICB0aGlzLnJlbGF5LnNlbmQoJ1tcIkNMT1NFXCIsJyArIEpTT04uc3RyaW5naWZ5KHRoaXMuaWQpICsgXCJdXCIpO1xuICAgICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLnJlbGF5Lm9wZW5TdWJzLmRlbGV0ZSh0aGlzLmlkKTtcbiAgICB0aGlzLm9uY2xvc2U/LihyZWFzb24pO1xuICB9XG59O1xuXG4vLyByZWxheS50c1xuZnVuY3Rpb24gcmVsYXlDb25uZWN0KHVybCkge1xuICByZXR1cm4gUmVsYXkuY29ubmVjdCh1cmwpO1xufVxudmFyIFJlbGF5ID0gY2xhc3MgZXh0ZW5kcyBBYnN0cmFjdFJlbGF5IHtcbiAgY29uc3RydWN0b3IodXJsKSB7XG4gICAgc3VwZXIodXJsLCB7IHZlcmlmeUV2ZW50IH0pO1xuICB9XG4gIHN0YXRpYyBhc3luYyBjb25uZWN0KHVybCkge1xuICAgIGNvbnN0IHJlbGF5ID0gbmV3IFJlbGF5KHVybCk7XG4gICAgYXdhaXQgcmVsYXkuY29ubmVjdCgpO1xuICAgIHJldHVybiByZWxheTtcbiAgfVxufTtcbmV4cG9ydCB7XG4gIEFic3RyYWN0UmVsYXksXG4gIFJlbGF5LFxuICBTdWJzY3JpcHRpb24sXG4gIHJlbGF5Q29ubmVjdCxcbiAgdXNlV2ViU29ja2V0SW1wbGVtZW50YXRpb25cbn07XG4iLCAiLy8gVW5pcXVlIElEIGNyZWF0aW9uIHJlcXVpcmVzIGEgaGlnaCBxdWFsaXR5IHJhbmRvbSAjIGdlbmVyYXRvci4gSW4gdGhlIGJyb3dzZXIgd2UgdGhlcmVmb3JlXG4vLyByZXF1aXJlIHRoZSBjcnlwdG8gQVBJIGFuZCBkbyBub3Qgc3VwcG9ydCBidWlsdC1pbiBmYWxsYmFjayB0byBsb3dlciBxdWFsaXR5IHJhbmRvbSBudW1iZXJcbi8vIGdlbmVyYXRvcnMgKGxpa2UgTWF0aC5yYW5kb20oKSkuXG5sZXQgZ2V0UmFuZG9tVmFsdWVzO1xuY29uc3Qgcm5kczggPSBuZXcgVWludDhBcnJheSgxNik7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBybmcoKSB7XG4gIC8vIGxhenkgbG9hZCBzbyB0aGF0IGVudmlyb25tZW50cyB0aGF0IG5lZWQgdG8gcG9seWZpbGwgaGF2ZSBhIGNoYW5jZSB0byBkbyBzb1xuICBpZiAoIWdldFJhbmRvbVZhbHVlcykge1xuICAgIC8vIGdldFJhbmRvbVZhbHVlcyBuZWVkcyB0byBiZSBpbnZva2VkIGluIGEgY29udGV4dCB3aGVyZSBcInRoaXNcIiBpcyBhIENyeXB0byBpbXBsZW1lbnRhdGlvbi5cbiAgICBnZXRSYW5kb21WYWx1ZXMgPSB0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChjcnlwdG8pO1xuXG4gICAgaWYgKCFnZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY3J5cHRvLmdldFJhbmRvbVZhbHVlcygpIG5vdCBzdXBwb3J0ZWQuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQjZ2V0cmFuZG9tdmFsdWVzLW5vdC1zdXBwb3J0ZWQnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZ2V0UmFuZG9tVmFsdWVzKHJuZHM4KTtcbn0iLCAiaW1wb3J0IHZhbGlkYXRlIGZyb20gJy4vdmFsaWRhdGUuanMnO1xuLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzIHRvIFVVSUQgc3RyaW5nIGZvcm1hdCBvZiB0aGUgZm9ybTpcbiAqIFhYWFhYWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFxuICovXG5cbmNvbnN0IGJ5dGVUb0hleCA9IFtdO1xuXG5mb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gIGJ5dGVUb0hleC5wdXNoKChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zbGljZSgxKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bnNhZmVTdHJpbmdpZnkoYXJyLCBvZmZzZXQgPSAwKSB7XG4gIC8vIE5vdGU6IEJlIGNhcmVmdWwgZWRpdGluZyB0aGlzIGNvZGUhICBJdCdzIGJlZW4gdHVuZWQgZm9yIHBlcmZvcm1hbmNlXG4gIC8vIGFuZCB3b3JrcyBpbiB3YXlzIHlvdSBtYXkgbm90IGV4cGVjdC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZC9wdWxsLzQzNFxuICByZXR1cm4gKGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDJdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgM11dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDVdXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA3XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDhdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMV1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxM11dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxNF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxNV1dKS50b0xvd2VyQ2FzZSgpO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnkoYXJyLCBvZmZzZXQgPSAwKSB7XG4gIGNvbnN0IHV1aWQgPSB1bnNhZmVTdHJpbmdpZnkoYXJyLCBvZmZzZXQpOyAvLyBDb25zaXN0ZW5jeSBjaGVjayBmb3IgdmFsaWQgVVVJRC4gIElmIHRoaXMgdGhyb3dzLCBpdCdzIGxpa2VseSBkdWUgdG8gb25lXG4gIC8vIG9mIHRoZSBmb2xsb3dpbmc6XG4gIC8vIC0gT25lIG9yIG1vcmUgaW5wdXQgYXJyYXkgdmFsdWVzIGRvbid0IG1hcCB0byBhIGhleCBvY3RldCAobGVhZGluZyB0b1xuICAvLyBcInVuZGVmaW5lZFwiIGluIHRoZSB1dWlkKVxuICAvLyAtIEludmFsaWQgaW5wdXQgdmFsdWVzIGZvciB0aGUgUkZDIGB2ZXJzaW9uYCBvciBgdmFyaWFudGAgZmllbGRzXG5cbiAgaWYgKCF2YWxpZGF0ZSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignU3RyaW5naWZpZWQgVVVJRCBpcyBpbnZhbGlkJyk7XG4gIH1cblxuICByZXR1cm4gdXVpZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3RyaW5naWZ5OyIsICJjb25zdCByYW5kb21VVUlEID0gdHlwZW9mIGNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLnJhbmRvbVVVSUQgJiYgY3J5cHRvLnJhbmRvbVVVSUQuYmluZChjcnlwdG8pO1xuZXhwb3J0IGRlZmF1bHQge1xuICByYW5kb21VVUlEXG59OyIsICJpbXBvcnQgbmF0aXZlIGZyb20gJy4vbmF0aXZlLmpzJztcbmltcG9ydCBybmcgZnJvbSAnLi9ybmcuanMnO1xuaW1wb3J0IHsgdW5zYWZlU3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuXG5mdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICBpZiAobmF0aXZlLnJhbmRvbVVVSUQgJiYgIWJ1ZiAmJiAhb3B0aW9ucykge1xuICAgIHJldHVybiBuYXRpdmUucmFuZG9tVVVJRCgpO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IHJuZHMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgcm5nKSgpOyAvLyBQZXIgNC40LCBzZXQgYml0cyBmb3IgdmVyc2lvbiBhbmQgYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgXG5cbiAgcm5kc1s2XSA9IHJuZHNbNl0gJiAweDBmIHwgMHg0MDtcbiAgcm5kc1s4XSA9IHJuZHNbOF0gJiAweDNmIHwgMHg4MDsgLy8gQ29weSBieXRlcyB0byBidWZmZXIsIGlmIHByb3ZpZGVkXG5cbiAgaWYgKGJ1Zikge1xuICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICBidWZbb2Zmc2V0ICsgaV0gPSBybmRzW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBidWY7XG4gIH1cblxuICByZXR1cm4gdW5zYWZlU3RyaW5naWZ5KHJuZHMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2NDsiLCAiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBiaW5kKGZuLCB0aGlzQXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKCkge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHMpO1xuICB9O1xufVxuIiwgIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IGJpbmQgZnJvbSAnLi9oZWxwZXJzL2JpbmQuanMnO1xuXG4vLyB1dGlscyBpcyBhIGxpYnJhcnkgb2YgZ2VuZXJpYyBoZWxwZXIgZnVuY3Rpb25zIG5vbi1zcGVjaWZpYyB0byBheGlvc1xuXG5jb25zdCB7dG9TdHJpbmd9ID0gT2JqZWN0LnByb3RvdHlwZTtcbmNvbnN0IHtnZXRQcm90b3R5cGVPZn0gPSBPYmplY3Q7XG5cbmNvbnN0IGtpbmRPZiA9IChjYWNoZSA9PiB0aGluZyA9PiB7XG4gICAgY29uc3Qgc3RyID0gdG9TdHJpbmcuY2FsbCh0aGluZyk7XG4gICAgcmV0dXJuIGNhY2hlW3N0cl0gfHwgKGNhY2hlW3N0cl0gPSBzdHIuc2xpY2UoOCwgLTEpLnRvTG93ZXJDYXNlKCkpO1xufSkoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG5cbmNvbnN0IGtpbmRPZlRlc3QgPSAodHlwZSkgPT4ge1xuICB0eXBlID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gKHRoaW5nKSA9PiBraW5kT2YodGhpbmcpID09PSB0eXBlXG59XG5cbmNvbnN0IHR5cGVPZlRlc3QgPSB0eXBlID0+IHRoaW5nID0+IHR5cGVvZiB0aGluZyA9PT0gdHlwZTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IHtpc0FycmF5fSA9IEFycmF5O1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIHVuZGVmaW5lZFxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIGlzIHVuZGVmaW5lZCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzVW5kZWZpbmVkID0gdHlwZU9mVGVzdCgndW5kZWZpbmVkJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCdWZmZXJcbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNCdWZmZXIodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgIWlzVW5kZWZpbmVkKHZhbCkgJiYgdmFsLmNvbnN0cnVjdG9yICE9PSBudWxsICYmICFpc1VuZGVmaW5lZCh2YWwuY29uc3RydWN0b3IpXG4gICAgJiYgaXNGdW5jdGlvbih2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIpICYmIHZhbC5jb25zdHJ1Y3Rvci5pc0J1ZmZlcih2YWwpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzQXJyYXlCdWZmZXIgPSBraW5kT2ZUZXN0KCdBcnJheUJ1ZmZlcicpO1xuXG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyh2YWwpIHtcbiAgbGV0IHJlc3VsdDtcbiAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnKSAmJiAoQXJyYXlCdWZmZXIuaXNWaWV3KSkge1xuICAgIHJlc3VsdCA9IEFycmF5QnVmZmVyLmlzVmlldyh2YWwpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9ICh2YWwpICYmICh2YWwuYnVmZmVyKSAmJiAoaXNBcnJheUJ1ZmZlcih2YWwuYnVmZmVyKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmluZ1xuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJpbmcsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc1N0cmluZyA9IHR5cGVPZlRlc3QoJ3N0cmluZycpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGdW5jdGlvbiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzRnVuY3Rpb24gPSB0eXBlT2ZUZXN0KCdmdW5jdGlvbicpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgTnVtYmVyXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIE51bWJlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzTnVtYmVyID0gdHlwZU9mVGVzdCgnbnVtYmVyJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gT2JqZWN0XG4gKlxuICogQHBhcmFtIHsqfSB0aGluZyBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIE9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzT2JqZWN0ID0gKHRoaW5nKSA9PiB0aGluZyAhPT0gbnVsbCAmJiB0eXBlb2YgdGhpbmcgPT09ICdvYmplY3QnO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQm9vbGVhblxuICpcbiAqIEBwYXJhbSB7Kn0gdGhpbmcgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQm9vbGVhbiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmNvbnN0IGlzQm9vbGVhbiA9IHRoaW5nID0+IHRoaW5nID09PSB0cnVlIHx8IHRoaW5nID09PSBmYWxzZTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIHBsYWluIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBwbGFpbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc1BsYWluT2JqZWN0ID0gKHZhbCkgPT4ge1xuICBpZiAoa2luZE9mKHZhbCkgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgcHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YodmFsKTtcbiAgcmV0dXJuIChwcm90b3R5cGUgPT09IG51bGwgfHwgcHJvdG90eXBlID09PSBPYmplY3QucHJvdG90eXBlIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90b3R5cGUpID09PSBudWxsKSAmJiAhKFN5bWJvbC50b1N0cmluZ1RhZyBpbiB2YWwpICYmICEoU3ltYm9sLml0ZXJhdG9yIGluIHZhbCk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBEYXRlXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIERhdGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0RhdGUgPSBraW5kT2ZUZXN0KCdEYXRlJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGaWxlXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZpbGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0ZpbGUgPSBraW5kT2ZUZXN0KCdGaWxlJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCbG9iXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJsb2IsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0Jsb2IgPSBraW5kT2ZUZXN0KCdCbG9iJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGaWxlTGlzdFxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGaWxlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNGaWxlTGlzdCA9IGtpbmRPZlRlc3QoJ0ZpbGVMaXN0Jyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJlYW1cbiAqXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyZWFtLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNTdHJlYW0gPSAodmFsKSA9PiBpc09iamVjdCh2YWwpICYmIGlzRnVuY3Rpb24odmFsLnBpcGUpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRm9ybURhdGFcbiAqXG4gKiBAcGFyYW0geyp9IHRoaW5nIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gRm9ybURhdGEsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc0Zvcm1EYXRhID0gKHRoaW5nKSA9PiB7XG4gIGxldCBraW5kO1xuICByZXR1cm4gdGhpbmcgJiYgKFxuICAgICh0eXBlb2YgRm9ybURhdGEgPT09ICdmdW5jdGlvbicgJiYgdGhpbmcgaW5zdGFuY2VvZiBGb3JtRGF0YSkgfHwgKFxuICAgICAgaXNGdW5jdGlvbih0aGluZy5hcHBlbmQpICYmIChcbiAgICAgICAgKGtpbmQgPSBraW5kT2YodGhpbmcpKSA9PT0gJ2Zvcm1kYXRhJyB8fFxuICAgICAgICAvLyBkZXRlY3QgZm9ybS1kYXRhIGluc3RhbmNlXG4gICAgICAgIChraW5kID09PSAnb2JqZWN0JyAmJiBpc0Z1bmN0aW9uKHRoaW5nLnRvU3RyaW5nKSAmJiB0aGluZy50b1N0cmluZygpID09PSAnW29iamVjdCBGb3JtRGF0YV0nKVxuICAgICAgKVxuICAgIClcbiAgKVxufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuY29uc3QgaXNVUkxTZWFyY2hQYXJhbXMgPSBraW5kT2ZUZXN0KCdVUkxTZWFyY2hQYXJhbXMnKTtcblxuLyoqXG4gKiBUcmltIGV4Y2VzcyB3aGl0ZXNwYWNlIG9mZiB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBTdHJpbmcgdG8gdHJpbVxuICpcbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBTdHJpbmcgZnJlZWQgb2YgZXhjZXNzIHdoaXRlc3BhY2VcbiAqL1xuY29uc3QgdHJpbSA9IChzdHIpID0+IHN0ci50cmltID9cbiAgc3RyLnRyaW0oKSA6IHN0ci5yZXBsYWNlKC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZywgJycpO1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbiBBcnJheSBvciBhbiBPYmplY3QgaW52b2tpbmcgYSBmdW5jdGlvbiBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmIGBvYmpgIGlzIGFuIEFycmF5IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwgaW5kZXgsIGFuZCBjb21wbGV0ZSBhcnJheSBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmICdvYmonIGlzIGFuIE9iamVjdCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGtleSwgYW5kIGNvbXBsZXRlIG9iamVjdCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqIFRoZSBvYmplY3QgdG8gaXRlcmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGNhbGxiYWNrIHRvIGludm9rZSBmb3IgZWFjaCBpdGVtXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBbYWxsT3duS2V5cyA9IGZhbHNlXVxuICogQHJldHVybnMge2FueX1cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChvYmosIGZuLCB7YWxsT3duS2V5cyA9IGZhbHNlfSA9IHt9KSB7XG4gIC8vIERvbid0IGJvdGhlciBpZiBubyB2YWx1ZSBwcm92aWRlZFxuICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IGk7XG4gIGxldCBsO1xuXG4gIC8vIEZvcmNlIGFuIGFycmF5IGlmIG5vdCBhbHJlYWR5IHNvbWV0aGluZyBpdGVyYWJsZVxuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICBvYmogPSBbb2JqXTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgYXJyYXkgdmFsdWVzXG4gICAgZm9yIChpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2ldLCBpLCBvYmopO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgb2JqZWN0IGtleXNcbiAgICBjb25zdCBrZXlzID0gYWxsT3duS2V5cyA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikgOiBPYmplY3Qua2V5cyhvYmopO1xuICAgIGNvbnN0IGxlbiA9IGtleXMubGVuZ3RoO1xuICAgIGxldCBrZXk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICBmbi5jYWxsKG51bGwsIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRLZXkob2JqLCBrZXkpIHtcbiAga2V5ID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBsZXQgaSA9IGtleXMubGVuZ3RoO1xuICBsZXQgX2tleTtcbiAgd2hpbGUgKGktLSA+IDApIHtcbiAgICBfa2V5ID0ga2V5c1tpXTtcbiAgICBpZiAoa2V5ID09PSBfa2V5LnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIHJldHVybiBfa2V5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuY29uc3QgX2dsb2JhbCA9ICgoKSA9PiB7XG4gIC8qZXNsaW50IG5vLXVuZGVmOjAqL1xuICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBnbG9iYWxUaGlzO1xuICByZXR1cm4gdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsKVxufSkoKTtcblxuY29uc3QgaXNDb250ZXh0RGVmaW5lZCA9IChjb250ZXh0KSA9PiAhaXNVbmRlZmluZWQoY29udGV4dCkgJiYgY29udGV4dCAhPT0gX2dsb2JhbDtcblxuLyoqXG4gKiBBY2NlcHRzIHZhcmFyZ3MgZXhwZWN0aW5nIGVhY2ggYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0LCB0aGVuXG4gKiBpbW11dGFibHkgbWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIGVhY2ggb2JqZWN0IGFuZCByZXR1cm5zIHJlc3VsdC5cbiAqXG4gKiBXaGVuIG11bHRpcGxlIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBrZXkgdGhlIGxhdGVyIG9iamVjdCBpblxuICogdGhlIGFyZ3VtZW50cyBsaXN0IHdpbGwgdGFrZSBwcmVjZWRlbmNlLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIHZhciByZXN1bHQgPSBtZXJnZSh7Zm9vOiAxMjN9LCB7Zm9vOiA0NTZ9KTtcbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5mb28pOyAvLyBvdXRwdXRzIDQ1NlxuICogYGBgXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iajEgT2JqZWN0IHRvIG1lcmdlXG4gKlxuICogQHJldHVybnMge09iamVjdH0gUmVzdWx0IG9mIGFsbCBtZXJnZSBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIG1lcmdlKC8qIG9iajEsIG9iajIsIG9iajMsIC4uLiAqLykge1xuICBjb25zdCB7Y2FzZWxlc3N9ID0gaXNDb250ZXh0RGVmaW5lZCh0aGlzKSAmJiB0aGlzIHx8IHt9O1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgY29uc3QgYXNzaWduVmFsdWUgPSAodmFsLCBrZXkpID0+IHtcbiAgICBjb25zdCB0YXJnZXRLZXkgPSBjYXNlbGVzcyAmJiBmaW5kS2V5KHJlc3VsdCwga2V5KSB8fCBrZXk7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QocmVzdWx0W3RhcmdldEtleV0pICYmIGlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgICAgcmVzdWx0W3RhcmdldEtleV0gPSBtZXJnZShyZXN1bHRbdGFyZ2V0S2V5XSwgdmFsKTtcbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodmFsKSkge1xuICAgICAgcmVzdWx0W3RhcmdldEtleV0gPSBtZXJnZSh7fSwgdmFsKTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsKSkge1xuICAgICAgcmVzdWx0W3RhcmdldEtleV0gPSB2YWwuc2xpY2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0W3RhcmdldEtleV0gPSB2YWw7XG4gICAgfVxuICB9XG5cbiAgZm9yIChsZXQgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgYXJndW1lbnRzW2ldICYmIGZvckVhY2goYXJndW1lbnRzW2ldLCBhc3NpZ25WYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBFeHRlbmRzIG9iamVjdCBhIGJ5IG11dGFibHkgYWRkaW5nIHRvIGl0IHRoZSBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhIFRoZSBvYmplY3QgdG8gYmUgZXh0ZW5kZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBiIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzQXJnIFRoZSBvYmplY3QgdG8gYmluZCBmdW5jdGlvbiB0b1xuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2FsbE93bktleXNdXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcmVzdWx0aW5nIHZhbHVlIG9mIG9iamVjdCBhXG4gKi9cbmNvbnN0IGV4dGVuZCA9IChhLCBiLCB0aGlzQXJnLCB7YWxsT3duS2V5c309IHt9KSA9PiB7XG4gIGZvckVhY2goYiwgKHZhbCwga2V5KSA9PiB7XG4gICAgaWYgKHRoaXNBcmcgJiYgaXNGdW5jdGlvbih2YWwpKSB7XG4gICAgICBhW2tleV0gPSBiaW5kKHZhbCwgdGhpc0FyZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFba2V5XSA9IHZhbDtcbiAgICB9XG4gIH0sIHthbGxPd25LZXlzfSk7XG4gIHJldHVybiBhO1xufVxuXG4vKipcbiAqIFJlbW92ZSBieXRlIG9yZGVyIG1hcmtlci4gVGhpcyBjYXRjaGVzIEVGIEJCIEJGICh0aGUgVVRGLTggQk9NKVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50IHdpdGggQk9NXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gY29udGVudCB2YWx1ZSB3aXRob3V0IEJPTVxuICovXG5jb25zdCBzdHJpcEJPTSA9IChjb250ZW50KSA9PiB7XG4gIGlmIChjb250ZW50LmNoYXJDb2RlQXQoMCkgPT09IDB4RkVGRikge1xuICAgIGNvbnRlbnQgPSBjb250ZW50LnNsaWNlKDEpO1xuICB9XG4gIHJldHVybiBjb250ZW50O1xufVxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlclxuICogQHBhcmFtIHtmdW5jdGlvbn0gY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBbcHJvcHNdXG4gKiBAcGFyYW0ge29iamVjdH0gW2Rlc2NyaXB0b3JzXVxuICpcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5jb25zdCBpbmhlcml0cyA9IChjb25zdHJ1Y3Rvciwgc3VwZXJDb25zdHJ1Y3RvciwgcHJvcHMsIGRlc2NyaXB0b3JzKSA9PiB7XG4gIGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIGRlc2NyaXB0b3JzKTtcbiAgY29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY29uc3RydWN0b3I7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb25zdHJ1Y3RvciwgJ3N1cGVyJywge1xuICAgIHZhbHVlOiBzdXBlckNvbnN0cnVjdG9yLnByb3RvdHlwZVxuICB9KTtcbiAgcHJvcHMgJiYgT2JqZWN0LmFzc2lnbihjb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3BzKTtcbn1cblxuLyoqXG4gKiBSZXNvbHZlIG9iamVjdCB3aXRoIGRlZXAgcHJvdG90eXBlIGNoYWluIHRvIGEgZmxhdCBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2VPYmogc291cmNlIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IFtkZXN0T2JqXVxuICogQHBhcmFtIHtGdW5jdGlvbnxCb29sZWFufSBbZmlsdGVyXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Byb3BGaWx0ZXJdXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuY29uc3QgdG9GbGF0T2JqZWN0ID0gKHNvdXJjZU9iaiwgZGVzdE9iaiwgZmlsdGVyLCBwcm9wRmlsdGVyKSA9PiB7XG4gIGxldCBwcm9wcztcbiAgbGV0IGk7XG4gIGxldCBwcm9wO1xuICBjb25zdCBtZXJnZWQgPSB7fTtcblxuICBkZXN0T2JqID0gZGVzdE9iaiB8fCB7fTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVxLW51bGwsZXFlcWVxXG4gIGlmIChzb3VyY2VPYmogPT0gbnVsbCkgcmV0dXJuIGRlc3RPYmo7XG5cbiAgZG8ge1xuICAgIHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc291cmNlT2JqKTtcbiAgICBpID0gcHJvcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgICBwcm9wID0gcHJvcHNbaV07XG4gICAgICBpZiAoKCFwcm9wRmlsdGVyIHx8IHByb3BGaWx0ZXIocHJvcCwgc291cmNlT2JqLCBkZXN0T2JqKSkgJiYgIW1lcmdlZFtwcm9wXSkge1xuICAgICAgICBkZXN0T2JqW3Byb3BdID0gc291cmNlT2JqW3Byb3BdO1xuICAgICAgICBtZXJnZWRbcHJvcF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBzb3VyY2VPYmogPSBmaWx0ZXIgIT09IGZhbHNlICYmIGdldFByb3RvdHlwZU9mKHNvdXJjZU9iaik7XG4gIH0gd2hpbGUgKHNvdXJjZU9iaiAmJiAoIWZpbHRlciB8fCBmaWx0ZXIoc291cmNlT2JqLCBkZXN0T2JqKSkgJiYgc291cmNlT2JqICE9PSBPYmplY3QucHJvdG90eXBlKTtcblxuICByZXR1cm4gZGVzdE9iajtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBzdHJpbmcgZW5kcyB3aXRoIHRoZSBjaGFyYWN0ZXJzIG9mIGEgc3BlY2lmaWVkIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWFyY2hTdHJpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBbcG9zaXRpb249IDBdXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGVuZHNXaXRoID0gKHN0ciwgc2VhcmNoU3RyaW5nLCBwb3NpdGlvbikgPT4ge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQgfHwgcG9zaXRpb24gPiBzdHIubGVuZ3RoKSB7XG4gICAgcG9zaXRpb24gPSBzdHIubGVuZ3RoO1xuICB9XG4gIHBvc2l0aW9uIC09IHNlYXJjaFN0cmluZy5sZW5ndGg7XG4gIGNvbnN0IGxhc3RJbmRleCA9IHN0ci5pbmRleE9mKHNlYXJjaFN0cmluZywgcG9zaXRpb24pO1xuICByZXR1cm4gbGFzdEluZGV4ICE9PSAtMSAmJiBsYXN0SW5kZXggPT09IHBvc2l0aW9uO1xufVxuXG5cbi8qKlxuICogUmV0dXJucyBuZXcgYXJyYXkgZnJvbSBhcnJheSBsaWtlIG9iamVjdCBvciBudWxsIGlmIGZhaWxlZFxuICpcbiAqIEBwYXJhbSB7Kn0gW3RoaW5nXVxuICpcbiAqIEByZXR1cm5zIHs/QXJyYXl9XG4gKi9cbmNvbnN0IHRvQXJyYXkgPSAodGhpbmcpID0+IHtcbiAgaWYgKCF0aGluZykgcmV0dXJuIG51bGw7XG4gIGlmIChpc0FycmF5KHRoaW5nKSkgcmV0dXJuIHRoaW5nO1xuICBsZXQgaSA9IHRoaW5nLmxlbmd0aDtcbiAgaWYgKCFpc051bWJlcihpKSkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IGFyciA9IG5ldyBBcnJheShpKTtcbiAgd2hpbGUgKGktLSA+IDApIHtcbiAgICBhcnJbaV0gPSB0aGluZ1tpXTtcbiAgfVxuICByZXR1cm4gYXJyO1xufVxuXG4vKipcbiAqIENoZWNraW5nIGlmIHRoZSBVaW50OEFycmF5IGV4aXN0cyBhbmQgaWYgaXQgZG9lcywgaXQgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmIHRoZVxuICogdGhpbmcgcGFzc2VkIGluIGlzIGFuIGluc3RhbmNlIG9mIFVpbnQ4QXJyYXlcbiAqXG4gKiBAcGFyYW0ge1R5cGVkQXJyYXl9XG4gKlxuICogQHJldHVybnMge0FycmF5fVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuY29uc3QgaXNUeXBlZEFycmF5ID0gKFR5cGVkQXJyYXkgPT4ge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICByZXR1cm4gdGhpbmcgPT4ge1xuICAgIHJldHVybiBUeXBlZEFycmF5ICYmIHRoaW5nIGluc3RhbmNlb2YgVHlwZWRBcnJheTtcbiAgfTtcbn0pKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiBnZXRQcm90b3R5cGVPZihVaW50OEFycmF5KSk7XG5cbi8qKlxuICogRm9yIGVhY2ggZW50cnkgaW4gdGhlIG9iamVjdCwgY2FsbCB0aGUgZnVuY3Rpb24gd2l0aCB0aGUga2V5IGFuZCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdDxhbnksIGFueT59IG9iaiAtIFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBlbnRyeS5cbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuY29uc3QgZm9yRWFjaEVudHJ5ID0gKG9iaiwgZm4pID0+IHtcbiAgY29uc3QgZ2VuZXJhdG9yID0gb2JqICYmIG9ialtTeW1ib2wuaXRlcmF0b3JdO1xuXG4gIGNvbnN0IGl0ZXJhdG9yID0gZ2VuZXJhdG9yLmNhbGwob2JqKTtcblxuICBsZXQgcmVzdWx0O1xuXG4gIHdoaWxlICgocmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpKSAmJiAhcmVzdWx0LmRvbmUpIHtcbiAgICBjb25zdCBwYWlyID0gcmVzdWx0LnZhbHVlO1xuICAgIGZuLmNhbGwob2JqLCBwYWlyWzBdLCBwYWlyWzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIEl0IHRha2VzIGEgcmVndWxhciBleHByZXNzaW9uIGFuZCBhIHN0cmluZywgYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgYWxsIHRoZSBtYXRjaGVzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJlZ0V4cCAtIFRoZSByZWd1bGFyIGV4cHJlc3Npb24gdG8gbWF0Y2ggYWdhaW5zdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBUaGUgc3RyaW5nIHRvIHNlYXJjaC5cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXk8Ym9vbGVhbj59XG4gKi9cbmNvbnN0IG1hdGNoQWxsID0gKHJlZ0V4cCwgc3RyKSA9PiB7XG4gIGxldCBtYXRjaGVzO1xuICBjb25zdCBhcnIgPSBbXTtcblxuICB3aGlsZSAoKG1hdGNoZXMgPSByZWdFeHAuZXhlYyhzdHIpKSAhPT0gbnVsbCkge1xuICAgIGFyci5wdXNoKG1hdGNoZXMpO1xuICB9XG5cbiAgcmV0dXJuIGFycjtcbn1cblxuLyogQ2hlY2tpbmcgaWYgdGhlIGtpbmRPZlRlc3QgZnVuY3Rpb24gcmV0dXJucyB0cnVlIHdoZW4gcGFzc2VkIGFuIEhUTUxGb3JtRWxlbWVudC4gKi9cbmNvbnN0IGlzSFRNTEZvcm0gPSBraW5kT2ZUZXN0KCdIVE1MRm9ybUVsZW1lbnQnKTtcblxuY29uc3QgdG9DYW1lbENhc2UgPSBzdHIgPT4ge1xuICByZXR1cm4gc3RyLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvWy1fXFxzXShbYS16XFxkXSkoXFx3KikvZyxcbiAgICBmdW5jdGlvbiByZXBsYWNlcihtLCBwMSwgcDIpIHtcbiAgICAgIHJldHVybiBwMS50b1VwcGVyQ2FzZSgpICsgcDI7XG4gICAgfVxuICApO1xufTtcblxuLyogQ3JlYXRpbmcgYSBmdW5jdGlvbiB0aGF0IHdpbGwgY2hlY2sgaWYgYW4gb2JqZWN0IGhhcyBhIHByb3BlcnR5LiAqL1xuY29uc3QgaGFzT3duUHJvcGVydHkgPSAoKHtoYXNPd25Qcm9wZXJ0eX0pID0+IChvYmosIHByb3ApID0+IGhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkoT2JqZWN0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBSZWdFeHAgb2JqZWN0XG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFJlZ0V4cCBvYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5jb25zdCBpc1JlZ0V4cCA9IGtpbmRPZlRlc3QoJ1JlZ0V4cCcpO1xuXG5jb25zdCByZWR1Y2VEZXNjcmlwdG9ycyA9IChvYmosIHJlZHVjZXIpID0+IHtcbiAgY29uc3QgZGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmopO1xuICBjb25zdCByZWR1Y2VkRGVzY3JpcHRvcnMgPSB7fTtcblxuICBmb3JFYWNoKGRlc2NyaXB0b3JzLCAoZGVzY3JpcHRvciwgbmFtZSkgPT4ge1xuICAgIGxldCByZXQ7XG4gICAgaWYgKChyZXQgPSByZWR1Y2VyKGRlc2NyaXB0b3IsIG5hbWUsIG9iaikpICE9PSBmYWxzZSkge1xuICAgICAgcmVkdWNlZERlc2NyaXB0b3JzW25hbWVdID0gcmV0IHx8IGRlc2NyaXB0b3I7XG4gICAgfVxuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhvYmosIHJlZHVjZWREZXNjcmlwdG9ycyk7XG59XG5cbi8qKlxuICogTWFrZXMgYWxsIG1ldGhvZHMgcmVhZC1vbmx5XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKi9cblxuY29uc3QgZnJlZXplTWV0aG9kcyA9IChvYmopID0+IHtcbiAgcmVkdWNlRGVzY3JpcHRvcnMob2JqLCAoZGVzY3JpcHRvciwgbmFtZSkgPT4ge1xuICAgIC8vIHNraXAgcmVzdHJpY3RlZCBwcm9wcyBpbiBzdHJpY3QgbW9kZVxuICAgIGlmIChpc0Z1bmN0aW9uKG9iaikgJiYgWydhcmd1bWVudHMnLCAnY2FsbGVyJywgJ2NhbGxlZSddLmluZGV4T2YobmFtZSkgIT09IC0xKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgdmFsdWUgPSBvYmpbbmFtZV07XG5cbiAgICBpZiAoIWlzRnVuY3Rpb24odmFsdWUpKSByZXR1cm47XG5cbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBmYWxzZTtcblxuICAgIGlmICgnd3JpdGFibGUnIGluIGRlc2NyaXB0b3IpIHtcbiAgICAgIGRlc2NyaXB0b3Iud3JpdGFibGUgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWRlc2NyaXB0b3Iuc2V0KSB7XG4gICAgICBkZXNjcmlwdG9yLnNldCA9ICgpID0+IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0NhbiBub3QgcmV3cml0ZSByZWFkLW9ubHkgbWV0aG9kIFxcJycgKyBuYW1lICsgJ1xcJycpO1xuICAgICAgfTtcbiAgICB9XG4gIH0pO1xufVxuXG5jb25zdCB0b09iamVjdFNldCA9IChhcnJheU9yU3RyaW5nLCBkZWxpbWl0ZXIpID0+IHtcbiAgY29uc3Qgb2JqID0ge307XG5cbiAgY29uc3QgZGVmaW5lID0gKGFycikgPT4ge1xuICAgIGFyci5mb3JFYWNoKHZhbHVlID0+IHtcbiAgICAgIG9ialt2YWx1ZV0gPSB0cnVlO1xuICAgIH0pO1xuICB9XG5cbiAgaXNBcnJheShhcnJheU9yU3RyaW5nKSA/IGRlZmluZShhcnJheU9yU3RyaW5nKSA6IGRlZmluZShTdHJpbmcoYXJyYXlPclN0cmluZykuc3BsaXQoZGVsaW1pdGVyKSk7XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuY29uc3Qgbm9vcCA9ICgpID0+IHt9XG5cbmNvbnN0IHRvRmluaXRlTnVtYmVyID0gKHZhbHVlLCBkZWZhdWx0VmFsdWUpID0+IHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIHJldHVybiBOdW1iZXIuaXNGaW5pdGUodmFsdWUpID8gdmFsdWUgOiBkZWZhdWx0VmFsdWU7XG59XG5cbmNvbnN0IEFMUEhBID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6J1xuXG5jb25zdCBESUdJVCA9ICcwMTIzNDU2Nzg5JztcblxuY29uc3QgQUxQSEFCRVQgPSB7XG4gIERJR0lULFxuICBBTFBIQSxcbiAgQUxQSEFfRElHSVQ6IEFMUEhBICsgQUxQSEEudG9VcHBlckNhc2UoKSArIERJR0lUXG59XG5cbmNvbnN0IGdlbmVyYXRlU3RyaW5nID0gKHNpemUgPSAxNiwgYWxwaGFiZXQgPSBBTFBIQUJFVC5BTFBIQV9ESUdJVCkgPT4ge1xuICBsZXQgc3RyID0gJyc7XG4gIGNvbnN0IHtsZW5ndGh9ID0gYWxwaGFiZXQ7XG4gIHdoaWxlIChzaXplLS0pIHtcbiAgICBzdHIgKz0gYWxwaGFiZXRbTWF0aC5yYW5kb20oKSAqIGxlbmd0aHwwXVxuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn1cblxuLyoqXG4gKiBJZiB0aGUgdGhpbmcgaXMgYSBGb3JtRGF0YSBvYmplY3QsIHJldHVybiB0cnVlLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxuICpcbiAqIEBwYXJhbSB7dW5rbm93bn0gdGhpbmcgLSBUaGUgdGhpbmcgdG8gY2hlY2suXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzU3BlY0NvbXBsaWFudEZvcm0odGhpbmcpIHtcbiAgcmV0dXJuICEhKHRoaW5nICYmIGlzRnVuY3Rpb24odGhpbmcuYXBwZW5kKSAmJiB0aGluZ1tTeW1ib2wudG9TdHJpbmdUYWddID09PSAnRm9ybURhdGEnICYmIHRoaW5nW1N5bWJvbC5pdGVyYXRvcl0pO1xufVxuXG5jb25zdCB0b0pTT05PYmplY3QgPSAob2JqKSA9PiB7XG4gIGNvbnN0IHN0YWNrID0gbmV3IEFycmF5KDEwKTtcblxuICBjb25zdCB2aXNpdCA9IChzb3VyY2UsIGkpID0+IHtcblxuICAgIGlmIChpc09iamVjdChzb3VyY2UpKSB7XG4gICAgICBpZiAoc3RhY2suaW5kZXhPZihzb3VyY2UpID49IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZighKCd0b0pTT04nIGluIHNvdXJjZSkpIHtcbiAgICAgICAgc3RhY2tbaV0gPSBzb3VyY2U7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGlzQXJyYXkoc291cmNlKSA/IFtdIDoge307XG5cbiAgICAgICAgZm9yRWFjaChzb3VyY2UsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVkdWNlZFZhbHVlID0gdmlzaXQodmFsdWUsIGkgKyAxKTtcbiAgICAgICAgICAhaXNVbmRlZmluZWQocmVkdWNlZFZhbHVlKSAmJiAodGFyZ2V0W2tleV0gPSByZWR1Y2VkVmFsdWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBzdGFja1tpXSA9IHVuZGVmaW5lZDtcblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cblxuICByZXR1cm4gdmlzaXQob2JqLCAwKTtcbn1cblxuY29uc3QgaXNBc3luY0ZuID0ga2luZE9mVGVzdCgnQXN5bmNGdW5jdGlvbicpO1xuXG5jb25zdCBpc1RoZW5hYmxlID0gKHRoaW5nKSA9PlxuICB0aGluZyAmJiAoaXNPYmplY3QodGhpbmcpIHx8IGlzRnVuY3Rpb24odGhpbmcpKSAmJiBpc0Z1bmN0aW9uKHRoaW5nLnRoZW4pICYmIGlzRnVuY3Rpb24odGhpbmcuY2F0Y2gpO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlzQXJyYXksXG4gIGlzQXJyYXlCdWZmZXIsXG4gIGlzQnVmZmVyLFxuICBpc0Zvcm1EYXRhLFxuICBpc0FycmF5QnVmZmVyVmlldyxcbiAgaXNTdHJpbmcsXG4gIGlzTnVtYmVyLFxuICBpc0Jvb2xlYW4sXG4gIGlzT2JqZWN0LFxuICBpc1BsYWluT2JqZWN0LFxuICBpc1VuZGVmaW5lZCxcbiAgaXNEYXRlLFxuICBpc0ZpbGUsXG4gIGlzQmxvYixcbiAgaXNSZWdFeHAsXG4gIGlzRnVuY3Rpb24sXG4gIGlzU3RyZWFtLFxuICBpc1VSTFNlYXJjaFBhcmFtcyxcbiAgaXNUeXBlZEFycmF5LFxuICBpc0ZpbGVMaXN0LFxuICBmb3JFYWNoLFxuICBtZXJnZSxcbiAgZXh0ZW5kLFxuICB0cmltLFxuICBzdHJpcEJPTSxcbiAgaW5oZXJpdHMsXG4gIHRvRmxhdE9iamVjdCxcbiAga2luZE9mLFxuICBraW5kT2ZUZXN0LFxuICBlbmRzV2l0aCxcbiAgdG9BcnJheSxcbiAgZm9yRWFjaEVudHJ5LFxuICBtYXRjaEFsbCxcbiAgaXNIVE1MRm9ybSxcbiAgaGFzT3duUHJvcGVydHksXG4gIGhhc093blByb3A6IGhhc093blByb3BlcnR5LCAvLyBhbiBhbGlhcyB0byBhdm9pZCBFU0xpbnQgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIGRldGVjdGlvblxuICByZWR1Y2VEZXNjcmlwdG9ycyxcbiAgZnJlZXplTWV0aG9kcyxcbiAgdG9PYmplY3RTZXQsXG4gIHRvQ2FtZWxDYXNlLFxuICBub29wLFxuICB0b0Zpbml0ZU51bWJlcixcbiAgZmluZEtleSxcbiAgZ2xvYmFsOiBfZ2xvYmFsLFxuICBpc0NvbnRleHREZWZpbmVkLFxuICBBTFBIQUJFVCxcbiAgZ2VuZXJhdGVTdHJpbmcsXG4gIGlzU3BlY0NvbXBsaWFudEZvcm0sXG4gIHRvSlNPTk9iamVjdCxcbiAgaXNBc3luY0ZuLFxuICBpc1RoZW5hYmxlXG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcblxuLyoqXG4gKiBDcmVhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UsIGNvbmZpZywgZXJyb3IgY29kZSwgcmVxdWVzdCBhbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RdIFRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxuICpcbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGNyZWF0ZWQgZXJyb3IuXG4gKi9cbmZ1bmN0aW9uIEF4aW9zRXJyb3IobWVzc2FnZSwgY29kZSwgY29uZmlnLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICBFcnJvci5jYWxsKHRoaXMpO1xuXG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuc3RhY2sgPSAobmV3IEVycm9yKCkpLnN0YWNrO1xuICB9XG5cbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgdGhpcy5uYW1lID0gJ0F4aW9zRXJyb3InO1xuICBjb2RlICYmICh0aGlzLmNvZGUgPSBjb2RlKTtcbiAgY29uZmlnICYmICh0aGlzLmNvbmZpZyA9IGNvbmZpZyk7XG4gIHJlcXVlc3QgJiYgKHRoaXMucmVxdWVzdCA9IHJlcXVlc3QpO1xuICByZXNwb25zZSAmJiAodGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlKTtcbn1cblxudXRpbHMuaW5oZXJpdHMoQXhpb3NFcnJvciwgRXJyb3IsIHtcbiAgdG9KU09OOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIFN0YW5kYXJkXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAvLyBNaWNyb3NvZnRcbiAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uLFxuICAgICAgbnVtYmVyOiB0aGlzLm51bWJlcixcbiAgICAgIC8vIE1vemlsbGFcbiAgICAgIGZpbGVOYW1lOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxuICAgICAgY29sdW1uTnVtYmVyOiB0aGlzLmNvbHVtbk51bWJlcixcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgLy8gQXhpb3NcbiAgICAgIGNvbmZpZzogdXRpbHMudG9KU09OT2JqZWN0KHRoaXMuY29uZmlnKSxcbiAgICAgIGNvZGU6IHRoaXMuY29kZSxcbiAgICAgIHN0YXR1czogdGhpcy5yZXNwb25zZSAmJiB0aGlzLnJlc3BvbnNlLnN0YXR1cyA/IHRoaXMucmVzcG9uc2Uuc3RhdHVzIDogbnVsbFxuICAgIH07XG4gIH1cbn0pO1xuXG5jb25zdCBwcm90b3R5cGUgPSBBeGlvc0Vycm9yLnByb3RvdHlwZTtcbmNvbnN0IGRlc2NyaXB0b3JzID0ge307XG5cbltcbiAgJ0VSUl9CQURfT1BUSU9OX1ZBTFVFJyxcbiAgJ0VSUl9CQURfT1BUSU9OJyxcbiAgJ0VDT05OQUJPUlRFRCcsXG4gICdFVElNRURPVVQnLFxuICAnRVJSX05FVFdPUksnLFxuICAnRVJSX0ZSX1RPT19NQU5ZX1JFRElSRUNUUycsXG4gICdFUlJfREVQUkVDQVRFRCcsXG4gICdFUlJfQkFEX1JFU1BPTlNFJyxcbiAgJ0VSUl9CQURfUkVRVUVTVCcsXG4gICdFUlJfQ0FOQ0VMRUQnLFxuICAnRVJSX05PVF9TVVBQT1JUJyxcbiAgJ0VSUl9JTlZBTElEX1VSTCdcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5dLmZvckVhY2goY29kZSA9PiB7XG4gIGRlc2NyaXB0b3JzW2NvZGVdID0ge3ZhbHVlOiBjb2RlfTtcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhBeGlvc0Vycm9yLCBkZXNjcmlwdG9ycyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCAnaXNBeGlvc0Vycm9yJywge3ZhbHVlOiB0cnVlfSk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5BeGlvc0Vycm9yLmZyb20gPSAoZXJyb3IsIGNvZGUsIGNvbmZpZywgcmVxdWVzdCwgcmVzcG9uc2UsIGN1c3RvbVByb3BzKSA9PiB7XG4gIGNvbnN0IGF4aW9zRXJyb3IgPSBPYmplY3QuY3JlYXRlKHByb3RvdHlwZSk7XG5cbiAgdXRpbHMudG9GbGF0T2JqZWN0KGVycm9yLCBheGlvc0Vycm9yLCBmdW5jdGlvbiBmaWx0ZXIob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPT0gRXJyb3IucHJvdG90eXBlO1xuICB9LCBwcm9wID0+IHtcbiAgICByZXR1cm4gcHJvcCAhPT0gJ2lzQXhpb3NFcnJvcic7XG4gIH0pO1xuXG4gIEF4aW9zRXJyb3IuY2FsbChheGlvc0Vycm9yLCBlcnJvci5tZXNzYWdlLCBjb2RlLCBjb25maWcsIHJlcXVlc3QsIHJlc3BvbnNlKTtcblxuICBheGlvc0Vycm9yLmNhdXNlID0gZXJyb3I7XG5cbiAgYXhpb3NFcnJvci5uYW1lID0gZXJyb3IubmFtZTtcblxuICBjdXN0b21Qcm9wcyAmJiBPYmplY3QuYXNzaWduKGF4aW9zRXJyb3IsIGN1c3RvbVByb3BzKTtcblxuICByZXR1cm4gYXhpb3NFcnJvcjtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEF4aW9zRXJyb3I7XG4iLCAiLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHN0cmljdFxuZXhwb3J0IGRlZmF1bHQgbnVsbDtcbiIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5pbXBvcnQgQXhpb3NFcnJvciBmcm9tICcuLi9jb3JlL0F4aW9zRXJyb3IuanMnO1xuLy8gdGVtcG9yYXJ5IGhvdGZpeCB0byBhdm9pZCBjaXJjdWxhciByZWZlcmVuY2VzIHVudGlsIEF4aW9zVVJMU2VhcmNoUGFyYW1zIGlzIHJlZmFjdG9yZWRcbmltcG9ydCBQbGF0Zm9ybUZvcm1EYXRhIGZyb20gJy4uL3BsYXRmb3JtL25vZGUvY2xhc3Nlcy9Gb3JtRGF0YS5qcyc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gdGhpbmcgaXMgYSBhcnJheSBvciBqcyBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRoaW5nIC0gVGhlIG9iamVjdCBvciBhcnJheSB0byBiZSB2aXNpdGVkLlxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1Zpc2l0YWJsZSh0aGluZykge1xuICByZXR1cm4gdXRpbHMuaXNQbGFpbk9iamVjdCh0aGluZykgfHwgdXRpbHMuaXNBcnJheSh0aGluZyk7XG59XG5cbi8qKlxuICogSXQgcmVtb3ZlcyB0aGUgYnJhY2tldHMgZnJvbSB0aGUgZW5kIG9mIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBrZXkgb2YgdGhlIHBhcmFtZXRlci5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUga2V5IHdpdGhvdXQgdGhlIGJyYWNrZXRzLlxuICovXG5mdW5jdGlvbiByZW1vdmVCcmFja2V0cyhrZXkpIHtcbiAgcmV0dXJuIHV0aWxzLmVuZHNXaXRoKGtleSwgJ1tdJykgPyBrZXkuc2xpY2UoMCwgLTIpIDoga2V5O1xufVxuXG4vKipcbiAqIEl0IHRha2VzIGEgcGF0aCwgYSBrZXksIGFuZCBhIGJvb2xlYW4sIGFuZCByZXR1cm5zIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggLSBUaGUgcGF0aCB0byB0aGUgY3VycmVudCBrZXkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gVGhlIGtleSBvZiB0aGUgY3VycmVudCBvYmplY3QgYmVpbmcgaXRlcmF0ZWQgb3Zlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkb3RzIC0gSWYgdHJ1ZSwgdGhlIGtleSB3aWxsIGJlIHJlbmRlcmVkIHdpdGggZG90cyBpbnN0ZWFkIG9mIGJyYWNrZXRzLlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBwYXRoIHRvIHRoZSBjdXJyZW50IGtleS5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyS2V5KHBhdGgsIGtleSwgZG90cykge1xuICBpZiAoIXBhdGgpIHJldHVybiBrZXk7XG4gIHJldHVybiBwYXRoLmNvbmNhdChrZXkpLm1hcChmdW5jdGlvbiBlYWNoKHRva2VuLCBpKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgdG9rZW4gPSByZW1vdmVCcmFja2V0cyh0b2tlbik7XG4gICAgcmV0dXJuICFkb3RzICYmIGkgPyAnWycgKyB0b2tlbiArICddJyA6IHRva2VuO1xuICB9KS5qb2luKGRvdHMgPyAnLicgOiAnJyk7XG59XG5cbi8qKlxuICogSWYgdGhlIGFycmF5IGlzIGFuIGFycmF5IGFuZCBub25lIG9mIGl0cyBlbGVtZW50cyBhcmUgdmlzaXRhYmxlLCB0aGVuIGl0J3MgYSBmbGF0IGFycmF5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gYXJyIC0gVGhlIGFycmF5IHRvIGNoZWNrXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRmxhdEFycmF5KGFycikge1xuICByZXR1cm4gdXRpbHMuaXNBcnJheShhcnIpICYmICFhcnIuc29tZShpc1Zpc2l0YWJsZSk7XG59XG5cbmNvbnN0IHByZWRpY2F0ZXMgPSB1dGlscy50b0ZsYXRPYmplY3QodXRpbHMsIHt9LCBudWxsLCBmdW5jdGlvbiBmaWx0ZXIocHJvcCkge1xuICByZXR1cm4gL15pc1tBLVpdLy50ZXN0KHByb3ApO1xufSk7XG5cbi8qKlxuICogQ29udmVydCBhIGRhdGEgb2JqZWN0IHRvIEZvcm1EYXRhXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHs/T2JqZWN0fSBbZm9ybURhdGFdXG4gKiBAcGFyYW0gez9PYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMudmlzaXRvcl1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWV0YVRva2VucyA9IHRydWVdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmRvdHMgPSBmYWxzZV1cbiAqIEBwYXJhbSB7P0Jvb2xlYW59IFtvcHRpb25zLmluZGV4ZXMgPSBmYWxzZV1cbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICoqL1xuXG4vKipcbiAqIEl0IGNvbnZlcnRzIGFuIG9iamVjdCBpbnRvIGEgRm9ybURhdGEgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3Q8YW55LCBhbnk+fSBvYmogLSBUaGUgb2JqZWN0IHRvIGNvbnZlcnQgdG8gZm9ybSBkYXRhLlxuICogQHBhcmFtIHtzdHJpbmd9IGZvcm1EYXRhIC0gVGhlIEZvcm1EYXRhIG9iamVjdCB0byBhcHBlbmQgdG8uXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiB0b0Zvcm1EYXRhKG9iaiwgZm9ybURhdGEsIG9wdGlvbnMpIHtcbiAgaWYgKCF1dGlscy5pc09iamVjdChvYmopKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGFyZ2V0IG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgZm9ybURhdGEgPSBmb3JtRGF0YSB8fCBuZXcgKFBsYXRmb3JtRm9ybURhdGEgfHwgRm9ybURhdGEpKCk7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIG9wdGlvbnMgPSB1dGlscy50b0ZsYXRPYmplY3Qob3B0aW9ucywge1xuICAgIG1ldGFUb2tlbnM6IHRydWUsXG4gICAgZG90czogZmFsc2UsXG4gICAgaW5kZXhlczogZmFsc2VcbiAgfSwgZmFsc2UsIGZ1bmN0aW9uIGRlZmluZWQob3B0aW9uLCBzb3VyY2UpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXEtbnVsbCxlcWVxZXFcbiAgICByZXR1cm4gIXV0aWxzLmlzVW5kZWZpbmVkKHNvdXJjZVtvcHRpb25dKTtcbiAgfSk7XG5cbiAgY29uc3QgbWV0YVRva2VucyA9IG9wdGlvbnMubWV0YVRva2VucztcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZS1iZWZvcmUtZGVmaW5lXG4gIGNvbnN0IHZpc2l0b3IgPSBvcHRpb25zLnZpc2l0b3IgfHwgZGVmYXVsdFZpc2l0b3I7XG4gIGNvbnN0IGRvdHMgPSBvcHRpb25zLmRvdHM7XG4gIGNvbnN0IGluZGV4ZXMgPSBvcHRpb25zLmluZGV4ZXM7XG4gIGNvbnN0IF9CbG9iID0gb3B0aW9ucy5CbG9iIHx8IHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiBCbG9iO1xuICBjb25zdCB1c2VCbG9iID0gX0Jsb2IgJiYgdXRpbHMuaXNTcGVjQ29tcGxpYW50Rm9ybShmb3JtRGF0YSk7XG5cbiAgaWYgKCF1dGlscy5pc0Z1bmN0aW9uKHZpc2l0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmlzaXRvciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnZlcnRWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkgcmV0dXJuICcnO1xuXG4gICAgaWYgKHV0aWxzLmlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZS50b0lTT1N0cmluZygpO1xuICAgIH1cblxuICAgIGlmICghdXNlQmxvYiAmJiB1dGlscy5pc0Jsb2IodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcignQmxvYiBpcyBub3Qgc3VwcG9ydGVkLiBVc2UgYSBCdWZmZXIgaW5zdGVhZC4nKTtcbiAgICB9XG5cbiAgICBpZiAodXRpbHMuaXNBcnJheUJ1ZmZlcih2YWx1ZSkgfHwgdXRpbHMuaXNUeXBlZEFycmF5KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHVzZUJsb2IgJiYgdHlwZW9mIEJsb2IgPT09ICdmdW5jdGlvbicgPyBuZXcgQmxvYihbdmFsdWVdKSA6IEJ1ZmZlci5mcm9tKHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogRGVmYXVsdCB2aXNpdG9yLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0ga2V5XG4gICAqIEBwYXJhbSB7QXJyYXk8U3RyaW5nfE51bWJlcj59IHBhdGhcbiAgICogQHRoaXMge0Zvcm1EYXRhfVxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gcmV0dXJuIHRydWUgdG8gdmlzaXQgdGhlIGVhY2ggcHJvcCBvZiB0aGUgdmFsdWUgcmVjdXJzaXZlbHlcbiAgICovXG4gIGZ1bmN0aW9uIGRlZmF1bHRWaXNpdG9yKHZhbHVlLCBrZXksIHBhdGgpIHtcbiAgICBsZXQgYXJyID0gdmFsdWU7XG5cbiAgICBpZiAodmFsdWUgJiYgIXBhdGggJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHV0aWxzLmVuZHNXaXRoKGtleSwgJ3t9JykpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgIGtleSA9IG1ldGFUb2tlbnMgPyBrZXkgOiBrZXkuc2xpY2UoMCwgLTIpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgdmFsdWUgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAodXRpbHMuaXNBcnJheSh2YWx1ZSkgJiYgaXNGbGF0QXJyYXkodmFsdWUpKSB8fFxuICAgICAgICAoKHV0aWxzLmlzRmlsZUxpc3QodmFsdWUpIHx8IHV0aWxzLmVuZHNXaXRoKGtleSwgJ1tdJykpICYmIChhcnIgPSB1dGlscy50b0FycmF5KHZhbHVlKSlcbiAgICAgICAgKSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAga2V5ID0gcmVtb3ZlQnJhY2tldHMoa2V5KTtcblxuICAgICAgICBhcnIuZm9yRWFjaChmdW5jdGlvbiBlYWNoKGVsLCBpbmRleCkge1xuICAgICAgICAgICEodXRpbHMuaXNVbmRlZmluZWQoZWwpIHx8IGVsID09PSBudWxsKSAmJiBmb3JtRGF0YS5hcHBlbmQoXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICAgICAgICAgIGluZGV4ZXMgPT09IHRydWUgPyByZW5kZXJLZXkoW2tleV0sIGluZGV4LCBkb3RzKSA6IChpbmRleGVzID09PSBudWxsID8ga2V5IDoga2V5ICsgJ1tdJyksXG4gICAgICAgICAgICBjb252ZXJ0VmFsdWUoZWwpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNWaXNpdGFibGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3JtRGF0YS5hcHBlbmQocmVuZGVyS2V5KHBhdGgsIGtleSwgZG90cyksIGNvbnZlcnRWYWx1ZSh2YWx1ZSkpO1xuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3Qgc3RhY2sgPSBbXTtcblxuICBjb25zdCBleHBvc2VkSGVscGVycyA9IE9iamVjdC5hc3NpZ24ocHJlZGljYXRlcywge1xuICAgIGRlZmF1bHRWaXNpdG9yLFxuICAgIGNvbnZlcnRWYWx1ZSxcbiAgICBpc1Zpc2l0YWJsZVxuICB9KTtcblxuICBmdW5jdGlvbiBidWlsZCh2YWx1ZSwgcGF0aCkge1xuICAgIGlmICh1dGlscy5pc1VuZGVmaW5lZCh2YWx1ZSkpIHJldHVybjtcblxuICAgIGlmIChzdGFjay5pbmRleE9mKHZhbHVlKSAhPT0gLTEpIHtcbiAgICAgIHRocm93IEVycm9yKCdDaXJjdWxhciByZWZlcmVuY2UgZGV0ZWN0ZWQgaW4gJyArIHBhdGguam9pbignLicpKTtcbiAgICB9XG5cbiAgICBzdGFjay5wdXNoKHZhbHVlKTtcblxuICAgIHV0aWxzLmZvckVhY2godmFsdWUsIGZ1bmN0aW9uIGVhY2goZWwsIGtleSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gISh1dGlscy5pc1VuZGVmaW5lZChlbCkgfHwgZWwgPT09IG51bGwpICYmIHZpc2l0b3IuY2FsbChcbiAgICAgICAgZm9ybURhdGEsIGVsLCB1dGlscy5pc1N0cmluZyhrZXkpID8ga2V5LnRyaW0oKSA6IGtleSwgcGF0aCwgZXhwb3NlZEhlbHBlcnNcbiAgICAgICk7XG5cbiAgICAgIGlmIChyZXN1bHQgPT09IHRydWUpIHtcbiAgICAgICAgYnVpbGQoZWwsIHBhdGggPyBwYXRoLmNvbmNhdChrZXkpIDogW2tleV0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgc3RhY2sucG9wKCk7XG4gIH1cblxuICBpZiAoIXV0aWxzLmlzT2JqZWN0KG9iaikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdkYXRhIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gIH1cblxuICBidWlsZChvYmopO1xuXG4gIHJldHVybiBmb3JtRGF0YTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdG9Gb3JtRGF0YTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB0b0Zvcm1EYXRhIGZyb20gJy4vdG9Gb3JtRGF0YS5qcyc7XG5cbi8qKlxuICogSXQgZW5jb2RlcyBhIHN0cmluZyBieSByZXBsYWNpbmcgYWxsIGNoYXJhY3RlcnMgdGhhdCBhcmUgbm90IGluIHRoZSB1bnJlc2VydmVkIHNldCB3aXRoXG4gKiB0aGVpciBwZXJjZW50LWVuY29kZWQgZXF1aXZhbGVudHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gVGhlIHN0cmluZyB0byBlbmNvZGUuXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGVuY29kZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBlbmNvZGUoc3RyKSB7XG4gIGNvbnN0IGNoYXJNYXAgPSB7XG4gICAgJyEnOiAnJTIxJyxcbiAgICBcIidcIjogJyUyNycsXG4gICAgJygnOiAnJTI4JyxcbiAgICAnKSc6ICclMjknLFxuICAgICd+JzogJyU3RScsXG4gICAgJyUyMCc6ICcrJyxcbiAgICAnJTAwJzogJ1xceDAwJ1xuICB9O1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cikucmVwbGFjZSgvWyEnKCl+XXwlMjB8JTAwL2csIGZ1bmN0aW9uIHJlcGxhY2VyKG1hdGNoKSB7XG4gICAgcmV0dXJuIGNoYXJNYXBbbWF0Y2hdO1xuICB9KTtcbn1cblxuLyoqXG4gKiBJdCB0YWtlcyBhIHBhcmFtcyBvYmplY3QgYW5kIGNvbnZlcnRzIGl0IHRvIGEgRm9ybURhdGEgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyB0byBiZSBjb252ZXJ0ZWQgdG8gYSBGb3JtRGF0YSBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBvYmplY3QgcGFzc2VkIHRvIHRoZSBBeGlvcyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuZnVuY3Rpb24gQXhpb3NVUkxTZWFyY2hQYXJhbXMocGFyYW1zLCBvcHRpb25zKSB7XG4gIHRoaXMuX3BhaXJzID0gW107XG5cbiAgcGFyYW1zICYmIHRvRm9ybURhdGEocGFyYW1zLCB0aGlzLCBvcHRpb25zKTtcbn1cblxuY29uc3QgcHJvdG90eXBlID0gQXhpb3NVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlO1xuXG5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kKG5hbWUsIHZhbHVlKSB7XG4gIHRoaXMuX3BhaXJzLnB1c2goW25hbWUsIHZhbHVlXSk7XG59O1xuXG5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhlbmNvZGVyKSB7XG4gIGNvbnN0IF9lbmNvZGUgPSBlbmNvZGVyID8gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZW5jb2Rlci5jYWxsKHRoaXMsIHZhbHVlLCBlbmNvZGUpO1xuICB9IDogZW5jb2RlO1xuXG4gIHJldHVybiB0aGlzLl9wYWlycy5tYXAoZnVuY3Rpb24gZWFjaChwYWlyKSB7XG4gICAgcmV0dXJuIF9lbmNvZGUocGFpclswXSkgKyAnPScgKyBfZW5jb2RlKHBhaXJbMV0pO1xuICB9LCAnJykuam9pbignJicpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQXhpb3NVUkxTZWFyY2hQYXJhbXM7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IEF4aW9zVVJMU2VhcmNoUGFyYW1zIGZyb20gJy4uL2hlbHBlcnMvQXhpb3NVUkxTZWFyY2hQYXJhbXMuanMnO1xuXG4vKipcbiAqIEl0IHJlcGxhY2VzIGFsbCBpbnN0YW5jZXMgb2YgdGhlIGNoYXJhY3RlcnMgYDpgLCBgJGAsIGAsYCwgYCtgLCBgW2AsIGFuZCBgXWAgd2l0aCB0aGVpclxuICogVVJJIGVuY29kZWQgY291bnRlcnBhcnRzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbCBUaGUgdmFsdWUgdG8gYmUgZW5jb2RlZC5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZW5jb2RlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZW5jb2RlKHZhbCkge1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHZhbCkuXG4gICAgcmVwbGFjZSgvJTNBL2dpLCAnOicpLlxuICAgIHJlcGxhY2UoLyUyNC9nLCAnJCcpLlxuICAgIHJlcGxhY2UoLyUyQy9naSwgJywnKS5cbiAgICByZXBsYWNlKC8lMjAvZywgJysnKS5cbiAgICByZXBsYWNlKC8lNUIvZ2ksICdbJykuXG4gICAgcmVwbGFjZSgvJTVEL2dpLCAnXScpO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgVVJMIGJ5IGFwcGVuZGluZyBwYXJhbXMgdG8gdGhlIGVuZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIGJhc2Ugb2YgdGhlIHVybCAoZS5nLiwgaHR0cDovL3d3dy5nb29nbGUuY29tKVxuICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdIFRoZSBwYXJhbXMgdG8gYmUgYXBwZW5kZWRcbiAqIEBwYXJhbSB7P29iamVjdH0gb3B0aW9uc1xuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgdXJsXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGJ1aWxkVVJMKHVybCwgcGFyYW1zLCBvcHRpb25zKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICBpZiAoIXBhcmFtcykge1xuICAgIHJldHVybiB1cmw7XG4gIH1cbiAgXG4gIGNvbnN0IF9lbmNvZGUgPSBvcHRpb25zICYmIG9wdGlvbnMuZW5jb2RlIHx8IGVuY29kZTtcblxuICBjb25zdCBzZXJpYWxpemVGbiA9IG9wdGlvbnMgJiYgb3B0aW9ucy5zZXJpYWxpemU7XG5cbiAgbGV0IHNlcmlhbGl6ZWRQYXJhbXM7XG5cbiAgaWYgKHNlcmlhbGl6ZUZuKSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHNlcmlhbGl6ZUZuKHBhcmFtcywgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKHBhcmFtcykgP1xuICAgICAgcGFyYW1zLnRvU3RyaW5nKCkgOlxuICAgICAgbmV3IEF4aW9zVVJMU2VhcmNoUGFyYW1zKHBhcmFtcywgb3B0aW9ucykudG9TdHJpbmcoX2VuY29kZSk7XG4gIH1cblxuICBpZiAoc2VyaWFsaXplZFBhcmFtcykge1xuICAgIGNvbnN0IGhhc2htYXJrSW5kZXggPSB1cmwuaW5kZXhPZihcIiNcIik7XG5cbiAgICBpZiAoaGFzaG1hcmtJbmRleCAhPT0gLTEpIHtcbiAgICAgIHVybCA9IHVybC5zbGljZSgwLCBoYXNobWFya0luZGV4KTtcbiAgICB9XG4gICAgdXJsICs9ICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyBzZXJpYWxpemVkUGFyYW1zO1xuICB9XG5cbiAgcmV0dXJuIHVybDtcbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLy4uL3V0aWxzLmpzJztcblxuY2xhc3MgSW50ZXJjZXB0b3JNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5oYW5kbGVycyA9IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIG5ldyBpbnRlcmNlcHRvciB0byB0aGUgc3RhY2tcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVsZmlsbGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHRoZW5gIGZvciBhIGBQcm9taXNlYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3RlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGByZWplY3RgIGZvciBhIGBQcm9taXNlYFxuICAgKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IEFuIElEIHVzZWQgdG8gcmVtb3ZlIGludGVyY2VwdG9yIGxhdGVyXG4gICAqL1xuICB1c2UoZnVsZmlsbGVkLCByZWplY3RlZCwgb3B0aW9ucykge1xuICAgIHRoaXMuaGFuZGxlcnMucHVzaCh7XG4gICAgICBmdWxmaWxsZWQsXG4gICAgICByZWplY3RlZCxcbiAgICAgIHN5bmNocm9ub3VzOiBvcHRpb25zID8gb3B0aW9ucy5zeW5jaHJvbm91cyA6IGZhbHNlLFxuICAgICAgcnVuV2hlbjogb3B0aW9ucyA/IG9wdGlvbnMucnVuV2hlbiA6IG51bGxcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVycy5sZW5ndGggLSAxO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBpbnRlcmNlcHRvciBmcm9tIHRoZSBzdGFja1xuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gaWQgVGhlIElEIHRoYXQgd2FzIHJldHVybmVkIGJ5IGB1c2VgXG4gICAqXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIGludGVyY2VwdG9yIHdhcyByZW1vdmVkLCBgZmFsc2VgIG90aGVyd2lzZVxuICAgKi9cbiAgZWplY3QoaWQpIHtcbiAgICBpZiAodGhpcy5oYW5kbGVyc1tpZF0pIHtcbiAgICAgIHRoaXMuaGFuZGxlcnNbaWRdID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXIgYWxsIGludGVyY2VwdG9ycyBmcm9tIHRoZSBzdGFja1xuICAgKlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGNsZWFyKCkge1xuICAgIGlmICh0aGlzLmhhbmRsZXJzKSB7XG4gICAgICB0aGlzLmhhbmRsZXJzID0gW107XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGUgb3ZlciBhbGwgdGhlIHJlZ2lzdGVyZWQgaW50ZXJjZXB0b3JzXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIHNraXBwaW5nIG92ZXIgYW55XG4gICAqIGludGVyY2VwdG9ycyB0aGF0IG1heSBoYXZlIGJlY29tZSBgbnVsbGAgY2FsbGluZyBgZWplY3RgLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBpbnRlcmNlcHRvclxuICAgKlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGZvckVhY2goZm4pIHtcbiAgICB1dGlscy5mb3JFYWNoKHRoaXMuaGFuZGxlcnMsIGZ1bmN0aW9uIGZvckVhY2hIYW5kbGVyKGgpIHtcbiAgICAgIGlmIChoICE9PSBudWxsKSB7XG4gICAgICAgIGZuKGgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEludGVyY2VwdG9yTWFuYWdlcjtcbiIsICIndXNlIHN0cmljdCc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgc2lsZW50SlNPTlBhcnNpbmc6IHRydWUsXG4gIGZvcmNlZEpTT05QYXJzaW5nOiB0cnVlLFxuICBjbGFyaWZ5VGltZW91dEVycm9yOiBmYWxzZVxufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBBeGlvc1VSTFNlYXJjaFBhcmFtcyBmcm9tICcuLi8uLi8uLi9oZWxwZXJzL0F4aW9zVVJMU2VhcmNoUGFyYW1zLmpzJztcbmV4cG9ydCBkZWZhdWx0IHR5cGVvZiBVUkxTZWFyY2hQYXJhbXMgIT09ICd1bmRlZmluZWQnID8gVVJMU2VhcmNoUGFyYW1zIDogQXhpb3NVUkxTZWFyY2hQYXJhbXM7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnQgZGVmYXVsdCB0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnID8gRm9ybURhdGEgOiBudWxsO1xuIiwgIid1c2Ugc3RyaWN0J1xuXG5leHBvcnQgZGVmYXVsdCB0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgPyBCbG9iIDogbnVsbFxuIiwgImltcG9ydCBVUkxTZWFyY2hQYXJhbXMgZnJvbSAnLi9jbGFzc2VzL1VSTFNlYXJjaFBhcmFtcy5qcydcbmltcG9ydCBGb3JtRGF0YSBmcm9tICcuL2NsYXNzZXMvRm9ybURhdGEuanMnXG5pbXBvcnQgQmxvYiBmcm9tICcuL2NsYXNzZXMvQmxvYi5qcydcblxuZXhwb3J0IGRlZmF1bHQge1xuICBpc0Jyb3dzZXI6IHRydWUsXG4gIGNsYXNzZXM6IHtcbiAgICBVUkxTZWFyY2hQYXJhbXMsXG4gICAgRm9ybURhdGEsXG4gICAgQmxvYlxuICB9LFxuICBwcm90b2NvbHM6IFsnaHR0cCcsICdodHRwcycsICdmaWxlJywgJ2Jsb2InLCAndXJsJywgJ2RhdGEnXVxufTtcbiIsICJjb25zdCBoYXNCcm93c2VyRW52ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgd2UncmUgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAqXG4gKiBUaGlzIGFsbG93cyBheGlvcyB0byBydW4gaW4gYSB3ZWIgd29ya2VyLCBhbmQgcmVhY3QtbmF0aXZlLlxuICogQm90aCBlbnZpcm9ubWVudHMgc3VwcG9ydCBYTUxIdHRwUmVxdWVzdCwgYnV0IG5vdCBmdWxseSBzdGFuZGFyZCBnbG9iYWxzLlxuICpcbiAqIHdlYiB3b3JrZXJzOlxuICogIHR5cGVvZiB3aW5kb3cgLT4gdW5kZWZpbmVkXG4gKiAgdHlwZW9mIGRvY3VtZW50IC0+IHVuZGVmaW5lZFxuICpcbiAqIHJlYWN0LW5hdGl2ZTpcbiAqICBuYXZpZ2F0b3IucHJvZHVjdCAtPiAnUmVhY3ROYXRpdmUnXG4gKiBuYXRpdmVzY3JpcHRcbiAqICBuYXZpZ2F0b3IucHJvZHVjdCAtPiAnTmF0aXZlU2NyaXB0JyBvciAnTlMnXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGhhc1N0YW5kYXJkQnJvd3NlckVudiA9IChcbiAgKHByb2R1Y3QpID0+IHtcbiAgICByZXR1cm4gaGFzQnJvd3NlckVudiAmJiBbJ1JlYWN0TmF0aXZlJywgJ05hdGl2ZVNjcmlwdCcsICdOUyddLmluZGV4T2YocHJvZHVjdCkgPCAwXG4gIH0pKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci5wcm9kdWN0KTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgd2UncmUgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgd2ViV29ya2VyIGVudmlyb25tZW50XG4gKlxuICogQWx0aG91Z2ggdGhlIGBpc1N0YW5kYXJkQnJvd3NlckVudmAgbWV0aG9kIGluZGljYXRlcyB0aGF0XG4gKiBgYWxsb3dzIGF4aW9zIHRvIHJ1biBpbiBhIHdlYiB3b3JrZXJgLCB0aGUgV2ViV29ya2VyIHdpbGwgc3RpbGwgYmVcbiAqIGZpbHRlcmVkIG91dCBkdWUgdG8gaXRzIGp1ZGdtZW50IHN0YW5kYXJkXG4gKiBgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ2AuXG4gKiBUaGlzIGxlYWRzIHRvIGEgcHJvYmxlbSB3aGVuIGF4aW9zIHBvc3QgYEZvcm1EYXRhYCBpbiB3ZWJXb3JrZXJcbiAqL1xuY29uc3QgaGFzU3RhbmRhcmRCcm93c2VyV2ViV29ya2VyRW52ID0gKCgpID0+IHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlICYmXG4gICAgdHlwZW9mIHNlbGYuaW1wb3J0U2NyaXB0cyA9PT0gJ2Z1bmN0aW9uJ1xuICApO1xufSkoKTtcblxuZXhwb3J0IHtcbiAgaGFzQnJvd3NlckVudixcbiAgaGFzU3RhbmRhcmRCcm93c2VyV2ViV29ya2VyRW52LFxuICBoYXNTdGFuZGFyZEJyb3dzZXJFbnZcbn1cbiIsICJpbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi9ub2RlL2luZGV4LmpzJztcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4vY29tbW9uL3V0aWxzLmpzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICAuLi51dGlscyxcbiAgLi4ucGxhdGZvcm1cbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5pbXBvcnQgdG9Gb3JtRGF0YSBmcm9tICcuL3RvRm9ybURhdGEuanMnO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uL3BsYXRmb3JtL2luZGV4LmpzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdG9VUkxFbmNvZGVkRm9ybShkYXRhLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b0Zvcm1EYXRhKGRhdGEsIG5ldyBwbGF0Zm9ybS5jbGFzc2VzLlVSTFNlYXJjaFBhcmFtcygpLCBPYmplY3QuYXNzaWduKHtcbiAgICB2aXNpdG9yOiBmdW5jdGlvbih2YWx1ZSwga2V5LCBwYXRoLCBoZWxwZXJzKSB7XG4gICAgICBpZiAocGxhdGZvcm0uaXNOb2RlICYmIHV0aWxzLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgICB0aGlzLmFwcGVuZChrZXksIHZhbHVlLnRvU3RyaW5nKCdiYXNlNjQnKSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhlbHBlcnMuZGVmYXVsdFZpc2l0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH0sIG9wdGlvbnMpKTtcbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5cbi8qKlxuICogSXQgdGFrZXMgYSBzdHJpbmcgbGlrZSBgZm9vW3hdW3ldW3pdYCBhbmQgcmV0dXJucyBhbiBhcnJheSBsaWtlIGBbJ2ZvbycsICd4JywgJ3knLCAneiddXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICpcbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHN0cmluZ3MuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlUHJvcFBhdGgobmFtZSkge1xuICAvLyBmb29beF1beV1bel1cbiAgLy8gZm9vLngueS56XG4gIC8vIGZvby14LXktelxuICAvLyBmb28geCB5IHpcbiAgcmV0dXJuIHV0aWxzLm1hdGNoQWxsKC9cXHcrfFxcWyhcXHcqKV0vZywgbmFtZSkubWFwKG1hdGNoID0+IHtcbiAgICByZXR1cm4gbWF0Y2hbMF0gPT09ICdbXScgPyAnJyA6IG1hdGNoWzFdIHx8IG1hdGNoWzBdO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGFuIGFycmF5IHRvIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PGFueT59IGFyciAtIFRoZSBhcnJheSB0byBjb252ZXJ0IHRvIGFuIG9iamVjdC5cbiAqXG4gKiBAcmV0dXJucyBBbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBrZXlzIGFuZCB2YWx1ZXMgYXMgdGhlIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheVRvT2JqZWN0KGFycikge1xuICBjb25zdCBvYmogPSB7fTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGFycik7XG4gIGxldCBpO1xuICBjb25zdCBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgbGV0IGtleTtcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICBvYmpba2V5XSA9IGFycltrZXldO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogSXQgdGFrZXMgYSBGb3JtRGF0YSBvYmplY3QgYW5kIHJldHVybnMgYSBKYXZhU2NyaXB0IG9iamVjdFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtRGF0YSBUaGUgRm9ybURhdGEgb2JqZWN0IHRvIGNvbnZlcnQgdG8gSlNPTi5cbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0PHN0cmluZywgYW55PiB8IG51bGx9IFRoZSBjb252ZXJ0ZWQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBmb3JtRGF0YVRvSlNPTihmb3JtRGF0YSkge1xuICBmdW5jdGlvbiBidWlsZFBhdGgocGF0aCwgdmFsdWUsIHRhcmdldCwgaW5kZXgpIHtcbiAgICBsZXQgbmFtZSA9IHBhdGhbaW5kZXgrK107XG5cbiAgICBpZiAobmFtZSA9PT0gJ19fcHJvdG9fXycpIHJldHVybiB0cnVlO1xuXG4gICAgY29uc3QgaXNOdW1lcmljS2V5ID0gTnVtYmVyLmlzRmluaXRlKCtuYW1lKTtcbiAgICBjb25zdCBpc0xhc3QgPSBpbmRleCA+PSBwYXRoLmxlbmd0aDtcbiAgICBuYW1lID0gIW5hbWUgJiYgdXRpbHMuaXNBcnJheSh0YXJnZXQpID8gdGFyZ2V0Lmxlbmd0aCA6IG5hbWU7XG5cbiAgICBpZiAoaXNMYXN0KSB7XG4gICAgICBpZiAodXRpbHMuaGFzT3duUHJvcCh0YXJnZXQsIG5hbWUpKSB7XG4gICAgICAgIHRhcmdldFtuYW1lXSA9IFt0YXJnZXRbbmFtZV0sIHZhbHVlXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldFtuYW1lXSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gIWlzTnVtZXJpY0tleTtcbiAgICB9XG5cbiAgICBpZiAoIXRhcmdldFtuYW1lXSB8fCAhdXRpbHMuaXNPYmplY3QodGFyZ2V0W25hbWVdKSkge1xuICAgICAgdGFyZ2V0W25hbWVdID0gW107XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gYnVpbGRQYXRoKHBhdGgsIHZhbHVlLCB0YXJnZXRbbmFtZV0sIGluZGV4KTtcblxuICAgIGlmIChyZXN1bHQgJiYgdXRpbHMuaXNBcnJheSh0YXJnZXRbbmFtZV0pKSB7XG4gICAgICB0YXJnZXRbbmFtZV0gPSBhcnJheVRvT2JqZWN0KHRhcmdldFtuYW1lXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuICFpc051bWVyaWNLZXk7XG4gIH1cblxuICBpZiAodXRpbHMuaXNGb3JtRGF0YShmb3JtRGF0YSkgJiYgdXRpbHMuaXNGdW5jdGlvbihmb3JtRGF0YS5lbnRyaWVzKSkge1xuICAgIGNvbnN0IG9iaiA9IHt9O1xuXG4gICAgdXRpbHMuZm9yRWFjaEVudHJ5KGZvcm1EYXRhLCAobmFtZSwgdmFsdWUpID0+IHtcbiAgICAgIGJ1aWxkUGF0aChwYXJzZVByb3BQYXRoKG5hbWUpLCB2YWx1ZSwgb2JqLCAwKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZm9ybURhdGFUb0pTT047XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IEF4aW9zRXJyb3IgZnJvbSAnLi4vY29yZS9BeGlvc0Vycm9yLmpzJztcbmltcG9ydCB0cmFuc2l0aW9uYWxEZWZhdWx0cyBmcm9tICcuL3RyYW5zaXRpb25hbC5qcyc7XG5pbXBvcnQgdG9Gb3JtRGF0YSBmcm9tICcuLi9oZWxwZXJzL3RvRm9ybURhdGEuanMnO1xuaW1wb3J0IHRvVVJMRW5jb2RlZEZvcm0gZnJvbSAnLi4vaGVscGVycy90b1VSTEVuY29kZWRGb3JtLmpzJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi9wbGF0Zm9ybS9pbmRleC5qcyc7XG5pbXBvcnQgZm9ybURhdGFUb0pTT04gZnJvbSAnLi4vaGVscGVycy9mb3JtRGF0YVRvSlNPTi5qcyc7XG5cbi8qKlxuICogSXQgdGFrZXMgYSBzdHJpbmcsIHRyaWVzIHRvIHBhcnNlIGl0LCBhbmQgaWYgaXQgZmFpbHMsIGl0IHJldHVybnMgdGhlIHN0cmluZ2lmaWVkIHZlcnNpb25cbiAqIG9mIHRoZSBpbnB1dFxuICpcbiAqIEBwYXJhbSB7YW55fSByYXdWYWx1ZSAtIFRoZSB2YWx1ZSB0byBiZSBzdHJpbmdpZmllZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHBhcnNlciAtIEEgZnVuY3Rpb24gdGhhdCBwYXJzZXMgYSBzdHJpbmcgaW50byBhIEphdmFTY3JpcHQgb2JqZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZW5jb2RlciAtIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHZhbHVlIGFuZCByZXR1cm5zIGEgc3RyaW5nLlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEEgc3RyaW5naWZpZWQgdmVyc2lvbiBvZiB0aGUgcmF3VmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ2lmeVNhZmVseShyYXdWYWx1ZSwgcGFyc2VyLCBlbmNvZGVyKSB7XG4gIGlmICh1dGlscy5pc1N0cmluZyhyYXdWYWx1ZSkpIHtcbiAgICB0cnkge1xuICAgICAgKHBhcnNlciB8fCBKU09OLnBhcnNlKShyYXdWYWx1ZSk7XG4gICAgICByZXR1cm4gdXRpbHMudHJpbShyYXdWYWx1ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUubmFtZSAhPT0gJ1N5bnRheEVycm9yJykge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAoZW5jb2RlciB8fCBKU09OLnN0cmluZ2lmeSkocmF3VmFsdWUpO1xufVxuXG5jb25zdCBkZWZhdWx0cyA9IHtcblxuICB0cmFuc2l0aW9uYWw6IHRyYW5zaXRpb25hbERlZmF1bHRzLFxuXG4gIGFkYXB0ZXI6IFsneGhyJywgJ2h0dHAnXSxcblxuICB0cmFuc2Zvcm1SZXF1ZXN0OiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVxdWVzdChkYXRhLCBoZWFkZXJzKSB7XG4gICAgY29uc3QgY29udGVudFR5cGUgPSBoZWFkZXJzLmdldENvbnRlbnRUeXBlKCkgfHwgJyc7XG4gICAgY29uc3QgaGFzSlNPTkNvbnRlbnRUeXBlID0gY29udGVudFR5cGUuaW5kZXhPZignYXBwbGljYXRpb24vanNvbicpID4gLTE7XG4gICAgY29uc3QgaXNPYmplY3RQYXlsb2FkID0gdXRpbHMuaXNPYmplY3QoZGF0YSk7XG5cbiAgICBpZiAoaXNPYmplY3RQYXlsb2FkICYmIHV0aWxzLmlzSFRNTEZvcm0oZGF0YSkpIHtcbiAgICAgIGRhdGEgPSBuZXcgRm9ybURhdGEoZGF0YSk7XG4gICAgfVxuXG4gICAgY29uc3QgaXNGb3JtRGF0YSA9IHV0aWxzLmlzRm9ybURhdGEoZGF0YSk7XG5cbiAgICBpZiAoaXNGb3JtRGF0YSkge1xuICAgICAgcmV0dXJuIGhhc0pTT05Db250ZW50VHlwZSA/IEpTT04uc3RyaW5naWZ5KGZvcm1EYXRhVG9KU09OKGRhdGEpKSA6IGRhdGE7XG4gICAgfVxuXG4gICAgaWYgKHV0aWxzLmlzQXJyYXlCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc1N0cmVhbShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNGaWxlKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0Jsb2IoZGF0YSlcbiAgICApIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNBcnJheUJ1ZmZlclZpZXcoZGF0YSkpIHtcbiAgICAgIHJldHVybiBkYXRhLmJ1ZmZlcjtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKGRhdGEpKSB7XG4gICAgICBoZWFkZXJzLnNldENvbnRlbnRUeXBlKCdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD11dGYtOCcsIGZhbHNlKTtcbiAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgbGV0IGlzRmlsZUxpc3Q7XG5cbiAgICBpZiAoaXNPYmplY3RQYXlsb2FkKSB7XG4gICAgICBpZiAoY29udGVudFR5cGUuaW5kZXhPZignYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJykgPiAtMSkge1xuICAgICAgICByZXR1cm4gdG9VUkxFbmNvZGVkRm9ybShkYXRhLCB0aGlzLmZvcm1TZXJpYWxpemVyKS50b1N0cmluZygpO1xuICAgICAgfVxuXG4gICAgICBpZiAoKGlzRmlsZUxpc3QgPSB1dGlscy5pc0ZpbGVMaXN0KGRhdGEpKSB8fCBjb250ZW50VHlwZS5pbmRleE9mKCdtdWx0aXBhcnQvZm9ybS1kYXRhJykgPiAtMSkge1xuICAgICAgICBjb25zdCBfRm9ybURhdGEgPSB0aGlzLmVudiAmJiB0aGlzLmVudi5Gb3JtRGF0YTtcblxuICAgICAgICByZXR1cm4gdG9Gb3JtRGF0YShcbiAgICAgICAgICBpc0ZpbGVMaXN0ID8geydmaWxlc1tdJzogZGF0YX0gOiBkYXRhLFxuICAgICAgICAgIF9Gb3JtRGF0YSAmJiBuZXcgX0Zvcm1EYXRhKCksXG4gICAgICAgICAgdGhpcy5mb3JtU2VyaWFsaXplclxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc09iamVjdFBheWxvYWQgfHwgaGFzSlNPTkNvbnRlbnRUeXBlICkge1xuICAgICAgaGVhZGVycy5zZXRDb250ZW50VHlwZSgnYXBwbGljYXRpb24vanNvbicsIGZhbHNlKTtcbiAgICAgIHJldHVybiBzdHJpbmdpZnlTYWZlbHkoZGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIHRyYW5zZm9ybVJlc3BvbnNlOiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVzcG9uc2UoZGF0YSkge1xuICAgIGNvbnN0IHRyYW5zaXRpb25hbCA9IHRoaXMudHJhbnNpdGlvbmFsIHx8IGRlZmF1bHRzLnRyYW5zaXRpb25hbDtcbiAgICBjb25zdCBmb3JjZWRKU09OUGFyc2luZyA9IHRyYW5zaXRpb25hbCAmJiB0cmFuc2l0aW9uYWwuZm9yY2VkSlNPTlBhcnNpbmc7XG4gICAgY29uc3QgSlNPTlJlcXVlc3RlZCA9IHRoaXMucmVzcG9uc2VUeXBlID09PSAnanNvbic7XG5cbiAgICBpZiAoZGF0YSAmJiB1dGlscy5pc1N0cmluZyhkYXRhKSAmJiAoKGZvcmNlZEpTT05QYXJzaW5nICYmICF0aGlzLnJlc3BvbnNlVHlwZSkgfHwgSlNPTlJlcXVlc3RlZCkpIHtcbiAgICAgIGNvbnN0IHNpbGVudEpTT05QYXJzaW5nID0gdHJhbnNpdGlvbmFsICYmIHRyYW5zaXRpb25hbC5zaWxlbnRKU09OUGFyc2luZztcbiAgICAgIGNvbnN0IHN0cmljdEpTT05QYXJzaW5nID0gIXNpbGVudEpTT05QYXJzaW5nICYmIEpTT05SZXF1ZXN0ZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoc3RyaWN0SlNPTlBhcnNpbmcpIHtcbiAgICAgICAgICBpZiAoZS5uYW1lID09PSAnU3ludGF4RXJyb3InKSB7XG4gICAgICAgICAgICB0aHJvdyBBeGlvc0Vycm9yLmZyb20oZSwgQXhpb3NFcnJvci5FUlJfQkFEX1JFU1BPTlNFLCB0aGlzLCBudWxsLCB0aGlzLnJlc3BvbnNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICAvKipcbiAgICogQSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyB0byBhYm9ydCBhIHJlcXVlc3QuIElmIHNldCB0byAwIChkZWZhdWx0KSBhXG4gICAqIHRpbWVvdXQgaXMgbm90IGNyZWF0ZWQuXG4gICAqL1xuICB0aW1lb3V0OiAwLFxuXG4gIHhzcmZDb29raWVOYW1lOiAnWFNSRi1UT0tFTicsXG4gIHhzcmZIZWFkZXJOYW1lOiAnWC1YU1JGLVRPS0VOJyxcblxuICBtYXhDb250ZW50TGVuZ3RoOiAtMSxcbiAgbWF4Qm9keUxlbmd0aDogLTEsXG5cbiAgZW52OiB7XG4gICAgRm9ybURhdGE6IHBsYXRmb3JtLmNsYXNzZXMuRm9ybURhdGEsXG4gICAgQmxvYjogcGxhdGZvcm0uY2xhc3Nlcy5CbG9iXG4gIH0sXG5cbiAgdmFsaWRhdGVTdGF0dXM6IGZ1bmN0aW9uIHZhbGlkYXRlU3RhdHVzKHN0YXR1cykge1xuICAgIHJldHVybiBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMDtcbiAgfSxcblxuICBoZWFkZXJzOiB7XG4gICAgY29tbW9uOiB7XG4gICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvcGxhaW4sICovKicsXG4gICAgICAnQ29udGVudC1UeXBlJzogdW5kZWZpbmVkXG4gICAgfVxuICB9XG59O1xuXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIChtZXRob2QpID0+IHtcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0ge307XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgZGVmYXVsdHM7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi8uLi91dGlscy5qcyc7XG5cbi8vIFJhd0F4aW9zSGVhZGVycyB3aG9zZSBkdXBsaWNhdGVzIGFyZSBpZ25vcmVkIGJ5IG5vZGVcbi8vIGMuZi4gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9odHRwLmh0bWwjaHR0cF9tZXNzYWdlX2hlYWRlcnNcbmNvbnN0IGlnbm9yZUR1cGxpY2F0ZU9mID0gdXRpbHMudG9PYmplY3RTZXQoW1xuICAnYWdlJywgJ2F1dGhvcml6YXRpb24nLCAnY29udGVudC1sZW5ndGgnLCAnY29udGVudC10eXBlJywgJ2V0YWcnLFxuICAnZXhwaXJlcycsICdmcm9tJywgJ2hvc3QnLCAnaWYtbW9kaWZpZWQtc2luY2UnLCAnaWYtdW5tb2RpZmllZC1zaW5jZScsXG4gICdsYXN0LW1vZGlmaWVkJywgJ2xvY2F0aW9uJywgJ21heC1mb3J3YXJkcycsICdwcm94eS1hdXRob3JpemF0aW9uJyxcbiAgJ3JlZmVyZXInLCAncmV0cnktYWZ0ZXInLCAndXNlci1hZ2VudCdcbl0pO1xuXG4vKipcbiAqIFBhcnNlIGhlYWRlcnMgaW50byBhbiBvYmplY3RcbiAqXG4gKiBgYGBcbiAqIERhdGU6IFdlZCwgMjcgQXVnIDIwMTQgMDg6NTg6NDkgR01UXG4gKiBDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL2pzb25cbiAqIENvbm5lY3Rpb246IGtlZXAtYWxpdmVcbiAqIFRyYW5zZmVyLUVuY29kaW5nOiBjaHVua2VkXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmF3SGVhZGVycyBIZWFkZXJzIG5lZWRpbmcgdG8gYmUgcGFyc2VkXG4gKlxuICogQHJldHVybnMge09iamVjdH0gSGVhZGVycyBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAqL1xuZXhwb3J0IGRlZmF1bHQgcmF3SGVhZGVycyA9PiB7XG4gIGNvbnN0IHBhcnNlZCA9IHt9O1xuICBsZXQga2V5O1xuICBsZXQgdmFsO1xuICBsZXQgaTtcblxuICByYXdIZWFkZXJzICYmIHJhd0hlYWRlcnMuc3BsaXQoJ1xcbicpLmZvckVhY2goZnVuY3Rpb24gcGFyc2VyKGxpbmUpIHtcbiAgICBpID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAga2V5ID0gbGluZS5zdWJzdHJpbmcoMCwgaSkudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFsID0gbGluZS5zdWJzdHJpbmcoaSArIDEpLnRyaW0oKTtcblxuICAgIGlmICgha2V5IHx8IChwYXJzZWRba2V5XSAmJiBpZ25vcmVEdXBsaWNhdGVPZltrZXldKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChrZXkgPT09ICdzZXQtY29va2llJykge1xuICAgICAgaWYgKHBhcnNlZFtrZXldKSB7XG4gICAgICAgIHBhcnNlZFtrZXldLnB1c2godmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gW3ZhbF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnNlZFtrZXldID0gcGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSArICcsICcgKyB2YWwgOiB2YWw7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcGFyc2VkO1xufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5pbXBvcnQgcGFyc2VIZWFkZXJzIGZyb20gJy4uL2hlbHBlcnMvcGFyc2VIZWFkZXJzLmpzJztcblxuY29uc3QgJGludGVybmFscyA9IFN5bWJvbCgnaW50ZXJuYWxzJyk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUhlYWRlcihoZWFkZXIpIHtcbiAgcmV0dXJuIGhlYWRlciAmJiBTdHJpbmcoaGVhZGVyKS50cmltKCkudG9Mb3dlckNhc2UoKTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSBmYWxzZSB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHV0aWxzLmlzQXJyYXkodmFsdWUpID8gdmFsdWUubWFwKG5vcm1hbGl6ZVZhbHVlKSA6IFN0cmluZyh2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlVG9rZW5zKHN0cikge1xuICBjb25zdCB0b2tlbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBjb25zdCB0b2tlbnNSRSA9IC8oW15cXHMsOz1dKylcXHMqKD86PVxccyooW14sO10rKSk/L2c7XG4gIGxldCBtYXRjaDtcblxuICB3aGlsZSAoKG1hdGNoID0gdG9rZW5zUkUuZXhlYyhzdHIpKSkge1xuICAgIHRva2Vuc1ttYXRjaFsxXV0gPSBtYXRjaFsyXTtcbiAgfVxuXG4gIHJldHVybiB0b2tlbnM7XG59XG5cbmNvbnN0IGlzVmFsaWRIZWFkZXJOYW1lID0gKHN0cikgPT4gL15bLV9hLXpBLVowLTleYHx+LCEjJCUmJyorLl0rJC8udGVzdChzdHIudHJpbSgpKTtcblxuZnVuY3Rpb24gbWF0Y2hIZWFkZXJWYWx1ZShjb250ZXh0LCB2YWx1ZSwgaGVhZGVyLCBmaWx0ZXIsIGlzSGVhZGVyTmFtZUZpbHRlcikge1xuICBpZiAodXRpbHMuaXNGdW5jdGlvbihmaWx0ZXIpKSB7XG4gICAgcmV0dXJuIGZpbHRlci5jYWxsKHRoaXMsIHZhbHVlLCBoZWFkZXIpO1xuICB9XG5cbiAgaWYgKGlzSGVhZGVyTmFtZUZpbHRlcikge1xuICAgIHZhbHVlID0gaGVhZGVyO1xuICB9XG5cbiAgaWYgKCF1dGlscy5pc1N0cmluZyh2YWx1ZSkpIHJldHVybjtcblxuICBpZiAodXRpbHMuaXNTdHJpbmcoZmlsdGVyKSkge1xuICAgIHJldHVybiB2YWx1ZS5pbmRleE9mKGZpbHRlcikgIT09IC0xO1xuICB9XG5cbiAgaWYgKHV0aWxzLmlzUmVnRXhwKGZpbHRlcikpIHtcbiAgICByZXR1cm4gZmlsdGVyLnRlc3QodmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvcm1hdEhlYWRlcihoZWFkZXIpIHtcbiAgcmV0dXJuIGhlYWRlci50cmltKClcbiAgICAudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8oW2EtelxcZF0pKFxcdyopL2csICh3LCBjaGFyLCBzdHIpID0+IHtcbiAgICAgIHJldHVybiBjaGFyLnRvVXBwZXJDYXNlKCkgKyBzdHI7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkQWNjZXNzb3JzKG9iaiwgaGVhZGVyKSB7XG4gIGNvbnN0IGFjY2Vzc29yTmFtZSA9IHV0aWxzLnRvQ2FtZWxDYXNlKCcgJyArIGhlYWRlcik7XG5cbiAgWydnZXQnLCAnc2V0JywgJ2hhcyddLmZvckVhY2gobWV0aG9kTmFtZSA9PiB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgbWV0aG9kTmFtZSArIGFjY2Vzc29yTmFtZSwge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uKGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbbWV0aG9kTmFtZV0uY2FsbCh0aGlzLCBoZWFkZXIsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgICAgfSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9KTtcbn1cblxuY2xhc3MgQXhpb3NIZWFkZXJzIHtcbiAgY29uc3RydWN0b3IoaGVhZGVycykge1xuICAgIGhlYWRlcnMgJiYgdGhpcy5zZXQoaGVhZGVycyk7XG4gIH1cblxuICBzZXQoaGVhZGVyLCB2YWx1ZU9yUmV3cml0ZSwgcmV3cml0ZSkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gc2V0SGVhZGVyKF92YWx1ZSwgX2hlYWRlciwgX3Jld3JpdGUpIHtcbiAgICAgIGNvbnN0IGxIZWFkZXIgPSBub3JtYWxpemVIZWFkZXIoX2hlYWRlcik7XG5cbiAgICAgIGlmICghbEhlYWRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hlYWRlciBuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGtleSA9IHV0aWxzLmZpbmRLZXkoc2VsZiwgbEhlYWRlcik7XG5cbiAgICAgIGlmKCFrZXkgfHwgc2VsZltrZXldID09PSB1bmRlZmluZWQgfHwgX3Jld3JpdGUgPT09IHRydWUgfHwgKF9yZXdyaXRlID09PSB1bmRlZmluZWQgJiYgc2VsZltrZXldICE9PSBmYWxzZSkpIHtcbiAgICAgICAgc2VsZltrZXkgfHwgX2hlYWRlcl0gPSBub3JtYWxpemVWYWx1ZShfdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHNldEhlYWRlcnMgPSAoaGVhZGVycywgX3Jld3JpdGUpID0+XG4gICAgICB1dGlscy5mb3JFYWNoKGhlYWRlcnMsIChfdmFsdWUsIF9oZWFkZXIpID0+IHNldEhlYWRlcihfdmFsdWUsIF9oZWFkZXIsIF9yZXdyaXRlKSk7XG5cbiAgICBpZiAodXRpbHMuaXNQbGFpbk9iamVjdChoZWFkZXIpIHx8IGhlYWRlciBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3IpIHtcbiAgICAgIHNldEhlYWRlcnMoaGVhZGVyLCB2YWx1ZU9yUmV3cml0ZSlcbiAgICB9IGVsc2UgaWYodXRpbHMuaXNTdHJpbmcoaGVhZGVyKSAmJiAoaGVhZGVyID0gaGVhZGVyLnRyaW0oKSkgJiYgIWlzVmFsaWRIZWFkZXJOYW1lKGhlYWRlcikpIHtcbiAgICAgIHNldEhlYWRlcnMocGFyc2VIZWFkZXJzKGhlYWRlciksIHZhbHVlT3JSZXdyaXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVhZGVyICE9IG51bGwgJiYgc2V0SGVhZGVyKHZhbHVlT3JSZXdyaXRlLCBoZWFkZXIsIHJld3JpdGUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0KGhlYWRlciwgcGFyc2VyKSB7XG4gICAgaGVhZGVyID0gbm9ybWFsaXplSGVhZGVyKGhlYWRlcik7XG5cbiAgICBpZiAoaGVhZGVyKSB7XG4gICAgICBjb25zdCBrZXkgPSB1dGlscy5maW5kS2V5KHRoaXMsIGhlYWRlcik7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzW2tleV07XG5cbiAgICAgICAgaWYgKCFwYXJzZXIpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyc2VyID09PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlVG9rZW5zKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKHBhcnNlcikpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VyLmNhbGwodGhpcywgdmFsdWUsIGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXRpbHMuaXNSZWdFeHAocGFyc2VyKSkge1xuICAgICAgICAgIHJldHVybiBwYXJzZXIuZXhlYyh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJzZXIgbXVzdCBiZSBib29sZWFufHJlZ2V4cHxmdW5jdGlvbicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhhcyhoZWFkZXIsIG1hdGNoZXIpIHtcbiAgICBoZWFkZXIgPSBub3JtYWxpemVIZWFkZXIoaGVhZGVyKTtcblxuICAgIGlmIChoZWFkZXIpIHtcbiAgICAgIGNvbnN0IGtleSA9IHV0aWxzLmZpbmRLZXkodGhpcywgaGVhZGVyKTtcblxuICAgICAgcmV0dXJuICEhKGtleSAmJiB0aGlzW2tleV0gIT09IHVuZGVmaW5lZCAmJiAoIW1hdGNoZXIgfHwgbWF0Y2hIZWFkZXJWYWx1ZSh0aGlzLCB0aGlzW2tleV0sIGtleSwgbWF0Y2hlcikpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBkZWxldGUoaGVhZGVyLCBtYXRjaGVyKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgbGV0IGRlbGV0ZWQgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIGRlbGV0ZUhlYWRlcihfaGVhZGVyKSB7XG4gICAgICBfaGVhZGVyID0gbm9ybWFsaXplSGVhZGVyKF9oZWFkZXIpO1xuXG4gICAgICBpZiAoX2hlYWRlcikge1xuICAgICAgICBjb25zdCBrZXkgPSB1dGlscy5maW5kS2V5KHNlbGYsIF9oZWFkZXIpO1xuXG4gICAgICAgIGlmIChrZXkgJiYgKCFtYXRjaGVyIHx8IG1hdGNoSGVhZGVyVmFsdWUoc2VsZiwgc2VsZltrZXldLCBrZXksIG1hdGNoZXIpKSkge1xuICAgICAgICAgIGRlbGV0ZSBzZWxmW2tleV07XG5cbiAgICAgICAgICBkZWxldGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh1dGlscy5pc0FycmF5KGhlYWRlcikpIHtcbiAgICAgIGhlYWRlci5mb3JFYWNoKGRlbGV0ZUhlYWRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZUhlYWRlcihoZWFkZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBkZWxldGVkO1xuICB9XG5cbiAgY2xlYXIobWF0Y2hlcikge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKTtcbiAgICBsZXQgaSA9IGtleXMubGVuZ3RoO1xuICAgIGxldCBkZWxldGVkID0gZmFsc2U7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYoIW1hdGNoZXIgfHwgbWF0Y2hIZWFkZXJWYWx1ZSh0aGlzLCB0aGlzW2tleV0sIGtleSwgbWF0Y2hlciwgdHJ1ZSkpIHtcbiAgICAgICAgZGVsZXRlIHRoaXNba2V5XTtcbiAgICAgICAgZGVsZXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlbGV0ZWQ7XG4gIH1cblxuICBub3JtYWxpemUoZm9ybWF0KSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgY29uc3QgaGVhZGVycyA9IHt9O1xuXG4gICAgdXRpbHMuZm9yRWFjaCh0aGlzLCAodmFsdWUsIGhlYWRlcikgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gdXRpbHMuZmluZEtleShoZWFkZXJzLCBoZWFkZXIpO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIHNlbGZba2V5XSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcbiAgICAgICAgZGVsZXRlIHNlbGZbaGVhZGVyXTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBub3JtYWxpemVkID0gZm9ybWF0ID8gZm9ybWF0SGVhZGVyKGhlYWRlcikgOiBTdHJpbmcoaGVhZGVyKS50cmltKCk7XG5cbiAgICAgIGlmIChub3JtYWxpemVkICE9PSBoZWFkZXIpIHtcbiAgICAgICAgZGVsZXRlIHNlbGZbaGVhZGVyXTtcbiAgICAgIH1cblxuICAgICAgc2VsZltub3JtYWxpemVkXSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcblxuICAgICAgaGVhZGVyc1tub3JtYWxpemVkXSA9IHRydWU7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGNvbmNhdCguLi50YXJnZXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IuY29uY2F0KHRoaXMsIC4uLnRhcmdldHMpO1xuICB9XG5cbiAgdG9KU09OKGFzU3RyaW5ncykge1xuICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICB1dGlscy5mb3JFYWNoKHRoaXMsICh2YWx1ZSwgaGVhZGVyKSA9PiB7XG4gICAgICB2YWx1ZSAhPSBudWxsICYmIHZhbHVlICE9PSBmYWxzZSAmJiAob2JqW2hlYWRlcl0gPSBhc1N0cmluZ3MgJiYgdXRpbHMuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5qb2luKCcsICcpIDogdmFsdWUpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiBPYmplY3QuZW50cmllcyh0aGlzLnRvSlNPTigpKVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXModGhpcy50b0pTT04oKSkubWFwKChbaGVhZGVyLCB2YWx1ZV0pID0+IGhlYWRlciArICc6ICcgKyB2YWx1ZSkuam9pbignXFxuJyk7XG4gIH1cblxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuICdBeGlvc0hlYWRlcnMnO1xuICB9XG5cbiAgc3RhdGljIGZyb20odGhpbmcpIHtcbiAgICByZXR1cm4gdGhpbmcgaW5zdGFuY2VvZiB0aGlzID8gdGhpbmcgOiBuZXcgdGhpcyh0aGluZyk7XG4gIH1cblxuICBzdGF0aWMgY29uY2F0KGZpcnN0LCAuLi50YXJnZXRzKSB7XG4gICAgY29uc3QgY29tcHV0ZWQgPSBuZXcgdGhpcyhmaXJzdCk7XG5cbiAgICB0YXJnZXRzLmZvckVhY2goKHRhcmdldCkgPT4gY29tcHV0ZWQuc2V0KHRhcmdldCkpO1xuXG4gICAgcmV0dXJuIGNvbXB1dGVkO1xuICB9XG5cbiAgc3RhdGljIGFjY2Vzc29yKGhlYWRlcikge1xuICAgIGNvbnN0IGludGVybmFscyA9IHRoaXNbJGludGVybmFsc10gPSAodGhpc1skaW50ZXJuYWxzXSA9IHtcbiAgICAgIGFjY2Vzc29yczoge31cbiAgICB9KTtcblxuICAgIGNvbnN0IGFjY2Vzc29ycyA9IGludGVybmFscy5hY2Nlc3NvcnM7XG4gICAgY29uc3QgcHJvdG90eXBlID0gdGhpcy5wcm90b3R5cGU7XG5cbiAgICBmdW5jdGlvbiBkZWZpbmVBY2Nlc3NvcihfaGVhZGVyKSB7XG4gICAgICBjb25zdCBsSGVhZGVyID0gbm9ybWFsaXplSGVhZGVyKF9oZWFkZXIpO1xuXG4gICAgICBpZiAoIWFjY2Vzc29yc1tsSGVhZGVyXSkge1xuICAgICAgICBidWlsZEFjY2Vzc29ycyhwcm90b3R5cGUsIF9oZWFkZXIpO1xuICAgICAgICBhY2Nlc3NvcnNbbEhlYWRlcl0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHV0aWxzLmlzQXJyYXkoaGVhZGVyKSA/IGhlYWRlci5mb3JFYWNoKGRlZmluZUFjY2Vzc29yKSA6IGRlZmluZUFjY2Vzc29yKGhlYWRlcik7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG5BeGlvc0hlYWRlcnMuYWNjZXNzb3IoWydDb250ZW50LVR5cGUnLCAnQ29udGVudC1MZW5ndGgnLCAnQWNjZXB0JywgJ0FjY2VwdC1FbmNvZGluZycsICdVc2VyLUFnZW50JywgJ0F1dGhvcml6YXRpb24nXSk7XG5cbi8vIHJlc2VydmVkIG5hbWVzIGhvdGZpeFxudXRpbHMucmVkdWNlRGVzY3JpcHRvcnMoQXhpb3NIZWFkZXJzLnByb3RvdHlwZSwgKHt2YWx1ZX0sIGtleSkgPT4ge1xuICBsZXQgbWFwcGVkID0ga2V5WzBdLnRvVXBwZXJDYXNlKCkgKyBrZXkuc2xpY2UoMSk7IC8vIG1hcCBgc2V0YCA9PiBgU2V0YFxuICByZXR1cm4ge1xuICAgIGdldDogKCkgPT4gdmFsdWUsXG4gICAgc2V0KGhlYWRlclZhbHVlKSB7XG4gICAgICB0aGlzW21hcHBlZF0gPSBoZWFkZXJWYWx1ZTtcbiAgICB9XG4gIH1cbn0pO1xuXG51dGlscy5mcmVlemVNZXRob2RzKEF4aW9zSGVhZGVycyk7XG5cbmV4cG9ydCBkZWZhdWx0IEF4aW9zSGVhZGVycztcbiIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLy4uL3V0aWxzLmpzJztcbmltcG9ydCBkZWZhdWx0cyBmcm9tICcuLi9kZWZhdWx0cy9pbmRleC5qcyc7XG5pbXBvcnQgQXhpb3NIZWFkZXJzIGZyb20gJy4uL2NvcmUvQXhpb3NIZWFkZXJzLmpzJztcblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIGRhdGEgZm9yIGEgcmVxdWVzdCBvciBhIHJlc3BvbnNlXG4gKlxuICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbn0gZm5zIEEgc2luZ2xlIGZ1bmN0aW9uIG9yIEFycmF5IG9mIGZ1bmN0aW9uc1xuICogQHBhcmFtIHs/T2JqZWN0fSByZXNwb25zZSBUaGUgcmVzcG9uc2Ugb2JqZWN0XG4gKlxuICogQHJldHVybnMgeyp9IFRoZSByZXN1bHRpbmcgdHJhbnNmb3JtZWQgZGF0YVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0cmFuc2Zvcm1EYXRhKGZucywgcmVzcG9uc2UpIHtcbiAgY29uc3QgY29uZmlnID0gdGhpcyB8fCBkZWZhdWx0cztcbiAgY29uc3QgY29udGV4dCA9IHJlc3BvbnNlIHx8IGNvbmZpZztcbiAgY29uc3QgaGVhZGVycyA9IEF4aW9zSGVhZGVycy5mcm9tKGNvbnRleHQuaGVhZGVycyk7XG4gIGxldCBkYXRhID0gY29udGV4dC5kYXRhO1xuXG4gIHV0aWxzLmZvckVhY2goZm5zLCBmdW5jdGlvbiB0cmFuc2Zvcm0oZm4pIHtcbiAgICBkYXRhID0gZm4uY2FsbChjb25maWcsIGRhdGEsIGhlYWRlcnMubm9ybWFsaXplKCksIHJlc3BvbnNlID8gcmVzcG9uc2Uuc3RhdHVzIDogdW5kZWZpbmVkKTtcbiAgfSk7XG5cbiAgaGVhZGVycy5ub3JtYWxpemUoKTtcblxuICByZXR1cm4gZGF0YTtcbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzQ2FuY2VsKHZhbHVlKSB7XG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5fX0NBTkNFTF9fKTtcbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBBeGlvc0Vycm9yIGZyb20gJy4uL2NvcmUvQXhpb3NFcnJvci5qcyc7XG5pbXBvcnQgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuXG4vKipcbiAqIEEgYENhbmNlbGVkRXJyb3JgIGlzIGFuIG9iamVjdCB0aGF0IGlzIHRocm93biB3aGVuIGFuIG9wZXJhdGlvbiBpcyBjYW5jZWxlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZz19IG1lc3NhZ2UgVGhlIG1lc3NhZ2UuXG4gKiBAcGFyYW0ge09iamVjdD19IGNvbmZpZyBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtPYmplY3Q9fSByZXF1ZXN0IFRoZSByZXF1ZXN0LlxuICpcbiAqIEByZXR1cm5zIHtDYW5jZWxlZEVycm9yfSBUaGUgY3JlYXRlZCBlcnJvci5cbiAqL1xuZnVuY3Rpb24gQ2FuY2VsZWRFcnJvcihtZXNzYWdlLCBjb25maWcsIHJlcXVlc3QpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVxLW51bGwsZXFlcWVxXG4gIEF4aW9zRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlID09IG51bGwgPyAnY2FuY2VsZWQnIDogbWVzc2FnZSwgQXhpb3NFcnJvci5FUlJfQ0FOQ0VMRUQsIGNvbmZpZywgcmVxdWVzdCk7XG4gIHRoaXMubmFtZSA9ICdDYW5jZWxlZEVycm9yJztcbn1cblxudXRpbHMuaW5oZXJpdHMoQ2FuY2VsZWRFcnJvciwgQXhpb3NFcnJvciwge1xuICBfX0NBTkNFTF9fOiB0cnVlXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgQ2FuY2VsZWRFcnJvcjtcbiIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBBeGlvc0Vycm9yIGZyb20gJy4vQXhpb3NFcnJvci5qcyc7XG5cbi8qKlxuICogUmVzb2x2ZSBvciByZWplY3QgYSBQcm9taXNlIGJhc2VkIG9uIHJlc3BvbnNlIHN0YXR1cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlIEEgZnVuY3Rpb24gdGhhdCByZXNvbHZlcyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdCBBIGZ1bmN0aW9uIHRoYXQgcmVqZWN0cyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZSBUaGUgcmVzcG9uc2UuXG4gKlxuICogQHJldHVybnMge29iamVjdH0gVGhlIHJlc3BvbnNlLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSkge1xuICBjb25zdCB2YWxpZGF0ZVN0YXR1cyA9IHJlc3BvbnNlLmNvbmZpZy52YWxpZGF0ZVN0YXR1cztcbiAgaWYgKCFyZXNwb25zZS5zdGF0dXMgfHwgIXZhbGlkYXRlU3RhdHVzIHx8IHZhbGlkYXRlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgfSBlbHNlIHtcbiAgICByZWplY3QobmV3IEF4aW9zRXJyb3IoXG4gICAgICAnUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAnICsgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgW0F4aW9zRXJyb3IuRVJSX0JBRF9SRVFVRVNULCBBeGlvc0Vycm9yLkVSUl9CQURfUkVTUE9OU0VdW01hdGguZmxvb3IocmVzcG9uc2Uuc3RhdHVzIC8gMTAwKSAtIDRdLFxuICAgICAgcmVzcG9uc2UuY29uZmlnLFxuICAgICAgcmVzcG9uc2UucmVxdWVzdCxcbiAgICAgIHJlc3BvbnNlXG4gICAgKSk7XG4gIH1cbn1cbiIsICJpbXBvcnQgdXRpbHMgZnJvbSAnLi8uLi91dGlscy5qcyc7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vcGxhdGZvcm0vaW5kZXguanMnO1xuXG5leHBvcnQgZGVmYXVsdCBwbGF0Zm9ybS5oYXNTdGFuZGFyZEJyb3dzZXJFbnYgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBzdXBwb3J0IGRvY3VtZW50LmNvb2tpZVxuICB7XG4gICAgd3JpdGUobmFtZSwgdmFsdWUsIGV4cGlyZXMsIHBhdGgsIGRvbWFpbiwgc2VjdXJlKSB7XG4gICAgICBjb25zdCBjb29raWUgPSBbbmFtZSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSldO1xuXG4gICAgICB1dGlscy5pc051bWJlcihleHBpcmVzKSAmJiBjb29raWUucHVzaCgnZXhwaXJlcz0nICsgbmV3IERhdGUoZXhwaXJlcykudG9HTVRTdHJpbmcoKSk7XG5cbiAgICAgIHV0aWxzLmlzU3RyaW5nKHBhdGgpICYmIGNvb2tpZS5wdXNoKCdwYXRoPScgKyBwYXRoKTtcblxuICAgICAgdXRpbHMuaXNTdHJpbmcoZG9tYWluKSAmJiBjb29raWUucHVzaCgnZG9tYWluPScgKyBkb21haW4pO1xuXG4gICAgICBzZWN1cmUgPT09IHRydWUgJiYgY29va2llLnB1c2goJ3NlY3VyZScpO1xuXG4gICAgICBkb2N1bWVudC5jb29raWUgPSBjb29raWUuam9pbignOyAnKTtcbiAgICB9LFxuXG4gICAgcmVhZChuYW1lKSB7XG4gICAgICBjb25zdCBtYXRjaCA9IGRvY3VtZW50LmNvb2tpZS5tYXRjaChuZXcgUmVnRXhwKCcoXnw7XFxcXHMqKSgnICsgbmFtZSArICcpPShbXjtdKiknKSk7XG4gICAgICByZXR1cm4gKG1hdGNoID8gZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoWzNdKSA6IG51bGwpO1xuICAgIH0sXG5cbiAgICByZW1vdmUobmFtZSkge1xuICAgICAgdGhpcy53cml0ZShuYW1lLCAnJywgRGF0ZS5ub3coKSAtIDg2NDAwMDAwKTtcbiAgICB9XG4gIH1cblxuICA6XG5cbiAgLy8gTm9uLXN0YW5kYXJkIGJyb3dzZXIgZW52ICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICB7XG4gICAgd3JpdGUoKSB7fSxcbiAgICByZWFkKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICByZW1vdmUoKSB7fVxuICB9O1xuXG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc0Fic29sdXRlVVJMKHVybCkge1xuICAvLyBBIFVSTCBpcyBjb25zaWRlcmVkIGFic29sdXRlIGlmIGl0IGJlZ2lucyB3aXRoIFwiPHNjaGVtZT46Ly9cIiBvciBcIi8vXCIgKHByb3RvY29sLXJlbGF0aXZlIFVSTCkuXG4gIC8vIFJGQyAzOTg2IGRlZmluZXMgc2NoZW1lIG5hbWUgYXMgYSBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzIGJlZ2lubmluZyB3aXRoIGEgbGV0dGVyIGFuZCBmb2xsb3dlZFxuICAvLyBieSBhbnkgY29tYmluYXRpb24gb2YgbGV0dGVycywgZGlnaXRzLCBwbHVzLCBwZXJpb2QsIG9yIGh5cGhlbi5cbiAgcmV0dXJuIC9eKFthLXpdW2EtelxcZCtcXC0uXSo6KT9cXC9cXC8vaS50ZXN0KHVybCk7XG59XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVVJMIGJ5IGNvbWJpbmluZyB0aGUgc3BlY2lmaWVkIFVSTHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSTCBUaGUgYmFzZSBVUkxcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWxhdGl2ZVVSTCBUaGUgcmVsYXRpdmUgVVJMXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIFVSTFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZWxhdGl2ZVVSTCkge1xuICByZXR1cm4gcmVsYXRpdmVVUkxcbiAgICA/IGJhc2VVUkwucmVwbGFjZSgvXFwvP1xcLyQvLCAnJykgKyAnLycgKyByZWxhdGl2ZVVSTC5yZXBsYWNlKC9eXFwvKy8sICcnKVxuICAgIDogYmFzZVVSTDtcbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCBpc0Fic29sdXRlVVJMIGZyb20gJy4uL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTC5qcyc7XG5pbXBvcnQgY29tYmluZVVSTHMgZnJvbSAnLi4vaGVscGVycy9jb21iaW5lVVJMcy5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBiYXNlVVJMIHdpdGggdGhlIHJlcXVlc3RlZFVSTCxcbiAqIG9ubHkgd2hlbiB0aGUgcmVxdWVzdGVkVVJMIGlzIG5vdCBhbHJlYWR5IGFuIGFic29sdXRlIFVSTC5cbiAqIElmIHRoZSByZXF1ZXN0VVJMIGlzIGFic29sdXRlLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIHJlcXVlc3RlZFVSTCB1bnRvdWNoZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVxdWVzdGVkVVJMIEFic29sdXRlIG9yIHJlbGF0aXZlIFVSTCB0byBjb21iaW5lXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIGZ1bGwgcGF0aFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBidWlsZEZ1bGxQYXRoKGJhc2VVUkwsIHJlcXVlc3RlZFVSTCkge1xuICBpZiAoYmFzZVVSTCAmJiAhaXNBYnNvbHV0ZVVSTChyZXF1ZXN0ZWRVUkwpKSB7XG4gICAgcmV0dXJuIGNvbWJpbmVVUkxzKGJhc2VVUkwsIHJlcXVlc3RlZFVSTCk7XG4gIH1cbiAgcmV0dXJuIHJlcXVlc3RlZFVSTDtcbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLy4uL3V0aWxzLmpzJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi9wbGF0Zm9ybS9pbmRleC5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHBsYXRmb3JtLmhhc1N0YW5kYXJkQnJvd3NlckVudiA/XG5cbi8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBoYXZlIGZ1bGwgc3VwcG9ydCBvZiB0aGUgQVBJcyBuZWVkZWQgdG8gdGVzdFxuLy8gd2hldGhlciB0aGUgcmVxdWVzdCBVUkwgaXMgb2YgdGhlIHNhbWUgb3JpZ2luIGFzIGN1cnJlbnQgbG9jYXRpb24uXG4gIChmdW5jdGlvbiBzdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgY29uc3QgbXNpZSA9IC8obXNpZXx0cmlkZW50KS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgY29uc3QgdXJsUGFyc2luZ05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgbGV0IG9yaWdpblVSTDtcblxuICAgIC8qKlxuICAgICogUGFyc2UgYSBVUkwgdG8gZGlzY292ZXIgaXRzIGNvbXBvbmVudHNcbiAgICAqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFRoZSBVUkwgdG8gYmUgcGFyc2VkXG4gICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICovXG4gICAgZnVuY3Rpb24gcmVzb2x2ZVVSTCh1cmwpIHtcbiAgICAgIGxldCBocmVmID0gdXJsO1xuXG4gICAgICBpZiAobXNpZSkge1xuICAgICAgICAvLyBJRSBuZWVkcyBhdHRyaWJ1dGUgc2V0IHR3aWNlIHRvIG5vcm1hbGl6ZSBwcm9wZXJ0aWVzXG4gICAgICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpO1xuICAgICAgICBocmVmID0gdXJsUGFyc2luZ05vZGUuaHJlZjtcbiAgICAgIH1cblxuICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG5cbiAgICAgIC8vIHVybFBhcnNpbmdOb2RlIHByb3ZpZGVzIHRoZSBVcmxVdGlscyBpbnRlcmZhY2UgLSBodHRwOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsdXRpbHNcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhyZWY6IHVybFBhcnNpbmdOb2RlLmhyZWYsXG4gICAgICAgIHByb3RvY29sOiB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbCA/IHVybFBhcnNpbmdOb2RlLnByb3RvY29sLnJlcGxhY2UoLzokLywgJycpIDogJycsXG4gICAgICAgIGhvc3Q6IHVybFBhcnNpbmdOb2RlLmhvc3QsXG4gICAgICAgIHNlYXJjaDogdXJsUGFyc2luZ05vZGUuc2VhcmNoID8gdXJsUGFyc2luZ05vZGUuc2VhcmNoLnJlcGxhY2UoL15cXD8vLCAnJykgOiAnJyxcbiAgICAgICAgaGFzaDogdXJsUGFyc2luZ05vZGUuaGFzaCA/IHVybFBhcnNpbmdOb2RlLmhhc2gucmVwbGFjZSgvXiMvLCAnJykgOiAnJyxcbiAgICAgICAgaG9zdG5hbWU6IHVybFBhcnNpbmdOb2RlLmhvc3RuYW1lLFxuICAgICAgICBwb3J0OiB1cmxQYXJzaW5nTm9kZS5wb3J0LFxuICAgICAgICBwYXRobmFtZTogKHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSA/XG4gICAgICAgICAgdXJsUGFyc2luZ05vZGUucGF0aG5hbWUgOlxuICAgICAgICAgICcvJyArIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lXG4gICAgICB9O1xuICAgIH1cblxuICAgIG9yaWdpblVSTCA9IHJlc29sdmVVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuXG4gICAgLyoqXG4gICAgKiBEZXRlcm1pbmUgaWYgYSBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiBhcyB0aGUgY3VycmVudCBsb2NhdGlvblxuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0VVJMIFRoZSBVUkwgdG8gdGVzdFxuICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4sIG90aGVyd2lzZSBmYWxzZVxuICAgICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbihyZXF1ZXN0VVJMKSB7XG4gICAgICBjb25zdCBwYXJzZWQgPSAodXRpbHMuaXNTdHJpbmcocmVxdWVzdFVSTCkpID8gcmVzb2x2ZVVSTChyZXF1ZXN0VVJMKSA6IHJlcXVlc3RVUkw7XG4gICAgICByZXR1cm4gKHBhcnNlZC5wcm90b2NvbCA9PT0gb3JpZ2luVVJMLnByb3RvY29sICYmXG4gICAgICAgICAgcGFyc2VkLmhvc3QgPT09IG9yaWdpblVSTC5ob3N0KTtcbiAgICB9O1xuICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnZzICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICAoZnVuY3Rpb24gbm9uU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4oKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9KSgpO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGFyc2VQcm90b2NvbCh1cmwpIHtcbiAgY29uc3QgbWF0Y2ggPSAvXihbLStcXHddezEsMjV9KSg6P1xcL1xcL3w6KS8uZXhlYyh1cmwpO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG59XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENhbGN1bGF0ZSBkYXRhIG1heFJhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2FtcGxlc0NvdW50PSAxMF1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbbWluPSAxMDAwXVxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBzcGVlZG9tZXRlcihzYW1wbGVzQ291bnQsIG1pbikge1xuICBzYW1wbGVzQ291bnQgPSBzYW1wbGVzQ291bnQgfHwgMTA7XG4gIGNvbnN0IGJ5dGVzID0gbmV3IEFycmF5KHNhbXBsZXNDb3VudCk7XG4gIGNvbnN0IHRpbWVzdGFtcHMgPSBuZXcgQXJyYXkoc2FtcGxlc0NvdW50KTtcbiAgbGV0IGhlYWQgPSAwO1xuICBsZXQgdGFpbCA9IDA7XG4gIGxldCBmaXJzdFNhbXBsZVRTO1xuXG4gIG1pbiA9IG1pbiAhPT0gdW5kZWZpbmVkID8gbWluIDogMTAwMDtcblxuICByZXR1cm4gZnVuY3Rpb24gcHVzaChjaHVua0xlbmd0aCkge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG5cbiAgICBjb25zdCBzdGFydGVkQXQgPSB0aW1lc3RhbXBzW3RhaWxdO1xuXG4gICAgaWYgKCFmaXJzdFNhbXBsZVRTKSB7XG4gICAgICBmaXJzdFNhbXBsZVRTID0gbm93O1xuICAgIH1cblxuICAgIGJ5dGVzW2hlYWRdID0gY2h1bmtMZW5ndGg7XG4gICAgdGltZXN0YW1wc1toZWFkXSA9IG5vdztcblxuICAgIGxldCBpID0gdGFpbDtcbiAgICBsZXQgYnl0ZXNDb3VudCA9IDA7XG5cbiAgICB3aGlsZSAoaSAhPT0gaGVhZCkge1xuICAgICAgYnl0ZXNDb3VudCArPSBieXRlc1tpKytdO1xuICAgICAgaSA9IGkgJSBzYW1wbGVzQ291bnQ7XG4gICAgfVxuXG4gICAgaGVhZCA9IChoZWFkICsgMSkgJSBzYW1wbGVzQ291bnQ7XG5cbiAgICBpZiAoaGVhZCA9PT0gdGFpbCkge1xuICAgICAgdGFpbCA9ICh0YWlsICsgMSkgJSBzYW1wbGVzQ291bnQ7XG4gICAgfVxuXG4gICAgaWYgKG5vdyAtIGZpcnN0U2FtcGxlVFMgPCBtaW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBwYXNzZWQgPSBzdGFydGVkQXQgJiYgbm93IC0gc3RhcnRlZEF0O1xuXG4gICAgcmV0dXJuIHBhc3NlZCA/IE1hdGgucm91bmQoYnl0ZXNDb3VudCAqIDEwMDAgLyBwYXNzZWQpIDogdW5kZWZpbmVkO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBzcGVlZG9tZXRlcjtcbiIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuLy4uL3V0aWxzLmpzJztcbmltcG9ydCBzZXR0bGUgZnJvbSAnLi8uLi9jb3JlL3NldHRsZS5qcyc7XG5pbXBvcnQgY29va2llcyBmcm9tICcuLy4uL2hlbHBlcnMvY29va2llcy5qcyc7XG5pbXBvcnQgYnVpbGRVUkwgZnJvbSAnLi8uLi9oZWxwZXJzL2J1aWxkVVJMLmpzJztcbmltcG9ydCBidWlsZEZ1bGxQYXRoIGZyb20gJy4uL2NvcmUvYnVpbGRGdWxsUGF0aC5qcyc7XG5pbXBvcnQgaXNVUkxTYW1lT3JpZ2luIGZyb20gJy4vLi4vaGVscGVycy9pc1VSTFNhbWVPcmlnaW4uanMnO1xuaW1wb3J0IHRyYW5zaXRpb25hbERlZmF1bHRzIGZyb20gJy4uL2RlZmF1bHRzL3RyYW5zaXRpb25hbC5qcyc7XG5pbXBvcnQgQXhpb3NFcnJvciBmcm9tICcuLi9jb3JlL0F4aW9zRXJyb3IuanMnO1xuaW1wb3J0IENhbmNlbGVkRXJyb3IgZnJvbSAnLi4vY2FuY2VsL0NhbmNlbGVkRXJyb3IuanMnO1xuaW1wb3J0IHBhcnNlUHJvdG9jb2wgZnJvbSAnLi4vaGVscGVycy9wYXJzZVByb3RvY29sLmpzJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi9wbGF0Zm9ybS9pbmRleC5qcyc7XG5pbXBvcnQgQXhpb3NIZWFkZXJzIGZyb20gJy4uL2NvcmUvQXhpb3NIZWFkZXJzLmpzJztcbmltcG9ydCBzcGVlZG9tZXRlciBmcm9tICcuLi9oZWxwZXJzL3NwZWVkb21ldGVyLmpzJztcblxuZnVuY3Rpb24gcHJvZ3Jlc3NFdmVudFJlZHVjZXIobGlzdGVuZXIsIGlzRG93bmxvYWRTdHJlYW0pIHtcbiAgbGV0IGJ5dGVzTm90aWZpZWQgPSAwO1xuICBjb25zdCBfc3BlZWRvbWV0ZXIgPSBzcGVlZG9tZXRlcig1MCwgMjUwKTtcblxuICByZXR1cm4gZSA9PiB7XG4gICAgY29uc3QgbG9hZGVkID0gZS5sb2FkZWQ7XG4gICAgY29uc3QgdG90YWwgPSBlLmxlbmd0aENvbXB1dGFibGUgPyBlLnRvdGFsIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHByb2dyZXNzQnl0ZXMgPSBsb2FkZWQgLSBieXRlc05vdGlmaWVkO1xuICAgIGNvbnN0IHJhdGUgPSBfc3BlZWRvbWV0ZXIocHJvZ3Jlc3NCeXRlcyk7XG4gICAgY29uc3QgaW5SYW5nZSA9IGxvYWRlZCA8PSB0b3RhbDtcblxuICAgIGJ5dGVzTm90aWZpZWQgPSBsb2FkZWQ7XG5cbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgbG9hZGVkLFxuICAgICAgdG90YWwsXG4gICAgICBwcm9ncmVzczogdG90YWwgPyAobG9hZGVkIC8gdG90YWwpIDogdW5kZWZpbmVkLFxuICAgICAgYnl0ZXM6IHByb2dyZXNzQnl0ZXMsXG4gICAgICByYXRlOiByYXRlID8gcmF0ZSA6IHVuZGVmaW5lZCxcbiAgICAgIGVzdGltYXRlZDogcmF0ZSAmJiB0b3RhbCAmJiBpblJhbmdlID8gKHRvdGFsIC0gbG9hZGVkKSAvIHJhdGUgOiB1bmRlZmluZWQsXG4gICAgICBldmVudDogZVxuICAgIH07XG5cbiAgICBkYXRhW2lzRG93bmxvYWRTdHJlYW0gPyAnZG93bmxvYWQnIDogJ3VwbG9hZCddID0gdHJ1ZTtcblxuICAgIGxpc3RlbmVyKGRhdGEpO1xuICB9O1xufVxuXG5jb25zdCBpc1hIUkFkYXB0ZXJTdXBwb3J0ZWQgPSB0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnO1xuXG5leHBvcnQgZGVmYXVsdCBpc1hIUkFkYXB0ZXJTdXBwb3J0ZWQgJiYgZnVuY3Rpb24gKGNvbmZpZykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gZGlzcGF0Y2hYaHJSZXF1ZXN0KHJlc29sdmUsIHJlamVjdCkge1xuICAgIGxldCByZXF1ZXN0RGF0YSA9IGNvbmZpZy5kYXRhO1xuICAgIGNvbnN0IHJlcXVlc3RIZWFkZXJzID0gQXhpb3NIZWFkZXJzLmZyb20oY29uZmlnLmhlYWRlcnMpLm5vcm1hbGl6ZSgpO1xuICAgIGxldCB7cmVzcG9uc2VUeXBlLCB3aXRoWFNSRlRva2VufSA9IGNvbmZpZztcbiAgICBsZXQgb25DYW5jZWxlZDtcbiAgICBmdW5jdGlvbiBkb25lKCkge1xuICAgICAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgICAgICBjb25maWcuY2FuY2VsVG9rZW4udW5zdWJzY3JpYmUob25DYW5jZWxlZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb25maWcuc2lnbmFsKSB7XG4gICAgICAgIGNvbmZpZy5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBvbkNhbmNlbGVkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgY29udGVudFR5cGU7XG5cbiAgICBpZiAodXRpbHMuaXNGb3JtRGF0YShyZXF1ZXN0RGF0YSkpIHtcbiAgICAgIGlmIChwbGF0Zm9ybS5oYXNTdGFuZGFyZEJyb3dzZXJFbnYgfHwgcGxhdGZvcm0uaGFzU3RhbmRhcmRCcm93c2VyV2ViV29ya2VyRW52KSB7XG4gICAgICAgIHJlcXVlc3RIZWFkZXJzLnNldENvbnRlbnRUeXBlKGZhbHNlKTsgLy8gTGV0IHRoZSBicm93c2VyIHNldCBpdFxuICAgICAgfSBlbHNlIGlmICgoY29udGVudFR5cGUgPSByZXF1ZXN0SGVhZGVycy5nZXRDb250ZW50VHlwZSgpKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgLy8gZml4IHNlbWljb2xvbiBkdXBsaWNhdGlvbiBpc3N1ZSBmb3IgUmVhY3ROYXRpdmUgRm9ybURhdGEgaW1wbGVtZW50YXRpb25cbiAgICAgICAgY29uc3QgW3R5cGUsIC4uLnRva2Vuc10gPSBjb250ZW50VHlwZSA/IGNvbnRlbnRUeXBlLnNwbGl0KCc7JykubWFwKHRva2VuID0+IHRva2VuLnRyaW0oKSkuZmlsdGVyKEJvb2xlYW4pIDogW107XG4gICAgICAgIHJlcXVlc3RIZWFkZXJzLnNldENvbnRlbnRUeXBlKFt0eXBlIHx8ICdtdWx0aXBhcnQvZm9ybS1kYXRhJywgLi4udG9rZW5zXS5qb2luKCc7ICcpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgLy8gSFRUUCBiYXNpYyBhdXRoZW50aWNhdGlvblxuICAgIGlmIChjb25maWcuYXV0aCkge1xuICAgICAgY29uc3QgdXNlcm5hbWUgPSBjb25maWcuYXV0aC51c2VybmFtZSB8fCAnJztcbiAgICAgIGNvbnN0IHBhc3N3b3JkID0gY29uZmlnLmF1dGgucGFzc3dvcmQgPyB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoY29uZmlnLmF1dGgucGFzc3dvcmQpKSA6ICcnO1xuICAgICAgcmVxdWVzdEhlYWRlcnMuc2V0KCdBdXRob3JpemF0aW9uJywgJ0Jhc2ljICcgKyBidG9hKHVzZXJuYW1lICsgJzonICsgcGFzc3dvcmQpKTtcbiAgICB9XG5cbiAgICBjb25zdCBmdWxsUGF0aCA9IGJ1aWxkRnVsbFBhdGgoY29uZmlnLmJhc2VVUkwsIGNvbmZpZy51cmwpO1xuXG4gICAgcmVxdWVzdC5vcGVuKGNvbmZpZy5tZXRob2QudG9VcHBlckNhc2UoKSwgYnVpbGRVUkwoZnVsbFBhdGgsIGNvbmZpZy5wYXJhbXMsIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyKSwgdHJ1ZSk7XG5cbiAgICAvLyBTZXQgdGhlIHJlcXVlc3QgdGltZW91dCBpbiBNU1xuICAgIHJlcXVlc3QudGltZW91dCA9IGNvbmZpZy50aW1lb3V0O1xuXG4gICAgZnVuY3Rpb24gb25sb2FkZW5kKCkge1xuICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFByZXBhcmUgdGhlIHJlc3BvbnNlXG4gICAgICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBBeGlvc0hlYWRlcnMuZnJvbShcbiAgICAgICAgJ2dldEFsbFJlc3BvbnNlSGVhZGVycycgaW4gcmVxdWVzdCAmJiByZXF1ZXN0LmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG4gICAgICApO1xuICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0gIXJlc3BvbnNlVHlwZSB8fCByZXNwb25zZVR5cGUgPT09ICd0ZXh0JyB8fCByZXNwb25zZVR5cGUgPT09ICdqc29uJyA/XG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUZXh0IDogcmVxdWVzdC5yZXNwb25zZTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0ge1xuICAgICAgICBkYXRhOiByZXNwb25zZURhdGEsXG4gICAgICAgIHN0YXR1czogcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlcXVlc3Quc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICBjb25maWcsXG4gICAgICAgIHJlcXVlc3RcbiAgICAgIH07XG5cbiAgICAgIHNldHRsZShmdW5jdGlvbiBfcmVzb2x2ZSh2YWx1ZSkge1xuICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSwgZnVuY3Rpb24gX3JlamVjdChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0sIHJlc3BvbnNlKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCdvbmxvYWRlbmQnIGluIHJlcXVlc3QpIHtcbiAgICAgIC8vIFVzZSBvbmxvYWRlbmQgaWYgYXZhaWxhYmxlXG4gICAgICByZXF1ZXN0Lm9ubG9hZGVuZCA9IG9ubG9hZGVuZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTGlzdGVuIGZvciByZWFkeSBzdGF0ZSB0byBlbXVsYXRlIG9ubG9hZGVuZFxuICAgICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVMb2FkKCkge1xuICAgICAgICBpZiAoIXJlcXVlc3QgfHwgcmVxdWVzdC5yZWFkeVN0YXRlICE9PSA0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIHJlcXVlc3QgZXJyb3JlZCBvdXQgYW5kIHdlIGRpZG4ndCBnZXQgYSByZXNwb25zZSwgdGhpcyB3aWxsIGJlXG4gICAgICAgIC8vIGhhbmRsZWQgYnkgb25lcnJvciBpbnN0ZWFkXG4gICAgICAgIC8vIFdpdGggb25lIGV4Y2VwdGlvbjogcmVxdWVzdCB0aGF0IHVzaW5nIGZpbGU6IHByb3RvY29sLCBtb3N0IGJyb3dzZXJzXG4gICAgICAgIC8vIHdpbGwgcmV0dXJuIHN0YXR1cyBhcyAwIGV2ZW4gdGhvdWdoIGl0J3MgYSBzdWNjZXNzZnVsIHJlcXVlc3RcbiAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAwICYmICEocmVxdWVzdC5yZXNwb25zZVVSTCAmJiByZXF1ZXN0LnJlc3BvbnNlVVJMLmluZGV4T2YoJ2ZpbGU6JykgPT09IDApKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlYWR5c3RhdGUgaGFuZGxlciBpcyBjYWxsaW5nIGJlZm9yZSBvbmVycm9yIG9yIG9udGltZW91dCBoYW5kbGVycyxcbiAgICAgICAgLy8gc28gd2Ugc2hvdWxkIGNhbGwgb25sb2FkZW5kIG9uIHRoZSBuZXh0ICd0aWNrJ1xuICAgICAgICBzZXRUaW1lb3V0KG9ubG9hZGVuZCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBicm93c2VyIHJlcXVlc3QgY2FuY2VsbGF0aW9uIChhcyBvcHBvc2VkIHRvIGEgbWFudWFsIGNhbmNlbGxhdGlvbilcbiAgICByZXF1ZXN0Lm9uYWJvcnQgPSBmdW5jdGlvbiBoYW5kbGVBYm9ydCgpIHtcbiAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlamVjdChuZXcgQXhpb3NFcnJvcignUmVxdWVzdCBhYm9ydGVkJywgQXhpb3NFcnJvci5FQ09OTkFCT1JURUQsIGNvbmZpZywgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIGxvdyBsZXZlbCBuZXR3b3JrIGVycm9yc1xuICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIGhhbmRsZUVycm9yKCkge1xuICAgICAgLy8gUmVhbCBlcnJvcnMgYXJlIGhpZGRlbiBmcm9tIHVzIGJ5IHRoZSBicm93c2VyXG4gICAgICAvLyBvbmVycm9yIHNob3VsZCBvbmx5IGZpcmUgaWYgaXQncyBhIG5ldHdvcmsgZXJyb3JcbiAgICAgIHJlamVjdChuZXcgQXhpb3NFcnJvcignTmV0d29yayBFcnJvcicsIEF4aW9zRXJyb3IuRVJSX05FVFdPUkssIGNvbmZpZywgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIHRpbWVvdXRcbiAgICByZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoKSB7XG4gICAgICBsZXQgdGltZW91dEVycm9yTWVzc2FnZSA9IGNvbmZpZy50aW1lb3V0ID8gJ3RpbWVvdXQgb2YgJyArIGNvbmZpZy50aW1lb3V0ICsgJ21zIGV4Y2VlZGVkJyA6ICd0aW1lb3V0IGV4Y2VlZGVkJztcbiAgICAgIGNvbnN0IHRyYW5zaXRpb25hbCA9IGNvbmZpZy50cmFuc2l0aW9uYWwgfHwgdHJhbnNpdGlvbmFsRGVmYXVsdHM7XG4gICAgICBpZiAoY29uZmlnLnRpbWVvdXRFcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgdGltZW91dEVycm9yTWVzc2FnZSA9IGNvbmZpZy50aW1lb3V0RXJyb3JNZXNzYWdlO1xuICAgICAgfVxuICAgICAgcmVqZWN0KG5ldyBBeGlvc0Vycm9yKFxuICAgICAgICB0aW1lb3V0RXJyb3JNZXNzYWdlLFxuICAgICAgICB0cmFuc2l0aW9uYWwuY2xhcmlmeVRpbWVvdXRFcnJvciA/IEF4aW9zRXJyb3IuRVRJTUVET1VUIDogQXhpb3NFcnJvci5FQ09OTkFCT1JURUQsXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgLy8gVGhpcyBpcyBvbmx5IGRvbmUgaWYgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnQuXG4gICAgLy8gU3BlY2lmaWNhbGx5IG5vdCBpZiB3ZSdyZSBpbiBhIHdlYiB3b3JrZXIsIG9yIHJlYWN0LW5hdGl2ZS5cbiAgICBpZihwbGF0Zm9ybS5oYXNTdGFuZGFyZEJyb3dzZXJFbnYpIHtcbiAgICAgIHdpdGhYU1JGVG9rZW4gJiYgdXRpbHMuaXNGdW5jdGlvbih3aXRoWFNSRlRva2VuKSAmJiAod2l0aFhTUkZUb2tlbiA9IHdpdGhYU1JGVG9rZW4oY29uZmlnKSk7XG5cbiAgICAgIGlmICh3aXRoWFNSRlRva2VuIHx8ICh3aXRoWFNSRlRva2VuICE9PSBmYWxzZSAmJiBpc1VSTFNhbWVPcmlnaW4oZnVsbFBhdGgpKSkge1xuICAgICAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAgICAgY29uc3QgeHNyZlZhbHVlID0gY29uZmlnLnhzcmZIZWFkZXJOYW1lICYmIGNvbmZpZy54c3JmQ29va2llTmFtZSAmJiBjb29raWVzLnJlYWQoY29uZmlnLnhzcmZDb29raWVOYW1lKTtcblxuICAgICAgICBpZiAoeHNyZlZhbHVlKSB7XG4gICAgICAgICAgcmVxdWVzdEhlYWRlcnMuc2V0KGNvbmZpZy54c3JmSGVhZGVyTmFtZSwgeHNyZlZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlbW92ZSBDb250ZW50LVR5cGUgaWYgZGF0YSBpcyB1bmRlZmluZWRcbiAgICByZXF1ZXN0RGF0YSA9PT0gdW5kZWZpbmVkICYmIHJlcXVlc3RIZWFkZXJzLnNldENvbnRlbnRUeXBlKG51bGwpO1xuXG4gICAgLy8gQWRkIGhlYWRlcnMgdG8gdGhlIHJlcXVlc3RcbiAgICBpZiAoJ3NldFJlcXVlc3RIZWFkZXInIGluIHJlcXVlc3QpIHtcbiAgICAgIHV0aWxzLmZvckVhY2gocmVxdWVzdEhlYWRlcnMudG9KU09OKCksIGZ1bmN0aW9uIHNldFJlcXVlc3RIZWFkZXIodmFsLCBrZXkpIHtcbiAgICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEFkZCB3aXRoQ3JlZGVudGlhbHMgdG8gcmVxdWVzdCBpZiBuZWVkZWRcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMpKSB7XG4gICAgICByZXF1ZXN0LndpdGhDcmVkZW50aWFscyA9ICEhY29uZmlnLndpdGhDcmVkZW50aWFscztcbiAgICB9XG5cbiAgICAvLyBBZGQgcmVzcG9uc2VUeXBlIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKHJlc3BvbnNlVHlwZSAmJiByZXNwb25zZVR5cGUgIT09ICdqc29uJykge1xuICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSBjb25maWcucmVzcG9uc2VUeXBlO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBwcm9ncmVzcyBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBwcm9ncmVzc0V2ZW50UmVkdWNlcihjb25maWcub25Eb3dubG9hZFByb2dyZXNzLCB0cnVlKSk7XG4gICAgfVxuXG4gICAgLy8gTm90IGFsbCBicm93c2VycyBzdXBwb3J0IHVwbG9hZCBldmVudHNcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nICYmIHJlcXVlc3QudXBsb2FkKSB7XG4gICAgICByZXF1ZXN0LnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIHByb2dyZXNzRXZlbnRSZWR1Y2VyKGNvbmZpZy5vblVwbG9hZFByb2dyZXNzKSk7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbiB8fCBjb25maWcuc2lnbmFsKSB7XG4gICAgICAvLyBIYW5kbGUgY2FuY2VsbGF0aW9uXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICAgICAgb25DYW5jZWxlZCA9IGNhbmNlbCA9PiB7XG4gICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZWplY3QoIWNhbmNlbCB8fCBjYW5jZWwudHlwZSA/IG5ldyBDYW5jZWxlZEVycm9yKG51bGwsIGNvbmZpZywgcmVxdWVzdCkgOiBjYW5jZWwpO1xuICAgICAgICByZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgICAgfTtcblxuICAgICAgY29uZmlnLmNhbmNlbFRva2VuICYmIGNvbmZpZy5jYW5jZWxUb2tlbi5zdWJzY3JpYmUob25DYW5jZWxlZCk7XG4gICAgICBpZiAoY29uZmlnLnNpZ25hbCkge1xuICAgICAgICBjb25maWcuc2lnbmFsLmFib3J0ZWQgPyBvbkNhbmNlbGVkKCkgOiBjb25maWcuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0Jywgb25DYW5jZWxlZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcHJvdG9jb2wgPSBwYXJzZVByb3RvY29sKGZ1bGxQYXRoKTtcblxuICAgIGlmIChwcm90b2NvbCAmJiBwbGF0Zm9ybS5wcm90b2NvbHMuaW5kZXhPZihwcm90b2NvbCkgPT09IC0xKSB7XG4gICAgICByZWplY3QobmV3IEF4aW9zRXJyb3IoJ1Vuc3VwcG9ydGVkIHByb3RvY29sICcgKyBwcm90b2NvbCArICc6JywgQXhpb3NFcnJvci5FUlJfQkFEX1JFUVVFU1QsIGNvbmZpZykpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuXG4gICAgLy8gU2VuZCB0aGUgcmVxdWVzdFxuICAgIHJlcXVlc3Quc2VuZChyZXF1ZXN0RGF0YSB8fCBudWxsKTtcbiAgfSk7XG59XG4iLCAiaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcbmltcG9ydCBodHRwQWRhcHRlciBmcm9tICcuL2h0dHAuanMnO1xuaW1wb3J0IHhockFkYXB0ZXIgZnJvbSAnLi94aHIuanMnO1xuaW1wb3J0IEF4aW9zRXJyb3IgZnJvbSBcIi4uL2NvcmUvQXhpb3NFcnJvci5qc1wiO1xuXG5jb25zdCBrbm93bkFkYXB0ZXJzID0ge1xuICBodHRwOiBodHRwQWRhcHRlcixcbiAgeGhyOiB4aHJBZGFwdGVyXG59XG5cbnV0aWxzLmZvckVhY2goa25vd25BZGFwdGVycywgKGZuLCB2YWx1ZSkgPT4ge1xuICBpZiAoZm4pIHtcbiAgICB0cnkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCAnbmFtZScsIHt2YWx1ZX0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sICdhZGFwdGVyTmFtZScsIHt2YWx1ZX0pO1xuICB9XG59KTtcblxuY29uc3QgcmVuZGVyUmVhc29uID0gKHJlYXNvbikgPT4gYC0gJHtyZWFzb259YDtcblxuY29uc3QgaXNSZXNvbHZlZEhhbmRsZSA9IChhZGFwdGVyKSA9PiB1dGlscy5pc0Z1bmN0aW9uKGFkYXB0ZXIpIHx8IGFkYXB0ZXIgPT09IG51bGwgfHwgYWRhcHRlciA9PT0gZmFsc2U7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZ2V0QWRhcHRlcjogKGFkYXB0ZXJzKSA9PiB7XG4gICAgYWRhcHRlcnMgPSB1dGlscy5pc0FycmF5KGFkYXB0ZXJzKSA/IGFkYXB0ZXJzIDogW2FkYXB0ZXJzXTtcblxuICAgIGNvbnN0IHtsZW5ndGh9ID0gYWRhcHRlcnM7XG4gICAgbGV0IG5hbWVPckFkYXB0ZXI7XG4gICAgbGV0IGFkYXB0ZXI7XG5cbiAgICBjb25zdCByZWplY3RlZFJlYXNvbnMgPSB7fTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIG5hbWVPckFkYXB0ZXIgPSBhZGFwdGVyc1tpXTtcbiAgICAgIGxldCBpZDtcblxuICAgICAgYWRhcHRlciA9IG5hbWVPckFkYXB0ZXI7XG5cbiAgICAgIGlmICghaXNSZXNvbHZlZEhhbmRsZShuYW1lT3JBZGFwdGVyKSkge1xuICAgICAgICBhZGFwdGVyID0ga25vd25BZGFwdGVyc1soaWQgPSBTdHJpbmcobmFtZU9yQWRhcHRlcikpLnRvTG93ZXJDYXNlKCldO1xuXG4gICAgICAgIGlmIChhZGFwdGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcihgVW5rbm93biBhZGFwdGVyICcke2lkfSdgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYWRhcHRlcikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmVqZWN0ZWRSZWFzb25zW2lkIHx8ICcjJyArIGldID0gYWRhcHRlcjtcbiAgICB9XG5cbiAgICBpZiAoIWFkYXB0ZXIpIHtcblxuICAgICAgY29uc3QgcmVhc29ucyA9IE9iamVjdC5lbnRyaWVzKHJlamVjdGVkUmVhc29ucylcbiAgICAgICAgLm1hcCgoW2lkLCBzdGF0ZV0pID0+IGBhZGFwdGVyICR7aWR9IGAgK1xuICAgICAgICAgIChzdGF0ZSA9PT0gZmFsc2UgPyAnaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgZW52aXJvbm1lbnQnIDogJ2lzIG5vdCBhdmFpbGFibGUgaW4gdGhlIGJ1aWxkJylcbiAgICAgICAgKTtcblxuICAgICAgbGV0IHMgPSBsZW5ndGggP1xuICAgICAgICAocmVhc29ucy5sZW5ndGggPiAxID8gJ3NpbmNlIDpcXG4nICsgcmVhc29ucy5tYXAocmVuZGVyUmVhc29uKS5qb2luKCdcXG4nKSA6ICcgJyArIHJlbmRlclJlYXNvbihyZWFzb25zWzBdKSkgOlxuICAgICAgICAnYXMgbm8gYWRhcHRlciBzcGVjaWZpZWQnO1xuXG4gICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcihcbiAgICAgICAgYFRoZXJlIGlzIG5vIHN1aXRhYmxlIGFkYXB0ZXIgdG8gZGlzcGF0Y2ggdGhlIHJlcXVlc3QgYCArIHMsXG4gICAgICAgICdFUlJfTk9UX1NVUFBPUlQnXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBhZGFwdGVyO1xuICB9LFxuICBhZGFwdGVyczoga25vd25BZGFwdGVyc1xufVxuIiwgIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHRyYW5zZm9ybURhdGEgZnJvbSAnLi90cmFuc2Zvcm1EYXRhLmpzJztcbmltcG9ydCBpc0NhbmNlbCBmcm9tICcuLi9jYW5jZWwvaXNDYW5jZWwuanMnO1xuaW1wb3J0IGRlZmF1bHRzIGZyb20gJy4uL2RlZmF1bHRzL2luZGV4LmpzJztcbmltcG9ydCBDYW5jZWxlZEVycm9yIGZyb20gJy4uL2NhbmNlbC9DYW5jZWxlZEVycm9yLmpzJztcbmltcG9ydCBBeGlvc0hlYWRlcnMgZnJvbSAnLi4vY29yZS9BeGlvc0hlYWRlcnMuanMnO1xuaW1wb3J0IGFkYXB0ZXJzIGZyb20gXCIuLi9hZGFwdGVycy9hZGFwdGVycy5qc1wiO1xuXG4vKipcbiAqIFRocm93cyBhIGBDYW5jZWxlZEVycm9yYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyB0aGF0IGlzIHRvIGJlIHVzZWQgZm9yIHRoZSByZXF1ZXN0XG4gKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKSB7XG4gIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICBjb25maWcuY2FuY2VsVG9rZW4udGhyb3dJZlJlcXVlc3RlZCgpO1xuICB9XG5cbiAgaWYgKGNvbmZpZy5zaWduYWwgJiYgY29uZmlnLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgdGhyb3cgbmV3IENhbmNlbGVkRXJyb3IobnVsbCwgY29uZmlnKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdCB0byB0aGUgc2VydmVyIHVzaW5nIHRoZSBjb25maWd1cmVkIGFkYXB0ZXIuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHRoYXQgaXMgdG8gYmUgdXNlZCBmb3IgdGhlIHJlcXVlc3RcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIFByb21pc2UgdG8gYmUgZnVsZmlsbGVkXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRpc3BhdGNoUmVxdWVzdChjb25maWcpIHtcbiAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gIGNvbmZpZy5oZWFkZXJzID0gQXhpb3NIZWFkZXJzLmZyb20oY29uZmlnLmhlYWRlcnMpO1xuXG4gIC8vIFRyYW5zZm9ybSByZXF1ZXN0IGRhdGFcbiAgY29uZmlnLmRhdGEgPSB0cmFuc2Zvcm1EYXRhLmNhbGwoXG4gICAgY29uZmlnLFxuICAgIGNvbmZpZy50cmFuc2Zvcm1SZXF1ZXN0XG4gICk7XG5cbiAgaWYgKFsncG9zdCcsICdwdXQnLCAncGF0Y2gnXS5pbmRleE9mKGNvbmZpZy5tZXRob2QpICE9PSAtMSkge1xuICAgIGNvbmZpZy5oZWFkZXJzLnNldENvbnRlbnRUeXBlKCdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLCBmYWxzZSk7XG4gIH1cblxuICBjb25zdCBhZGFwdGVyID0gYWRhcHRlcnMuZ2V0QWRhcHRlcihjb25maWcuYWRhcHRlciB8fCBkZWZhdWx0cy5hZGFwdGVyKTtcblxuICByZXR1cm4gYWRhcHRlcihjb25maWcpLnRoZW4oZnVuY3Rpb24gb25BZGFwdGVyUmVzb2x1dGlvbihyZXNwb25zZSkge1xuICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgcmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEuY2FsbChcbiAgICAgIGNvbmZpZyxcbiAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZSxcbiAgICAgIHJlc3BvbnNlXG4gICAgKTtcblxuICAgIHJlc3BvbnNlLmhlYWRlcnMgPSBBeGlvc0hlYWRlcnMuZnJvbShyZXNwb25zZS5oZWFkZXJzKTtcblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfSwgZnVuY3Rpb24gb25BZGFwdGVyUmVqZWN0aW9uKHJlYXNvbikge1xuICAgIGlmICghaXNDYW5jZWwocmVhc29uKSkge1xuICAgICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gICAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgICAgaWYgKHJlYXNvbiAmJiByZWFzb24ucmVzcG9uc2UpIHtcbiAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhLmNhbGwoXG4gICAgICAgICAgY29uZmlnLFxuICAgICAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZSxcbiAgICAgICAgICByZWFzb24ucmVzcG9uc2VcbiAgICAgICAgKTtcbiAgICAgICAgcmVhc29uLnJlc3BvbnNlLmhlYWRlcnMgPSBBeGlvc0hlYWRlcnMuZnJvbShyZWFzb24ucmVzcG9uc2UuaGVhZGVycyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlYXNvbik7XG4gIH0pO1xufVxuIiwgIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcbmltcG9ydCBBeGlvc0hlYWRlcnMgZnJvbSBcIi4vQXhpb3NIZWFkZXJzLmpzXCI7XG5cbmNvbnN0IGhlYWRlcnNUb09iamVjdCA9ICh0aGluZykgPT4gdGhpbmcgaW5zdGFuY2VvZiBBeGlvc0hlYWRlcnMgPyB7IC4uLnRoaW5nIH0gOiB0aGluZztcblxuLyoqXG4gKiBDb25maWctc3BlY2lmaWMgbWVyZ2UtZnVuY3Rpb24gd2hpY2ggY3JlYXRlcyBhIG5ldyBjb25maWctb2JqZWN0XG4gKiBieSBtZXJnaW5nIHR3byBjb25maWd1cmF0aW9uIG9iamVjdHMgdG9nZXRoZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZzFcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcyXG4gKlxuICogQHJldHVybnMge09iamVjdH0gTmV3IG9iamVjdCByZXN1bHRpbmcgZnJvbSBtZXJnaW5nIGNvbmZpZzIgdG8gY29uZmlnMVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtZXJnZUNvbmZpZyhjb25maWcxLCBjb25maWcyKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICBjb25maWcyID0gY29uZmlnMiB8fCB7fTtcbiAgY29uc3QgY29uZmlnID0ge307XG5cbiAgZnVuY3Rpb24gZ2V0TWVyZ2VkVmFsdWUodGFyZ2V0LCBzb3VyY2UsIGNhc2VsZXNzKSB7XG4gICAgaWYgKHV0aWxzLmlzUGxhaW5PYmplY3QodGFyZ2V0KSAmJiB1dGlscy5pc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiB1dGlscy5tZXJnZS5jYWxsKHtjYXNlbGVzc30sIHRhcmdldCwgc291cmNlKTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHV0aWxzLm1lcmdlKHt9LCBzb3VyY2UpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gc291cmNlLnNsaWNlKCk7XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgZnVuY3Rpb24gbWVyZ2VEZWVwUHJvcGVydGllcyhhLCBiLCBjYXNlbGVzcykge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoYikpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZShhLCBiLCBjYXNlbGVzcyk7XG4gICAgfSBlbHNlIGlmICghdXRpbHMuaXNVbmRlZmluZWQoYSkpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGEsIGNhc2VsZXNzKTtcbiAgICB9XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgZnVuY3Rpb24gdmFsdWVGcm9tQ29uZmlnMihhLCBiKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChiKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgYik7XG4gICAgfVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gIGZ1bmN0aW9uIGRlZmF1bHRUb0NvbmZpZzIoYSwgYikge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoYikpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGIpO1xuICAgIH0gZWxzZSBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGEpKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBhKTtcbiAgICB9XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgZnVuY3Rpb24gbWVyZ2VEaXJlY3RLZXlzKGEsIGIsIHByb3ApIHtcbiAgICBpZiAocHJvcCBpbiBjb25maWcyKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUoYSwgYik7XG4gICAgfSBlbHNlIGlmIChwcm9wIGluIGNvbmZpZzEpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGEpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG1lcmdlTWFwID0ge1xuICAgIHVybDogdmFsdWVGcm9tQ29uZmlnMixcbiAgICBtZXRob2Q6IHZhbHVlRnJvbUNvbmZpZzIsXG4gICAgZGF0YTogdmFsdWVGcm9tQ29uZmlnMixcbiAgICBiYXNlVVJMOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHRyYW5zZm9ybVJlcXVlc3Q6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgdHJhbnNmb3JtUmVzcG9uc2U6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgcGFyYW1zU2VyaWFsaXplcjogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB0aW1lb3V0OiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHRpbWVvdXRNZXNzYWdlOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHdpdGhDcmVkZW50aWFsczogZGVmYXVsdFRvQ29uZmlnMixcbiAgICB3aXRoWFNSRlRva2VuOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIGFkYXB0ZXI6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgcmVzcG9uc2VUeXBlOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHhzcmZDb29raWVOYW1lOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHhzcmZIZWFkZXJOYW1lOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIG9uVXBsb2FkUHJvZ3Jlc3M6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgb25Eb3dubG9hZFByb2dyZXNzOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIGRlY29tcHJlc3M6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgbWF4Q29udGVudExlbmd0aDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBtYXhCb2R5TGVuZ3RoOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIGJlZm9yZVJlZGlyZWN0OiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHRyYW5zcG9ydDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBodHRwQWdlbnQ6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgaHR0cHNBZ2VudDogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBjYW5jZWxUb2tlbjogZGVmYXVsdFRvQ29uZmlnMixcbiAgICBzb2NrZXRQYXRoOiBkZWZhdWx0VG9Db25maWcyLFxuICAgIHJlc3BvbnNlRW5jb2Rpbmc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgdmFsaWRhdGVTdGF0dXM6IG1lcmdlRGlyZWN0S2V5cyxcbiAgICBoZWFkZXJzOiAoYSwgYikgPT4gbWVyZ2VEZWVwUHJvcGVydGllcyhoZWFkZXJzVG9PYmplY3QoYSksIGhlYWRlcnNUb09iamVjdChiKSwgdHJ1ZSlcbiAgfTtcblxuICB1dGlscy5mb3JFYWNoKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZzEsIGNvbmZpZzIpKSwgZnVuY3Rpb24gY29tcHV0ZUNvbmZpZ1ZhbHVlKHByb3ApIHtcbiAgICBjb25zdCBtZXJnZSA9IG1lcmdlTWFwW3Byb3BdIHx8IG1lcmdlRGVlcFByb3BlcnRpZXM7XG4gICAgY29uc3QgY29uZmlnVmFsdWUgPSBtZXJnZShjb25maWcxW3Byb3BdLCBjb25maWcyW3Byb3BdLCBwcm9wKTtcbiAgICAodXRpbHMuaXNVbmRlZmluZWQoY29uZmlnVmFsdWUpICYmIG1lcmdlICE9PSBtZXJnZURpcmVjdEtleXMpIHx8IChjb25maWdbcHJvcF0gPSBjb25maWdWYWx1ZSk7XG4gIH0pO1xuXG4gIHJldHVybiBjb25maWc7XG59XG4iLCAiZXhwb3J0IGNvbnN0IFZFUlNJT04gPSBcIjEuNi44XCI7IiwgIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHtWRVJTSU9OfSBmcm9tICcuLi9lbnYvZGF0YS5qcyc7XG5pbXBvcnQgQXhpb3NFcnJvciBmcm9tICcuLi9jb3JlL0F4aW9zRXJyb3IuanMnO1xuXG5jb25zdCB2YWxpZGF0b3JzID0ge307XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5bJ29iamVjdCcsICdib29sZWFuJywgJ251bWJlcicsICdmdW5jdGlvbicsICdzdHJpbmcnLCAnc3ltYm9sJ10uZm9yRWFjaCgodHlwZSwgaSkgPT4ge1xuICB2YWxpZGF0b3JzW3R5cGVdID0gZnVuY3Rpb24gdmFsaWRhdG9yKHRoaW5nKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGluZyA9PT0gdHlwZSB8fCAnYScgKyAoaSA8IDEgPyAnbiAnIDogJyAnKSArIHR5cGU7XG4gIH07XG59KTtcblxuY29uc3QgZGVwcmVjYXRlZFdhcm5pbmdzID0ge307XG5cbi8qKlxuICogVHJhbnNpdGlvbmFsIG9wdGlvbiB2YWxpZGF0b3JcbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufGJvb2xlYW4/fSB2YWxpZGF0b3IgLSBzZXQgdG8gZmFsc2UgaWYgdGhlIHRyYW5zaXRpb25hbCBvcHRpb24gaGFzIGJlZW4gcmVtb3ZlZFxuICogQHBhcmFtIHtzdHJpbmc/fSB2ZXJzaW9uIC0gZGVwcmVjYXRlZCB2ZXJzaW9uIC8gcmVtb3ZlZCBzaW5jZSB2ZXJzaW9uXG4gKiBAcGFyYW0ge3N0cmluZz99IG1lc3NhZ2UgLSBzb21lIG1lc3NhZ2Ugd2l0aCBhZGRpdGlvbmFsIGluZm9cbiAqXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259XG4gKi9cbnZhbGlkYXRvcnMudHJhbnNpdGlvbmFsID0gZnVuY3Rpb24gdHJhbnNpdGlvbmFsKHZhbGlkYXRvciwgdmVyc2lvbiwgbWVzc2FnZSkge1xuICBmdW5jdGlvbiBmb3JtYXRNZXNzYWdlKG9wdCwgZGVzYykge1xuICAgIHJldHVybiAnW0F4aW9zIHYnICsgVkVSU0lPTiArICddIFRyYW5zaXRpb25hbCBvcHRpb24gXFwnJyArIG9wdCArICdcXCcnICsgZGVzYyArIChtZXNzYWdlID8gJy4gJyArIG1lc3NhZ2UgOiAnJyk7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICByZXR1cm4gKHZhbHVlLCBvcHQsIG9wdHMpID0+IHtcbiAgICBpZiAodmFsaWRhdG9yID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IoXG4gICAgICAgIGZvcm1hdE1lc3NhZ2Uob3B0LCAnIGhhcyBiZWVuIHJlbW92ZWQnICsgKHZlcnNpb24gPyAnIGluICcgKyB2ZXJzaW9uIDogJycpKSxcbiAgICAgICAgQXhpb3NFcnJvci5FUlJfREVQUkVDQVRFRFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodmVyc2lvbiAmJiAhZGVwcmVjYXRlZFdhcm5pbmdzW29wdF0pIHtcbiAgICAgIGRlcHJlY2F0ZWRXYXJuaW5nc1tvcHRdID0gdHJ1ZTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGZvcm1hdE1lc3NhZ2UoXG4gICAgICAgICAgb3B0LFxuICAgICAgICAgICcgaGFzIGJlZW4gZGVwcmVjYXRlZCBzaW5jZSB2JyArIHZlcnNpb24gKyAnIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5lYXIgZnV0dXJlJ1xuICAgICAgICApXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB2YWxpZGF0b3IgPyB2YWxpZGF0b3IodmFsdWUsIG9wdCwgb3B0cykgOiB0cnVlO1xuICB9O1xufTtcblxuLyoqXG4gKiBBc3NlcnQgb2JqZWN0J3MgcHJvcGVydGllcyB0eXBlXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7b2JqZWN0fSBzY2hlbWFcbiAqIEBwYXJhbSB7Ym9vbGVhbj99IGFsbG93VW5rbm93blxuICpcbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBzY2hlbWEsIGFsbG93VW5rbm93bikge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IoJ29wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QnLCBBeGlvc0Vycm9yLkVSUl9CQURfT1BUSU9OX1ZBTFVFKTtcbiAgfVxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucyk7XG4gIGxldCBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgY29uc3Qgb3B0ID0ga2V5c1tpXTtcbiAgICBjb25zdCB2YWxpZGF0b3IgPSBzY2hlbWFbb3B0XTtcbiAgICBpZiAodmFsaWRhdG9yKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG9wdGlvbnNbb3B0XTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsaWRhdG9yKHZhbHVlLCBvcHQsIG9wdGlvbnMpO1xuICAgICAgaWYgKHJlc3VsdCAhPT0gdHJ1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcignb3B0aW9uICcgKyBvcHQgKyAnIG11c3QgYmUgJyArIHJlc3VsdCwgQXhpb3NFcnJvci5FUlJfQkFEX09QVElPTl9WQUxVRSk7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGFsbG93VW5rbm93biAhPT0gdHJ1ZSkge1xuICAgICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IoJ1Vua25vd24gb3B0aW9uICcgKyBvcHQsIEF4aW9zRXJyb3IuRVJSX0JBRF9PUFRJT04pO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGFzc2VydE9wdGlvbnMsXG4gIHZhbGlkYXRvcnNcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi8uLi91dGlscy5qcyc7XG5pbXBvcnQgYnVpbGRVUkwgZnJvbSAnLi4vaGVscGVycy9idWlsZFVSTC5qcyc7XG5pbXBvcnQgSW50ZXJjZXB0b3JNYW5hZ2VyIGZyb20gJy4vSW50ZXJjZXB0b3JNYW5hZ2VyLmpzJztcbmltcG9ydCBkaXNwYXRjaFJlcXVlc3QgZnJvbSAnLi9kaXNwYXRjaFJlcXVlc3QuanMnO1xuaW1wb3J0IG1lcmdlQ29uZmlnIGZyb20gJy4vbWVyZ2VDb25maWcuanMnO1xuaW1wb3J0IGJ1aWxkRnVsbFBhdGggZnJvbSAnLi9idWlsZEZ1bGxQYXRoLmpzJztcbmltcG9ydCB2YWxpZGF0b3IgZnJvbSAnLi4vaGVscGVycy92YWxpZGF0b3IuanMnO1xuaW1wb3J0IEF4aW9zSGVhZGVycyBmcm9tICcuL0F4aW9zSGVhZGVycy5qcyc7XG5cbmNvbnN0IHZhbGlkYXRvcnMgPSB2YWxpZGF0b3IudmFsaWRhdG9ycztcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaW5zdGFuY2VDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqXG4gKiBAcmV0dXJuIHtBeGlvc30gQSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqL1xuY2xhc3MgQXhpb3Mge1xuICBjb25zdHJ1Y3RvcihpbnN0YW5jZUNvbmZpZykge1xuICAgIHRoaXMuZGVmYXVsdHMgPSBpbnN0YW5jZUNvbmZpZztcbiAgICB0aGlzLmludGVyY2VwdG9ycyA9IHtcbiAgICAgIHJlcXVlc3Q6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKSxcbiAgICAgIHJlc3BvbnNlOiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERpc3BhdGNoIGEgcmVxdWVzdFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGNvbmZpZ09yVXJsIFRoZSBjb25maWcgc3BlY2lmaWMgZm9yIHRoaXMgcmVxdWVzdCAobWVyZ2VkIHdpdGggdGhpcy5kZWZhdWx0cylcbiAgICogQHBhcmFtIHs/T2JqZWN0fSBjb25maWdcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBQcm9taXNlIHRvIGJlIGZ1bGZpbGxlZFxuICAgKi9cbiAgYXN5bmMgcmVxdWVzdChjb25maWdPclVybCwgY29uZmlnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9yZXF1ZXN0KGNvbmZpZ09yVXJsLCBjb25maWcpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGxldCBkdW1teTtcblxuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA/IEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGR1bW15ID0ge30pIDogKGR1bW15ID0gbmV3IEVycm9yKCkpO1xuXG4gICAgICAgIC8vIHNsaWNlIG9mZiB0aGUgRXJyb3I6IC4uLiBsaW5lXG4gICAgICAgIGNvbnN0IHN0YWNrID0gZHVtbXkuc3RhY2sgPyBkdW1teS5zdGFjay5yZXBsYWNlKC9eLitcXG4vLCAnJykgOiAnJztcblxuICAgICAgICBpZiAoIWVyci5zdGFjaykge1xuICAgICAgICAgIGVyci5zdGFjayA9IHN0YWNrO1xuICAgICAgICAgIC8vIG1hdGNoIHdpdGhvdXQgdGhlIDIgdG9wIHN0YWNrIGxpbmVzXG4gICAgICAgIH0gZWxzZSBpZiAoc3RhY2sgJiYgIVN0cmluZyhlcnIuc3RhY2spLmVuZHNXaXRoKHN0YWNrLnJlcGxhY2UoL14uK1xcbi4rXFxuLywgJycpKSkge1xuICAgICAgICAgIGVyci5zdGFjayArPSAnXFxuJyArIHN0YWNrXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuXG4gIF9yZXF1ZXN0KGNvbmZpZ09yVXJsLCBjb25maWcpIHtcbiAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICAvLyBBbGxvdyBmb3IgYXhpb3MoJ2V4YW1wbGUvdXJsJ1ssIGNvbmZpZ10pIGEgbGEgZmV0Y2ggQVBJXG4gICAgaWYgKHR5cGVvZiBjb25maWdPclVybCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICAgIGNvbmZpZy51cmwgPSBjb25maWdPclVybDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uZmlnID0gY29uZmlnT3JVcmwgfHwge307XG4gICAgfVxuXG4gICAgY29uZmlnID0gbWVyZ2VDb25maWcodGhpcy5kZWZhdWx0cywgY29uZmlnKTtcblxuICAgIGNvbnN0IHt0cmFuc2l0aW9uYWwsIHBhcmFtc1NlcmlhbGl6ZXIsIGhlYWRlcnN9ID0gY29uZmlnO1xuXG4gICAgaWYgKHRyYW5zaXRpb25hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YWxpZGF0b3IuYXNzZXJ0T3B0aW9ucyh0cmFuc2l0aW9uYWwsIHtcbiAgICAgICAgc2lsZW50SlNPTlBhcnNpbmc6IHZhbGlkYXRvcnMudHJhbnNpdGlvbmFsKHZhbGlkYXRvcnMuYm9vbGVhbiksXG4gICAgICAgIGZvcmNlZEpTT05QYXJzaW5nOiB2YWxpZGF0b3JzLnRyYW5zaXRpb25hbCh2YWxpZGF0b3JzLmJvb2xlYW4pLFxuICAgICAgICBjbGFyaWZ5VGltZW91dEVycm9yOiB2YWxpZGF0b3JzLnRyYW5zaXRpb25hbCh2YWxpZGF0b3JzLmJvb2xlYW4pXG4gICAgICB9LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgaWYgKHBhcmFtc1NlcmlhbGl6ZXIgIT0gbnVsbCkge1xuICAgICAgaWYgKHV0aWxzLmlzRnVuY3Rpb24ocGFyYW1zU2VyaWFsaXplcikpIHtcbiAgICAgICAgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIgPSB7XG4gICAgICAgICAgc2VyaWFsaXplOiBwYXJhbXNTZXJpYWxpemVyXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbGlkYXRvci5hc3NlcnRPcHRpb25zKHBhcmFtc1NlcmlhbGl6ZXIsIHtcbiAgICAgICAgICBlbmNvZGU6IHZhbGlkYXRvcnMuZnVuY3Rpb24sXG4gICAgICAgICAgc2VyaWFsaXplOiB2YWxpZGF0b3JzLmZ1bmN0aW9uXG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNldCBjb25maWcubWV0aG9kXG4gICAgY29uZmlnLm1ldGhvZCA9IChjb25maWcubWV0aG9kIHx8IHRoaXMuZGVmYXVsdHMubWV0aG9kIHx8ICdnZXQnKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgLy8gRmxhdHRlbiBoZWFkZXJzXG4gICAgbGV0IGNvbnRleHRIZWFkZXJzID0gaGVhZGVycyAmJiB1dGlscy5tZXJnZShcbiAgICAgIGhlYWRlcnMuY29tbW9uLFxuICAgICAgaGVhZGVyc1tjb25maWcubWV0aG9kXVxuICAgICk7XG5cbiAgICBoZWFkZXJzICYmIHV0aWxzLmZvckVhY2goXG4gICAgICBbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdwb3N0JywgJ3B1dCcsICdwYXRjaCcsICdjb21tb24nXSxcbiAgICAgIChtZXRob2QpID0+IHtcbiAgICAgICAgZGVsZXRlIGhlYWRlcnNbbWV0aG9kXTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgY29uZmlnLmhlYWRlcnMgPSBBeGlvc0hlYWRlcnMuY29uY2F0KGNvbnRleHRIZWFkZXJzLCBoZWFkZXJzKTtcblxuICAgIC8vIGZpbHRlciBvdXQgc2tpcHBlZCBpbnRlcmNlcHRvcnNcbiAgICBjb25zdCByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbiA9IFtdO1xuICAgIGxldCBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgPSB0cnVlO1xuICAgIHRoaXMuaW50ZXJjZXB0b3JzLnJlcXVlc3QuZm9yRWFjaChmdW5jdGlvbiB1bnNoaWZ0UmVxdWVzdEludGVyY2VwdG9ycyhpbnRlcmNlcHRvcikge1xuICAgICAgaWYgKHR5cGVvZiBpbnRlcmNlcHRvci5ydW5XaGVuID09PSAnZnVuY3Rpb24nICYmIGludGVyY2VwdG9yLnJ1bldoZW4oY29uZmlnKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgPSBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgJiYgaW50ZXJjZXB0b3Iuc3luY2hyb25vdXM7XG5cbiAgICAgIHJlcXVlc3RJbnRlcmNlcHRvckNoYWluLnVuc2hpZnQoaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gICAgfSk7XG5cbiAgICBjb25zdCByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4gPSBbXTtcbiAgICB0aGlzLmludGVyY2VwdG9ycy5yZXNwb25zZS5mb3JFYWNoKGZ1bmN0aW9uIHB1c2hSZXNwb25zZUludGVyY2VwdG9ycyhpbnRlcmNlcHRvcikge1xuICAgICAgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluLnB1c2goaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gICAgfSk7XG5cbiAgICBsZXQgcHJvbWlzZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGxlbjtcblxuICAgIGlmICghc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzKSB7XG4gICAgICBjb25zdCBjaGFpbiA9IFtkaXNwYXRjaFJlcXVlc3QuYmluZCh0aGlzKSwgdW5kZWZpbmVkXTtcbiAgICAgIGNoYWluLnVuc2hpZnQuYXBwbHkoY2hhaW4sIHJlcXVlc3RJbnRlcmNlcHRvckNoYWluKTtcbiAgICAgIGNoYWluLnB1c2guYXBwbHkoY2hhaW4sIHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbik7XG4gICAgICBsZW4gPSBjaGFpbi5sZW5ndGg7XG5cbiAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoY29uZmlnKTtcblxuICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihjaGFpbltpKytdLCBjaGFpbltpKytdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuXG4gICAgbGVuID0gcmVxdWVzdEludGVyY2VwdG9yQ2hhaW4ubGVuZ3RoO1xuXG4gICAgbGV0IG5ld0NvbmZpZyA9IGNvbmZpZztcblxuICAgIGkgPSAwO1xuXG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgIGNvbnN0IG9uRnVsZmlsbGVkID0gcmVxdWVzdEludGVyY2VwdG9yQ2hhaW5baSsrXTtcbiAgICAgIGNvbnN0IG9uUmVqZWN0ZWQgPSByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbltpKytdO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3Q29uZmlnID0gb25GdWxmaWxsZWQobmV3Q29uZmlnKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIG9uUmVqZWN0ZWQuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBwcm9taXNlID0gZGlzcGF0Y2hSZXF1ZXN0LmNhbGwodGhpcywgbmV3Q29uZmlnKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG5cbiAgICBpID0gMDtcbiAgICBsZW4gPSByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4ubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4ocmVzcG9uc2VJbnRlcmNlcHRvckNoYWluW2krK10sIHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbltpKytdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIGdldFVyaShjb25maWcpIHtcbiAgICBjb25maWcgPSBtZXJnZUNvbmZpZyh0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xuICAgIGNvbnN0IGZ1bGxQYXRoID0gYnVpbGRGdWxsUGF0aChjb25maWcuYmFzZVVSTCwgY29uZmlnLnVybCk7XG4gICAgcmV0dXJuIGJ1aWxkVVJMKGZ1bGxQYXRoLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplcik7XG4gIH1cbn1cblxuLy8gUHJvdmlkZSBhbGlhc2VzIGZvciBzdXBwb3J0ZWQgcmVxdWVzdCBtZXRob2RzXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ29wdGlvbnMnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QobWVyZ2VDb25maWcoY29uZmlnIHx8IHt9LCB7XG4gICAgICBtZXRob2QsXG4gICAgICB1cmwsXG4gICAgICBkYXRhOiAoY29uZmlnIHx8IHt9KS5kYXRhXG4gICAgfSkpO1xuICB9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVIVFRQTWV0aG9kKGlzRm9ybSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBodHRwTWV0aG9kKHVybCwgZGF0YSwgY29uZmlnKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KG1lcmdlQ29uZmlnKGNvbmZpZyB8fCB7fSwge1xuICAgICAgICBtZXRob2QsXG4gICAgICAgIGhlYWRlcnM6IGlzRm9ybSA/IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ211bHRpcGFydC9mb3JtLWRhdGEnXG4gICAgICAgIH0gOiB7fSxcbiAgICAgICAgdXJsLFxuICAgICAgICBkYXRhXG4gICAgICB9KSk7XG4gICAgfTtcbiAgfVxuXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZ2VuZXJhdGVIVFRQTWV0aG9kKCk7XG5cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZCArICdGb3JtJ10gPSBnZW5lcmF0ZUhUVFBNZXRob2QodHJ1ZSk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgQXhpb3M7XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQ2FuY2VsZWRFcnJvciBmcm9tICcuL0NhbmNlbGVkRXJyb3IuanMnO1xuXG4vKipcbiAqIEEgYENhbmNlbFRva2VuYCBpcyBhbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byByZXF1ZXN0IGNhbmNlbGxhdGlvbiBvZiBhbiBvcGVyYXRpb24uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXhlY3V0b3IgVGhlIGV4ZWN1dG9yIGZ1bmN0aW9uLlxuICpcbiAqIEByZXR1cm5zIHtDYW5jZWxUb2tlbn1cbiAqL1xuY2xhc3MgQ2FuY2VsVG9rZW4ge1xuICBjb25zdHJ1Y3RvcihleGVjdXRvcikge1xuICAgIGlmICh0eXBlb2YgZXhlY3V0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4ZWN1dG9yIG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICBsZXQgcmVzb2x2ZVByb21pc2U7XG5cbiAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiBwcm9taXNlRXhlY3V0b3IocmVzb2x2ZSkge1xuICAgICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICAgIH0pO1xuXG4gICAgY29uc3QgdG9rZW4gPSB0aGlzO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgICB0aGlzLnByb21pc2UudGhlbihjYW5jZWwgPT4ge1xuICAgICAgaWYgKCF0b2tlbi5fbGlzdGVuZXJzKSByZXR1cm47XG5cbiAgICAgIGxldCBpID0gdG9rZW4uX2xpc3RlbmVycy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgICAgIHRva2VuLl9saXN0ZW5lcnNbaV0oY2FuY2VsKTtcbiAgICAgIH1cbiAgICAgIHRva2VuLl9saXN0ZW5lcnMgPSBudWxsO1xuICAgIH0pO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgICB0aGlzLnByb21pc2UudGhlbiA9IG9uZnVsZmlsbGVkID0+IHtcbiAgICAgIGxldCBfcmVzb2x2ZTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIHRva2VuLnN1YnNjcmliZShyZXNvbHZlKTtcbiAgICAgICAgX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgfSkudGhlbihvbmZ1bGZpbGxlZCk7XG5cbiAgICAgIHByb21pc2UuY2FuY2VsID0gZnVuY3Rpb24gcmVqZWN0KCkge1xuICAgICAgICB0b2tlbi51bnN1YnNjcmliZShfcmVzb2x2ZSk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuXG4gICAgZXhlY3V0b3IoZnVuY3Rpb24gY2FuY2VsKG1lc3NhZ2UsIGNvbmZpZywgcmVxdWVzdCkge1xuICAgICAgaWYgKHRva2VuLnJlYXNvbikge1xuICAgICAgICAvLyBDYW5jZWxsYXRpb24gaGFzIGFscmVhZHkgYmVlbiByZXF1ZXN0ZWRcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0b2tlbi5yZWFzb24gPSBuZXcgQ2FuY2VsZWRFcnJvcihtZXNzYWdlLCBjb25maWcsIHJlcXVlc3QpO1xuICAgICAgcmVzb2x2ZVByb21pc2UodG9rZW4ucmVhc29uKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaHJvd3MgYSBgQ2FuY2VsZWRFcnJvcmAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAgICovXG4gIHRocm93SWZSZXF1ZXN0ZWQoKSB7XG4gICAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgICB0aHJvdyB0aGlzLnJlYXNvbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3Vic2NyaWJlIHRvIHRoZSBjYW5jZWwgc2lnbmFsXG4gICAqL1xuXG4gIHN1YnNjcmliZShsaXN0ZW5lcikge1xuICAgIGlmICh0aGlzLnJlYXNvbikge1xuICAgICAgbGlzdGVuZXIodGhpcy5yZWFzb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9saXN0ZW5lcnMpIHtcbiAgICAgIHRoaXMuX2xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbGlzdGVuZXJzID0gW2xpc3RlbmVyXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVW5zdWJzY3JpYmUgZnJvbSB0aGUgY2FuY2VsIHNpZ25hbFxuICAgKi9cblxuICB1bnN1YnNjcmliZShsaXN0ZW5lcikge1xuICAgIGlmICghdGhpcy5fbGlzdGVuZXJzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMuX2xpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgbmV3IGBDYW5jZWxUb2tlbmAgYW5kIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsXG4gICAqIGNhbmNlbHMgdGhlIGBDYW5jZWxUb2tlbmAuXG4gICAqL1xuICBzdGF0aWMgc291cmNlKCkge1xuICAgIGxldCBjYW5jZWw7XG4gICAgY29uc3QgdG9rZW4gPSBuZXcgQ2FuY2VsVG9rZW4oZnVuY3Rpb24gZXhlY3V0b3IoYykge1xuICAgICAgY2FuY2VsID0gYztcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgdG9rZW4sXG4gICAgICBjYW5jZWxcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENhbmNlbFRva2VuO1xuIiwgIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTeW50YWN0aWMgc3VnYXIgZm9yIGludm9raW5nIGEgZnVuY3Rpb24gYW5kIGV4cGFuZGluZyBhbiBhcnJheSBmb3IgYXJndW1lbnRzLlxuICpcbiAqIENvbW1vbiB1c2UgY2FzZSB3b3VsZCBiZSB0byB1c2UgYEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseWAuXG4gKlxuICogIGBgYGpzXG4gKiAgZnVuY3Rpb24gZih4LCB5LCB6KSB7fVxuICogIHZhciBhcmdzID0gWzEsIDIsIDNdO1xuICogIGYuYXBwbHkobnVsbCwgYXJncyk7XG4gKiAgYGBgXG4gKlxuICogV2l0aCBgc3ByZWFkYCB0aGlzIGV4YW1wbGUgY2FuIGJlIHJlLXdyaXR0ZW4uXG4gKlxuICogIGBgYGpzXG4gKiAgc3ByZWFkKGZ1bmN0aW9uKHgsIHksIHopIHt9KShbMSwgMiwgM10pO1xuICogIGBgYFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKlxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzcHJlYWQoY2FsbGJhY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoYXJyKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFycik7XG4gIH07XG59XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdXRpbHMgZnJvbSAnLi8uLi91dGlscy5qcyc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwYXlsb2FkIGlzIGFuIGVycm9yIHRocm93biBieSBBeGlvc1xuICpcbiAqIEBwYXJhbSB7Kn0gcGF5bG9hZCBUaGUgdmFsdWUgdG8gdGVzdFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBwYXlsb2FkIGlzIGFuIGVycm9yIHRocm93biBieSBBeGlvcywgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzQXhpb3NFcnJvcihwYXlsb2FkKSB7XG4gIHJldHVybiB1dGlscy5pc09iamVjdChwYXlsb2FkKSAmJiAocGF5bG9hZC5pc0F4aW9zRXJyb3IgPT09IHRydWUpO1xufVxuIiwgImNvbnN0IEh0dHBTdGF0dXNDb2RlID0ge1xuICBDb250aW51ZTogMTAwLFxuICBTd2l0Y2hpbmdQcm90b2NvbHM6IDEwMSxcbiAgUHJvY2Vzc2luZzogMTAyLFxuICBFYXJseUhpbnRzOiAxMDMsXG4gIE9rOiAyMDAsXG4gIENyZWF0ZWQ6IDIwMSxcbiAgQWNjZXB0ZWQ6IDIwMixcbiAgTm9uQXV0aG9yaXRhdGl2ZUluZm9ybWF0aW9uOiAyMDMsXG4gIE5vQ29udGVudDogMjA0LFxuICBSZXNldENvbnRlbnQ6IDIwNSxcbiAgUGFydGlhbENvbnRlbnQ6IDIwNixcbiAgTXVsdGlTdGF0dXM6IDIwNyxcbiAgQWxyZWFkeVJlcG9ydGVkOiAyMDgsXG4gIEltVXNlZDogMjI2LFxuICBNdWx0aXBsZUNob2ljZXM6IDMwMCxcbiAgTW92ZWRQZXJtYW5lbnRseTogMzAxLFxuICBGb3VuZDogMzAyLFxuICBTZWVPdGhlcjogMzAzLFxuICBOb3RNb2RpZmllZDogMzA0LFxuICBVc2VQcm94eTogMzA1LFxuICBVbnVzZWQ6IDMwNixcbiAgVGVtcG9yYXJ5UmVkaXJlY3Q6IDMwNyxcbiAgUGVybWFuZW50UmVkaXJlY3Q6IDMwOCxcbiAgQmFkUmVxdWVzdDogNDAwLFxuICBVbmF1dGhvcml6ZWQ6IDQwMSxcbiAgUGF5bWVudFJlcXVpcmVkOiA0MDIsXG4gIEZvcmJpZGRlbjogNDAzLFxuICBOb3RGb3VuZDogNDA0LFxuICBNZXRob2ROb3RBbGxvd2VkOiA0MDUsXG4gIE5vdEFjY2VwdGFibGU6IDQwNixcbiAgUHJveHlBdXRoZW50aWNhdGlvblJlcXVpcmVkOiA0MDcsXG4gIFJlcXVlc3RUaW1lb3V0OiA0MDgsXG4gIENvbmZsaWN0OiA0MDksXG4gIEdvbmU6IDQxMCxcbiAgTGVuZ3RoUmVxdWlyZWQ6IDQxMSxcbiAgUHJlY29uZGl0aW9uRmFpbGVkOiA0MTIsXG4gIFBheWxvYWRUb29MYXJnZTogNDEzLFxuICBVcmlUb29Mb25nOiA0MTQsXG4gIFVuc3VwcG9ydGVkTWVkaWFUeXBlOiA0MTUsXG4gIFJhbmdlTm90U2F0aXNmaWFibGU6IDQxNixcbiAgRXhwZWN0YXRpb25GYWlsZWQ6IDQxNyxcbiAgSW1BVGVhcG90OiA0MTgsXG4gIE1pc2RpcmVjdGVkUmVxdWVzdDogNDIxLFxuICBVbnByb2Nlc3NhYmxlRW50aXR5OiA0MjIsXG4gIExvY2tlZDogNDIzLFxuICBGYWlsZWREZXBlbmRlbmN5OiA0MjQsXG4gIFRvb0Vhcmx5OiA0MjUsXG4gIFVwZ3JhZGVSZXF1aXJlZDogNDI2LFxuICBQcmVjb25kaXRpb25SZXF1aXJlZDogNDI4LFxuICBUb29NYW55UmVxdWVzdHM6IDQyOSxcbiAgUmVxdWVzdEhlYWRlckZpZWxkc1Rvb0xhcmdlOiA0MzEsXG4gIFVuYXZhaWxhYmxlRm9yTGVnYWxSZWFzb25zOiA0NTEsXG4gIEludGVybmFsU2VydmVyRXJyb3I6IDUwMCxcbiAgTm90SW1wbGVtZW50ZWQ6IDUwMSxcbiAgQmFkR2F0ZXdheTogNTAyLFxuICBTZXJ2aWNlVW5hdmFpbGFibGU6IDUwMyxcbiAgR2F0ZXdheVRpbWVvdXQ6IDUwNCxcbiAgSHR0cFZlcnNpb25Ob3RTdXBwb3J0ZWQ6IDUwNSxcbiAgVmFyaWFudEFsc29OZWdvdGlhdGVzOiA1MDYsXG4gIEluc3VmZmljaWVudFN0b3JhZ2U6IDUwNyxcbiAgTG9vcERldGVjdGVkOiA1MDgsXG4gIE5vdEV4dGVuZGVkOiA1MTAsXG4gIE5ldHdvcmtBdXRoZW50aWNhdGlvblJlcXVpcmVkOiA1MTEsXG59O1xuXG5PYmplY3QuZW50cmllcyhIdHRwU3RhdHVzQ29kZSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gIEh0dHBTdGF0dXNDb2RlW3ZhbHVlXSA9IGtleTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBIdHRwU3RhdHVzQ29kZTtcbiIsICIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlscyBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCBiaW5kIGZyb20gJy4vaGVscGVycy9iaW5kLmpzJztcbmltcG9ydCBBeGlvcyBmcm9tICcuL2NvcmUvQXhpb3MuanMnO1xuaW1wb3J0IG1lcmdlQ29uZmlnIGZyb20gJy4vY29yZS9tZXJnZUNvbmZpZy5qcyc7XG5pbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi9kZWZhdWx0cy9pbmRleC5qcyc7XG5pbXBvcnQgZm9ybURhdGFUb0pTT04gZnJvbSAnLi9oZWxwZXJzL2Zvcm1EYXRhVG9KU09OLmpzJztcbmltcG9ydCBDYW5jZWxlZEVycm9yIGZyb20gJy4vY2FuY2VsL0NhbmNlbGVkRXJyb3IuanMnO1xuaW1wb3J0IENhbmNlbFRva2VuIGZyb20gJy4vY2FuY2VsL0NhbmNlbFRva2VuLmpzJztcbmltcG9ydCBpc0NhbmNlbCBmcm9tICcuL2NhbmNlbC9pc0NhbmNlbC5qcyc7XG5pbXBvcnQge1ZFUlNJT059IGZyb20gJy4vZW52L2RhdGEuanMnO1xuaW1wb3J0IHRvRm9ybURhdGEgZnJvbSAnLi9oZWxwZXJzL3RvRm9ybURhdGEuanMnO1xuaW1wb3J0IEF4aW9zRXJyb3IgZnJvbSAnLi9jb3JlL0F4aW9zRXJyb3IuanMnO1xuaW1wb3J0IHNwcmVhZCBmcm9tICcuL2hlbHBlcnMvc3ByZWFkLmpzJztcbmltcG9ydCBpc0F4aW9zRXJyb3IgZnJvbSAnLi9oZWxwZXJzL2lzQXhpb3NFcnJvci5qcyc7XG5pbXBvcnQgQXhpb3NIZWFkZXJzIGZyb20gXCIuL2NvcmUvQXhpb3NIZWFkZXJzLmpzXCI7XG5pbXBvcnQgYWRhcHRlcnMgZnJvbSAnLi9hZGFwdGVycy9hZGFwdGVycy5qcyc7XG5pbXBvcnQgSHR0cFN0YXR1c0NvZGUgZnJvbSAnLi9oZWxwZXJzL0h0dHBTdGF0dXNDb2RlLmpzJztcblxuLyoqXG4gKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdENvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICpcbiAqIEByZXR1cm5zIHtBeGlvc30gQSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdENvbmZpZykge1xuICBjb25zdCBjb250ZXh0ID0gbmV3IEF4aW9zKGRlZmF1bHRDb25maWcpO1xuICBjb25zdCBpbnN0YW5jZSA9IGJpbmQoQXhpb3MucHJvdG90eXBlLnJlcXVlc3QsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgYXhpb3MucHJvdG90eXBlIHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgQXhpb3MucHJvdG90eXBlLCBjb250ZXh0LCB7YWxsT3duS2V5czogdHJ1ZX0pO1xuXG4gIC8vIENvcHkgY29udGV4dCB0byBpbnN0YW5jZVxuICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIGNvbnRleHQsIG51bGwsIHthbGxPd25LZXlzOiB0cnVlfSk7XG5cbiAgLy8gRmFjdG9yeSBmb3IgY3JlYXRpbmcgbmV3IGluc3RhbmNlc1xuICBpbnN0YW5jZS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaW5zdGFuY2VDb25maWcpIHtcbiAgICByZXR1cm4gY3JlYXRlSW5zdGFuY2UobWVyZ2VDb25maWcoZGVmYXVsdENvbmZpZywgaW5zdGFuY2VDb25maWcpKTtcbiAgfTtcblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbi8vIENyZWF0ZSB0aGUgZGVmYXVsdCBpbnN0YW5jZSB0byBiZSBleHBvcnRlZFxuY29uc3QgYXhpb3MgPSBjcmVhdGVJbnN0YW5jZShkZWZhdWx0cyk7XG5cbi8vIEV4cG9zZSBBeGlvcyBjbGFzcyB0byBhbGxvdyBjbGFzcyBpbmhlcml0YW5jZVxuYXhpb3MuQXhpb3MgPSBBeGlvcztcblxuLy8gRXhwb3NlIENhbmNlbCAmIENhbmNlbFRva2VuXG5heGlvcy5DYW5jZWxlZEVycm9yID0gQ2FuY2VsZWRFcnJvcjtcbmF4aW9zLkNhbmNlbFRva2VuID0gQ2FuY2VsVG9rZW47XG5heGlvcy5pc0NhbmNlbCA9IGlzQ2FuY2VsO1xuYXhpb3MuVkVSU0lPTiA9IFZFUlNJT047XG5heGlvcy50b0Zvcm1EYXRhID0gdG9Gb3JtRGF0YTtcblxuLy8gRXhwb3NlIEF4aW9zRXJyb3IgY2xhc3NcbmF4aW9zLkF4aW9zRXJyb3IgPSBBeGlvc0Vycm9yO1xuXG4vLyBhbGlhcyBmb3IgQ2FuY2VsZWRFcnJvciBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuYXhpb3MuQ2FuY2VsID0gYXhpb3MuQ2FuY2VsZWRFcnJvcjtcblxuLy8gRXhwb3NlIGFsbC9zcHJlYWRcbmF4aW9zLmFsbCA9IGZ1bmN0aW9uIGFsbChwcm9taXNlcykge1xuICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xufTtcblxuYXhpb3Muc3ByZWFkID0gc3ByZWFkO1xuXG4vLyBFeHBvc2UgaXNBeGlvc0Vycm9yXG5heGlvcy5pc0F4aW9zRXJyb3IgPSBpc0F4aW9zRXJyb3I7XG5cbi8vIEV4cG9zZSBtZXJnZUNvbmZpZ1xuYXhpb3MubWVyZ2VDb25maWcgPSBtZXJnZUNvbmZpZztcblxuYXhpb3MuQXhpb3NIZWFkZXJzID0gQXhpb3NIZWFkZXJzO1xuXG5heGlvcy5mb3JtVG9KU09OID0gdGhpbmcgPT4gZm9ybURhdGFUb0pTT04odXRpbHMuaXNIVE1MRm9ybSh0aGluZykgPyBuZXcgRm9ybURhdGEodGhpbmcpIDogdGhpbmcpO1xuXG5heGlvcy5nZXRBZGFwdGVyID0gYWRhcHRlcnMuZ2V0QWRhcHRlcjtcblxuYXhpb3MuSHR0cFN0YXR1c0NvZGUgPSBIdHRwU3RhdHVzQ29kZTtcblxuYXhpb3MuZGVmYXVsdCA9IGF4aW9zO1xuXG4vLyB0aGlzIG1vZHVsZSBzaG91bGQgb25seSBoYXZlIGEgZGVmYXVsdCBleHBvcnRcbmV4cG9ydCBkZWZhdWx0IGF4aW9zXG4iLCAiaW1wb3J0IGF4aW9zIGZyb20gJy4vbGliL2F4aW9zLmpzJztcblxuLy8gVGhpcyBtb2R1bGUgaXMgaW50ZW5kZWQgdG8gdW53cmFwIEF4aW9zIGRlZmF1bHQgZXhwb3J0IGFzIG5hbWVkLlxuLy8gS2VlcCB0b3AtbGV2ZWwgZXhwb3J0IHNhbWUgd2l0aCBzdGF0aWMgcHJvcGVydGllc1xuLy8gc28gdGhhdCBpdCBjYW4ga2VlcCBzYW1lIHdpdGggZXMgbW9kdWxlIG9yIGNqc1xuY29uc3Qge1xuICBBeGlvcyxcbiAgQXhpb3NFcnJvcixcbiAgQ2FuY2VsZWRFcnJvcixcbiAgaXNDYW5jZWwsXG4gIENhbmNlbFRva2VuLFxuICBWRVJTSU9OLFxuICBhbGwsXG4gIENhbmNlbCxcbiAgaXNBeGlvc0Vycm9yLFxuICBzcHJlYWQsXG4gIHRvRm9ybURhdGEsXG4gIEF4aW9zSGVhZGVycyxcbiAgSHR0cFN0YXR1c0NvZGUsXG4gIGZvcm1Ub0pTT04sXG4gIGdldEFkYXB0ZXIsXG4gIG1lcmdlQ29uZmlnXG59ID0gYXhpb3M7XG5cbmV4cG9ydCB7XG4gIGF4aW9zIGFzIGRlZmF1bHQsXG4gIEF4aW9zLFxuICBBeGlvc0Vycm9yLFxuICBDYW5jZWxlZEVycm9yLFxuICBpc0NhbmNlbCxcbiAgQ2FuY2VsVG9rZW4sXG4gIFZFUlNJT04sXG4gIGFsbCxcbiAgQ2FuY2VsLFxuICBpc0F4aW9zRXJyb3IsXG4gIHNwcmVhZCxcbiAgdG9Gb3JtRGF0YSxcbiAgQXhpb3NIZWFkZXJzLFxuICBIdHRwU3RhdHVzQ29kZSxcbiAgZm9ybVRvSlNPTixcbiAgZ2V0QWRhcHRlcixcbiAgbWVyZ2VDb25maWdcbn1cbiIsICJpbXBvcnQgTm9zdHJXcml0ZXJQbHVnaW4gZnJvbSBcIm1haW5cIjtcbmltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XG5pbXBvcnQgeyBBcHAsIE5vdGljZSwgRmlsZVN5c3RlbUFkYXB0ZXIsIFJlcXVlc3RVcmxQYXJhbSwgVEZpbGUsIG5vcm1hbGl6ZVBhdGgsIHJlcXVlc3RVcmwgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IE5vc3RyV3JpdGVyUGx1Z2luU2V0dGluZ3MgfSBmcm9tIFwic3JjL3NldHRpbmdzXCI7XG5pbXBvcnQgeyBmaW5hbGl6ZUV2ZW50LCBuaXA5OCwgbmlwMTkgfSBmcm9tIFwibm9zdHItdG9vbHNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW1hZ2VVcGxvYWRTZXJ2aWNlIHtcblx0cHJpdmF0ZSBwbHVnaW46IE5vc3RyV3JpdGVyUGx1Z2luO1xuXHRwcml2YXRlIGFwcDogQXBwO1xuXHRwcml2YXRlIHRhcmdldFByb3ZpZGVyOiBzdHJpbmc7XG5cdHByaXZhdGUgcHJlbWl1bU5JUDk4VXNlcjogYm9vbGVhbjtcblx0cHJpdmF0ZSBwcml2YXRlS2V5OiBzdHJpbmc7XG5cdHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IFVQTE9BRF9FTkRQT0lOVCA9IFwiaHR0cHM6Ly9ub3N0ci5idWlsZC9hcGkvdjIvdXBsb2FkL2ZpbGVzXCI7XG5cblxuXHRjb25zdHJ1Y3RvcihwbHVnaW46IE5vc3RyV3JpdGVyUGx1Z2luLCBhcHA6IEFwcCwgc2V0dGluZ3M6IE5vc3RyV3JpdGVyUGx1Z2luU2V0dGluZ3MpIHtcblx0XHR0aGlzLnRhcmdldFByb3ZpZGVyID0gc2V0dGluZ3Muc2VsZWN0ZWRJbWFnZVN0b3JhZ2VQcm92aWRlcjtcblx0XHR0aGlzLnByZW1pdW1OSVA5OFVzZXIgPSBzZXR0aW5ncy5wcmVtaXVtU3RvcmFnZUVuYWJsZWQ7XG5cdFx0dGhpcy5wbHVnaW4gPSBwbHVnaW47XG5cdFx0dGhpcy5wcml2YXRlS2V5ID0gdGhpcy5jb252ZXJ0S2V5VG9IZXgoc2V0dGluZ3MucHJpdmF0ZUtleSk7XG5cdFx0dGhpcy5hcHAgPSBhcHA7XG5cdH1cblxuXHRhc3luYyB1cGxvYWRBcnRpY2xlQmFubmVySW1hZ2UoaW1hZ2VGaWxlUGF0aDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiB7XG5cdFx0bGV0IHJlc3VsdCA9IG51bGw7XG5cdFx0dHJ5IHtcblx0XHRcdGxldCBwYXRoID0gbm9ybWFsaXplUGF0aChpbWFnZUZpbGVQYXRoKTtcblx0XHRcdGxldCBpbWFnZUJ1ZmZlciA9IGF3YWl0IEZpbGVTeXN0ZW1BZGFwdGVyLnJlYWRMb2NhbEZpbGUocGF0aCk7XG5cdFx0XHRpZiAoaW1hZ2VCdWZmZXIpIHtcblx0XHRcdFx0Y29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcblx0XHRcdFx0Zm9ybURhdGEuYXBwZW5kKCdmaWxlJywgbmV3IEJsb2IoW2ltYWdlQnVmZmVyXSkpO1xuXHRcdFx0XHRsZXQgaGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcblx0XHRcdFx0XHQnQ29udGVudC1UeXBlJzogJ211bHRpcGFydC9mb3JtLWRhdGEnLFxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdGlmICh0aGlzLnByZW1pdW1OSVA5OFVzZXIpIHtcblx0XHRcdFx0XHRsZXQgYmFzZTY0ZW5jb2RlZEV2ZW50U3RyaW5nID0gYXdhaXQgbmlwOTguZ2V0VG9rZW4oSW1hZ2VVcGxvYWRTZXJ2aWNlLlVQTE9BRF9FTkRQT0lOVCwgJ3Bvc3QnLFxuXHRcdFx0XHRcdFx0KGF1dGhFdmVudCkgPT4gZmluYWxpemVFdmVudChhdXRoRXZlbnQsIEJ1ZmZlci5mcm9tKHRoaXMucHJpdmF0ZUtleSkpLCB0cnVlKTtcblx0XHRcdFx0XHRoZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSBiYXNlNjRlbmNvZGVkRXZlbnRTdHJpbmc7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShcIlx1MjNGMyBVcGxvYWRpbmcgYXMgcHJlbWl1bSB1c2VyLlwiKVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5wb3N0KCdodHRwczovL25vc3RyLmJ1aWxkL2FwaS92Mi91cGxvYWQvZmlsZXMnLCBmb3JtRGF0YSwge1xuXHRcdFx0XHRcdGhlYWRlcnM6IGhlYWRlcnMsXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRjb25zdCB7IGRhdGEgfSA9IHJlc3BvbnNlO1xuXHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheShkYXRhLmRhdGEpICYmIGRhdGEuZGF0YS5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0cmVzdWx0ID0gZGF0YS5kYXRhWzBdLnVybDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKGBQcm9ibGVtIHdpdGggaW1hZ2UgZmlsZSByZWFkaW5nIDogJHtlcnJvcn1gKVxuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0YXN5bmMgdXBsb2FkSW1hZ2VzVG9TdG9yYWdlUHJvdmlkZXIoaW1hZ2VGaWxlUGF0aHM6IHN0cmluZ1tdKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW4sIHJlc3VsdHM6IHsgZmlsZVBhdGg6IHN0cmluZywgc3RyaW5nVG9SZXBsYWNlOiBzdHJpbmcsIHJlcGxhY2VtZW50U3RyaW5nVVJMOiBzdHJpbmcsIHVwbG9hZE1ldGFkYXRhOiBhbnkgfVtdIH0+IHtcblx0XHRsZXQgdXBsb2FkUmVzdWx0cyA9IFtdO1xuXHRcdGxldCBzdWNjZXNzID0gdHJ1ZTtcblxuXHRcdGZvciAobGV0IGltYWdlUGF0aCBvZiBpbWFnZUZpbGVQYXRocykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0bGV0IGltYWdlRmlsZSA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChpbWFnZVBhdGgpXG5cdFx0XHRcdGlmIChpbWFnZUZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xuXHRcdFx0XHRcdGxldCBpbWFnZUJpbmFyeSA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWRCaW5hcnkoaW1hZ2VGaWxlKTtcblxuXHRcdFx0XHRcdGlmICh0aGlzLmlzRmlsZVNpemVPdmVyTGltaXQoaW1hZ2VCaW5hcnkpKSB7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcblx0XHRcdFx0XHRmb3JtRGF0YS5hcHBlbmQoJ2ZpbGUnLCBuZXcgQmxvYihbaW1hZ2VCaW5hcnldKSwgaW1hZ2VGaWxlLm5hbWUpO1xuXG5cdFx0XHRcdFx0Ly9jb25zdCByZXF1ZXN0VXJsUGFyYW1zOiBSZXF1ZXN0VXJsUGFyYW0gPSB7XG5cdFx0XHRcdFx0Ly9cdHVybDogJ2h0dHBzOi8vbm9zdHIuYnVpbGQvYXBpL3YyL3VwbG9hZC9maWxlcycsXG5cdFx0XHRcdFx0Ly9cdG1ldGhvZDogJ1BPU1QnLFxuXHRcdFx0XHRcdC8vXHRib2R5OiBmb3JtRGF0YVN0cmluZyxcblx0XHRcdFx0XHQvL1x0aGVhZGVyczoge1xuXHRcdFx0XHRcdC8vXHRcdC8vXHQnQ29udGVudC1UeXBlJzogJ211bHRpcGFydC9mb3JtLWRhdGEnLFxuXHRcdFx0XHRcdC8vXHR9LFxuXHRcdFx0XHRcdC8vfVxuXG5cdFx0XHRcdFx0Ly8gdXNpbmcgYXhpb3MgaGFzIENPUlMgcHJvYmxlbXMuLi4uXG5cdFx0XHRcdFx0Ly8gbm9zdHIuYnVpbGQgYWxsb3dzIE9ic2lkaWFuIGJ1dCBvdGhlciBzdHJvYWdlIHByb3ZpZGVycyBtYXkgbm90IFxuXHRcdFx0XHRcdC8vIHNvIG5lZWQgdG8gdXNlIE9ic2lkaWFuJ3MgcmVxdWVzdFVybCBtZXRob2QgZm9yIGZ1dHVyZSBjYXNlcy4uLi5cblx0XHRcdFx0XHQvLyBzZW5kaW5nIGZvcm1EYXRhIGlzIHRyaWNreSB1c2luZyB0aGlzIGFwaSAtIHNlZSBiZWxvd1xuXHRcdFx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9haS1jaGVuMjA1MC9vYnNpZGlhbi13ZWNoYXQtcHVibGljLXBsYXRmb3JtL2Jsb2IvOWZkZWNiOTY5NjZlYWFmZGQ2Y2JhYzcxNmZmYTVkYTNmYjhkNGIyYi9zcmMvYXBpLnRzI0w5MlxuXHRcdFx0XHRcdC8vIG9yLi4uXG5cdFx0XHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2dhdnZ2ci9vYnNpZGlhbi1pbWd1ci1wbHVnaW4vYmxvYi9tYWluL3NyYy91cGxvYWRlci9pbWd1ci9JbWd1ckFub255bW91c1VwbG9hZGVyLnRzXG5cdFx0XHRcdFx0bGV0IGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG5cdFx0XHRcdFx0XHQnQ29udGVudC1UeXBlJzogJ211bHRpcGFydC9mb3JtLWRhdGEnLFxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRpZiAodGhpcy5wcmVtaXVtTklQOThVc2VyKSB7XG5cdFx0XHRcdFx0XHRsZXQgYmFzZTY0ZW5jb2RlZEV2ZW50U3RyaW5nID0gYXdhaXQgbmlwOTguZ2V0VG9rZW4oSW1hZ2VVcGxvYWRTZXJ2aWNlLlVQTE9BRF9FTkRQT0lOVCwgJ3Bvc3QnLFxuXHRcdFx0XHRcdFx0XHQoYXV0aEV2ZW50KSA9PiBmaW5hbGl6ZUV2ZW50KGF1dGhFdmVudCwgQnVmZmVyLmZyb20odGhpcy5wcml2YXRlS2V5KSksIHRydWUpO1xuXHRcdFx0XHRcdFx0aGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gYmFzZTY0ZW5jb2RlZEV2ZW50U3RyaW5nO1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZShcIlx1MjNGMyBVcGxvYWRpbmcgYXMgcHJlbWl1bSB1c2VyLlwiKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLnBvc3QoJ2h0dHBzOi8vbm9zdHIuYnVpbGQvYXBpL3YyL3VwbG9hZC9maWxlcycsIGZvcm1EYXRhLCB7XG5cdFx0XHRcdFx0XHRoZWFkZXJzOiBoZWFkZXJzLFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdC8vbGV0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdFVybChyZXF1ZXN0VXJsUGFyYW1zKTtcblx0XHRcdFx0XHQvL2NvbnN0IHsgZGF0YSB9ID0gcmVzcG9uc2UuanNvbigpO1xuXHRcdFx0XHRcdGNvbnN0IHsgZGF0YSB9ID0gcmVzcG9uc2U7XG5cdFx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoZGF0YS5kYXRhKSAmJiBkYXRhLmRhdGEubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdFx0Y29uc3QgcmVzdWx0ID0ge1xuXHRcdFx0XHRcdFx0XHRmaWxlUGF0aDogaW1hZ2VQYXRoLFxuXHRcdFx0XHRcdFx0XHRzdHJpbmdUb1JlcGxhY2U6IGAhW1ske2ltYWdlRmlsZS5uYW1lfV1dYCxcblx0XHRcdFx0XHRcdFx0cmVwbGFjZW1lbnRTdHJpbmdVUkw6IGRhdGEuZGF0YVswXS51cmwsXG5cdFx0XHRcdFx0XHRcdHVwbG9hZE1ldGFkYXRhOiBkYXRhLmRhdGFbMF1cblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR1cGxvYWRSZXN1bHRzLnB1c2gocmVzdWx0KTtcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoYFx1MjcwNSBVcGxvYWRlZCAke2ltYWdlRmlsZS5uYW1lfWApXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoYFx1Mjc0QyBQcm9ibGVtIHVwbG9hZGluZyAke2ltYWdlRmlsZS5uYW1lfWApXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdG5ldyBOb3RpY2UoYFx1Mjc0QyBQcm9ibGVtIHVwbG9hZGluZyBgKVxuXHRcdFx0XHRjb25zb2xlLmVycm9yKGBQcm9ibGVtIHdpdGggaW1hZ2UgZmlsZSByZWFkaW5nIDogJHtlcnJvcn1gKVxuXHRcdFx0XHRzdWNjZXNzID0gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHR9XG5cdFx0cmV0dXJuIHsgc3VjY2VzcywgcmVzdWx0czogdXBsb2FkUmVzdWx0cyB9O1xuXHR9XG5cblx0aXNGaWxlU2l6ZU92ZXJMaW1pdChmaWxlOiBBcnJheUJ1ZmZlcik6IGJvb2xlYW4ge1xuXHRcdGxldCBtYXhTaXplSW5CeXRlcyA9IDEwICogMTAyNCAqIDEwMjQ7IC8vIDEwIE1CXG5cdFx0aWYgKHRoaXMucHJlbWl1bU5JUDk4VXNlcikge1xuXHRcdFx0bWF4U2l6ZUluQnl0ZXMgPSA1MCAqIDEwMjQgKiAxMDI0OyAvLyAxMDBNQlxuXHRcdH1cblx0XHRpZiAoZmlsZS5ieXRlTGVuZ3RoID4gbWF4U2l6ZUluQnl0ZXMpIHtcblx0XHRcdGlmICh0aGlzLnByZW1pdW1OSVA5OFVzZXIpIHtcblx0XHRcdFx0bmV3IE5vdGljZSgnXHUyNzRDIDUwIE1CIGlubGluZSBpbWFnZSBsaW1pdC4gV2lsbCBub3QgdXBsb2FkLicpO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdG5ldyBOb3RpY2UoJ1x1Mjc0QyBJbmxpbmUgaW1hZ2Ugc2l6ZSBleGNlZWRzIHRoZSBsaW1pdC4gV2lsbCBub3QgdXBsb2FkLicpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGNvbnZlcnRLZXlUb0hleCh2YWx1ZTogc3RyaW5nKTogc3RyaW5nIHtcblx0XHRpZiAodmFsdWUgJiYgdmFsdWUuc3RhcnRzV2l0aChcIm5zZWNcIikpIHtcblx0XHRcdGxldCBkZWNvZGVkUHJpdmF0ZUtleSA9IG5pcDE5LmRlY29kZSh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gZGVjb2RlZFByaXZhdGVLZXkuZGF0YSBhcyBzdHJpbmc7XG5cdFx0fVxuXHRcdGlmICh2YWx1ZSAmJiB2YWx1ZS5zdGFydHNXaXRoKFwibnB1YlwiKSkge1xuXHRcdFx0bGV0IGRlY29kZWRQdWJsaWNLZXkgPSBuaXAxOS5kZWNvZGUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIGRlY29kZWRQdWJsaWNLZXkuZGF0YSBhcyBzdHJpbmc7XG5cdFx0fVxuXHRcdHJldHVybiB2YWx1ZTtcblx0fVxufVxuXG4iLCAiaW1wb3J0IHtcblx0QXBwLFxuXHROb3RpY2UsXG5cdFBsdWdpblNldHRpbmdUYWIsXG5cdFNldHRpbmcsXG5cdFRleHRDb21wb25lbnRcbn0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgTm9zdHJXcml0ZXJQbHVnaW4gZnJvbSBcIi4uL21haW5cIjtcblxuaW50ZXJmYWNlIFByb2ZpbGUge1xuXHRwcm9maWxlTmlja25hbWU6IHN0cmluZztcblx0cHJvZmlsZVByaXZhdGVLZXk6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBOb3N0cldyaXRlclBsdWdpblNldHRpbmdzIHtcblx0cHJpdmF0ZUtleTogc3RyaW5nO1xuXHRzaG9ydEZvcm1FbmFibGVkOiBib29sZWFuO1xuXHRzdGF0dXNCYXJFbmFibGVkOiBib29sZWFuO1xuXHRyZWxheUNvbmZpZ0VuYWJsZWQ6IGJvb2xlYW47XG5cdHJlbGF5VVJMczogc3RyaW5nW107XG5cdG11bHRpcGxlUHJvZmlsZXNFbmFibGVkOiBib29sZWFuO1xuXHRwcm9maWxlczogUHJvZmlsZVtdO1xuXHRpbWFnZVN0b3JhZ2VQcm92aWRlcnM6IHN0cmluZ1tdO1xuXHRzZWxlY3RlZEltYWdlU3RvcmFnZVByb3ZpZGVyOiBzdHJpbmc7XG5cdHByZW1pdW1TdG9yYWdlRW5hYmxlZDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNsYXNzIE5vc3RyV3JpdGVyU2V0dGluZ1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xuXHRwbHVnaW46IE5vc3RyV3JpdGVyUGx1Z2luO1xuXHRwcml2YXRlIHJlZnJlc2hEaXNwbGF5OiAoKSA9PiB2b2lkO1xuXHRwcml2YXRlIHJlbGF5VXJsSW5wdXQ6IFRleHRDb21wb25lbnQ7XG5cblx0Y29uc3RydWN0b3IoYXBwOiBBcHAsIHBsdWdpbjogTm9zdHJXcml0ZXJQbHVnaW4pIHtcblx0XHRzdXBlcihhcHAsIHBsdWdpbik7XG5cdFx0dGhpcy5wbHVnaW4gPSBwbHVnaW47XG5cdFx0dGhpcy5yZWZyZXNoRGlzcGxheSA9ICgpID0+IHRoaXMuZGlzcGxheSgpO1xuXHR9XG5cblx0ZGlzcGxheSgpOiB2b2lkIHtcblx0XHRsZXQgeyBjb250YWluZXJFbCB9ID0gdGhpcztcblxuXHRcdGNvbnRhaW5lckVsLmVtcHR5KCk7XG5cblx0XHRsZXQgcHJpdmF0ZUtleUZpZWxkOiBIVE1MSW5wdXRFbGVtZW50O1xuXHRcdGxldCBwcml2YXRlS2V5SW5wdXQ6IGFueTtcblxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoXCJOb3N0ciBwcml2YXRlIGtleVwiKVxuXHRcdFx0LnNldERlc2MoXCJEZWZhdWx0IHByb2ZpbGUgdG8gcHVibGlzaCBmcm9tLlwiKVxuXHRcdFx0LmFkZFRleHQoKHRleHQpID0+IHtcblx0XHRcdFx0cHJpdmF0ZUtleUlucHV0ID0gdGV4dDtcblx0XHRcdFx0dGV4dC5zZXRQbGFjZWhvbGRlcihcIm5zZWMuLi5cIilcblx0XHRcdFx0XHQuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MucHJpdmF0ZUtleSlcblx0XHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0XHRpZiAoaXNWYWxpZFByaXZhdGVLZXkodmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLnByaXZhdGVLZXkgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdFx0XHRcdHRoaXMucGx1Z2luLnN0YXJ0dXBOb3N0clNlcnZpY2UoKTtcblx0XHRcdFx0XHRcdFx0bmV3IE5vdGljZShcIlByaXZhdGUga2V5IHNhdmVkIVwiKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoXCJJbnZhbGlkIHByaXZhdGUga2V5XCIsIDUwMDApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHByaXZhdGVLZXlGaWVsZCA9IHRleHQuaW5wdXRFbDtcblx0XHRcdFx0cHJpdmF0ZUtleUZpZWxkLnR5cGUgPSBcInBhc3N3b3JkXCI7XG5cdFx0XHRcdHByaXZhdGVLZXlGaWVsZC5zdHlsZS53aWR0aCA9IFwiNDAwcHhcIjtcblx0XHRcdH0pXG5cdFx0XHQuYWRkQnV0dG9uKChidXR0b24pID0+XG5cdFx0XHRcdGJ1dHRvblxuXHRcdFx0XHRcdC5zZXRUb29sdGlwKFwiQ29weSBwcml2YXRlIGtleVwiKVxuXHRcdFx0XHRcdC5zZXRJY29uKFwiY29weVwiKVxuXHRcdFx0XHRcdC5vbkNsaWNrKCgpID0+IHtcblx0XHRcdFx0XHRcdGlmIChwcml2YXRlS2V5RmllbGQpIHtcblx0XHRcdFx0XHRcdFx0bmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQoXG5cdFx0XHRcdFx0XHRcdFx0cHJpdmF0ZUtleUZpZWxkLnZhbHVlXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoXCJQcml2YXRlIEtleSBDb3BpZWQgLSBCZSBDYXJlZnVsIFx1RDgzRFx1REQxMFwiKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KVxuXHRcdFx0KVxuXHRcdFx0LmFkZEJ1dHRvbigoYnV0dG9uKSA9PlxuXHRcdFx0XHRidXR0b25cblx0XHRcdFx0XHQuc2V0QnV0dG9uVGV4dChcIkRlbGV0ZVwiKVxuXHRcdFx0XHRcdC5zZXRXYXJuaW5nKClcblx0XHRcdFx0XHQuc2V0VG9vbHRpcChcIkRlbGV0ZSB0aGUgcHJpdmF0ZSBrZXkgZnJvbSBtZW1vcnlcIilcblx0XHRcdFx0XHQub25DbGljayhhc3luYyAoKSA9PiB7XG5cdFx0XHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0XHRcdGNvbmZpcm0oXG5cdFx0XHRcdFx0XHRcdFx0XCJBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gZGVsZXRlIHlvdXIgcHJpdmF0ZSBrZXk/IFRoaXMgY2Fubm90IGJlIHVuZG9uZS5cIlxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5wbHVnaW4uc2V0dGluZ3MucHJpdmF0ZUtleSA9IFwiXCI7XG5cdFx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdFx0XHRwcml2YXRlS2V5SW5wdXQuc2V0VmFsdWUoXCJcIik7XG5cdFx0XHRcdFx0XHRcdHRoaXMucGx1Z2luLnN0YXJ0dXBOb3N0clNlcnZpY2UoKTtcblx0XHRcdFx0XHRcdFx0bmV3IE5vdGljZShcIlByaXZhdGUga2V5IGRlbGV0ZWQhXHVEODNEXHVEREQxXCIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pXG5cdFx0XHQpO1xuXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHQuc2V0TmFtZShcIlNob3cgcHJpdmF0ZSBrZXlcIilcblx0XHRcdC5zZXREZXNjKFwiVG9nZ2xlIHRvIHNob3cvaGlkZSB0aGUgcHJpdmF0ZSBrZXkuXCIpXG5cdFx0XHQuYWRkVG9nZ2xlKCh0b2dnbGUpID0+XG5cdFx0XHRcdHRvZ2dsZS5zZXRWYWx1ZShmYWxzZSkub25DaGFuZ2UoKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0aWYgKHByaXZhdGVLZXlGaWVsZCkge1xuXHRcdFx0XHRcdFx0Ly8gU2V0IHRoZSB0eXBlIG9mIHRoZSBpbnB1dCBmaWVsZCBiYXNlZCBvbiB0aGUgdmFsdWUgb2YgdGhlIGNoZWNrYm94XG5cdFx0XHRcdFx0XHRwcml2YXRlS2V5RmllbGQudHlwZSA9IHZhbHVlID8gXCJ0ZXh0XCIgOiBcInBhc3N3b3JkXCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KVxuXHRcdFx0KTtcblxuLy9cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4vL1x0XHRcdC5zZXROYW1lKFwiSW1hZ2UgU3RvcmFnZSBQcm92aWRlclwiKVxuLy9cdFx0XHQuc2V0RGVzYyhcbi8vXHRcdFx0XHRcIkNvbmZpZ3VyZSB3aGVyZSB5b3Ugc3RvcmUgaW1hZ2VzIGluIHlvdXIgcHVibGlzaGVkIHdvcmsuXCJcbi8vXHRcdFx0KVxuLy9cdFx0XHRcdC5hZGREcm9wZG93bigoZHJvcGRvd24pID0+IHtcbi8vXHRcdFx0XHRcdGZvciAoY29uc3QgIHN0b3JhZ2VQcm92aWRlciBvZiB0aGlzLnBsdWdpbi5zZXR0aW5ncy5pbWFnZVN0b3JhZ2VQcm92aWRlcnMpIHtcbi8vXHRcdFx0XHRcdFx0ZHJvcGRvd24uYWRkT3B0aW9uKHN0b3JhZ2VQcm92aWRlciwgc3RvcmFnZVByb3ZpZGVyKTtcbi8vXHRcdFx0XHRcdH1cbi8vXHRcdFx0XHRcdGRyb3Bkb3duLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnNlbGVjdGVkSW1hZ2VTdG9yYWdlUHJvdmlkZXIpO1xuLy9cdFx0XHRcdFx0ZHJvcGRvd24ub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4vL1x0XHRcdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLnNlbGVjdGVkSW1hZ2VTdG9yYWdlUHJvdmlkZXIgPSB2YWx1ZTtcbi8vXHRcdFx0XHRcdFx0bmV3IE5vdGljZShgXHVEODNEXHVEREJDXHVGRTBGICR7dGhpcy5wbHVnaW4uc2V0dGluZ3Muc2VsZWN0ZWRJbWFnZVN0b3JhZ2VQcm92aWRlcn0gc2VsZWN0ZWRgKTtcbi8vXHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4vL1x0XHRcdFx0XHRcdHRoaXMucmVmcmVzaERpc3BsYXkoKTtcbi8vXHRcdFx0XHRcdH0pO1xuLy9cdFx0XHRcdH0pO1xuXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHQuc2V0TmFtZShcIlByZW1pdW0gU3RvcmFnZSBVc2VyXCIpXG5cdFx0XHQuc2V0RGVzYyhcblx0XHRcdFx0YFR1cm4gb24gaWYgeW91IGhhdmUgYSBwcmVtaXVtIGFjY291bnQgd2l0aCBub3N0ci5idWlsZCBzdG9yYWdlIHNlcnZpY2UuYFxuXHRcdFx0KVxuXHRcdFx0LmFkZFRvZ2dsZSgodG9nZ2xlKSA9PlxuXHRcdFx0XHR0b2dnbGVcblx0XHRcdFx0XHQuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MucHJlbWl1bVN0b3JhZ2VFbmFibGVkKVxuXHRcdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLnByZW1pdW1TdG9yYWdlRW5hYmxlZCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZSggYFx1MjcwNSBQcmVtaXVtIGltYWdlIHVzZXIgbW9kZSAke3ZhbHVlID8gXCJlbmFibGVkXCIgOiBcImRpc2FibGVkXCJ9YCk7XG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0XHRcdHRoaXMucmVmcmVzaERpc3BsYXkoKTtcblx0XHRcdFx0XHR9KVxuXHRcdFx0KTtcblxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoXCJFbmFibGUgbXVsdGlwbGUgTm9zdHIgcHJvZmlsZXNcIilcblx0XHRcdC5zZXREZXNjKFxuXHRcdFx0XHRcIkVuYWJsZSAmIGFkZCBtdWx0aXBsZSBOb3N0ciBwcm9maWxlcyB0byBwdWJsaXNoIGZyb20uXCJcblx0XHRcdClcblx0XHRcdC5hZGRUb2dnbGUoKHRvZ2dsZSkgPT5cblx0XHRcdFx0dG9nZ2xlXG5cdFx0XHRcdFx0LnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLm11bHRpcGxlUHJvZmlsZXNFbmFibGVkKVxuXHRcdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHRcdHRoaXMucGx1Z2luLnNldHRpbmdzLm11bHRpcGxlUHJvZmlsZXNFbmFibGVkID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0XHRcdHRoaXMucmVmcmVzaERpc3BsYXkoKTtcblx0XHRcdFx0XHR9KVxuXHRcdFx0KTtcblxuXHRcdGlmICh0aGlzLnBsdWdpbi5zZXR0aW5ncy5tdWx0aXBsZVByb2ZpbGVzRW5hYmxlZCkge1xuXHRcdFx0bGV0IG5ld1Byb2ZpbGVQcml2YXRlS2V5RmllbGQ6IHN0cmluZztcblx0XHRcdGxldCBuZXdQcm9maWxlTmlja25hbWVGaWVsZDogc3RyaW5nO1xuXG5cdFx0XHRsZXQgbXVsdGlwbGVQcml2YXRlS2V5RmllbGQ6IEhUTUxJbnB1dEVsZW1lbnQ7XG5cblx0XHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKFwiaDVcIiwgeyB0ZXh0OiBcIkFkZGl0aW9uYWwgTm9zdHIgUHJvZmlsZXNcIiB9KTtcblx0XHRcdG5ldyBTZXR0aW5nKHRoaXMuY29udGFpbmVyRWwpXG5cdFx0XHRcdC5zZXREZXNjKFwiQWRkIGEgbmV3IE5vc3RyIHByb2ZpbGUgdG8gcHVibGlzaCBmcm9tLlwiKVxuXHRcdFx0XHQuc2V0TmFtZShcIkFkZCBQcm9maWxlXCIpXG5cdFx0XHRcdC5hZGRUZXh0KChuZXdBY2NvdW50Tmlja25hbWVJbnB1dCkgPT4ge1xuXHRcdFx0XHRcdG5ld0FjY291bnROaWNrbmFtZUlucHV0LnNldFBsYWNlaG9sZGVyKFwiUHJvZmlsZSBOaWNrbmFtZVwiKTtcblx0XHRcdFx0XHRuZXdBY2NvdW50Tmlja25hbWVJbnB1dC5vbkNoYW5nZSgodmFsdWUpID0+IHtcblx0XHRcdFx0XHRcdGlmICh2YWx1ZS50b0xvd2VyQ2FzZSgpICE9PSBcImRlZmF1bHRcIikge1xuXHRcdFx0XHRcdFx0XHRuZXdQcm9maWxlTmlja25hbWVGaWVsZCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0bmV3IE5vdGljZShcIlx1Mjc0QyBDYW4ndCBjYWxsIGFuIGFkZGl0aW9uYWwgcHJvZmlsZSBkZWZhdWx0XCIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5hZGRUZXh0KChuZXdBY2NvdW50TnNlY0lucHV0KSA9PiB7XG5cdFx0XHRcdFx0bmV3QWNjb3VudE5zZWNJbnB1dC5zZXRQbGFjZWhvbGRlcihcIm5zZWNcIik7XG5cdFx0XHRcdFx0bmV3QWNjb3VudE5zZWNJbnB1dC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHRcdGlmIChpc1ZhbGlkUHJpdmF0ZUtleSh2YWx1ZSkpIHtcblx0XHRcdFx0XHRcdFx0bmV3UHJvZmlsZVByaXZhdGVLZXlGaWVsZCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHRuZXcgTm90aWNlKFwiXHUyNzA1IFByaXZhdGUga2V5IE9LIVwiKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoXCJcdTI3NEMgSW52YWxpZCBwcml2YXRlIGtleVwiLCA1MDAwKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRtdWx0aXBsZVByaXZhdGVLZXlGaWVsZCA9IG5ld0FjY291bnROc2VjSW5wdXQuaW5wdXRFbDtcblx0XHRcdFx0XHRtdWx0aXBsZVByaXZhdGVLZXlGaWVsZC50eXBlID0gXCJwYXNzd29yZFwiO1xuXHRcdFx0XHRcdG11bHRpcGxlUHJpdmF0ZUtleUZpZWxkLnN0eWxlLndpZHRoID0gXCIyMDBweFwiO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQuYWRkQnV0dG9uKChidG4pID0+IHtcblx0XHRcdFx0XHRidG4uc2V0SWNvbihcInBsdXNcIik7XG5cdFx0XHRcdFx0YnRuLnNldEN0YSgpO1xuXHRcdFx0XHRcdGJ0bi5zZXRUb29sdGlwKFwiQWRkIHRoaXMgcHJvZmlsZVwiKTtcblx0XHRcdFx0XHRidG4ub25DbGljayhhc3luYyAoKSA9PiB7XG5cdFx0XHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0XHRcdG5ld1Byb2ZpbGVQcml2YXRlS2V5RmllbGQgJiZcblx0XHRcdFx0XHRcdFx0bmV3UHJvZmlsZU5pY2tuYW1lRmllbGQgJiZcblx0XHRcdFx0XHRcdFx0dGhpcy5pc1ZhbGlkTmlja25hbWUobmV3UHJvZmlsZU5pY2tuYW1lRmllbGQpXG5cdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5wbHVnaW4uc2V0dGluZ3MucHJvZmlsZXMucHVzaCh7XG5cdFx0XHRcdFx0XHRcdFx0cHJvZmlsZU5pY2tuYW1lOiBuZXdQcm9maWxlTmlja25hbWVGaWVsZCxcblx0XHRcdFx0XHRcdFx0XHRwcm9maWxlUHJpdmF0ZUtleTogbmV3UHJvZmlsZVByaXZhdGVLZXlGaWVsZCxcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdFx0XHR0aGlzLnJlZnJlc2hEaXNwbGF5KCk7XG5cdFx0XHRcdFx0XHRcdHRoaXMucGx1Z2luLm5vc3RyU2VydmljZS5yZWxvYWRNdWx0aXBsZUFjY291bnRzKCk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRuZXcgTm90aWNlKFwiQWRkIGEgcHJvZmlsZSBuaWNrbmFtZSAmIGEgdmFsaWQgbnNlY1wiKTtcblx0XHRcdFx0XHRcdFx0aWYgKCF0aGlzLmlzVmFsaWROaWNrbmFtZShuZXdQcm9maWxlTmlja25hbWVGaWVsZCkpIHtcblx0XHRcdFx0XHRcdFx0XHRuZXcgTm90aWNlKFwiXHUyNzRDIEludmFsaWQgbmlja25hbWUgLSBhbHJlYWR5IGluIHVzZVwiKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdGZvciAoY29uc3QgW2ksIHsgcHJvZmlsZU5pY2tuYW1lIH1dIG9mIHRoaXMucGx1Z2luLnNldHRpbmdzLnByb2ZpbGVzLmVudHJpZXMoKSkge1xuXHRcdFx0XHRuZXcgU2V0dGluZyh0aGlzLmNvbnRhaW5lckVsKVxuXHRcdFx0XHRcdC5zZXROYW1lKGBcdUQ4M0RcdURDNjQgLSAke3Byb2ZpbGVOaWNrbmFtZX1gKVxuXHRcdFx0XHRcdC5hZGRCdXR0b24oKGJ0bikgPT4ge1xuXHRcdFx0XHRcdFx0YnRuLnNldEljb24oXCJ0cmFzaFwiKTtcblx0XHRcdFx0XHRcdGJ0bi5zZXRXYXJuaW5nKCk7XG5cdFx0XHRcdFx0XHRidG4uc2V0VG9vbHRpcChcIlJlbW92ZSB0aGlzIHByb2ZpbGVcIik7XG5cdFx0XHRcdFx0XHRidG4ub25DbGljayhhc3luYyAoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdFx0XHRjb25maXJtKFxuXHRcdFx0XHRcdFx0XHRcdFx0XCJBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gZGVsZXRlIHRoaXMgcHJvZmlsZT8gVGhpcyBjYW5ub3QgYmUgdW5kb25lLlwiXG5cdFx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcm9maWxlcy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5yZWZyZXNoRGlzcGxheSgpO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMucGx1Z2luLm5vc3RyU2VydmljZS5yZWxvYWRNdWx0aXBsZUFjY291bnRzKCk7XG5cdFx0XHRcdFx0XHRcdFx0bmV3IE5vdGljZShcIlx1RDgzRFx1REREMVx1RkUwRiBQcm9maWxlIHN1Y2Nlc3NmdWxseSBkZWxldGVkLlwiKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRjb250YWluZXJFbC5jcmVhdGVFbChcImJyXCIpO1xuXHRcdH1cblxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoXCJDbGVhciBsb2NhbCBwdWJsaXNoZWQgaGlzdG9yeVwiKVxuXHRcdFx0LnNldERlc2MoXCJUaGlzIGRvZXMgbm90IGRlbGV0ZSB5b3VyIG5vdGVzIGZyb20gdGhlIE5vc3RyIG5ldHdvcmsuXCIpXG5cdFx0XHQuYWRkQnV0dG9uKChidXR0b24pID0+XG5cdFx0XHRcdGJ1dHRvblxuXHRcdFx0XHRcdC5zZXRCdXR0b25UZXh0KFwiQ2xlYXJcIilcblx0XHRcdFx0XHQuc2V0SWNvbihcInRyYXNoXCIpXG5cdFx0XHRcdFx0LnNldFRvb2x0aXAoXCJEZWxldGUgdGhlIGxvY2FsIHB1Ymxpc2hlZCBoaXN0b3J5XCIpXG5cdFx0XHRcdFx0Lm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0XHRjb25maXJtKFxuXHRcdFx0XHRcdFx0XHRcdFwiQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIGRlbGV0ZSB5b3VyIGxvY2FsIGhpc3Rvcnk/IFRoaXMgY2Fubm90IGJlIHVuZG9uZS5cIlxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0Y2xlYXJMb2NhbFB1Ymxpc2hlZEZpbGUoKTtcblx0XHRcdFx0XHRcdFx0bmV3IE5vdGljZShcIlx1RDgzRFx1REREMVx1RkUwRiBQdWJsaXNoZWQgSGlzdG9yeSBkZWxldGVkIVwiKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KVxuXHRcdFx0KTtcblxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoXCJTaG9ydCBmb3JtIG1vZGVcIilcblx0XHRcdC5zZXREZXNjKFwiQWRkIHNob3J0IGZvcm0gd3JpdGluZyBidXR0b24gdG8geW91ciBtZW51LlwiKVxuXHRcdFx0LmFkZFRvZ2dsZSgodG9nZ2xlKSA9PlxuXHRcdFx0XHR0b2dnbGVcblx0XHRcdFx0XHQuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3Muc2hvcnRGb3JtRW5hYmxlZClcblx0XHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5zaG9ydEZvcm1FbmFibGVkID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0XHRcdHRoaXMucGx1Z2luLnVwZGF0ZVJpYmJvbkljb24oKTtcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoXG5cdFx0XHRcdFx0XHRcdGBcdTI3MDUgU2hvcnQgZm9ybSBtb2RlICR7dmFsdWUgPyBcImVuYWJsZWRcIiA6IFwiZGlzYWJsZWRcIn1gXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH0pXG5cdFx0XHQpO1xuXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHQuc2V0TmFtZShcIkNvbmZpZ3VyZSByZWxheXNcIilcblx0XHRcdC5zZXREZXNjKFwiRWRpdCB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uICYgc2VlIGRldGFpbHMuXCIpXG5cdFx0XHQuYWRkVG9nZ2xlKCh0b2dnbGUpID0+XG5cdFx0XHRcdHRvZ2dsZVxuXHRcdFx0XHRcdC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5yZWxheUNvbmZpZ0VuYWJsZWQpXG5cdFx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdFx0dGhpcy5wbHVnaW4uc2V0dGluZ3MucmVsYXlDb25maWdFbmFibGVkID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0XHRcdHRoaXMucmVmcmVzaERpc3BsYXkoKTtcblx0XHRcdFx0XHR9KVxuXHRcdFx0KTtcblxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoXCJSZWNvbm5lY3QgdG8gcmVsYXlzIFwiKVxuXHRcdFx0LnNldERlc2MoXG5cdFx0XHRcdFwiUmVmcmVzaCBjb25uZWN0aW9uIHRvIHJlbGF5cyAtIGNoZWNrIHN0YXR1cyBiYXIgZm9yIGRldGFpbHMuXCJcblx0XHRcdClcblx0XHRcdC5hZGRCdXR0b24oKGJ0bikgPT4ge1xuXHRcdFx0XHRidG4uc2V0SWNvbihcInJlc2V0XCIpO1xuXHRcdFx0XHRidG4uc2V0Q3RhKCk7XG5cdFx0XHRcdGJ0bi5zZXRUb29sdGlwKFwiUmUtY29ubmVjdFwiKTtcblx0XHRcdFx0YnRuLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYFJlLWNvbm5lY3RpbmcgdG8gTm9zdHIuLi5gKTtcblx0XHRcdFx0XHR0aGlzLnJlZnJlc2hEaXNwbGF5KCk7XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4ubm9zdHJTZXJ2aWNlLmNvbm5lY3RUb1JlbGF5cygpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXG5cdFx0aWYgKHRoaXMucGx1Z2luLnNldHRpbmdzLnJlbGF5Q29uZmlnRW5hYmxlZCkge1xuXHRcdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoXCJoNVwiLCB7IHRleHQ6IFwiUmVsYXkgQ29uZmlndXJhdGlvblwiIH0pO1xuXHRcdFx0bmV3IFNldHRpbmcodGhpcy5jb250YWluZXJFbClcblx0XHRcdFx0LnNldERlc2MoXCJBZGQgYSByZWxheSBVUkwgdG8gc2V0dGluZ3NcIilcblx0XHRcdFx0LnNldE5hbWUoXCJBZGQgUmVsYXlcIilcblx0XHRcdFx0LmFkZFRleHQoKHJlbGF5VXJsSW5wdXQpID0+IHtcblx0XHRcdFx0XHRyZWxheVVybElucHV0LnNldFBsYWNlaG9sZGVyKFwid3NzOi8vZmF2LnJlbGF5LmNvbVwiKTtcblx0XHRcdFx0XHRyZWxheVVybElucHV0Lm9uQ2hhbmdlKCgpID0+IHtcblx0XHRcdFx0XHRcdHRoaXMucmVsYXlVcmxJbnB1dCA9IHJlbGF5VXJsSW5wdXQ7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5hZGRCdXR0b24oKGJ0bikgPT4ge1xuXHRcdFx0XHRcdGJ0bi5zZXRJY29uKFwicGx1c1wiKTtcblx0XHRcdFx0XHRidG4uc2V0Q3RhKCk7XG5cdFx0XHRcdFx0YnRuLnNldFRvb2x0aXAoXCJBZGQgdGhpcyByZWxheVwiKTtcblx0XHRcdFx0XHRidG4ub25DbGljayhhc3luYyAoKSA9PiB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRsZXQgYWRkZWRSZWxheVVybCA9IHRoaXMucmVsYXlVcmxJbnB1dC5nZXRWYWx1ZSgpO1xuXHRcdFx0XHRcdFx0XHRpZiAodGhpcy5pc1ZhbGlkVXJsKGFkZGVkUmVsYXlVcmwpKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5wbHVnaW4uc2V0dGluZ3MucmVsYXlVUkxzLnB1c2goXG5cdFx0XHRcdFx0XHRcdFx0XHRhZGRlZFJlbGF5VXJsXG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0XHRcdFx0XHRuZXcgTm90aWNlKFxuXHRcdFx0XHRcdFx0XHRcdFx0YEFkZGVkICR7YWRkZWRSZWxheVVybH0gdG8gcmVsYXkgY29uZmlndXJhdGlvbi5gXG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHRuZXcgTm90aWNlKGBSZS1jb25uZWN0aW5nIHRvIE5vc3RyLi4uYCk7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5yZWZyZXNoRGlzcGxheSgpO1xuXHRcdFx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLm5vc3RyU2VydmljZS5jb25uZWN0VG9SZWxheXMoKTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnJlbGF5VXJsSW5wdXQuc2V0VmFsdWUoXCJcIik7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0bmV3IE5vdGljZShcIkludmFsaWQgVVJMIGFkZGVkXCIpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGNhdGNoIHtcblx0XHRcdFx0XHRcdFx0bmV3IE5vdGljZShcIk5vIFVSTCBhZGRlZFwiKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSk7XG5cdFx0XHRmb3IgKGNvbnN0IFtpLCB1cmxdIG9mIHRoaXMucGx1Z2luLnNldHRpbmdzLnJlbGF5VVJMcy5lbnRyaWVzKCkpIHtcblx0XHRcdFx0bmV3IFNldHRpbmcodGhpcy5jb250YWluZXJFbClcblx0XHRcdFx0XHQuc2V0RGVzYyhcblx0XHRcdFx0XHRcdGAke3VybH0gaXMgJHt0aGlzLnBsdWdpbi5ub3N0clNlcnZpY2UuZ2V0UmVsYXlJbmZvKHVybClcblx0XHRcdFx0XHRcdFx0PyBcImNvbm5lY3RlZFwiXG5cdFx0XHRcdFx0XHRcdDogXCJkaXNjb25uZWN0ZWRcIlxuXHRcdFx0XHRcdFx0fWBcblx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0LnNldE5hbWUoXG5cdFx0XHRcdFx0XHRgJHt0aGlzLnBsdWdpbi5ub3N0clNlcnZpY2UuZ2V0UmVsYXlJbmZvKHVybClcblx0XHRcdFx0XHRcdFx0PyBcIlx1RDgzRFx1REZFMlwiXG5cdFx0XHRcdFx0XHRcdDogXCJcdUQ4M0RcdURDODBcIlxuXHRcdFx0XHRcdFx0fSAtIFJlbGF5ICR7aSArIDF9IGBcblx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0LmFkZEJ1dHRvbigoYnRuKSA9PiB7XG5cdFx0XHRcdFx0XHRidG4uc2V0SWNvbihcInRyYXNoXCIpO1xuXHRcdFx0XHRcdFx0YnRuLnNldFRvb2x0aXAoXCJSZW1vdmUgdGhpcyByZWxheVwiKTtcblx0XHRcdFx0XHRcdGJ0bi5vbkNsaWNrKGFzeW5jICgpID0+IHtcblx0XHRcdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0XHRcdGNvbmZpcm0oXG5cdFx0XHRcdFx0XHRcdFx0XHRcIkFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBkZWxldGUgdGhpcyByZWxheT8gVGhpcyBjYW5ub3QgYmUgdW5kb25lLlwiXG5cdFx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5yZWxheVVSTHMuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdFx0XHRcdGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMucmVmcmVzaERpc3BsYXkoKTtcblx0XHRcdFx0XHRcdFx0XHRuZXcgTm90aWNlKFwiUmVsYXkgc3VjY2Vzc2Z1bGx5IGRlbGV0ZWQuXCIpO1xuXHRcdFx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoYFJlLWNvbm5lY3RpbmcgdG8gTm9zdHIuLi5gKTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnBsdWdpbi5ub3N0clNlcnZpY2UuY29ubmVjdFRvUmVsYXlzKCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNvbnRhaW5lckVsLmNyZWF0ZUVsKFwiaDVcIiwgeyB0ZXh0OiBcIlN1cHBvcnRcIiB9KTtcblx0XHRuZXcgU2V0dGluZyh0aGlzLmNvbnRhaW5lckVsKVxuXHRcdFx0LnNldERlc2MoXG5cdFx0XHRcdFwiSGFzIHRoaXMgcGx1Z2luIGVuaGFuY2VkIHlvdXIgd29ya2Zsb3c/IFNheSB0aGFua3MgYXMgYSBvbmUtdGltZSBwYXltZW50IGFuZCB6YXAvYnV5IG1lIGEgY29mZmVlLlwiXG5cdFx0XHQpXG5cdFx0XHQuYWRkQnV0dG9uKChidCkgPT4ge1xuXHRcdFx0XHRidC5zZXRUb29sdGlwKFwiQ29weSAyMGsgc2F0cyBsaWdodG5pbmcgaW52b2ljZVwiKVxuXHRcdFx0XHRcdC5zZXRJY29uKFwiemFwXCIpXG5cdFx0XHRcdFx0LnNldEN0YSgpXG5cdFx0XHRcdFx0Lm9uQ2xpY2soKCkgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKHByaXZhdGVLZXlGaWVsZCkge1xuXHRcdFx0XHRcdFx0XHRuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dChcblx0XHRcdFx0XHRcdFx0XHRcImxuYmMyMDB1MXBqdnUwM2RwcDV4MjBwMHE1dGR3eWxnNWhzcXczYXY2cXh1ZmFoMHk2NGVmbGRhem1nYWQycnNmZmdkYThxZHBkZmVoaHhhcmp5cHRoeTZ0NXY0ZXpxbm16d2Q1a2c2dHBkY3M5cW1yNHZhNWt1Y3F6enN4cXl6NXZxc3A1dzU1cDR0emF3eWZ6NWZhc2ZsbXN2ZGZubmFwcGQ2aHFudzlwN3kycDBubDk3NGYwbXRrcTlxeXlzc3FxNmd2cG52dnVmdHFzZHF5eHpuOXdycmUzcWZrcGVmeno2a3F3c3NhM3B6OGw5bXpjenlxNHU3cWRjMDlqcGF0dzlla2xuOWdoNDd2eHJ2eDZ6ZzZ2bHNxdzdwcTRhN2t2ajRrdTRxcGRyZmx3alwiXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoXCJMaWdodG5pbmcgSW52b2ljZSBBZGRyZXNzIENvcGllZCFcdTI2QTFcdUZFMEZcIik7XG5cdFx0XHRcdFx0XHRcdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoXCJUaGFuayBZb3UgXHVEODNFXHVERDFEXCIpO1xuXHRcdFx0XHRcdFx0XHR9LCA1MDApO1xuXHRcdFx0XHRcdFx0XHRzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdFx0XHRcdFx0XHRuZXcgTm90aWNlKFwiU3RheSBIdW1ibGUgXHUyNjk2XHVGRTBGXCIpO1xuXHRcdFx0XHRcdFx0XHR9LCAxMDAwKTtcblx0XHRcdFx0XHRcdFx0c2V0VGltZW91dCgoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0bmV3IE5vdGljZShcIlN0YWNrIFNhdHMgXHUyNkExXHVGRTBGXCIpO1xuXHRcdFx0XHRcdFx0XHR9LCAxNTAwKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdH0pXG5cdFx0XHQuYWRkQnV0dG9uKChidXR0b24pID0+IHtcblx0XHRcdFx0YnV0dG9uXG5cdFx0XHRcdFx0LnNldFRvb2x0aXAoXCJTcG9uc29yIG9uIEdpdEh1YlwiKVxuXHRcdFx0XHRcdC5zZXRJY29uKFwiZ2l0aHViXCIpXG5cdFx0XHRcdFx0Lm9uQ2xpY2soKCkgPT5cblx0XHRcdFx0XHRcdHdpbmRvdy5vcGVuKFxuXHRcdFx0XHRcdFx0XHRcImh0dHBzOi8vZ2l0aHViLmNvbS9zcG9uc29ycy9qYW1lc21hZ29vXCIsXG5cdFx0XHRcdFx0XHRcdFwiX2JsYW5rXCJcblx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRidXR0b24uYnV0dG9uRWwuc3R5bGUuaGVpZ2h0ID0gXCIzNXB4XCI7XG5cdFx0XHR9KVxuXHRcdFx0LmFkZEJ1dHRvbigoYnQpID0+IHtcblx0XHRcdFx0Y29uc3QgYW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG5cdFx0XHRcdGFuY2hvci5ocmVmID0gXCJodHRwczovL3d3dy5idXltZWFjb2ZmZWUuY29tL2phbWVzbWFnb29cIjtcblx0XHRcdFx0YW5jaG9yLnRhcmdldCA9IFwiX2JsYW5rXCI7XG5cblx0XHRcdFx0Y29uc3QgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcblx0XHRcdFx0aW1nLnN0eWxlLmhlaWdodCA9IFwiMzVweFwiO1xuXHRcdFx0XHRpbWcuc3JjID1cblx0XHRcdFx0XHRcImh0dHBzOi8vY2RuLmJ1eW1lYWNvZmZlZS5jb20vYnV0dG9ucy92Mi9kZWZhdWx0LXllbGxvdy5wbmdcIjtcblx0XHRcdFx0aW1nLmFsdCA9IFwiQnV5IE1lIEEgQ29mZmVlXCI7XG5cdFx0XHRcdGFuY2hvci5hcHBlbmRDaGlsZChpbWcpO1xuXHRcdFx0XHRidC5idXR0b25FbC5yZXBsYWNlV2l0aChhbmNob3IpO1xuXHRcdFx0fSk7XG5cdH1cblxuXHRpc1ZhbGlkVXJsKHVybDogc3RyaW5nKSB7XG5cdFx0dHJ5IHtcblx0XHRcdG5ldyBVUkwodXJsKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmxvZyhlcnJvcik7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0aXNWYWxpZE5pY2tuYW1lKG5pY2tuYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcblx0XHRsZXQgaXNWYWxpZDogYm9vbGVhbiA9IHRydWU7XG5cdFx0Ly8gZ2V0IHRoZSBhcnJheSBvZiBwcm9maWxlc1xuXHRcdGxldCBwcm9maWxlc1RvQ2hlY2sgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcm9maWxlcztcblx0XHRpZiAocHJvZmlsZXNUb0NoZWNrICYmIHByb2ZpbGVzVG9DaGVjay5sZW5ndGggPiAwKSB7XG5cdFx0XHRmb3IgKGNvbnN0IHByb2ZpbGUgb2YgcHJvZmlsZXNUb0NoZWNrKSB7XG5cdFx0XHRcdGlmIChwcm9maWxlLnByb2ZpbGVOaWNrbmFtZSA9PSBuaWNrbmFtZSkge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiZm91bmQgYSBtYXRjaFwiKTtcblx0XHRcdFx0XHRpc1ZhbGlkID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGlzVmFsaWQ7XG5cdH1cbn1cblxuZnVuY3Rpb24gaXNWYWxpZFByaXZhdGVLZXkoa2V5OiBzdHJpbmcpOiBib29sZWFuIHtcblx0cmV0dXJuIChcblx0XHR0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICYmIGtleS5sZW5ndGggPT09IDYzICYmIGtleS5zdGFydHNXaXRoKFwibnNlY1wiKVxuXHQpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBjbGVhckxvY2FsUHVibGlzaGVkRmlsZSgpIHtcblx0Y29uc3QgcGF0aFRvUGx1Z2luID0gdGhpcy5hcHAudmF1bHQuY29uZmlnRGlyICsgXCIvcGx1Z2lucy9ub3N0ci13cml0ZXJcIjtcblx0Y29uc3QgcHVibGlzaGVkRmlsZVBhdGggPSBgJHtwYXRoVG9QbHVnaW59L3B1Ymxpc2hlZC5qc29uYDtcblx0dHJ5IHtcblx0XHRhd2FpdCB0aGlzLmFwcC52YXVsdC5hZGFwdGVyLnJlbW92ZShwdWJsaXNoZWRGaWxlUGF0aCk7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Y29uc29sZS5sb2coZXJyb3IpO1xuXHR9XG59XG4iLCAiaW1wb3J0IE5vc3RyV3JpdGVyUGx1Z2luIGZyb20gXCJtYWluXCI7XG5pbXBvcnQgeyBCdXR0b25Db21wb25lbnQsIEl0ZW1WaWV3LCBOb3RpY2UsIFRGaWxlLCBXb3Jrc3BhY2VMZWFmIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgeyBuaXAxOSB9IGZyb20gXCJub3N0ci10b29sc1wiO1xuXG5leHBvcnQgY29uc3QgUFVCTElTSEVEX1ZJRVcgPSBcInB1Ymxpc2hlZC12aWV3XCI7XG5cbmV4cG9ydCBjbGFzcyBQdWJsaXNoZWRWaWV3IGV4dGVuZHMgSXRlbVZpZXcge1xuXHRwbHVnaW46IE5vc3RyV3JpdGVyUGx1Z2luO1xuXHRwcml2YXRlIHJlZnJlc2hEaXNwbGF5OiAoKSA9PiB2b2lkO1xuXG5cblx0Y29uc3RydWN0b3IobGVhZjogV29ya3NwYWNlTGVhZiwgcGx1Z2luOiBOb3N0cldyaXRlclBsdWdpbikge1xuXHRcdHN1cGVyKGxlYWYpO1xuXHRcdHRoaXMucGx1Z2luID0gcGx1Z2luO1xuXHRcdHRoaXMucmVmcmVzaERpc3BsYXkgPSAoKSA9PiB0aGlzLm9uT3BlbigpXG5cdH1cblxuXHRnZXRWaWV3VHlwZSgpIHtcblx0XHRyZXR1cm4gUFVCTElTSEVEX1ZJRVc7XG5cdH1cblxuXHRnZXREaXNwbGF5VGV4dCgpIHtcblx0XHRyZXR1cm4gXCJQdWJsaXNoZWQgVG8gTm9zdHJcIjtcblx0fVxuXG5cdGdldEljb24oKSB7XG5cdFx0cmV0dXJuIFwic2Nyb2xsXCI7XG5cdH1cblxuXHRhc3luYyBvbk9wZW4oKSB7XG5cdFx0Y29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXJFbC5jaGlsZHJlblsxXTtcblx0XHRjb250YWluZXIuZW1wdHkoKTtcblx0XHRsZXQgYmFubmVyID0gY29udGFpbmVyLmNyZWF0ZUVsKFwiZGl2XCIsIHtcblx0XHRcdGNsczogXCJwdWJsaXNoZWQtYmFubmVyLWRpdlwiLFxuXHRcdH0pO1xuXHRcdGJhbm5lci5jcmVhdGVFbChcImg0XCIsIHsgdGV4dDogXCJQdWJsaXNoZWRcIiB9KTtcblx0XHRuZXcgQnV0dG9uQ29tcG9uZW50KGJhbm5lcilcblx0XHRcdC5zZXRJY29uKFwicmVmcmVzaC1jd1wiKVxuXHRcdFx0LnNldEN0YSgpXG5cdFx0XHQuc2V0VG9vbHRpcChcIlJlZnJlc2ggdmlld1wiKVxuXHRcdFx0Lm9uQ2xpY2soKCkgPT4ge1xuXHRcdFx0XHR0aGlzLnJlZnJlc2hEaXNwbGF5KClcblx0XHRcdFx0bmV3IE5vdGljZShcIlZpZXcgcmVmcmVzaGVkXCIpXG5cdFx0XHR9KTtcblxuXHRcdGNvbnN0IHB1Ymxpc2hlZEZpbGVQYXRoID0gYCR7dGhpcy5wbHVnaW4ubWFuaWZlc3QuZGlyfS9wdWJsaXNoZWQuanNvbmA7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IGZpbGUgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5hZGFwdGVyLnJlYWQocHVibGlzaGVkRmlsZVBhdGgpO1xuXHRcdFx0Y29uc3QgcHVibGlzaGVkTm90ZXMgPSBKU09OLnBhcnNlKGZpbGUpO1xuXG5cdFx0XHRpZiAocHVibGlzaGVkTm90ZXMpIHtcblx0XHRcdFx0Y29udGFpbmVyLmNyZWF0ZUVsKFwicFwiLCB7IHRleHQ6IGBUb3RhbDogJHtwdWJsaXNoZWROb3Rlcy5sZW5ndGh9IFx1MjcwNWAgfSlcblx0XHRcdFx0cHVibGlzaGVkTm90ZXNcblx0XHRcdFx0XHQucmV2ZXJzZSgpXG5cdFx0XHRcdFx0LmZvckVhY2goKG5vdGU6IHsgdGFnczogYW55W107IGNyZWF0ZWRfYXQ6IG51bWJlciwgaWQ6IHN0cmluZywgZmlsZXBhdGg6IHN0cmluZywgcHJvZmlsZU5pY2tuYW1lOiBzdHJpbmcsIHB1YmtleTogc3RyaW5nLCBwdWJsaXNoZWRUb1JlbGF5czogc3RyaW5nW10sIGtpbmQ6IG51bWJlciB9KSA9PiB7XG5cdFx0XHRcdFx0XHRjb25zdCB0aXRsZVRhZyA9IG5vdGUudGFncy5maW5kKFxuXHRcdFx0XHRcdFx0XHQodGFnOiBhbnlbXSkgPT4gdGFnWzBdID09PSBcInRpdGxlXCJcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRjb25zdCBwdWJsaXNoZWRBdFRhZyA9IG5vdGUudGFncy5maW5kKFxuXHRcdFx0XHRcdFx0XHQodGFnOiBhbnlbXSkgPT4gdGFnWzBdID09PSBcInB1Ymxpc2hlZF9hdFwiXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRjb25zdCB0aXRsZSA9IHRpdGxlVGFnID8gdGl0bGVUYWdbMV0gOiBcIk5vIFRpdGxlXCI7XG5cdFx0XHRcdFx0XHQvLyBjb25zdCBzdW1tYXJ5ID0gc3VtbWFyeVRhZyA/IHN1bW1hcnlUYWdbMV0gOiBcIk5vIFN1bW1hcnlcIjtcblx0XHRcdFx0XHRcdGNvbnN0IHB1Ymxpc2hlZERhdGUgPSBwdWJsaXNoZWRBdFRhZyA/IG5ldyBEYXRlKE51bWJlcihwdWJsaXNoZWRBdFRhZ1sxXSkgKiAxMDAwKS50b0xvY2FsZVN0cmluZygnZW4tVVMnLCB7XG5cdFx0XHRcdFx0XHRcdHllYXI6ICdudW1lcmljJyxcblx0XHRcdFx0XHRcdFx0bW9udGg6ICdsb25nJyxcblx0XHRcdFx0XHRcdFx0ZGF5OiAnbnVtZXJpYycsXG5cdFx0XHRcdFx0XHRcdHdlZWtkYXk6ICdsb25nJyxcblx0XHRcdFx0XHRcdFx0aG91cjogJzItZGlnaXQnLFxuXHRcdFx0XHRcdFx0XHRtaW51dGU6ICcyLWRpZ2l0Jyxcblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHRcdDogXCJObyBQdWJsaXNoZWQgRGF0ZVwiO1xuXG5cdFx0XHRcdFx0XHRjb25zdCBjYXJkRGl2ID0gY29udGFpbmVyLmNyZWF0ZUVsKFwiZGl2XCIsIHtcblx0XHRcdFx0XHRcdFx0Y2xzOiBcInB1Ymxpc2hlZC1jYXJkXCIsXG5cdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0Y2FyZERpdi5jcmVhdGVFbChcInNwYW5cIiwgeyB0ZXh0OiBgXHVEODNEXHVEQ0RDICR7dGl0bGV9YCB9KTtcblxuXHRcdFx0XHRcdFx0aWYgKHRoaXMucGx1Z2luLnNldHRpbmdzLm11bHRpcGxlUHJvZmlsZXNFbmFibGVkKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChub3RlLnByb2ZpbGVOaWNrbmFtZSkge1xuXHRcdFx0XHRcdFx0XHRcdGxldCBkaXNwbGF5Tmlja25hbWUgPSBub3RlLnByb2ZpbGVOaWNrbmFtZVxuXHRcdFx0XHRcdFx0XHRcdGlmIChub3RlLnByb2ZpbGVOaWNrbmFtZSA9PSBcImRlZmF1bHRcIikge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGlzcGxheU5pY2tuYW1lID0gXCJEZWZhdWx0IFByb2ZpbGVcIlxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdGNhcmREaXYuY3JlYXRlRWwoXCJkaXZcIiwge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGV4dDogYFx1RDgzRFx1REM2NCAtICR7ZGlzcGxheU5pY2tuYW1lfWAsXG5cdFx0XHRcdFx0XHRcdFx0XHRjbHM6IFwicHVibGlzaGVkLXByb2ZpbGVcIixcblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRsZXQgZGV0YWlsc0RpdiA9IGNhcmREaXYuY3JlYXRlRWwoXCJkaXZcIiwge1xuXHRcdFx0XHRcdFx0XHRjbHM6IFwicHVibGlzaGVkLWRldGFpbHMtZGl2XCIsXG5cdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0ZGV0YWlsc0Rpdi5jcmVhdGVFbChcInBcIiwge1xuXHRcdFx0XHRcdFx0XHR0ZXh0OiBgJHtwdWJsaXNoZWREYXRlfS5gLFxuXHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRcdGxldCBub3RlRGl2ID0gY2FyZERpdi5jcmVhdGVFbChcImRpdlwiLCB7XG5cdFx0XHRcdFx0XHRcdGNsczogXCJwdWJsaXNoZWQtaWRcIixcblx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0XHRsZXQgdGFyZ2V0OiBuaXAxOS5FdmVudFBvaW50ZXIgPSB7XG5cdFx0XHRcdFx0XHRcdGlkOiBub3RlLmlkLFxuXHRcdFx0XHRcdFx0XHRhdXRob3I6IG5vdGUucHVia2V5LFxuXHRcdFx0XHRcdFx0XHRyZWxheXM6IG5vdGUucHVibGlzaGVkVG9SZWxheXNcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0bGV0IG5ldmVudCA9IG5pcDE5Lm5ldmVudEVuY29kZSh0YXJnZXQpXG5cblx0XHRcdFx0XHRcdG5ldyBCdXR0b25Db21wb25lbnQoZGV0YWlsc0Rpdilcblx0XHRcdFx0XHRcdFx0LnNldEljb24oXCJwb3B1cC1vcGVuXCIpXG5cdFx0XHRcdFx0XHRcdC5zZXRDdGEoKVxuXHRcdFx0XHRcdFx0XHQuc2V0VG9vbHRpcChcIlZpZXcgT25saW5lXCIpXG5cdFx0XHRcdFx0XHRcdC5vbkNsaWNrKCgpID0+IHtcblx0XHRcdFx0XHRcdFx0XHRjb25zdCB1cmwgPSBgaHR0cHM6Ly9uanVtcC5tZS8ke25ldmVudH1gO1xuXHRcdFx0XHRcdFx0XHRcdHdpbmRvdy5vcGVuKHVybCwgJ19ibGFuaycpO1xuXHRcdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0bmV3IEJ1dHRvbkNvbXBvbmVudChkZXRhaWxzRGl2KVxuXHRcdFx0XHRcdFx0XHQuc2V0SWNvbihcImdvLXRvLWZpbGVcIilcblx0XHRcdFx0XHRcdFx0LnNldEN0YSgpXG5cdFx0XHRcdFx0XHRcdC5zZXRUb29sdGlwKFwiR28gdG8gZmlsZSBpbiBPYnNpZGlhblwiKVxuXHRcdFx0XHRcdFx0XHQub25DbGljaygoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKG5vdGUuZmlsZXBhdGggPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29uc3Qgb3BlbkZpbGUgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpO1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29uc29sZS5sb2cob3BlbkZpbGU/LnBhdGgpXG5cdFx0XHRcdFx0XHRcdFx0XHRuZXcgTm90aWNlKFwiRmlsZSBwYXRoIG5vdCBhdmFpbGFibGVcIilcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5mb2N1c0ZpbGUobm90ZS5maWxlcGF0aClcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc3Qgbm9Qb3N0c0RpdiA9IGNvbnRhaW5lci5jcmVhdGVFbChcImRpdlwiLCB7IGNsczogXCJwdWJsaXNoZWQtY2FyZFwiLCB9KTtcblx0XHRcdFx0bm9Qb3N0c0Rpdi5jcmVhdGVFbChcImg2XCIsIHsgdGV4dDogXCJObyBQb3N0cyBcdUQ4M0RcdURDRERcIiB9KTtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoXCJFcnJvciByZWFkaW5nIHB1Ymxpc2hlZC5qc29uOlwiLCBlcnIpO1xuXHRcdFx0Y29uc3Qgbm9Qb3N0c0RpdiA9IGNvbnRhaW5lci5jcmVhdGVFbChcImRpdlwiLCB7IGNsczogXCJuby1wb3N0c1wiLCB9KTtcblx0XHRcdG5vUG9zdHNEaXYuY3JlYXRlRWwoXCJoNlwiLCB7IHRleHQ6IFwiTm8gUG9zdHMgXHVEODNEXHVEQ0REXCIgfSk7XG5cdFx0fVxuXHR9XG5cblx0Zm9jdXNGaWxlID0gKHBhdGg6IHN0cmluZywgc2hvdWxkU3BsaXQgPSBmYWxzZSk6IHZvaWQgPT4ge1xuXHRcdGNvbnN0IHRhcmdldEZpbGUgPSB0aGlzLmFwcC52YXVsdFxuXHRcdFx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChwYXRoKVxuXHRcdGlmICh0YXJnZXRGaWxlICYmIHRhcmdldEZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xuXHRcdFx0bGV0IGxlYWYgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0TGVhZigpO1xuXHRcdFx0Y29uc3QgY3JlYXRlTGVhZiA9IHNob3VsZFNwbGl0IHx8IGxlYWY/LmdldFZpZXdTdGF0ZSgpLnBpbm5lZDtcblx0XHRcdGlmIChjcmVhdGVMZWFmKSB7XG5cdFx0XHRcdGxlYWYgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0TGVhZigndGFiJyk7XG5cdFx0XHR9XG5cdFx0XHRsZWFmPy5vcGVuRmlsZSh0YXJnZXRGaWxlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bmV3IE5vdGljZSgnQ2Fubm90IGZpbmQgYSBmaWxlIHdpdGggdGhhdCBuYW1lJyk7XG5cdFx0fVxuXHR9O1xuXG59XG5cblxuIiwgImltcG9ydCBOb3N0cldyaXRlclBsdWdpbiBmcm9tIFwibWFpblwiO1xuaW1wb3J0IE5vc3RyU2VydmljZSBmcm9tIFwiLi9zZXJ2aWNlL05vc3RyU2VydmljZVwiO1xuaW1wb3J0IHsgQnV0dG9uQ29tcG9uZW50LCBJdGVtVmlldywgTm90aWNlLCBURmlsZSwgV29ya3NwYWNlTGVhZiB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgbmlwMTkgfSBmcm9tIFwibm9zdHItdG9vbHNcIjtcbmltcG9ydCB7IHBhcnNlUmVmZXJlbmNlcyB9IGZyb20gJ25vc3RyLXRvb2xzL3JlZmVyZW5jZXMnXG5cbmV4cG9ydCBjb25zdCBSRUFERVJfVklFVyA9IFwicmVhZGVyLXZpZXdcIjtcblxuZXhwb3J0IGNsYXNzIFJlYWRlclZpZXcgZXh0ZW5kcyBJdGVtVmlldyB7XG5cdHBsdWdpbjogTm9zdHJXcml0ZXJQbHVnaW47XG5cdG5vc3RyU2VydmljZTogTm9zdHJTZXJ2aWNlO1xuXHRyZWZyZXNoRGlzcGxheTogKCkgPT4gdm9pZDtcblxuXG5cdGNvbnN0cnVjdG9yKGxlYWY6IFdvcmtzcGFjZUxlYWYsIHBsdWdpbjogTm9zdHJXcml0ZXJQbHVnaW4sIG5vc3RyU2VydmljZTogTm9zdHJTZXJ2aWNlKSB7XG5cdFx0c3VwZXIobGVhZik7XG5cdFx0dGhpcy5wbHVnaW4gPSBwbHVnaW47XG5cdFx0dGhpcy5ub3N0clNlcnZpY2UgPSBub3N0clNlcnZpY2U7XG5cdFx0dGhpcy5yZWZyZXNoRGlzcGxheSA9ICgpID0+IHRoaXMub25PcGVuKClcblx0fVxuXG5cdGdldFZpZXdUeXBlKCkge1xuXHRcdHJldHVybiBSRUFERVJfVklFVztcblx0fVxuXG5cdGdldERpc3BsYXlUZXh0KCkge1xuXHRcdHJldHVybiBcIllvdXIgTm9zdHIgQm9va21hcmtzXCI7XG5cdH1cblxuXHRnZXRJY29uKCkge1xuXHRcdHJldHVybiBcInN0YXItbGlzdFwiO1xuXHR9XG5cblx0YXN5bmMgb25PcGVuKCkge1xuXHRcdGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyRWwuY2hpbGRyZW5bMV07XG5cdFx0Y29udGFpbmVyLmVtcHR5KCk7XG5cdFx0bGV0IGJhbm5lciA9IGNvbnRhaW5lci5jcmVhdGVFbChcImRpdlwiLCB7XG5cdFx0XHRjbHM6IFwicHVibGlzaGVkLWJhbm5lci1kaXZcIixcblx0XHR9KTtcblx0XHRiYW5uZXIuY3JlYXRlRWwoXCJoNFwiLCB7IHRleHQ6IFwiQm9va21hcmtzXCIgfSk7XG5cdFx0bmV3IEJ1dHRvbkNvbXBvbmVudChiYW5uZXIpXG5cdFx0XHQuc2V0SWNvbihcInJlZnJlc2gtY3dcIilcblx0XHRcdC5zZXRDdGEoKVxuXHRcdFx0LnNldFRvb2x0aXAoXCJSZWZyZXNoIGJvb2ttYXJrc1wiKVxuXHRcdFx0Lm9uQ2xpY2soKCkgPT4ge1xuXHRcdFx0XHR0aGlzLnJlZnJlc2hEaXNwbGF5KClcblx0XHRcdFx0bmV3IE5vdGljZShcIlZpZXcgcmVmcmVzaGVkXCIpXG5cdFx0XHR9KTtcblxuXHRcdHRyeSB7XG5cdFx0XHRsZXQgYm9va21hcmtzID0gYXdhaXQgdGhpcy5ub3N0clNlcnZpY2UubG9hZFVzZXJCb29rbWFya3MoKTtcblx0XHRcdGlmICh0aGlzLm5vc3RyU2VydmljZS5jb25uZWN0ZWRSZWxheXMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdG5ldyBOb3RpY2UoXCJSZS1jb25uZWN0IHRvIHJlbGF5cy4uLlwiKVxuXHRcdFx0fVxuXHRcdFx0aWYgKGJvb2ttYXJrcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdGNvbnRhaW5lci5jcmVhdGVFbChcInBcIiwgeyB0ZXh0OiBgVG90YWw6ICR7Ym9va21hcmtzLmxlbmd0aH0gXHUyNzA1YCB9KTtcblxuXHRcdFx0XHRib29rbWFya3MucmV2ZXJzZSgpLmZvckVhY2goYXN5bmMgKGJvb2ttYXJrKSA9PiB7XG5cdFx0XHRcdFx0bGV0IGJvb2ttYXJrUHJvZmlsZSA9IGF3YWl0IHRoaXMubm9zdHJTZXJ2aWNlLmdldFVzZXJQcm9maWxlKGJvb2ttYXJrLnB1YmtleSk7XG5cdFx0XHRcdFx0bGV0IHByb2ZpbGVOYW1lID0gXCJcIjtcblx0XHRcdFx0XHRsZXQgcHJvZmlsZVBpY1VSTCA9IFwiXCI7XG5cblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0Y29uc3QgcHJvZmlsZU9iamVjdCA9IEpTT04ucGFyc2UoYm9va21hcmtQcm9maWxlWzBdLmNvbnRlbnQpO1xuXHRcdFx0XHRcdFx0Y29uc3QgeyBuYW1lLCBwaWN0dXJlIH0gPSBwcm9maWxlT2JqZWN0O1xuXHRcdFx0XHRcdFx0cHJvZmlsZU5hbWUgPSBuYW1lO1xuXG5cdFx0XHRcdFx0XHRpZiAocGljdHVyZSA9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0Zm9yIChjb25zdCB0YWcgb2YgYm9va21hcmtQcm9maWxlLnRhZ3MpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAodGFnWzBdID09PSBcImltYWdlXCIpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnN0IHBpY3R1cmVVcmwgPSB0YWdbMV07XG5cdFx0XHRcdFx0XHRcdFx0XHRwcm9maWxlUGljVVJMID0gcGljdHVyZVVybDtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cHJvZmlsZVBpY1VSTCA9IHBpY3R1cmU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKFwiUHJvYmxlbSBQYXJzaW5nIFByb2ZpbGUuLi5zZXR0aW5nIGRlZmF1bHRzLi4uXCIsIGVycilcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjb25zdCBjYXJkRGl2ID0gY29udGFpbmVyLmNyZWF0ZUVsKFwiZGl2XCIsIHtcblx0XHRcdFx0XHRcdGNsczogXCJib29rbWFyay1jYXJkXCIsXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0aWYgKGJvb2ttYXJrLmtpbmQgPT09IDMwMDIzKSB7XG5cdFx0XHRcdFx0XHRjb25zdCB0aXRsZVRhZyA9IGJvb2ttYXJrLnRhZ3MuZmluZCgodGFnOiBhbnlbXSkgPT4gdGFnWzBdID09PSBcInRpdGxlXCIpO1xuXHRcdFx0XHRcdFx0aWYgKHRpdGxlVGFnKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IHRpdGxlID0gdGl0bGVUYWdbMV07XG5cdFx0XHRcdFx0XHRcdGNhcmREaXYuY3JlYXRlRWwoXCJoM1wiLCB7IHRleHQ6IHRpdGxlIH0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNvbnN0IGNvbnRlbnREaXYgPSBjYXJkRGl2LmNyZWF0ZURpdih7XG5cdFx0XHRcdFx0XHRjbHM6IFwiYm9va21hcmstY29udGVudFwiLFxuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0Ly8gcGFyc2Ugbm9zdHIgdGFncywgbnB1YnMgd3RjLlxuXHRcdFx0XHRcdGxldCByZWZlcmVuY2VzID0gcGFyc2VSZWZlcmVuY2VzKGJvb2ttYXJrKVxuXHRcdFx0XHRcdGxldCBsaW5rZWRFdmVudCA9IGZhbHNlO1xuXHRcdFx0XHRcdGxldCBsaW5rZWRFdmVudFVSTCA9IFwiXCI7XG5cdFx0XHRcdFx0bGV0IHNpbXBsZUF1Z21lbnRlZENvbnRlbnQgPSBib29rbWFyay5jb250ZW50O1xuXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCByZWZlcmVuY2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRsZXQgeyB0ZXh0LCBwcm9maWxlLCBldmVudCwgYWRkcmVzcyB9ID0gcmVmZXJlbmNlc1tpXTtcblxuXHRcdFx0XHRcdFx0bGV0IGF1Z21lbnRlZFJlZmVyZW5jZTtcblx0XHRcdFx0XHRcdGlmIChwcm9maWxlKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IHRhZ2dlZFByb2ZpbGUgPSBhd2FpdCB0aGlzLm5vc3RyU2VydmljZS5nZXRVc2VyUHJvZmlsZShwcm9maWxlLnB1YmtleSk7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IHsgbmFtZSB9ID0gSlNPTi5wYXJzZSh0YWdnZWRQcm9maWxlWzBdLmNvbnRlbnQpO1xuXHRcdFx0XHRcdFx0XHRhdWdtZW50ZWRSZWZlcmVuY2UgPSBgPHN0cm9uZz5AJHtuYW1lfTwvc3Ryb25nPmA7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGV2ZW50KSB7XG5cdFx0XHRcdFx0XHRcdGxldCBsaW5rZWRFdmVudFBvaW50ZXI6IG5pcDE5LkV2ZW50UG9pbnRlciA9IHtcblx0XHRcdFx0XHRcdFx0XHRpZDogZXZlbnQuaWQsXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0bGV0IHggPSBuaXAxOS5uZXZlbnRFbmNvZGUobGlua2VkRXZlbnRQb2ludGVyKTtcblx0XHRcdFx0XHRcdFx0Ly9hdWdtZW50ZWRSZWZlcmVuY2UgPSBgPGEgaHJlZj1cImh0dHBzOi8vbmp1bXAubWUvJHt4fVwiIHRhcmdldD1cIl9ibGFua1wiPlJlZmVyZW5jZWQgRXZlbnQ8L2E+YDtcblx0XHRcdFx0XHRcdFx0YXVnbWVudGVkUmVmZXJlbmNlID0gXCJcIjtcblx0XHRcdFx0XHRcdFx0bGlua2VkRXZlbnQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRsaW5rZWRFdmVudFVSTCA9IGBodHRwczovL25qdW1wLm1lLyR7eH1gXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGFkZHJlc3MpIHtcblx0XHRcdFx0XHRcdFx0YXVnbWVudGVkUmVmZXJlbmNlID0gYDxhIGhyZWY9XCIke3RleHR9XCI+UmVmZXJlbmNlZCBFdmVudDwvYT5gO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0YXVnbWVudGVkUmVmZXJlbmNlID0gdGV4dDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHNpbXBsZUF1Z21lbnRlZENvbnRlbnQgPSBzaW1wbGVBdWdtZW50ZWRDb250ZW50LnJlcGxhY2VBbGwodGV4dCwgYXVnbWVudGVkUmVmZXJlbmNlKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoYm9va21hcmsua2luZCA9PT0gMzAwMjMpIHtcblx0XHRcdFx0XHRcdGNvbnN0IHN1bW1hcnlUYWcgPSBib29rbWFyay50YWdzLmZpbmQoKHRhZzogYW55W10pID0+IHRhZ1swXSA9PT0gXCJzdW1tYXJ5XCIpO1xuXHRcdFx0XHRcdFx0aWYgKHN1bW1hcnlUYWcpIHtcblx0XHRcdFx0XHRcdFx0Y29uc3Qgc3VtbWFyeSA9IHN1bW1hcnlUYWdbMV07XG5cdFx0XHRcdFx0XHRcdHNpbXBsZUF1Z21lbnRlZENvbnRlbnQgPSBgPGVtPiR7c3VtbWFyeX08L2VtPmA7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGZpcnN0TGluZUluZGV4ID0gc2ltcGxlQXVnbWVudGVkQ29udGVudC5pbmRleE9mKCdcXG4nKTtcblx0XHRcdFx0XHRcdFx0aWYgKGZpcnN0TGluZUluZGV4ICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0XHRcdHNpbXBsZUF1Z21lbnRlZENvbnRlbnQgPSBzaW1wbGVBdWdtZW50ZWRDb250ZW50LnN1YnN0cmluZygwLCBmaXJzdExpbmVJbmRleCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0c2ltcGxlQXVnbWVudGVkQ29udGVudCA9IHNpbXBsZUF1Z21lbnRlZENvbnRlbnQuc3Vic3RyaW5nKDAsIDE0MCkgKyAnLi4uJ1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y29udGVudERpdi5pbm5lckhUTUwgPSBzaW1wbGVBdWdtZW50ZWRDb250ZW50LnJlcGxhY2UoL1xcYmh0dHBzPzpcXC9cXC9cXFMrL2dpLCBcIlwiKTtcblxuXHRcdFx0XHRcdGNvbnN0IGltYWdlVXJscyA9IHRoaXMuZXh0cmFjdEltYWdlVXJscyhib29rbWFyay5jb250ZW50KTtcblxuXHRcdFx0XHRcdGltYWdlVXJscy5mb3JFYWNoKChpbWFnZVVybCkgPT4ge1xuXHRcdFx0XHRcdFx0Y2FyZERpdi5jcmVhdGVFbChcImltZ1wiLCB7XG5cdFx0XHRcdFx0XHRcdGF0dHI6IHtcblx0XHRcdFx0XHRcdFx0XHRzcmM6IGltYWdlVXJsLFxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRjbHM6IFwiYm9va21hcmstaW1hZ2VcIixcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0pO1xuXG5cblx0XHRcdFx0XHRjb25zdCBpbWFnZVRhZyA9IGJvb2ttYXJrLnRhZ3MuZmluZCgodGFnOiBhbnlbXSkgPT4gdGFnWzBdID09PSBcImltYWdlXCIpO1xuXHRcdFx0XHRcdGlmIChpbWFnZVRhZykge1xuXHRcdFx0XHRcdFx0Y29uc3QgaW1hZ2VVUkwgPSBpbWFnZVRhZ1sxXTtcblx0XHRcdFx0XHRcdGNhcmREaXYuY3JlYXRlRWwoXCJpbWdcIiwge1xuXHRcdFx0XHRcdFx0XHRhdHRyOiB7XG5cdFx0XHRcdFx0XHRcdFx0c3JjOiBpbWFnZVVSTCxcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0Y2xzOiBcImJvb2ttYXJrLWltYWdlXCIsXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cblxuXHRcdFx0XHRcdGNvbnN0IHB1YmxpY0tleURpdiA9IGNhcmREaXYuY3JlYXRlRWwoXCJkaXZcIiwge1xuXHRcdFx0XHRcdFx0Y2xzOiBcImJvb2ttYXJrLXB1YmtleVwiLFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdHB1YmxpY0tleURpdi5jcmVhdGVFbChcImltZ1wiLCB7XG5cdFx0XHRcdFx0XHRhdHRyOiB7XG5cdFx0XHRcdFx0XHRcdHNyYzogYCR7cHJvZmlsZVBpY1VSTH1gLFxuXHRcdFx0XHRcdFx0XHRhbHQ6IFwiUHJvZmlsZSBQaWNcIixcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRjbHM6IFwiYm9va21hcmstcHJvZmlsZS1waWNcIixcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRjb25zdCBkaXNwbGF5TmFtZSA9IHByb2ZpbGVOYW1lID8gcHJvZmlsZU5hbWUgOiBcIlVua25vd25cIjtcblxuXHRcdFx0XHRcdHB1YmxpY0tleURpdi5jcmVhdGVFbChcInNwYW5cIiwgeyB0ZXh0OiBkaXNwbGF5TmFtZSB9KTtcblxuXHRcdFx0XHRcdGNvbnN0IGNyZWF0ZWRBdCA9IG5ldyBEYXRlKGJvb2ttYXJrLmNyZWF0ZWRfYXQgKiAxMDAwKS50b0xvY2FsZVN0cmluZygpO1xuXHRcdFx0XHRcdGNhcmREaXYuY3JlYXRlRWwoXCJkaXZcIiwge1xuXHRcdFx0XHRcdFx0dGV4dDogYEJvb2ttYXJrZWQgT246ICR7Y3JlYXRlZEF0fWAsXG5cdFx0XHRcdFx0XHRjbHM6IFwiYm9va21hcmstY3JlYXRlZC1hdFwiLFxuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0bGV0IGRldGFpbHNEaXYgPSBjYXJkRGl2LmNyZWF0ZUVsKFwiZGl2XCIsIHtcblx0XHRcdFx0XHRcdGNsczogXCJib29rbWFyay12aWV3LW9ubGluZS1idG5cIixcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdGxldCB0YXJnZXQ6IG5pcDE5LkV2ZW50UG9pbnRlciA9IHtcblx0XHRcdFx0XHRcdGlkOiBib29rbWFyay5pZCxcblx0XHRcdFx0XHRcdGF1dGhvcjogYm9va21hcmsucHVia2V5LFxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGxldCBuZXZlbnQgPSBuaXAxOS5uZXZlbnRFbmNvZGUodGFyZ2V0KVxuXG5cdFx0XHRcdFx0bmV3IEJ1dHRvbkNvbXBvbmVudChkZXRhaWxzRGl2KVxuXHRcdFx0XHRcdFx0LnNldEljb24oXCJwb3B1cC1vcGVuXCIpXG5cdFx0XHRcdFx0XHQuc2V0Q3RhKClcblx0XHRcdFx0XHRcdC5zZXRUb29sdGlwKFwiVmlldyBPbmxpbmVcIilcblx0XHRcdFx0XHRcdC5vbkNsaWNrKCgpID0+IHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgdXJsID0gYGh0dHBzOi8vbmp1bXAubWUvJHtuZXZlbnR9YDtcblx0XHRcdFx0XHRcdFx0d2luZG93Lm9wZW4odXJsLCAnX2JsYW5rJyk7XG5cdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdG5ldyBCdXR0b25Db21wb25lbnQoZGV0YWlsc0Rpdilcblx0XHRcdFx0XHRcdC5zZXRJY29uKFwiZG93bmxvYWRcIilcblx0XHRcdFx0XHRcdC5zZXRDbGFzcyhcImJvb2ttYXJrLWJ0blwiKVxuXHRcdFx0XHRcdFx0LnNldEN0YSgpXG5cdFx0XHRcdFx0XHQuc2V0VG9vbHRpcChcIkRvd25sb2FkICYgT3BlbiBpbiBPYnNpZGlhblwiKVxuXHRcdFx0XHRcdFx0Lm9uQ2xpY2soKCkgPT4ge1xuXHRcdFx0XHRcdFx0XHR0aGlzLmRvd25sb2FkQm9va21hcmsoYm9va21hcmspO1xuXHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRpZiAobGlua2VkRXZlbnQpIHtcblx0XHRcdFx0XHRcdG5ldyBCdXR0b25Db21wb25lbnQoZGV0YWlsc0Rpdilcblx0XHRcdFx0XHRcdFx0LnNldEljb24oXCJsaW5rXCIpXG5cdFx0XHRcdFx0XHRcdC5zZXRDdGEoKVxuXHRcdFx0XHRcdFx0XHQuc2V0VG9vbHRpcChcIlZpZXcgTGlua2VkIEV2ZW50XCIpXG5cdFx0XHRcdFx0XHRcdC5vbkNsaWNrKCgpID0+IHtcblx0XHRcdFx0XHRcdFx0XHR3aW5kb3cub3BlbihsaW5rZWRFdmVudFVSTCwgJ19ibGFuaycpO1xuXHRcdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zdCBub0Jvb2ttYXJrc0RpdiA9IGNvbnRhaW5lci5jcmVhdGVFbChcImRpdlwiLCB7IGNsczogXCJub2Jvb2ttYXJrcy1jYXJkXCIgfSk7XG5cdFx0XHRcdG5vQm9va21hcmtzRGl2LmNyZWF0ZUVsKFwiaDZcIiwgeyB0ZXh0OiBcIk5vIEJvb2ttYXJrcyBGb3VuZCBcdUQ4M0RcdURDREFcIiB9KTtcblx0XHRcdFx0bm9Cb29rbWFya3NEaXYuY3JlYXRlRWwoXCJwXCIsIHsgdGV4dDogXCJVc2UgbGlzdHIubG9sIHRvIGVkaXQgJiBtYW5hZ2UgeW91ciBib29rbWFya3NcIiB9KTtcblx0XHRcdFx0Y29uc3QgbGlua0VsID0gbm9Cb29rbWFya3NEaXYuY3JlYXRlRWwoXCJhXCIsIHsgdGV4dDogXCJsaXN0ci5sb2xcIiB9KTtcblx0XHRcdFx0bGlua0VsLmhyZWYgPSBcImh0dHBzOi8vbGlzdHIubG9sXCI7XG5cdFx0XHRcdGxpbmtFbC50YXJnZXQgPSBcIl9ibGFua1wiO1xuXG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKFwiRXJyb3IgcmVhZGluZyBib29rbWFya3M6XCIsIGVycik7XG5cdFx0XHRuZXcgTm90aWNlKFwiUHJvYmxlbSByZWFkaW5nIGJvb2ttYXJrcyAtIHJlLWNvbm5lY3QgJiBjaGVjayB5b3UgbGlzdC5cIilcblx0XHRcdGNvbnN0IG5vQm9va21hcmtzRGl2ID0gY29udGFpbmVyLmNyZWF0ZUVsKFwiZGl2XCIsIHsgY2xzOiBcIm5vYm9va21hcmtzLWNhcmRcIiB9KTtcblx0XHRcdG5vQm9va21hcmtzRGl2LmNyZWF0ZUVsKFwiaDZcIiwgeyB0ZXh0OiBcIk5vIEJvb2ttYXJrcyBGb3VuZCBcdUQ4M0RcdURDREFcIiB9KTtcblx0XHRcdG5vQm9va21hcmtzRGl2LmNyZWF0ZUVsKFwicFwiLCB7IHRleHQ6IFwiVXNlIGxpc3RyLmxvbCB0byBlZGl0ICYgbWFuYWdlIHlvdXIgYm9va21hcmtzXCIgfSk7XG5cdFx0XHRjb25zdCBsaW5rRWwgPSBub0Jvb2ttYXJrc0Rpdi5jcmVhdGVFbChcImFcIiwgeyB0ZXh0OiBcImxpc3RyLmxvbFwiIH0pO1xuXHRcdFx0bGlua0VsLmhyZWYgPSBcImh0dHBzOi8vbGlzdHIubG9sXCI7XG5cdFx0XHRsaW5rRWwudGFyZ2V0ID0gXCJfYmxhbmtcIjtcblx0XHR9XG5cdH1cblxuXHRvcGVuTGluayh1cmw6IHN0cmluZykge1xuXHRcdGNvbnNvbGUubG9nKHVybClcblx0XHR3aW5kb3cub3Blbih1cmwsICdfYmxhbmsnKTtcblx0fVxuXG5cblx0YXN5bmMgZG93bmxvYWRCb29rbWFyayhib29rbWFyazogYW55KSB7XG5cdFx0dHJ5IHtcblx0XHRcdGxldCBmaWxlbmFtZTogc3RyaW5nO1xuXHRcdFx0Y29uc3QgdGl0bGVUYWcgPSBib29rbWFyay50YWdzLmZpbmQoKHRhZzogYW55W10pID0+IHRhZ1swXSA9PT0gXCJ0aXRsZVwiKTtcblx0XHRcdGlmICh0aXRsZVRhZykge1xuXHRcdFx0XHRmaWxlbmFtZSA9IGAke3RpdGxlVGFnWzFdfS5tZGA7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmaWxlbmFtZSA9IGBib29rbWFya18ke2Jvb2ttYXJrLmlkLnN1YnN0cmluZygwLCA4KX0ubWRgO1xuXHRcdFx0fVxuXHRcdFx0Y29uc3QgY29udGVudCA9IHRoaXMuZ2VuZXJhdGVNYXJrZG93bkNvbnRlbnQoYm9va21hcmspOyBcblxuXHRcdFx0Y29uc3QgZmlsZTogVEZpbGUgfCBudWxsID0gYXdhaXQgdGhpcy5jcmVhdGVNYXJrZG93bkZpbGUoZmlsZW5hbWUsIGNvbnRlbnQpO1xuXG5cdFx0XHRpZiAoZmlsZSAhPT0gbnVsbCkge1xuXHRcdFx0XHRhd2FpdCB0aGlzLmFwcC53b3Jrc3BhY2Uub3BlbkxpbmtUZXh0KGZpbGVuYW1lLCBmaWxlLnBhdGgsIHRydWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bmV3IE5vdGljZShcIkZhaWxlZCB0byBjcmVhdGUgZmlsZS4gRmlsZSBtYXkgYWxyZWFkeSBleGlzdC5cIik7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoXCJFcnJvciBkb3dubG9hZGluZyBib29rbWFyazpcIiwgZXJyb3IpO1xuXHRcdFx0bmV3IE5vdGljZShcIkZhaWxlZCB0byBjcmVhdGUgZmlsZS4gRmlsZSBtYXkgYWxyZWFkeSBleGlzdC5cIik7XG5cdFx0fVxuXHR9XG5cblxuXHRhc3luYyBjcmVhdGVNYXJrZG93bkZpbGUoZmlsZW5hbWU6IHN0cmluZywgY29udGVudDogc3RyaW5nKTogUHJvbWlzZTxURmlsZSB8IG51bGw+IHtcblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgZmlsZSA9IHRoaXMuYXBwLnZhdWx0LmNyZWF0ZShmaWxlbmFtZSwgY29udGVudCk7XG5cdFx0XHRyZXR1cm4gZmlsZTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoXCJGaWxlIGFscmVhZHkgZXhpc3RzXCIpKSB7XG5cdFx0XHRcdG5ldyBOb3RpY2UoXCJGaWxlIGFscmVhZHkgZXhpc3RzXCIpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcihcIkVycm9yIGNyZWF0aW5nIGZpbGU6XCIsIGVycm9yKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0fVxuXG5cblxuXHRnZW5lcmF0ZU1hcmtkb3duQ29udGVudChib29rbWFyazogYW55KTogc3RyaW5nIHtcblx0XHRjb25zdCBjcmVhdGVkQXQgPSBuZXcgRGF0ZShib29rbWFyay5jcmVhdGVkX2F0ICogMTAwMCkudG9Mb2NhbGVTdHJpbmcoKTtcblxuXHRcdGxldCBzb3VyY2UgOiBuaXAxOS5Qcm9maWxlUG9pbnRlciA9IHtcblx0XHRcdHB1YmtleTogYm9va21hcmsucHVia2V5LCBcblx0XHR9XG5cdFx0bGV0IHkgPSBuaXAxOS5ucHJvZmlsZUVuY29kZShzb3VyY2UpO1xuXHRcdGNvbnN0IHVybCA9IGBodHRwczovL25qdW1wLm1lLyR7eX1gO1xuXHRcdGNvbnN0IG1hcmtkb3duQ29udGVudCA9IGBcbiMgTm9zdHIgQm9va21hcmtcblxuKipDb250ZW50OioqIFxuXFxuIFxuJHtib29rbWFyay5jb250ZW50fVxuXFxuXG4qKipcbioqQ3JlYXRlZCBBdDoqKiAke2NyZWF0ZWRBdH1cbioqU291cmNlOioqICR7dXJsfVxuXHRcdGA7XG5cblx0XHRyZXR1cm4gbWFya2Rvd25Db250ZW50O1xuXHR9XG5cblxuXHRleHRyYWN0SW1hZ2VVcmxzKGNvbnRlbnQ6IHN0cmluZyk6IHN0cmluZ1tdIHtcblx0XHRjb25zdCB1cmxSZWdleCA9IC8oaHR0cHM/OlxcL1xcL1teXFxzXStcXC4oPzpqcGd8anBlZ3xwbmd8Z2lmKSkvZ2k7XG5cdFx0Y29uc3QgdXJsczogc3RyaW5nW10gPSBbXTtcblx0XHRsZXQgbWF0Y2g7XG5cdFx0d2hpbGUgKChtYXRjaCA9IHVybFJlZ2V4LmV4ZWMoY29udGVudCkpICE9PSBudWxsKSB7XG5cdFx0XHR1cmxzLnB1c2gobWF0Y2hbMF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gdXJscztcblx0fVxuXG5cblxuXHRmb2N1c0ZpbGUgPSAocGF0aDogc3RyaW5nLCBzaG91bGRTcGxpdCA9IGZhbHNlKTogdm9pZCA9PiB7XG5cdFx0Y29uc3QgdGFyZ2V0RmlsZSA9IHRoaXMuYXBwLnZhdWx0XG5cdFx0XHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHBhdGgpXG5cdFx0aWYgKHRhcmdldEZpbGUgJiYgdGFyZ2V0RmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XG5cdFx0XHRsZXQgbGVhZiA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRMZWFmKCk7XG5cdFx0XHRjb25zdCBjcmVhdGVMZWFmID0gc2hvdWxkU3BsaXQgfHwgbGVhZj8uZ2V0Vmlld1N0YXRlKCkucGlubmVkO1xuXHRcdFx0aWYgKGNyZWF0ZUxlYWYpIHtcblx0XHRcdFx0bGVhZiA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRMZWFmKCd0YWInKTtcblx0XHRcdH1cblx0XHRcdGxlYWY/Lm9wZW5GaWxlKHRhcmdldEZpbGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRuZXcgTm90aWNlKCdDYW5ub3QgZmluZCBhIGZpbGUgd2l0aCB0aGF0IG5hbWUnKTtcblx0XHR9XG5cdH07XG5cbn1cblxuXG4iLCAiLy8gbmlwMTkudHNcbmltcG9ydCB7IGJ5dGVzVG9IZXgsIGNvbmNhdEJ5dGVzLCBoZXhUb0J5dGVzIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvdXRpbHNcIjtcbmltcG9ydCB7IGJlY2gzMiB9IGZyb20gXCJAc2N1cmUvYmFzZVwiO1xuXG4vLyB1dGlscy50c1xudmFyIHV0ZjhEZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKFwidXRmLThcIik7XG52YXIgdXRmOEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcblxuLy8gbmlwMTkudHNcbnZhciBCZWNoMzJNYXhTaXplID0gNWUzO1xuZnVuY3Rpb24gZGVjb2RlKG5pcDE5KSB7XG4gIGxldCB7IHByZWZpeCwgd29yZHMgfSA9IGJlY2gzMi5kZWNvZGUobmlwMTksIEJlY2gzMk1heFNpemUpO1xuICBsZXQgZGF0YSA9IG5ldyBVaW50OEFycmF5KGJlY2gzMi5mcm9tV29yZHMod29yZHMpKTtcbiAgc3dpdGNoIChwcmVmaXgpIHtcbiAgICBjYXNlIFwibnByb2ZpbGVcIjoge1xuICAgICAgbGV0IHRsdiA9IHBhcnNlVExWKGRhdGEpO1xuICAgICAgaWYgKCF0bHZbMF0/LlswXSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBUTFYgMCBmb3IgbnByb2ZpbGVcIik7XG4gICAgICBpZiAodGx2WzBdWzBdLmxlbmd0aCAhPT0gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRMViAwIHNob3VsZCBiZSAzMiBieXRlc1wiKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibnByb2ZpbGVcIixcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHB1YmtleTogYnl0ZXNUb0hleCh0bHZbMF1bMF0pLFxuICAgICAgICAgIHJlbGF5czogdGx2WzFdID8gdGx2WzFdLm1hcCgoZCkgPT4gdXRmOERlY29kZXIuZGVjb2RlKGQpKSA6IFtdXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJuZXZlbnRcIjoge1xuICAgICAgbGV0IHRsdiA9IHBhcnNlVExWKGRhdGEpO1xuICAgICAgaWYgKCF0bHZbMF0/LlswXSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBUTFYgMCBmb3IgbmV2ZW50XCIpO1xuICAgICAgaWYgKHRsdlswXVswXS5sZW5ndGggIT09IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUTFYgMCBzaG91bGQgYmUgMzIgYnl0ZXNcIik7XG4gICAgICBpZiAodGx2WzJdICYmIHRsdlsyXVswXS5sZW5ndGggIT09IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUTFYgMiBzaG91bGQgYmUgMzIgYnl0ZXNcIik7XG4gICAgICBpZiAodGx2WzNdICYmIHRsdlszXVswXS5sZW5ndGggIT09IDQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRMViAzIHNob3VsZCBiZSA0IGJ5dGVzXCIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJuZXZlbnRcIixcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGlkOiBieXRlc1RvSGV4KHRsdlswXVswXSksXG4gICAgICAgICAgcmVsYXlzOiB0bHZbMV0gPyB0bHZbMV0ubWFwKChkKSA9PiB1dGY4RGVjb2Rlci5kZWNvZGUoZCkpIDogW10sXG4gICAgICAgICAgYXV0aG9yOiB0bHZbMl0/LlswXSA/IGJ5dGVzVG9IZXgodGx2WzJdWzBdKSA6IHZvaWQgMCxcbiAgICAgICAgICBraW5kOiB0bHZbM10/LlswXSA/IHBhcnNlSW50KGJ5dGVzVG9IZXgodGx2WzNdWzBdKSwgMTYpIDogdm9pZCAwXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJuYWRkclwiOiB7XG4gICAgICBsZXQgdGx2ID0gcGFyc2VUTFYoZGF0YSk7XG4gICAgICBpZiAoIXRsdlswXT8uWzBdKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIFRMViAwIGZvciBuYWRkclwiKTtcbiAgICAgIGlmICghdGx2WzJdPy5bMF0pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgVExWIDIgZm9yIG5hZGRyXCIpO1xuICAgICAgaWYgKHRsdlsyXVswXS5sZW5ndGggIT09IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUTFYgMiBzaG91bGQgYmUgMzIgYnl0ZXNcIik7XG4gICAgICBpZiAoIXRsdlszXT8uWzBdKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIFRMViAzIGZvciBuYWRkclwiKTtcbiAgICAgIGlmICh0bHZbM11bMF0ubGVuZ3RoICE9PSA0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUTFYgMyBzaG91bGQgYmUgNCBieXRlc1wiKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibmFkZHJcIixcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGlkZW50aWZpZXI6IHV0ZjhEZWNvZGVyLmRlY29kZSh0bHZbMF1bMF0pLFxuICAgICAgICAgIHB1YmtleTogYnl0ZXNUb0hleCh0bHZbMl1bMF0pLFxuICAgICAgICAgIGtpbmQ6IHBhcnNlSW50KGJ5dGVzVG9IZXgodGx2WzNdWzBdKSwgMTYpLFxuICAgICAgICAgIHJlbGF5czogdGx2WzFdID8gdGx2WzFdLm1hcCgoZCkgPT4gdXRmOERlY29kZXIuZGVjb2RlKGQpKSA6IFtdXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJucmVsYXlcIjoge1xuICAgICAgbGV0IHRsdiA9IHBhcnNlVExWKGRhdGEpO1xuICAgICAgaWYgKCF0bHZbMF0/LlswXSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBUTFYgMCBmb3IgbnJlbGF5XCIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJucmVsYXlcIixcbiAgICAgICAgZGF0YTogdXRmOERlY29kZXIuZGVjb2RlKHRsdlswXVswXSlcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJuc2VjXCI6XG4gICAgICByZXR1cm4geyB0eXBlOiBwcmVmaXgsIGRhdGEgfTtcbiAgICBjYXNlIFwibnB1YlwiOlxuICAgIGNhc2UgXCJub3RlXCI6XG4gICAgICByZXR1cm4geyB0eXBlOiBwcmVmaXgsIGRhdGE6IGJ5dGVzVG9IZXgoZGF0YSkgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIHByZWZpeCAke3ByZWZpeH1gKTtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VUTFYoZGF0YSkge1xuICBsZXQgcmVzdWx0ID0ge307XG4gIGxldCByZXN0ID0gZGF0YTtcbiAgd2hpbGUgKHJlc3QubGVuZ3RoID4gMCkge1xuICAgIGxldCB0ID0gcmVzdFswXTtcbiAgICBsZXQgbCA9IHJlc3RbMV07XG4gICAgbGV0IHYgPSByZXN0LnNsaWNlKDIsIDIgKyBsKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgyICsgbCk7XG4gICAgaWYgKHYubGVuZ3RoIDwgbClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbm90IGVub3VnaCBkYXRhIHRvIHJlYWQgb24gVExWICR7dH1gKTtcbiAgICByZXN1bHRbdF0gPSByZXN1bHRbdF0gfHwgW107XG4gICAgcmVzdWx0W3RdLnB1c2godik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gcmVmZXJlbmNlcy50c1xudmFyIG1lbnRpb25SZWdleCA9IC9cXGJub3N0cjooKG5vdGV8bnB1YnxuYWRkcnxuZXZlbnR8bnByb2ZpbGUpMVxcdyspXFxifCNcXFsoXFxkKylcXF0vZztcbmZ1bmN0aW9uIHBhcnNlUmVmZXJlbmNlcyhldnQpIHtcbiAgbGV0IHJlZmVyZW5jZXMgPSBbXTtcbiAgZm9yIChsZXQgcmVmIG9mIGV2dC5jb250ZW50Lm1hdGNoQWxsKG1lbnRpb25SZWdleCkpIHtcbiAgICBpZiAocmVmWzJdKSB7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgeyB0eXBlLCBkYXRhIH0gPSBkZWNvZGUocmVmWzFdKTtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBcIm5wdWJcIjoge1xuICAgICAgICAgICAgcmVmZXJlbmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgdGV4dDogcmVmWzBdLFxuICAgICAgICAgICAgICBwcm9maWxlOiB7IHB1YmtleTogZGF0YSwgcmVsYXlzOiBbXSB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwibnByb2ZpbGVcIjoge1xuICAgICAgICAgICAgcmVmZXJlbmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgdGV4dDogcmVmWzBdLFxuICAgICAgICAgICAgICBwcm9maWxlOiBkYXRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwibm90ZVwiOiB7XG4gICAgICAgICAgICByZWZlcmVuY2VzLnB1c2goe1xuICAgICAgICAgICAgICB0ZXh0OiByZWZbMF0sXG4gICAgICAgICAgICAgIGV2ZW50OiB7IGlkOiBkYXRhLCByZWxheXM6IFtdIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJuZXZlbnRcIjoge1xuICAgICAgICAgICAgcmVmZXJlbmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgdGV4dDogcmVmWzBdLFxuICAgICAgICAgICAgICBldmVudDogZGF0YVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIm5hZGRyXCI6IHtcbiAgICAgICAgICAgIHJlZmVyZW5jZXMucHVzaCh7XG4gICAgICAgICAgICAgIHRleHQ6IHJlZlswXSxcbiAgICAgICAgICAgICAgYWRkcmVzczogZGF0YVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmVmWzNdKSB7XG4gICAgICBsZXQgaWR4ID0gcGFyc2VJbnQocmVmWzNdLCAxMCk7XG4gICAgICBsZXQgdGFnID0gZXZ0LnRhZ3NbaWR4XTtcbiAgICAgIGlmICghdGFnKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHN3aXRjaCAodGFnWzBdKSB7XG4gICAgICAgIGNhc2UgXCJwXCI6IHtcbiAgICAgICAgICByZWZlcmVuY2VzLnB1c2goe1xuICAgICAgICAgICAgdGV4dDogcmVmWzBdLFxuICAgICAgICAgICAgcHJvZmlsZTogeyBwdWJrZXk6IHRhZ1sxXSwgcmVsYXlzOiB0YWdbMl0gPyBbdGFnWzJdXSA6IFtdIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZVwiOiB7XG4gICAgICAgICAgcmVmZXJlbmNlcy5wdXNoKHtcbiAgICAgICAgICAgIHRleHQ6IHJlZlswXSxcbiAgICAgICAgICAgIGV2ZW50OiB7IGlkOiB0YWdbMV0sIHJlbGF5czogdGFnWzJdID8gW3RhZ1syXV0gOiBbXSB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImFcIjoge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgW2tpbmQsIHB1YmtleSwgaWRlbnRpZmllcl0gPSB0YWdbMV0uc3BsaXQoXCI6XCIpO1xuICAgICAgICAgICAgcmVmZXJlbmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgdGV4dDogcmVmWzBdLFxuICAgICAgICAgICAgICBhZGRyZXNzOiB7XG4gICAgICAgICAgICAgICAgaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICBwdWJrZXksXG4gICAgICAgICAgICAgICAga2luZDogcGFyc2VJbnQoa2luZCwgMTApLFxuICAgICAgICAgICAgICAgIHJlbGF5czogdGFnWzJdID8gW3RhZ1syXV0gOiBbXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlZmVyZW5jZXM7XG59XG5leHBvcnQge1xuICBwYXJzZVJlZmVyZW5jZXNcbn07XG4iLCAiaW1wb3J0IE5vc3RyV3JpdGVyUGx1Z2luIGZyb20gXCJtYWluXCI7XG5pbXBvcnQgTm9zdHJTZXJ2aWNlIGZyb20gXCIuL3NlcnZpY2UvTm9zdHJTZXJ2aWNlXCI7XG5pbXBvcnQgeyBCdXR0b25Db21wb25lbnQsIEl0ZW1WaWV3LCBOb3RpY2UsIFRGaWxlLCBXb3Jrc3BhY2VMZWFmIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgeyBuaXAxOSB9IGZyb20gXCJub3N0ci10b29sc1wiO1xuaW1wb3J0IHsgcGFyc2VSZWZlcmVuY2VzIH0gZnJvbSAnbm9zdHItdG9vbHMvcmVmZXJlbmNlcydcblxuZXhwb3J0IGNvbnN0IEhJR0hMSUdIVFNfVklFVyA9IFwiaGlnaGxpZ2h0cy12aWV3XCI7XG5cbmV4cG9ydCBjbGFzcyBIaWdobGlnaHRzVmlldyBleHRlbmRzIEl0ZW1WaWV3IHtcblx0cGx1Z2luOiBOb3N0cldyaXRlclBsdWdpbjtcblx0bm9zdHJTZXJ2aWNlOiBOb3N0clNlcnZpY2U7XG5cdHJlZnJlc2hEaXNwbGF5OiAoKSA9PiB2b2lkO1xuXG5cblx0Y29uc3RydWN0b3IobGVhZjogV29ya3NwYWNlTGVhZiwgcGx1Z2luOiBOb3N0cldyaXRlclBsdWdpbiwgbm9zdHJTZXJ2aWNlOiBOb3N0clNlcnZpY2UpIHtcblx0XHRzdXBlcihsZWFmKTtcblx0XHR0aGlzLnBsdWdpbiA9IHBsdWdpbjtcblx0XHR0aGlzLm5vc3RyU2VydmljZSA9IG5vc3RyU2VydmljZTtcblx0XHR0aGlzLnJlZnJlc2hEaXNwbGF5ID0gKCkgPT4gdGhpcy5vbk9wZW4oKVxuXHR9XG5cblx0Z2V0Vmlld1R5cGUoKSB7XG5cdFx0cmV0dXJuIEhJR0hMSUdIVFNfVklFVztcblx0fVxuXG5cdGdldERpc3BsYXlUZXh0KCkge1xuXHRcdHJldHVybiBcIllvdXIgTm9zdHIgSGlnaGxpZ2h0c1wiO1xuXHR9XG5cblx0Z2V0SWNvbigpIHtcblx0XHRyZXR1cm4gXCJlZGl0XCI7XG5cdH1cblxuXHRhc3luYyBvbk9wZW4oKSB7XG5cdFx0Y29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXJFbC5jaGlsZHJlblsxXTtcblx0XHRjb250YWluZXIuZW1wdHkoKTtcblx0XHRsZXQgYmFubmVyID0gY29udGFpbmVyLmNyZWF0ZUVsKFwiZGl2XCIsIHtcblx0XHRcdGNsczogXCJwdWJsaXNoZWQtYmFubmVyLWRpdlwiLFxuXHRcdH0pO1xuXHRcdGJhbm5lci5jcmVhdGVFbChcImg0XCIsIHsgdGV4dDogXCJIaWdobGlnaHRzXCIgfSk7XG5cdFx0bmV3IEJ1dHRvbkNvbXBvbmVudChiYW5uZXIpXG5cdFx0XHQuc2V0SWNvbihcInJlZnJlc2gtY3dcIilcblx0XHRcdC5zZXRDdGEoKVxuXHRcdFx0LnNldFRvb2x0aXAoXCJSZWZyZXNoIGhpZ2hsaWdodHNcIilcblx0XHRcdC5vbkNsaWNrKCgpID0+IHtcblx0XHRcdFx0dGhpcy5yZWZyZXNoRGlzcGxheSgpXG5cdFx0XHRcdG5ldyBOb3RpY2UoXCJWaWV3IHJlZnJlc2hlZFwiKVxuXHRcdFx0fSk7XG5cblx0XHR0cnkge1xuXHRcdFx0bGV0IGhpZ2hsaWdodHMgPSBhd2FpdCB0aGlzLm5vc3RyU2VydmljZS5sb2FkVXNlckhpZ2hsaWdodHMoKTtcblx0XHRcdGlmICh0aGlzLm5vc3RyU2VydmljZS5jb25uZWN0ZWRSZWxheXMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdG5ldyBOb3RpY2UoXCJSZS1jb25uZWN0IHRvIHJlbGF5cy4uLlwiKVxuXHRcdFx0fVxuXHRcdFx0aWYgKGhpZ2hsaWdodHMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRjb250YWluZXIuY3JlYXRlRWwoXCJwXCIsIHsgdGV4dDogYFRvdGFsOiAke2hpZ2hsaWdodHMubGVuZ3RofSBcdTI3MDVgIH0pO1xuXG5cdFx0XHRcdGhpZ2hsaWdodHMucmV2ZXJzZSgpLmZvckVhY2goYXN5bmMgKGhpZ2hsaWdodCkgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IGNhcmREaXYgPSBjb250YWluZXIuY3JlYXRlRWwoXCJkaXZcIiwge1xuXHRcdFx0XHRcdFx0Y2xzOiBcImJvb2ttYXJrLWNhcmRcIixcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRjb25zdCBjb250ZW50RGl2ID0gY2FyZERpdi5jcmVhdGVEaXYoe1xuXHRcdFx0XHRcdFx0Y2xzOiBcImhpZ2hsaWdodC1jb250ZW50XCIsXG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHQvLyBwYXJzZSBub3N0ciB0YWdzLCBucHVicyB3dGMuXG5cdFx0XHRcdFx0bGV0IHJlZmVyZW5jZXMgPSBwYXJzZVJlZmVyZW5jZXMoaGlnaGxpZ2h0KVxuXHRcdFx0XHRcdGxldCBsaW5rZWRFdmVudCA9IGZhbHNlO1xuXHRcdFx0XHRcdGxldCBsaW5rZWRFdmVudFVSTCA9IFwiXCI7XG5cdFx0XHRcdFx0bGV0IHNpbXBsZUF1Z21lbnRlZENvbnRlbnQgPSBoaWdobGlnaHQuY29udGVudDtcblxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcmVmZXJlbmNlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0bGV0IHsgdGV4dCwgcHJvZmlsZSwgZXZlbnQsIGFkZHJlc3MgfSA9IHJlZmVyZW5jZXNbaV07XG5cblx0XHRcdFx0XHRcdGxldCBhdWdtZW50ZWRSZWZlcmVuY2U7XG5cdFx0XHRcdFx0XHRpZiAocHJvZmlsZSkge1xuXHRcdFx0XHRcdFx0XHRjb25zdCB0YWdnZWRQcm9maWxlID0gYXdhaXQgdGhpcy5ub3N0clNlcnZpY2UuZ2V0VXNlclByb2ZpbGUocHJvZmlsZS5wdWJrZXkpO1xuXHRcdFx0XHRcdFx0XHRjb25zdCB7IG5hbWUgfSA9IEpTT04ucGFyc2UodGFnZ2VkUHJvZmlsZVswXS5jb250ZW50KTtcblx0XHRcdFx0XHRcdFx0YXVnbWVudGVkUmVmZXJlbmNlID0gYDxzdHJvbmc+QCR7bmFtZX08L3N0cm9uZz5gO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChldmVudCkge1xuXHRcdFx0XHRcdFx0XHRsZXQgbGlua2VkRXZlbnRQb2ludGVyOiBuaXAxOS5FdmVudFBvaW50ZXIgPSB7XG5cdFx0XHRcdFx0XHRcdFx0aWQ6IGV2ZW50LmlkLFxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGxldCB4ID0gbmlwMTkubmV2ZW50RW5jb2RlKGxpbmtlZEV2ZW50UG9pbnRlcik7XG5cdFx0XHRcdFx0XHRcdGF1Z21lbnRlZFJlZmVyZW5jZSA9IFwiXCI7XG5cdFx0XHRcdFx0XHRcdGxpbmtlZEV2ZW50ID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0bGlua2VkRXZlbnRVUkwgPSBgaHR0cHM6Ly9uanVtcC5tZS8ke3h9YFxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChhZGRyZXNzKSB7XG5cdFx0XHRcdFx0XHRcdGF1Z21lbnRlZFJlZmVyZW5jZSA9IGA8YSBocmVmPVwiJHt0ZXh0fVwiPlJlZmVyZW5jZWQgRXZlbnQ8L2E+YDtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGF1Z21lbnRlZFJlZmVyZW5jZSA9IHRleHQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRzaW1wbGVBdWdtZW50ZWRDb250ZW50ID0gc2ltcGxlQXVnbWVudGVkQ29udGVudC5yZXBsYWNlQWxsKHRleHQsIGF1Z21lbnRlZFJlZmVyZW5jZSk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y29udGVudERpdi5pbm5lckhUTUwgPSBzaW1wbGVBdWdtZW50ZWRDb250ZW50LnJlcGxhY2UoL1xcYmh0dHBzPzpcXC9cXC9cXFMrL2dpLCBcIlwiKTtcblxuXHRcdFx0XHRcdGNvbnRlbnREaXYuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0Y29uc3QgdGV4dFRvQ29weSA9IGNvbnRlbnREaXYudGV4dENvbnRlbnQ7XG5cdFx0XHRcdFx0XHRuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dCh0ZXh0VG9Db3B5KVxuXHRcdFx0XHRcdFx0XHQudGhlbigoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gU2hvdyB0b29sdGlwXG5cdFx0XHRcdFx0XHRcdFx0bmV3IE5vdGljZShcIlx1RDgzRFx1RENDQiBDb3BpZWQgdG8gY2xpcGJvYXJkIFx1MjcwNS5cIilcblx0XHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdFx0LmNhdGNoKGVycm9yID0+IHtcblx0XHRcdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGNvcHkgdGV4dDogXCIsIGVycm9yKTtcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRjb25zdCBhdXRob3JUYWcgPSBoaWdobGlnaHQudGFncy5maW5kKCh0YWc6IGFueVtdKSA9PiB0YWdbMF0gPT09IFwicFwiKTtcblxuXHRcdFx0XHRcdC8vIFRPRE8gTmVlZCB0byBnZXQgdGhlIGhpZ2hsaWdodCBzb3VyY2UgYXJ0aWNsZSBhbmQgZGlzcGxheSBpdCB3aXRoIGEgbGluayB0aGlzIGlzIHRoZSBcImFcIiB0YWcgXG5cdFx0XHRcdFx0bGV0IHNvdXJjZVRhZyA9IGhpZ2hsaWdodC50YWdzLmZpbmQoKHRhZzogYW55W10pID0+IHRhZ1swXSA9PT0gXCJhXCIpO1xuXHRcdFx0XHRcdGlmIChzb3VyY2VUYWcgPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHQvLyB0cnkgdGhlIFwiZVwiIHRhZ1xuXHRcdFx0XHRcdFx0c291cmNlVGFnID0gaGlnaGxpZ2h0LnRhZ3MuZmluZCgodGFnOiBhbnlbXSkgPT4gdGFnWzBdID09PSBcImVcIik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNvbnN0IGV4dGVybmFsU291cmNlVGFnID0gaGlnaGxpZ2h0LnRhZ3MuZmluZCgodGFnOiBhbnlbXSkgPT4gdGFnWzBdID09PSBcInJcIik7XG5cdFx0XHRcdFx0bGV0IGhpZ2hsaWdodFNvdXJjZTogYW55ID0gbnVsbDtcblx0XHRcdFx0XHRpZiAoc291cmNlVGFnICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdGhpZ2hsaWdodFNvdXJjZSA9IGF3YWl0IHRoaXMubm9zdHJTZXJ2aWNlLmdldEV2ZW50RnJvbUFUYWcoc291cmNlVGFnWzFdKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoYXV0aG9yVGFnICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdGxldCBoaWdobGlnaHRQcm9maWxlID0gYXdhaXQgdGhpcy5ub3N0clNlcnZpY2UuZ2V0VXNlclByb2ZpbGUoYXV0aG9yVGFnWzFdKTtcblx0XHRcdFx0XHRcdGxldCBwcm9maWxlTmFtZSA9IFwiXCI7XG5cdFx0XHRcdFx0XHRsZXQgcHJvZmlsZVBpY1VSTCA9IFwiXCI7XG5cblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IHByb2ZpbGVPYmplY3QgPSBKU09OLnBhcnNlKGhpZ2hsaWdodFByb2ZpbGVbMF0uY29udGVudCk7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IHsgbmFtZSwgcGljdHVyZSB9ID0gcHJvZmlsZU9iamVjdDtcblx0XHRcdFx0XHRcdFx0cHJvZmlsZU5hbWUgPSBuYW1lO1xuXG5cdFx0XHRcdFx0XHRcdGlmIChwaWN0dXJlID09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRcdGZvciAoY29uc3QgdGFnIG9mIGhpZ2hsaWdodFByb2ZpbGUudGFncykge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKHRhZ1swXSA9PT0gXCJpbWFnZVwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnN0IHBpY3R1cmVVcmwgPSB0YWdbMV07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHByb2ZpbGVQaWNVUkwgPSBwaWN0dXJlVXJsO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0cHJvZmlsZVBpY1VSTCA9IHBpY3R1cmU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKFwiUHJvYmxlbSBQYXJzaW5nIFByb2ZpbGUuLi5zZXR0aW5nIGRlZmF1bHRzLi4uXCIsIGVycilcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0aWYgKHNvdXJjZVRhZyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChoaWdobGlnaHRTb3VyY2UgIT09IG51bGwpIHtcblx0XHRcdFx0XHRcdFx0XHRsZXQgc291cmNlVGl0bGUgPSBcIlVua25vd24uLi5cIlxuXHRcdFx0XHRcdFx0XHRcdGZvciAoY29uc3QgdGFnIG9mIGhpZ2hsaWdodFNvdXJjZS50YWdzKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAodGFnWzBdID09PSBcInRpdGxlXCIpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0c291cmNlVGl0bGUgPSB0YWdbMV07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdGxldCB0YXJnZXQ6IG5pcDE5LkV2ZW50UG9pbnRlciA9IHtcblx0XHRcdFx0XHRcdFx0XHRcdGlkOiBoaWdobGlnaHRTb3VyY2UuaWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRhdXRob3I6IGhpZ2hsaWdodFNvdXJjZS5wdWJrZXksXG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0bGV0IG5ldmVudCA9IG5pcDE5Lm5ldmVudEVuY29kZSh0YXJnZXQpXG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QgdXJsID0gYGh0dHBzOi8vbmp1bXAubWUvJHtuZXZlbnR9YDtcblxuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IGNvbnRlbnRTb3VyY2VEaXYgPSBjYXJkRGl2LmNyZWF0ZUVsKFwiZGl2XCIsIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNsczogXCJoaWdobGlnaHQtY29udGVudC1zb3VyY2VcIixcblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0XHRjb250ZW50U291cmNlRGl2LmNyZWF0ZUVsKFwiaW1nXCIsIHtcblx0XHRcdFx0XHRcdFx0XHRcdGF0dHI6IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0c3JjOiBgJHtwcm9maWxlUGljVVJMfWAsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGFsdDogXCJQcm9maWxlIFBpY1wiLFxuXHRcdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHRcdGNsczogXCJib29rbWFyay1wcm9maWxlLXBpY1wiLFxuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IGRpc3BsYXlOYW1lID0gcHJvZmlsZU5hbWUgPyBwcm9maWxlTmFtZSA6IFwiVW5rbm93blwiO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y29udGVudFNvdXJjZURpdi5jcmVhdGVFbChcImFcIiwge1xuXHRcdFx0XHRcdFx0XHRcdFx0YXR0cjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRocmVmOiB1cmwsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldDogXCJfYmxhbmtcIixcblx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR0ZXh0OiBgJHtzb3VyY2VUaXRsZX1gLFxuXHRcdFx0XHRcdFx0XHRcdFx0Y2xzOiBcInNvdXJjZS1hcnRpY2xlLWxpbmtcIixcblx0XHRcdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0XHRcdGNvbnRlbnRTb3VyY2VEaXYuY3JlYXRlRWwoXCJzcGFuXCIsIHsgdGV4dDogXCIgIFwiIH0pO1xuXHRcdFx0XHRcdFx0XHRcdGNvbnRlbnRTb3VyY2VEaXYuY3JlYXRlRWwoXCJzcGFuXCIsIHsgdGV4dDogXCIgfCBcIiB9KTtcblx0XHRcdFx0XHRcdFx0XHRjb250ZW50U291cmNlRGl2LmNyZWF0ZUVsKFwic3BhblwiLCB7IHRleHQ6IGRpc3BsYXlOYW1lIH0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmIChleHRlcm5hbFNvdXJjZVRhZyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0XHRcdGxldCBleHRlcm5hbFNvdXJjZURpdiA9IGNhcmREaXYuY3JlYXRlRWwoXCJkaXZcIiwge1xuXHRcdFx0XHRcdFx0XHRcdGNsczogXCJoaWdobGlnaHQtY29udGVudC1zb3VyY2VcIixcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdGV4dGVybmFsU291cmNlRGl2LmNyZWF0ZUVsKFwiYVwiLCB7XG5cdFx0XHRcdFx0XHRcdFx0YXR0cjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0aHJlZjogZXh0ZXJuYWxTb3VyY2VUYWdbMV0sXG5cdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXQ6IFwiX2JsYW5rXCIsXG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0XHR0ZXh0OiBleHRlcm5hbFNvdXJjZVRhZ1sxXSxcblx0XHRcdFx0XHRcdFx0XHRjbHM6IFwic291cmNlLWFydGljbGUtbGlua1wiLFxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjb25zdCBjcmVhdGVkQXQgPSBuZXcgRGF0ZShoaWdobGlnaHQuY3JlYXRlZF9hdCAqIDEwMDApLnRvTG9jYWxlU3RyaW5nKCk7XG5cdFx0XHRcdFx0bGV0IGJvdHRvbURpdiA9IGNhcmREaXYuY3JlYXRlRWwoXCJkaXZcIiwge1xuXHRcdFx0XHRcdFx0dGV4dDogYEhpZ2hsaWdodGVkIG9uOiAke2NyZWF0ZWRBdH1gLFxuXHRcdFx0XHRcdFx0Y2xzOiBcImhpZ2hsaWdodC1jcmVhdGVkLWF0XCIsXG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRpZiAoaGlnaGxpZ2h0U291cmNlICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRuZXcgQnV0dG9uQ29tcG9uZW50KGJvdHRvbURpdilcblx0XHRcdFx0XHRcdFx0LnNldEljb24oXCJkb3dubG9hZFwiKVxuXHRcdFx0XHRcdFx0XHQuc2V0Q2xhc3MoXCJoaWdobGlnaHQtYnRuXCIpXG5cdFx0XHRcdFx0XHRcdC5zZXRUb29sdGlwKFwiRG93bmxvYWQgZnVsbCBzb3VyY2UgYXJ0aWNsZS5cIilcblx0XHRcdFx0XHRcdFx0Lm9uQ2xpY2soKCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuZG93bmxvYWRCb29rbWFyayhoaWdobGlnaHRTb3VyY2UpO1xuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc3Qgbm9Cb29rbWFya3NEaXYgPSBjb250YWluZXIuY3JlYXRlRWwoXCJkaXZcIiwgeyBjbHM6IFwibm9ib29rbWFya3MtY2FyZFwiIH0pO1xuXHRcdFx0XHRub0Jvb2ttYXJrc0Rpdi5jcmVhdGVFbChcImg2XCIsIHsgdGV4dDogXCJObyBIaWdobGlnaHRzIEZvdW5kIFx1RDgzRFx1RENEQVwiIH0pO1xuXHRcdFx0XHRub0Jvb2ttYXJrc0Rpdi5jcmVhdGVFbChcInBcIiwgeyB0ZXh0OiBcIlVzZSBoaWdobGlnaHRlci5jb20gdG8gcmVhZCBhbmQgaGlnaGxpZ2h0LlwiIH0pO1xuXHRcdFx0XHRjb25zdCBsaW5rRWwgPSBub0Jvb2ttYXJrc0Rpdi5jcmVhdGVFbChcImFcIiwgeyB0ZXh0OiBcImhpZ2hsaWdodGVyLmNvbVwiIH0pO1xuXHRcdFx0XHRsaW5rRWwuaHJlZiA9IFwiaHR0cHM6Ly9oaWdobGlnaHRlci5jb21cIjtcblx0XHRcdFx0bGlua0VsLnRhcmdldCA9IFwiX2JsYW5rXCI7XG5cblx0XHRcdH1cblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoXCJFcnJvciByZWFkaW5nIGhpZ2hsaWdodHM6XCIsIGVycik7XG5cdFx0XHRuZXcgTm90aWNlKFwiUHJvYmxlbSByZWFkaW5nIGhpZ2hsaWdodHMgLSByZS1jb25uZWN0ICYgY2hlY2sgeW91IGxpc3QuXCIpXG5cdFx0XHRjb25zdCBub0Jvb2ttYXJrc0RpdiA9IGNvbnRhaW5lci5jcmVhdGVFbChcImRpdlwiLCB7IGNsczogXCJub2Jvb2ttYXJrcy1jYXJkXCIgfSk7XG5cdFx0XHRub0Jvb2ttYXJrc0Rpdi5jcmVhdGVFbChcImg2XCIsIHsgdGV4dDogXCJObyBIaWdobGlnaHRzIEZvdW5kIFx1RDgzRFx1RENEQVwiIH0pO1xuXHRcdFx0bm9Cb29rbWFya3NEaXYuY3JlYXRlRWwoXCJwXCIsIHsgdGV4dDogXCJVc2UgaGlnaGxpZ2h0ZXIuY29tIHRvIHJlYWQgYW5kIGhpZ2hsaWdodC5cIiB9KTtcblx0XHRcdGNvbnN0IGxpbmtFbCA9IG5vQm9va21hcmtzRGl2LmNyZWF0ZUVsKFwiYVwiLCB7IHRleHQ6IFwiaGlnaGxpZ2h0ZXIuY29tXCIgfSk7XG5cdFx0XHRsaW5rRWwuaHJlZiA9IFwiaHR0cHM6Ly9oaWdobGlnaHRlci5jb21cIjtcblx0XHRcdGxpbmtFbC50YXJnZXQgPSBcIl9ibGFua1wiO1xuXHRcdH1cblx0fVxuXG5cdG9wZW5MaW5rKHVybDogc3RyaW5nKSB7XG5cdFx0Y29uc29sZS5sb2codXJsKVxuXHRcdHdpbmRvdy5vcGVuKHVybCwgJ19ibGFuaycpO1xuXHR9XG5cblxuXHRhc3luYyBkb3dubG9hZEJvb2ttYXJrKGJvb2ttYXJrOiBhbnkpIHtcblx0XHR0cnkge1xuXHRcdFx0bGV0IGZpbGVuYW1lOiBzdHJpbmc7XG5cdFx0XHRjb25zdCB0aXRsZVRhZyA9IGJvb2ttYXJrLnRhZ3MuZmluZCgodGFnOiBhbnlbXSkgPT4gdGFnWzBdID09PSBcInRpdGxlXCIpO1xuXHRcdFx0aWYgKHRpdGxlVGFnKSB7XG5cdFx0XHRcdGZpbGVuYW1lID0gYCR7dGl0bGVUYWdbMV19Lm1kYDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZpbGVuYW1lID0gYGJvb2ttYXJrXyR7Ym9va21hcmsuaWQuc3Vic3RyaW5nKDAsIDgpfS5tZGA7XG5cdFx0XHR9XG5cdFx0XHRjb25zdCBjb250ZW50ID0gdGhpcy5nZW5lcmF0ZU1hcmtkb3duQ29udGVudChib29rbWFyayk7XG5cblx0XHRcdGNvbnN0IGZpbGU6IFRGaWxlIHwgbnVsbCA9IGF3YWl0IHRoaXMuY3JlYXRlTWFya2Rvd25GaWxlKGZpbGVuYW1lLCBjb250ZW50KTtcblxuXHRcdFx0aWYgKGZpbGUgIT09IG51bGwpIHtcblx0XHRcdFx0YXdhaXQgdGhpcy5hcHAud29ya3NwYWNlLm9wZW5MaW5rVGV4dChmaWxlbmFtZSwgZmlsZS5wYXRoLCB0cnVlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5ldyBOb3RpY2UoXCJGYWlsZWQgdG8gY3JlYXRlIGZpbGUuIEZpbGUgbWF5IGFscmVhZHkgZXhpc3QuXCIpO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKFwiRXJyb3IgZG93bmxvYWRpbmcgYm9va21hcms6XCIsIGVycm9yKTtcblx0XHRcdG5ldyBOb3RpY2UoXCJGYWlsZWQgdG8gY3JlYXRlIGZpbGUuIEZpbGUgbWF5IGFscmVhZHkgZXhpc3QuXCIpO1xuXHRcdH1cblx0fVxuXG5cblx0YXN5bmMgY3JlYXRlTWFya2Rvd25GaWxlKGZpbGVuYW1lOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZyk6IFByb21pc2U8VEZpbGUgfCBudWxsPiB7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IGZpbGUgPSB0aGlzLmFwcC52YXVsdC5jcmVhdGUoZmlsZW5hbWUsIGNvbnRlbnQpO1xuXHRcdFx0cmV0dXJuIGZpbGU7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKFwiRmlsZSBhbHJlYWR5IGV4aXN0c1wiKSkge1xuXHRcdFx0XHRuZXcgTm90aWNlKFwiRmlsZSBhbHJlYWR5IGV4aXN0c1wiKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjcmVhdGluZyBmaWxlOlwiLCBlcnJvcik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdH1cblxuXG5cblx0Z2VuZXJhdGVNYXJrZG93bkNvbnRlbnQoYm9va21hcms6IGFueSk6IHN0cmluZyB7XG5cdFx0Y29uc3QgY3JlYXRlZEF0ID0gbmV3IERhdGUoYm9va21hcmsuY3JlYXRlZF9hdCAqIDEwMDApLnRvTG9jYWxlU3RyaW5nKCk7XG5cblx0XHRsZXQgc291cmNlOiBuaXAxOS5Qcm9maWxlUG9pbnRlciA9IHtcblx0XHRcdHB1YmtleTogYm9va21hcmsucHVia2V5LFxuXHRcdH1cblx0XHRsZXQgeSA9IG5pcDE5Lm5wcm9maWxlRW5jb2RlKHNvdXJjZSk7XG5cdFx0Y29uc3QgdXJsID0gYGh0dHBzOi8vbmp1bXAubWUvJHt5fWA7XG5cdFx0Y29uc3QgbWFya2Rvd25Db250ZW50ID0gYFxuIyBOb3N0ciBIaWdobGlnaHQgU291cmNlXG5cbioqQ29udGVudDoqKiBcblxcbiBcbiR7Ym9va21hcmsuY29udGVudH1cblxcblxuKioqXG4qKkNyZWF0ZWQgQXQ6KiogJHtjcmVhdGVkQXR9XG4qKlNvdXJjZToqKiAke3VybH1cblx0XHRgO1xuXG5cdFx0cmV0dXJuIG1hcmtkb3duQ29udGVudDtcblx0fVxuXG5cblx0ZXh0cmFjdEltYWdlVXJscyhjb250ZW50OiBzdHJpbmcpOiBzdHJpbmdbXSB7XG5cdFx0Y29uc3QgdXJsUmVnZXggPSAvKGh0dHBzPzpcXC9cXC9bXlxcc10rXFwuKD86anBnfGpwZWd8cG5nfGdpZikpL2dpO1xuXHRcdGNvbnN0IHVybHM6IHN0cmluZ1tdID0gW107XG5cdFx0bGV0IG1hdGNoO1xuXHRcdHdoaWxlICgobWF0Y2ggPSB1cmxSZWdleC5leGVjKGNvbnRlbnQpKSAhPT0gbnVsbCkge1xuXHRcdFx0dXJscy5wdXNoKG1hdGNoWzBdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHVybHM7XG5cdH1cblxuXG5cblx0Zm9jdXNGaWxlID0gKHBhdGg6IHN0cmluZywgc2hvdWxkU3BsaXQgPSBmYWxzZSk6IHZvaWQgPT4ge1xuXHRcdGNvbnN0IHRhcmdldEZpbGUgPSB0aGlzLmFwcC52YXVsdFxuXHRcdFx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChwYXRoKVxuXHRcdGlmICh0YXJnZXRGaWxlICYmIHRhcmdldEZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xuXHRcdFx0bGV0IGxlYWYgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0TGVhZigpO1xuXHRcdFx0Y29uc3QgY3JlYXRlTGVhZiA9IHNob3VsZFNwbGl0IHx8IGxlYWY/LmdldFZpZXdTdGF0ZSgpLnBpbm5lZDtcblx0XHRcdGlmIChjcmVhdGVMZWFmKSB7XG5cdFx0XHRcdGxlYWYgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0TGVhZigndGFiJyk7XG5cdFx0XHR9XG5cdFx0XHRsZWFmPy5vcGVuRmlsZSh0YXJnZXRGaWxlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bmV3IE5vdGljZSgnQ2Fubm90IGZpbmQgYSBmaWxlIHdpdGggdGhhdCBuYW1lJyk7XG5cdFx0fVxuXHR9O1xuXG59XG5cblxuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUEsbUJBQStCOzs7QUNBL0Isc0JBT087QUFJUCxJQUFxQixpQkFBckIsY0FBNEMsc0JBQU07QUFBQSxFQUdqRCxZQUNDLEtBQ1EsY0FDUixRQUNDO0FBQ0QsVUFBTSxHQUFHO0FBSEQ7QUFJUixTQUFLLFNBQVM7QUFBQSxFQUNmO0FBQUEsRUFFQSxNQUFNLFNBQVM7QUFDZCxRQUFJLEVBQUUsVUFBVSxJQUFJO0FBQ3BCLGNBQVUsU0FBUyxNQUFNLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUN2RCxRQUFJLGNBQWMsSUFBSSxrQ0FBa0IsU0FBUyxFQUMvQyxlQUFlLCtCQUErQixFQUM5QyxTQUFTLEVBQUU7QUFFYixnQkFBWSxRQUFRLGFBQWE7QUFBQSxNQUNoQyxPQUFPO0FBQUEsTUFDUCxRQUFRO0FBQUEsTUFDUixjQUFjO0FBQUEsTUFDZCxXQUFXO0FBQUEsTUFDWCxNQUFNO0FBQUEsSUFDUCxDQUFDO0FBRUQsUUFBSSxxQkFBcUI7QUFDekIsUUFBRyxLQUFLLE9BQU8sU0FBUyxTQUFTLFNBQVMsS0FBSyxLQUFLLE9BQU8sU0FBUyx5QkFBd0I7QUFDM0YsVUFBSSx3QkFBUSxTQUFTLEVBQ3BCLFFBQVEsZ0JBQWdCLEVBQ3hCLFFBQVEsMENBQTBDLEVBQ2xELFlBQVksQ0FBQyxhQUFhO0FBQzFCLGlCQUFTLFVBQVUsV0FBVyxTQUFTO0FBQ3ZDLG1CQUFXLEVB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QUFJLElBQUksRUFBRTtBQUN0QixVQUFJLEtBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDdEIsV0FBS0EsSUFBRyxJQUFJLElBQUksRUFBRTtBQUNsQixXQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ2xCLFdBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDbEIsV0FBS0EsSUFBRyxJQUFJLEdBQUcsRUFBRTtBQUNqQixXQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ2xCLFdBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDbEIsV0FBS0EsSUFBRyxJQUFJLElBQUksRUFBRTtBQUNsQixXQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ2xCLFdBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDbEIsV0FBS0EsSUFBRyxJQUFJLElBQUksRUFBRTtBQUNsQixXQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ2xCLFdBQUtBLElBQUcsSUFBSSxHQUFHLEVBQUU7QUFDakIsV0FBS0EsSUFBRyxJQUFJLElBQUksRUFBRTtBQUNsQixXQUFLQSxJQUFHLElBQUksR0FBRyxFQUFFO0FBQ2pCLFdBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDbEIsV0FBS0EsSUFBRyxJQUFJLElBQUksRUFBRTtBQUNsQixXQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ2xCLFdBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDbEIsV0FBS0EsSUFBRyxJQUFJLElBQUksRUFBRTtBQUNsQixXQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ2xCLFdBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDbEIsV0FBS0EsSUFBRyxJQUFJLElBQUksRUFBRTtBQUNsQixXQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ2xCLFdBQUtBLElBQUcsSUFBSSxJQUFJLEVBQUU7QUFDbEIsV0FBS0EsSUFBRyxJQUFJLElBQUksRUFBRTtBQUNsQixXQUFLQSxJQUFHLElBQUksSUFBSSxFQUFFO0FBQ2xCLFdBQUtBLElBQUcs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LEtBQUssQ0FBQztBQUU5QyxVQUFPLE1BQU0sTUFBTztBQUFHLFVBQU0sS0FBSyxNQUFNLEtBQUssRUFBRTtBQUMvQyxVQUFPLE1BQU0sTUFBTztBQUFHLFVBQU0sS0FBSyxNQUFNLEtBQUssRUFBRTtBQUMvQyxVQUFPLE1BQU0sTUFBTztBQUFHLFVBQU0sS0FBSyxNQUFNLEtBQUssQ0FBQztBQUM5QyxVQUFPLE1BQU0sTUFBTztBQUFHLFVBQU0sS0FBSyxNQUFNLEtBQUssQ0FBQztBQUU5QyxVQUFPLE1BQU0sTUFBTztBQUFHLFVBQU0sS0FBSyxNQUFNLEtBQUssRUFBRTtBQUMvQyxVQUFPLE1BQU0sTUFBTztBQUFHLFVBQU0sS0FBSyxNQUFNLEtBQUssRUFBRTtBQUMvQyxVQUFPLE1BQU0sTUFBTztBQUFHLFVBQU0sS0FBSyxNQUFLLEtBQUssQ0FBQztBQUM3QyxVQUFPLE1BQU0sTUFBTztBQUFHLFVBQU0sS0FBSyxNQUFNLEtBQUssQ0FBQztBQUU5QyxVQUFPLE1BQU0sTUFBTztBQUFHLFVBQU0sS0FBSyxNQUFNLEtBQUssRUFBRTtBQUMvQyxVQUFPLE1BQU0sTUFBTztBQUFHLFVBQU0sS0FBSyxNQUFNLEtBQUssRUFBRTtBQUMvQyxVQUFPLE1BQU0sTUFBTztBQUFHLFVBQU0sS0FBSyxNQUFNLEtBQUssQ0FBQztBQUM5QyxVQUFPLE1BQU0sTUFBTztBQUFHLFVBQU0sS0FBSyxNQUFNLEtBQUssQ0FBQztBQUU5QyxVQUFPLE1BQU0sTUFBTztBQUFHLFVBQU0sS0FBSyxNQUFNLEtBQUssRUFBRTtBQUMvQyxVQUFPLE1BQU0sTUFBTztBQUFHLFVBQU0sS0FBSyxNQUFNLEtBQUssRUFBRTtBQUMvQyxVQUFPLE1BQU0sTUFBTztBQUFHLFVBQU0sS0FBSyxNQUFNLEtBQUssQ0FBQztBQUM5QyxVQUFPLE1BQU0sTUFBTztBQUFHLFVBQU0sS0FBSyxNQUFNLEtBQUssQ0FBQztBQUU5QyxVQUFPLE1BQU0sTUFBTztBQUFHLFVBQU0sS0FBSyxNQUFNLEtBQUssRUFBRTtBQUMvQyxVQUFPLE1BQU0sTUFBTztBQUFHLFVBQU0sS0FBSyxNQUFNLEtBQUssRUFBRTtBQUMvQyxVQUFPLE1BQU0sTUFBTztBQUFHLFVBQU0sS0FBSyxNQUFNLEtBQUssQ0FBQztBQUM5QyxVQUFPLE1BQU0sTUFBTztBQUFHLFVBQU0sS0FBSyxNQUFNLEtBQUssQ0FBQztBQUU5QyxVQUFPLE1BQU0sTUFBTztBQUFHLFVBQU0sS0FBSyxNQUFNLEtBQUssRUFBRTtBQUMvQyxVQUFPLE1BQU0sTUFBTztBQUFHLFVBQU0sS0FBSyxNQUFNLEtBQUssRUFBRTtBQUMvQyxVQUFPLE1BQU0sTUFBTztBQUFHLFVBQU0sS0FBSyxNQUFNLEtBQUssQ0FBQztBQUM5QyxVQUFPLE1BQU0sTUFBTztBQUFHLFVBQU0sS0FBSyxNQUFNLEtBQUssQ0FBQztBQUU5QyxVQUFPLE1BQU0sTUFBTztBQUFHLFVBQU0sS0FBSyxNQUFNLEtBQUssRUFBRTtBQUMvQyxVQUFPLE1BQU0sTUFBTztBQUFHLFVBQU0sS0FBSyxNQUFNLEtBQUssRUFBRTtBQUMvQyxVQUFPLE1BQU0sTUFBTztBQUFHLFVBQU0sS0FBSyxNQUFNLEtBQUssQ0FBQztBQUM5QyxVQUFPLE1BQU0sTUFBTztBQUFHLFVBQU0sS0FBSyxNQUFNLEtBQUssQ0FBQztFQUNoRDtBQUVBLE1BQUksS0FBSztBQUNULE1BQUksSUFBSSxJQUFLLE1BQU0sTUFBTztBQUFHLE1BQUksSUFBSSxJQUFLLE1BQU0sTUFBTztBQUN2RCxNQUFJLElBQUksSUFBSyxNQUFNLE1BQU87QUFBRyxNQUFJLElBQUksSUFBSyxNQUFNLE1BQU87QUFDdkQsTUFBSSxJQUFJLElBQUssTUFBTSxNQUFPO0FBQUcsTUFBSSxJQUFJLElBQUssTUFBTSxNQUFPO0FBQ3ZELE1BQUksSUFBSSxJQUFLLE1BQU0sTUFBTztBQUFHLE1BQUksSUFBSSxJQUFLLE1BQU0sTUFBTztBQUN2RCxNQUFJLElBQUksSUFBSyxNQUFNLE1BQU87QUFBRyxNQUFJLElBQUksSUFBSyxNQUFNLE1BQU87QUFDdkQsTUFBSSxJQUFJLElBQUssTUFBTSxNQUFPO0FBQUcsTUFBSSxJQUFJLElBQUssTUFBTSxNQUFPO0FBQ3ZELE1BQUksSUFBSSxJQUFLLE1BQU0sTUFBTztBQUFHLE1BQUksSUFBSSxJQUFLLE1BQU0sTUFBTztBQUN2RCxNQUFJLElBQUksSUFBSyxNQUFNLE1BQU87QUFBRyxNQUFJLElBQUksSUFBSyxNQUFNLE1BQU87QUFDekQ7QUFRTSxTQUFVLFFBQ2QsR0FBZ0IsR0FBZ0JJLElBQWdCLEtBQWdCO0FBRWhFLE1BQUksTUFBTSxFQUFFLENBQUMsR0FBRyxNQUFNLEVBQUUsQ0FBQyxHQUFHLE1BQU0sRUFBRSxDQUFDLEdBQUcsTUFBTSxFQUFFLENBQUMsR0FDN0MsTUFBTSxFQUFFLENBQUMsR0FBRyxNQUFNLEVBQUUsQ0FBQyxHQUFHLE1BQU0sRUFBRSxDQUFDLEdBQUcsTUFBTSxFQUFFLENBQUMsR0FDN0MsTUFBTSxFQUFFLENBQUMsR0FBRyxNQUFNLEVBQUUsQ0FBQyxHQUFHLE1BQU0sRUFBRSxDQUFDLEdBQUcsTUFBTSxFQUFFLENBQUMsR0FDN0MsTUFBTUEsR0FBRSxDQUFDLEdBQUcsTUFBTUEsR0FBRSxDQUFDLEdBQUcsTUFBTUEsR0FBRSxDQUFDLEdBQUcsTUFBTUEsR0FBRSxDQUFDO0FBQ2pELFdBQVMsSUFBSSxHQUFHLElBQUksSUFBSSxLQUFLLEdBQUc7QUFDOUIsVUFBTyxNQUFNLE1BQU87QUFBRyxVQUFNLEtBQUssTUFBTSxLQUFLLEVBQUU7QUFDL0MsVUFBTyxNQUFNLE1BQU87QUFBRyxVQUFNLEtBQUssTUFBTSxLQUFLLEVBQUU7QUFDL0MsVUFBTyxNQUFNLE1BQU87QUFBRyxVQUFNLEtBQUssTUFBTSxLQUFLLENBQUM7QUFDOUMsVUFBTyxNQUFNLE1BQU87QUFBRyxVQUFNLEtBQUssTUFBTSxLQUFLLENBQUM7QUFFOUMsVUFBTyxNQUFNLE1BQU87QUFBRyxVQUFNLEtBQUssTUFBTSxLQUFLLEVBQUU7QUFDL0MsVUFBTyxNQUFNLE1BQU87QUFBRyxVQUFNLEtBQUssTUFBTSxLQUFLLEVBQUU7QUFDL0MsVUFBTyxNQUFNLE1BQU87QUFBRyxVQUFNLEtBQUssTUFBTSxLQUFLLENBQUM7QUFDOUMsVUFBTyxNQUFNLE1BQU87QUFBRyxVQUFNLEtBQUssTUFBTSxLQUFLLENBQUM7QUFFOUMsVUFBTyxNQUFNLE1BQU87QUFBRyxVQUFNLEtBQUssTUFBTSxLQUFLLEVBQUU7QUFDL0MsVUFBTyxNQUFNLE1BQU87QUFBRyxVQUFNLEtBQUssTUFBTSxLQUFLLEVBQUU7QUFDL0MsVUFBTyxNQUFNLE1BQU87QUFBRyxVQUFNLEtBQUssTUFBTSxLQUFLLENBQUM7QUFDOUMsVUFBTyxNQUFNLE1BQU87QUFBRyxVQUFNLEtBQUssTUFBTSxLQUFLLENBQUM7QUFFOUMsVUFBTyxNQUFNLE1BQU87QUFBRyxVQUFNLEtBQUssTUFBTSxLQUFLLEVBQUU7QUFDL0MsVUFBTyxNQUFNLE1BQU87QUFBRyxVQUFNLEtBQUssTUFBTSxLQUFLLEVBQUU7QUFDL0MsVUFBTyxNQUFNLE1BQU87QUFBRyxVQUFNLEtBQUssTUFBTSxLQUFLLENBQUM7QUFDOUMsVUFBTyxNQUFNLE1BQU87QUFBRyxVQUFNLEtBQUssTUFBTSxLQUFLLENBQUM7QUFFOUMsVUFBTyxNQUFNLE1BQU87QUFBRyxVQUFNLEtBQUssTUFBTSxLQUFLLEVBQUU7QUFDL0MsVUFBTyxNQUFNLE1BQU87QUFBRyxVQUFNLEtBQUssTUFBTSxLQUFLLEVBQUU7QUFDL0MsVUFBTyxNQUFNLE1BQU87QUFBRyxVQUFNLEtBQUssTUFBTSxLQUFLLENBQUM7QUFDOUMsVUFBTyxNQUFNLE1BQU87QUFBRyxVQUFNLEtBQUssTUFBTSxLQUFLLENBQUM7QUFFOUMsVUFBTyxNQUFNLE1BQU87QUFBRyxVQUFNLEtBQUssTUFBTSxLQUFLLEVBQUU7QUFDL0MsVUFBTyxNQUFNLE1BQU87QUFBRyxVQUFNLEtBQUssTUFBTSxLQUFLLEVBQUU7QUFDL0MsVUFBTyxNQUFNLE1BQU87QUFBRyxVQUFNLEtBQUssTUFBTSxLQUFLLENBQUM7QUFDOUMsVUFBTyxNQUFNLE1BQU87QUFBRyxVQUFNLEtBQUssTUFBTSxLQUFLLENBQUM7QUFFOUMsVUFB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LHdCQUF3QjtBQUFBLElBQzlCO0FBQUEsRUFDRDtBQUFBLEVBRUEsa0JBQWtCO0FBQ2pCLFFBQUksS0FBSyxTQUFTLGtCQUFrQjtBQUNuQyxVQUFJLENBQUMsS0FBSyxXQUFXO0FBQ3BCLGFBQUssWUFBWSxLQUFLLGlCQUFpQjtBQUN2QyxhQUFLLFVBQVUsU0FBUyxlQUFlO0FBQ3ZDLHNCQUFjLEtBQUssV0FBVztBQUFBLFVBQzdCLGNBQWM7QUFBQSxVQUNkLHVCQUF1QjtBQUFBLFFBQ3hCLENBQUM7QUFDRCxhQUFLLFVBQVUsaUJBQWlCLFNBQVMsTUFBTTtBQUM5QyxlQUFLLGFBQWEsZ0JBQWdCO0FBQ2xDLGNBQUksd0JBQU8sdUNBQTZCO0FBQUEsUUFDekMsQ0FBQztBQUFBLE1BQ0Y7QUFBQSxJQUNELFdBQVcsS0FBSyxXQUFXO0FBQzFCLFdBQUssVUFBVSxPQUFPO0FBQ3RCLFdBQUssWUFBWTtBQUFBLElBQ2xCO0FBQUEsRUFDRDtBQUNEO0FBRU8sU0FBUyxjQUFjLFNBQWMsWUFBaUI7QUFDNUQsV0FBUyxPQUFPLFlBQVk7QUFDM0IsWUFBUSxhQUFhLEtBQUssV0FBVyxHQUFHLENBQUM7QUFBQSxFQUMxQztBQUNEOyIsCiAgIm5hbWVzIjogWyJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgInJlZ2V4IiwgImhhc2giLCAiY3J5cHRvIiwgImNyeXB0byIsICJpc0xFIiwgImkiLCAiaSIsICJjb25jYXRCeXRlcyIsICJ1dGY4VG9CeXRlcyIsICJ1OGEiLCAiaSIsICJieXRlcyIsICJoZXgiLCAidmFsaWRhdG9ycyIsICJfMG4iLCAiXzFuIiwgIl8ybiIsICJudW1iZXIiLCAidSIsICJnY2QiLCAiRnAiLCAiZ2UiLCAiaSIsICJfMG4iLCAiXzFuIiwgImkiLCAiYml0TGVuIiwgImlzTEUiLCAiXzBuIiwgIl8xbiIsICJieXRlcyIsICJpc0xFIiwgIl8xbiIsICJfMG4iLCAiXzFuIiwgIndpbmRvdyIsICJpIiwgIkZwIiwgImhleCIsICJzIiwgIl8wbiIsICJfMW4iLCAiXzJuIiwgIl8zbiIsICJfNG4iLCAidG9CeXRlcyIsICJjb25jYXRCeXRlcyIsICJieXRlcyIsICJQb2ludCIsICJpIiwgIm11bCIsICJhIiwgIm1vZE4iLCAibnVtYmVyIiwgImdldFB1YmxpY0tleSIsICJoYXNoIiwgInJhbmRvbUJ5dGVzIiwgInIiLCAiaGFzaCIsICJpIiwgImhhc2giLCAiXzFuIiwgIl8ybiIsICJfM24iLCAiXzBuIiwgImNvbmNhdEJ5dGVzIiwgImNyeXB0byIsICJ1OGEiLCAiY3JlYXRlVmlldyIsICJyb3RyIiwgImlzTEUiLCAiaGV4ZXMiLCAiaSIsICJieXRlc1RvSGV4IiwgImJ5dGVzIiwgInU4YSIsICJoZXgiLCAiaGV4VG9CeXRlcyIsICJ1dGY4VG9CeXRlcyIsICJ0b0J5dGVzIiwgInU4YSIsICJjb25jYXRCeXRlcyIsICJIYXNoIiwgIndyYXBDb25zdHJ1Y3RvciIsICJ0b0J5dGVzIiwgInJhbmRvbUJ5dGVzIiwgImNyeXB0byIsICJudW1iZXIiLCAiYnl0ZXMiLCAiaGFzaCIsICJleGlzdHMiLCAib3V0cHV0IiwgInNldEJpZ1VpbnQ2NCIsICJpc0xFIiwgIlNIQTIiLCAiSGFzaCIsICJjcmVhdGVWaWV3IiwgInRvQnl0ZXMiLCAiaSIsICJDaGkiLCAiTWFqIiwgIlNIQTI1Nl9LIiwgIklWIiwgIlNIQTI1Nl9XIiwgIlNIQTI1NiIsICJTSEEyIiwgImkiLCAicm90ciIsICJzaGEyNTYiLCAid3JhcENvbnN0cnVjdG9yIiwgImVuY29kZSIsICJpIiwgImRlY29kZSIsICJhbHBoYWJldCIsICJwYWRkaW5nIiwgImJ5dGVzIiwgImkiLCAiaSIsICJlbmNvZGUiLCAibGltaXQiLCAiZGVjb2RlIiwgIl93b3JkcyIsICJudW1iZXIiLCAiYm9vbCIsICJieXRlcyIsICJleGlzdHMiLCAib3V0cHV0IiwgImJ5dGVzIiwgImNyZWF0ZVZpZXciLCAiaXNMRSIsICJ1dGY4VG9CeXRlcyIsICJ0b0J5dGVzIiwgInV0ZjhUb0J5dGVzIiwgImRlZmF1bHRzIiwgImVxdWFsQnl0ZXMiLCAiaSIsICJzZXRCaWdVaW50NjQiLCAiaXNMRSIsICJpIiwgImJ5dGVzIiwgInRvQnl0ZXMiLCAiY3JlYXRlVmlldyIsICJleGlzdHMiLCAib3V0cHV0IiwgIkJMT0NLX1NJWkUiLCAiUE9MWSIsICJtdWwyIiwgImkiLCAic2JveCIsICJzYm94MiIsICJieXRlcyIsICJ0MCIsICJ0MSIsICJ0MiIsICJ0MyIsICJjdHIiLCAiaXNMRSIsICJjcmVhdGVWaWV3IiwgImVjYiIsICJjYmMiLCAic2V0QmlnVWludDY0IiwgImdjbSIsICJlcXVhbEJ5dGVzIiwgInNpdiIsICJpIiwgInRvQnl0ZXMiLCAiYnl0ZXMiLCAiZXhpc3RzIiwgIm91dHB1dCIsICJ3cmFwQ29uc3RydWN0b3JXaXRoS2V5IiwgInV0ZjhUb0J5dGVzIiwgIm91dHB1dCIsICJudW1iZXIiLCAiYm9vbCIsICJieXRlcyIsICJpIiwgIlpFUk9TMTYiLCAiWkVST1MzMiIsICJjb21wdXRlVGFnIiwgImNyZWF0ZVZpZXciLCAic2V0QmlnVWludDY0IiwgImJ5dGVzIiwgIm91dHB1dCIsICJlcXVhbEJ5dGVzIiwgIkhNQUMiLCAiSGFzaCIsICJoYXNoIiwgInRvQnl0ZXMiLCAiaSIsICJobWFjIiwgImhhc2giLCAiaG1hYyIsICJ0b0J5dGVzIiwgIkhNQUMiLCAiX19kZWZQcm9wIiwgIl9fZXhwb3J0IiwgImFsbCIsICJpMiIsICJ1dGlsc19leHBvcnRzIiwgImJ5dGVzVG9IZXgiLCAiaGFzaCIsICJzaGEyNTYiLCAiX19leHBvcnQiLCAiY2hhbGxlbmdlIiwgIl9fZXhwb3J0IiwgIm51bWJlciIsICJieXRlc1RvSGV4IiwgImhleCIsICJoZXhUb0J5dGVzIiwgImJ5dGVzIiwgImNvbmNhdEJ5dGVzIiwgIl9fZXhwb3J0IiwgImRlY3J5cHQiLCAiZW5jcnlwdCIsICJieXRlc1RvSGV4IiwgInJhbmRvbUJ5dGVzIiwgImhleCIsICJpMiIsICJ1dGY4VG9CeXRlcyIsICJieXRlcyIsICJzaGEyNTYiLCAiY29uY2F0Qnl0ZXMiLCAiaG1hYyIsICJlbmNyeXB0MiIsICJkZWNyeXB0MiIsICJlcXVhbEJ5dGVzIiwgImhhc2giLCAidmVyaWZpZWRTeW1ib2wiLCAiaXNSZWNvcmQiLCAidmFsaWRhdGVFdmVudCIsICJpMiIsICJ1dGY4RGVjb2RlciIsICJ1dGY4RW5jb2RlciIsICJub3JtYWxpemVVUkwiLCAiUXVldWVOb2RlIiwgIlF1ZXVlIiwgIkpTIiwgImJ5dGVzVG9IZXgiLCAiZ2V0RXZlbnRIYXNoIiwgImhhc2giLCAic2VyaWFsaXplRXZlbnQiLCAic2hhMjU2IiwgImkiLCAiZ2VuZXJhdGVTZWNyZXRLZXkiLCAiZ2V0UHVibGljS2V5IiwgImZpbmFsaXplRXZlbnQiLCAidmVyaWZ5RXZlbnQiLCAiQ2xpZW50QXV0aCIsICJmaWx0ZXIiLCAiZ2V0SGV4NjQiLCAiZ2V0U3Vic2NyaXB0aW9uSWQiLCAibWFrZUF1dGhFdmVudCIsICJjaGFsbGVuZ2UiLCAiX1dlYlNvY2tldCIsICJ2ZXJpZmllZFN5bWJvbCIsICJpc1JlY29yZCIsICJ2YWxpZGF0ZUV2ZW50IiwgImkyIiwgInV0ZjhEZWNvZGVyIiwgInV0ZjhFbmNvZGVyIiwgIkpTIiwgImJ5dGVzVG9IZXgiLCAiZ2V0RXZlbnRIYXNoIiwgImhhc2giLCAic2VyaWFsaXplRXZlbnQiLCAic2hhMjU2IiwgImkiLCAiZ2VuZXJhdGVTZWNyZXRLZXkiLCAiZ2V0UHVibGljS2V5IiwgImZpbmFsaXplRXZlbnQiLCAidmVyaWZ5RXZlbnQiLCAidmVyaWZpZWRTeW1ib2wiLCAiaXNSZWNvcmQiLCAidmFsaWRhdGVFdmVudCIsICJpMiIsICJ1dGY4RGVjb2RlciIsICJ1dGY4RW5jb2RlciIsICJub3JtYWxpemVVUkwiLCAiUXVldWVOb2RlIiwgIlF1ZXVlIiwgIkpTIiwgImJ5dGVzVG9IZXgiLCAiZ2V0RXZlbnRIYXNoIiwgImhhc2giLCAic2VyaWFsaXplRXZlbnQiLCAic2hhMjU2IiwgImkiLCAiZ2VuZXJhdGVTZWNyZXRLZXkiLCAiZ2V0UHVibGljS2V5IiwgImZpbmFsaXplRXZlbnQiLCAidmVyaWZ5RXZlbnQiLCAiQ2xpZW50QXV0aCIsICJtYXRjaEZpbHRlciIsICJmaWx0ZXIiLCAibWF0Y2hGaWx0ZXJzIiwgImdldEhleDY0IiwgImdldFN1YnNjcmlwdGlvbklkIiwgIm1ha2VBdXRoRXZlbnQiLCAiY2hhbGxlbmdlIiwgInlpZWxkVGhyZWFkIiwgIl9XZWJTb2NrZXQiLCAiQWJzdHJhY3RSZWxheSIsICJRdWV1ZSIsICJub3JtYWxpemVVUkwiLCAiX1dlYlNvY2tldCIsICJ5aWVsZFRocmVhZCIsICJnZXRTdWJzY3JpcHRpb25JZCIsICJnZXRIZXg2NCIsICJtYXRjaEZpbHRlcnMiLCAibWFrZUF1dGhFdmVudCIsICJTdWJzY3JpcHRpb24iLCAiQWJzdHJhY3RSZWxheSIsICJ2ZXJpZnlFdmVudCIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaSIsICJpIiwgInByb3RvdHlwZSIsICJpIiwgImRlc2NyaXB0b3JzIiwgImZpbHRlciIsICJtYXRjaEFsbCIsICJoYXNPd25Qcm9wZXJ0eSIsICJhbHBoYWJldCIsICJmaWx0ZXIiLCAicGF0aCIsICJpIiwgInByb3RvdHlwZSIsICJ0b1N0cmluZyIsICJlbmNvZGUiLCAidXRpbHNfZXhwb3J0cyIsICJ1dGlsc19leHBvcnRzIiwgInBhdGgiLCAiaSIsICJwYXRoIiwgImlzRm9ybURhdGEiLCAiaXNGaWxlTGlzdCIsICJ0cmFuc2l0aW9uYWwiLCAiaSIsICJmaWx0ZXIiLCAic2VsZiIsICJpIiwgInByb3RvdHlwZSIsICJ2YWxpZGF0ZVN0YXR1cyIsICJwYXRoIiwgImJ5dGVzIiwgImkiLCAidHJhbnNpdGlvbmFsIiwgImkiLCAibWVyZ2UiLCAiaSIsICJ2YWxpZGF0b3JzIiwgInRyYW5zaXRpb25hbCIsICJpIiwgImNoYWluIiwgImkiLCAiQXhpb3MiLCAiQXhpb3NFcnJvciIsICJDYW5jZWxlZEVycm9yIiwgImlzQ2FuY2VsIiwgIkNhbmNlbFRva2VuIiwgIlZFUlNJT04iLCAiYWxsIiwgImlzQXhpb3NFcnJvciIsICJzcHJlYWQiLCAidG9Gb3JtRGF0YSIsICJBeGlvc0hlYWRlcnMiLCAiSHR0cFN0YXR1c0NvZGUiLCAibWVyZ2VDb25maWciLCAiaW1wb3J0X29ic2lkaWFuIiwgInBhdGgiLCAiZ2V0UHVibGljS2V5IiwgImZpbmFsaXplRXZlbnQiLCAiaW1wb3J0X29ic2lkaWFuIiwgImkiLCAiaXNWYWxpZCIsICJpbXBvcnRfb2JzaWRpYW4iLCAicGF0aCIsICJpbXBvcnRfb2JzaWRpYW4iLCAidXRmOERlY29kZXIiLCAidXRmOEVuY29kZXIiLCAiQmVjaDMyTWF4U2l6ZSIsICJkZWNvZGUiLCAicGFyc2VUTFYiLCAiYnl0ZXNUb0hleCIsICJwYXRoIiwgImkiLCAiaW1wb3J0X29ic2lkaWFuIiwgInBhdGgiLCAiaSJdCn0K
