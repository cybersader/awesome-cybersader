/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AutoClassifierPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/settings.ts
var import_obsidian2 = require("obsidian");

// src/api.ts
var import_obsidian = require("obsidian");
var ChatGPT = class {
  static async callAPI(system_role, user_prompt, apiKey, model = "gpt-3.5-turbo", temperature = 0, max_tokens = 150, top_p = 0.95, frequency_penalty = 0, presence_penalty = 0.5) {
    const headers = {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${apiKey}`
    };
    const body = JSON.stringify({
      model: "gpt-3.5-turbo",
      messages: [
        { "role": "system", "content": system_role },
        { "role": "user", "content": user_prompt }
      ],
      max_tokens,
      n: 1,
      // stop: '\n',
      stop: null,
      temperature,
      top_p,
      frequency_penalty,
      presence_penalty
    });
    const response = await (0, import_obsidian.requestUrl)({
      url: this.baseUrl,
      method: "POST",
      headers,
      body
    });
    if (response.status >= 400) {
      throw new Error(`API call error: ${response.status}`);
    }
    const data = JSON.parse(response.text);
    return data.choices[0].message.content;
  }
};
ChatGPT.baseUrl = "https://api.openai.com/v1/chat/completions";

// src/template.ts
var DEFAULT_CHAT_ROLE = `You are a JSON answer bot. Don't answer other words.`;
var DEFAULT_PROMPT_TEMPLATE = `Classify this content:
"""
{{input}}
"""
Answer format is JSON {reliability:0~1, output:selected_category}. 
Even if you are not sure, qualify the reliability and select one. 
Output must be one of these:

{{reference}}
`;
var DEFAULT_PROMPT_TEMPLATE_WO_REF = `Classify this content:
"""
{{input}}
"""
Answer format is JSON {reliability:0~1, output:selected_category}. 
Even if you are not sure, qualify the reliability and recommend a proper category.

`;

// src/settings.ts
var DEFAULT_SETTINGS = {
  apiKey: "",
  apiKeyCreatedAt: null,
  commandOption: {
    useRef: true,
    refs: [],
    manualRefs: [],
    refType: 0 /* All */,
    filterRegex: "",
    outLocation: 0 /* Cursor */,
    // outLocation_link: OutLocation_link.Cursor,
    outType: 2 /* Tag */,
    outPrefix: "",
    outSuffix: "",
    key: "tags",
    overwrite: false,
    useCustomCommand: false,
    chat_role: DEFAULT_CHAT_ROLE,
    prmpt_template: DEFAULT_PROMPT_TEMPLATE
  }
};
var AutoClassifierSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  async display() {
    const { containerEl } = this;
    const commandOption = this.plugin.settings.commandOption;
    containerEl.empty();
    const shortcutEl = new import_obsidian2.Setting(this.containerEl).setDesc("").addButton((cb) => {
      cb.setButtonText("Specify shortcuts").setCta().onClick(() => {
        app.setting.openTabById("hotkeys");
        const tab = app.setting.activeTab;
        tab.setQuery(this.plugin.manifest.id);
        tab.updateHotkeyVisibility();
      });
    });
    shortcutEl.descEl.createSpan({ text: "This plugin does not have default shortcuts to prevent shortcut conflicts." });
    shortcutEl.descEl.createEl("br");
    shortcutEl.descEl.createSpan({ text: "Assign your own shortcuts to run commands for different input types." });
    containerEl.createEl("h1", { text: "API Setting" });
    const apiKeySetting = new import_obsidian2.Setting(containerEl).setName("ChatGPT API Key").setDesc("").addText(
      (text) => text.setPlaceholder("API key").setValue(this.plugin.settings.apiKey).onChange((value) => {
        this.plugin.settings.apiKey = value;
        this.plugin.saveSettings();
      })
    );
    apiKeySetting.descEl.createSpan({ text: "Enter your ChatGPT API key. If you don't have one yet, you can create it at " });
    apiKeySetting.descEl.createEl("a", { href: "https://platform.openai.com/account/api-keys", text: "here" });
    const apiTestMessageEl = document.createElement("div");
    apiKeySetting.descEl.appendChild(apiTestMessageEl);
    if (this.plugin.settings.apiKey && this.plugin.settings.apiKeyCreatedAt) {
      apiTestMessageEl.setText(`This key was tested at ${this.plugin.settings.apiKeyCreatedAt.toString()}`);
      apiTestMessageEl.style.color = "var(--success-color)";
    }
    apiKeySetting.addButton((cb) => {
      cb.setButtonText("Test API call").setCta().onClick(async () => {
        this.plugin.settings.apiKeyCreatedAt;
        apiTestMessageEl.setText("Testing api call...");
        apiTestMessageEl.style.color = "var(--text-normal)";
        try {
          await ChatGPT.callAPI("", "test", this.plugin.settings.apiKey);
          apiTestMessageEl.setText("Success! API working.");
          apiTestMessageEl.style.color = "var(--success-color)";
          this.plugin.settings.apiKeyCreatedAt = new Date();
        } catch (error) {
          apiTestMessageEl.setText("Error: API is not working.");
          apiTestMessageEl.style.color = "var(--warning-color)";
          this.plugin.settings.apiKeyCreatedAt = null;
        }
      });
    });
    containerEl.createEl("h1", { text: "Tag Reference Setting" });
    new import_obsidian2.Setting(containerEl).setName("Use Reference").setDesc("If not, it will recommend new tags").addToggle(
      (toggle) => toggle.setValue(commandOption.useRef).onChange(async (value) => {
        commandOption.useRef = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    if (commandOption.useRef) {
      new import_obsidian2.Setting(containerEl).setName("Reference type").setDesc("Choose the type of reference tag").setClass("setting-item-child").addDropdown((dropdown) => {
        dropdown.addOption(String(0 /* All */), "All tags").addOption(String(1 /* Filter */), "Filtered tags").addOption(String(2 /* Manual */), "Manual tags").setValue(String(commandOption.refType)).onChange(async (refTye) => {
          this.setRefType(parseInt(refTye));
          this.setRefs(parseInt(refTye));
          this.display();
        });
      });
      if (commandOption.refType == 0 /* All */) {
        this.setRefs(0 /* All */);
      }
      if (commandOption.refType == 1 /* Filter */) {
        new import_obsidian2.Setting(containerEl).setName("Filter regex").setDesc("Specify a regular expression to filter tags").setClass("setting-item-child").addText(
          (text) => text.setPlaceholder("Regular expression").setValue(commandOption.filterRegex).onChange(async (value) => {
            this.setRefs(1 /* Filter */, value);
          })
        );
      } else if (commandOption.refType == 2 /* Manual */) {
        new import_obsidian2.Setting(containerEl).setName("Manual tags").setDesc("Manually specify tags to reference.").setClass("setting-item-child").setClass("height10-text-area").addTextArea((text) => {
          var _a;
          text.setPlaceholder("Tags").setValue((_a = commandOption.manualRefs) == null ? void 0 : _a.join("\n")).onChange(async (value) => {
            this.setRefs(2 /* Manual */, value);
          });
        }).addExtraButton((cb) => {
          cb.setIcon("reset").setTooltip("Bring All Tags").onClick(async () => {
            var _a;
            const allTags = (_a = await this.plugin.viewManager.getTags()) != null ? _a : [];
            commandOption.manualRefs = allTags;
            this.setRefs(2 /* Manual */);
            this.display();
          });
        });
      }
      new import_obsidian2.Setting(containerEl).setClass("setting-item-child").addButton((cb) => {
        cb.setButtonText("View Reference Tags").onClick(async () => {
          var _a;
          const tags = (_a = commandOption.refs) != null ? _a : [];
          new import_obsidian2.Notice(`${tags.join("\n")}`);
        });
      });
    }
    containerEl.createEl("h1", { text: "Output Setting" });
    new import_obsidian2.Setting(containerEl).setName("Output Type").setDesc("Specify output type").addDropdown((cb) => {
      cb.addOption(String(2 /* Tag */), "#Tag").addOption(String(3 /* Wikilink */), "[[Wikilink]]").addOption(String(0 /* FrontMatter */), "FrontMatter").addOption(String(1 /* Title */), "Title alternative").setValue(String(commandOption.outType)).onChange(async (value) => {
        commandOption.outType = parseInt(value);
        commandOption.outLocation = 0;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    if (commandOption.outType == 2 /* Tag */) {
      new import_obsidian2.Setting(containerEl).setName("Output Location").setClass("setting-item-child").setDesc("Specify where to put the output tag").addDropdown((cb) => {
        cb.addOption(String(0 /* Cursor */), "Current Cursor").addOption(String(1 /* ContentTop */), "Top of Content").setValue(String(commandOption.outLocation)).onChange(async (value) => {
          commandOption.outLocation = parseInt(value);
          await this.plugin.saveSettings();
          this.display();
        });
      });
    } else if (commandOption.outType == 3 /* Wikilink */) {
      new import_obsidian2.Setting(containerEl).setName("Output Location").setClass("setting-item-child").setDesc("Specify where to put the output wikilink").addDropdown((cb) => {
        cb.addOption(String(0 /* Cursor */), "Current Cursor").addOption(String(1 /* ContentTop */), "Top of Content").setValue(String(commandOption.outLocation)).onChange(async (value) => {
          commandOption.outLocation = parseInt(value);
          await this.plugin.saveSettings();
          this.display();
        });
      });
    } else if (commandOption.outType == 0 /* FrontMatter */) {
      new import_obsidian2.Setting(containerEl).setName("FrontMatter key").setDesc("Specify FrontMatter key to put the output tag").setClass("setting-item-child").addText(
        (text) => text.setPlaceholder("Key").setValue(commandOption.key).onChange(async (value) => {
          commandOption.key = value;
          await this.plugin.saveSettings();
        })
      );
    }
    if (commandOption.outType == 2 /* Tag */ && commandOption.outLocation == 0 /* Cursor */ || commandOption.outType == 3 /* Wikilink */ && commandOption.outLocation == 0 /* Cursor */ || commandOption.outType == 1 /* Title */ || commandOption.outType == 0 /* FrontMatter */) {
      let overwriteName = "";
      if (commandOption.outLocation == 0 /* Cursor */)
        overwriteName = "Overwrite if selected.";
      if (commandOption.outType == 1 /* Title */)
        overwriteName = "Overwrite whole title. If false, add to end of title.";
      if (commandOption.outType == 0 /* FrontMatter */)
        overwriteName = "Overwrite value of the key.";
      new import_obsidian2.Setting(containerEl).setName(overwriteName).setClass("setting-item-child").addToggle(
        (toggle) => toggle.setValue(commandOption.overwrite).onChange(async (value) => {
          commandOption.overwrite = value;
          await this.plugin.saveSettings();
          this.display();
        })
      );
    }
    new import_obsidian2.Setting(containerEl).setName("Add Prefix & Suffix").setDesc(`Output: {prefix} + {output} + {suffix}`);
    new import_obsidian2.Setting(containerEl).setName("Prefix").setClass("setting-item-child").addText(
      (text) => text.setPlaceholder("prefix").setValue(commandOption.outPrefix).onChange(async (value) => {
        commandOption.outPrefix = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Suffix").setClass("setting-item-child").addText(
      (text) => text.setPlaceholder("suffix").setValue(commandOption.outSuffix).onChange(async (value) => {
        commandOption.outSuffix = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h1", { text: "Advanced Setting" });
    new import_obsidian2.Setting(containerEl).setName("Use Custom Request Template").addToggle(
      (toggle) => toggle.setValue(commandOption.useCustomCommand).onChange(async (value) => {
        commandOption.useCustomCommand = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    if (commandOption.useCustomCommand) {
      if (commandOption.useRef) {
        if (commandOption.prmpt_template == DEFAULT_PROMPT_TEMPLATE_WO_REF)
          commandOption.prmpt_template = DEFAULT_PROMPT_TEMPLATE;
      } else {
        if (commandOption.prmpt_template == DEFAULT_PROMPT_TEMPLATE)
          commandOption.prmpt_template = DEFAULT_PROMPT_TEMPLATE_WO_REF;
      }
      const customPromptTemplateEl = new import_obsidian2.Setting(containerEl).setName("Custom Prompt Template").setDesc("").setClass("setting-item-child").setClass("block-control-item").setClass("height20-text-area").addTextArea(
        (text) => text.setPlaceholder("Write custom prompt template.").setValue(commandOption.prmpt_template).onChange(async (value) => {
          commandOption.prmpt_template = value;
          await this.plugin.saveSettings();
        })
      ).addExtraButton((cb) => {
        cb.setIcon("reset").setTooltip("Restore to default").onClick(async () => {
          if (commandOption.useRef)
            commandOption.prmpt_template = DEFAULT_PROMPT_TEMPLATE;
          else
            commandOption.prmpt_template = DEFAULT_PROMPT_TEMPLATE_WO_REF;
          await this.plugin.saveSettings();
          this.display();
        });
      });
      customPromptTemplateEl.descEl.createSpan({ text: "This plugin is based on the ChatGPT answer." });
      customPromptTemplateEl.descEl.createEl("br");
      customPromptTemplateEl.descEl.createSpan({ text: "You can use your own template when making a request to ChatGPT." });
      customPromptTemplateEl.descEl.createEl("br");
      customPromptTemplateEl.descEl.createEl("br");
      customPromptTemplateEl.descEl.createSpan({ text: "Variables:" });
      customPromptTemplateEl.descEl.createEl("br");
      customPromptTemplateEl.descEl.createSpan({ text: "- {{input}}: The text to classify will be inserted here." });
      customPromptTemplateEl.descEl.createEl("br");
      customPromptTemplateEl.descEl.createSpan({ text: "- {{reference}}: The reference tags will be inserted here." });
      customPromptTemplateEl.descEl.createEl("br");
      const customChatRoleEl = new import_obsidian2.Setting(containerEl).setName("Custom Chat Role").setDesc("").setClass("setting-item-child").setClass("block-control-item").setClass("height10-text-area").addTextArea(
        (text) => text.setPlaceholder("Write custom chat role for gpt system.").setValue(commandOption.chat_role).onChange(async (value) => {
          commandOption.chat_role = value;
          await this.plugin.saveSettings();
        })
      ).addExtraButton((cb) => {
        cb.setIcon("reset").setTooltip("Restore to default").onClick(async () => {
          commandOption.chat_role = DEFAULT_CHAT_ROLE;
          await this.plugin.saveSettings();
          this.display();
        });
      });
      customChatRoleEl.descEl.createSpan({ text: "Define custom role to ChatGPT system." });
    }
  }
  setRefType(refType) {
    this.plugin.settings.commandOption.refType = refType;
  }
  async setRefs(refType, value) {
    var _a, _b;
    const commandOption = this.plugin.settings.commandOption;
    if (refType == 0 /* All */) {
      const tags = (_a = await this.plugin.viewManager.getTags()) != null ? _a : [];
      commandOption.refs = tags;
    } else if (refType == 1 /* Filter */) {
      if (value) {
        commandOption.filterRegex = value;
      }
      const tags = (_b = await this.plugin.viewManager.getTags(commandOption.filterRegex)) != null ? _b : [];
      commandOption.refs = tags;
    } else if (refType == 2 /* Manual */) {
      if (value) {
        commandOption.manualRefs = value == null ? void 0 : value.split(/,|\n/).map((tag) => tag.trim());
      }
      commandOption.refs = commandOption.manualRefs;
    }
    await this.plugin.saveSettings();
  }
};

// src/view-manager.ts
var import_obsidian3 = require("obsidian");
var ViewManager = class {
  constructor(app2) {
    this.app = app2;
  }
  async getSelection(editor) {
    if (editor) {
      return editor.getSelection();
    }
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
    if (activeView) {
      return activeView.editor.getSelection();
    }
    return null;
  }
  async getTitle() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
    if (activeView) {
      return activeView.file.basename;
    }
    return null;
  }
  async getFrontMatter() {
    var _a;
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
    if (activeView) {
      const file = activeView.file;
      const frontmatter = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
      if (frontmatter == null ? void 0 : frontmatter.position) {
        delete frontmatter.position;
      }
      return JSON.stringify(frontmatter);
    }
    return null;
  }
  async getContent() {
    var _a;
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
    if (activeView) {
      let content = activeView.getViewData();
      const file = activeView.file;
      const frontmatter = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
      if (frontmatter) {
        content = content.split("---").slice(2).join("---");
      }
      return content;
    }
    return null;
  }
  async getTags(filterRegex) {
    const tagsDict = this.app.metadataCache.getTags();
    let tags = Object.keys(tagsDict);
    if (!tags || tags.length == 0)
      return null;
    tags = tags.map((tag) => tag.replace(/^#/, ""));
    if (filterRegex) {
      return tags.filter((tag) => RegExp(filterRegex).test(tag));
    }
    return tags;
  }
  async insertAtFrontMatter(key, value, overwrite = false, prefix = "", suffix = "") {
    value = `${prefix}${value}${suffix}`;
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
    if (activeView) {
      const file = activeView.file;
      await this.app.fileManager.processFrontMatter(file, (frontmatter) => {
        frontmatter = frontmatter || {};
        if (frontmatter[key] && !overwrite) {
          if (Array.isArray(frontmatter[key])) {
            frontmatter[key].push(value);
          } else {
            frontmatter[key] = [frontmatter[key], value];
          }
        } else {
          frontmatter[key] = value;
        }
      });
    }
  }
  async insertAtTitle(value, overwrite = false, prefix = "", suffix = "") {
    value = `${prefix}${value}${suffix}`;
    const file = this.app.workspace.getActiveFile();
    if (!file)
      return;
    let newName = file.basename;
    if (overwrite) {
      newName = `${value}`;
    } else {
      newName = `${newName} ${value}`;
    }
    newName = newName.replace(/[\"\/<>:\|?\"]/g, "");
    const newPath = file.getNewPathAfterRename(newName);
    await this.app.fileManager.renameFile(file, newPath);
  }
  async insertAtCursor(value, overwrite = false, outType, prefix = "", suffix = "") {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
    const output = this.preprocessOutput(value, outType, prefix, suffix);
    if (activeView) {
      const editor = activeView.editor;
      const selection = editor.getSelection();
      if (selection && !overwrite) {
        editor.setSelection(editor.getCursor("to"));
      }
      editor.replaceSelection(output);
    }
  }
  async insertAtContentTop(value, outType, prefix = "", suffix = "") {
    var _a;
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
    const output = this.preprocessOutput(value, outType, prefix, suffix);
    if (activeView) {
      const editor = activeView.editor;
      const file = activeView.file;
      const sections = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.sections;
      let topLine = 0;
      if (sections && sections[0].type == "yaml") {
        topLine = sections[0].position.end.line + 1;
      }
      editor.setCursor({ line: topLine, ch: 0 });
      editor.replaceSelection(`${output}
`);
    }
  }
  preprocessOutput(value, outType, prefix = "", suffix = "") {
    let output = "";
    if (outType == 2 /* Tag */) {
      output = `${prefix}${value}${suffix}`;
      output = output.replace(/ /g, "_");
      output = ` #${output} `;
    } else if (outType == 3 /* Wikilink */)
      output = `[[${prefix}${value}${suffix}]]`;
    return output;
  }
};

// src/main.ts
var AutoClassifierPlugin = class extends import_obsidian4.Plugin {
  constructor() {
    super(...arguments);
    this.viewManager = new ViewManager(this.app);
  }
  async onload() {
    await this.loadSettings();
    this.addCommand({
      id: "classify-tag-selected",
      name: "Classify tag from Selected Area",
      callback: async () => {
        await this.runClassifyTag(0 /* SelectedArea */);
      }
    });
    this.addCommand({
      id: "classify-tag-title",
      name: "Classify tag from Note Title",
      callback: async () => {
        await this.runClassifyTag(1 /* Title */);
      }
    });
    this.addCommand({
      id: "classify-tag-frontmatter",
      name: "Classify tag from FrontMatter",
      callback: async () => {
        await this.runClassifyTag(2 /* FrontMatter */);
      }
    });
    this.addCommand({
      id: "classify-tag-content",
      name: "Classify tag from Note Content",
      callback: async () => {
        await this.runClassifyTag(3 /* Content */);
      }
    });
    this.addSettingTab(new AutoClassifierSettingTab(this.app, this));
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async onunload() {
  }
  async runClassifyTag(inputType) {
    const loadingNotice = this.createLoadingNotice(`${this.manifest.name}: Processing..`);
    try {
      await this.classifyTag(inputType);
      loadingNotice.hide();
    } catch (err) {
      loadingNotice.hide();
    }
  }
  // Main Classification
  async classifyTag(inputType) {
    const commandOption = this.settings.commandOption;
    if (!this.settings.apiKey) {
      new import_obsidian4.Notice(`\u26D4 ${this.manifest.name}: You shuld input your API Key`);
      return null;
    }
    const refs = this.settings.commandOption.refs;
    if (this.settings.commandOption.useRef && (!refs || refs.length == 0)) {
      new import_obsidian4.Notice(`\u26D4 ${this.manifest.name}: no reference tags`);
      return null;
    }
    let input = "";
    if (inputType == 0 /* SelectedArea */) {
      input = await this.viewManager.getSelection();
    } else if (inputType == 1 /* Title */) {
      input = await this.viewManager.getTitle();
    } else if (inputType == 2 /* FrontMatter */) {
      input = await this.viewManager.getFrontMatter();
    } else if (inputType == 3 /* Content */) {
      input = await this.viewManager.getContent();
    }
    if (!input) {
      new import_obsidian4.Notice(`\u26D4 ${this.manifest.name}: no input data`);
      return null;
    }
    let user_prompt = this.settings.commandOption.prmpt_template;
    user_prompt = user_prompt.replace("{{input}}", input);
    user_prompt = user_prompt.replace("{{reference}}", refs.join(","));
    const system_role = this.settings.commandOption.prmpt_template;
    const responseRaw = await ChatGPT.callAPI(system_role, user_prompt, this.settings.apiKey);
    const jsonRegex = /reliability[\s\S]*?:\s*([\d.]+)[\s\S]*?output[\s\S]*?:\s*"([^"^}]+)/;
    const match = responseRaw.match(jsonRegex);
    let resOutput;
    let resReliabity;
    if (match && match.length > 1) {
      resOutput = match[2];
      resReliabity = parseFloat(match[1]);
    } else {
      new import_obsidian4.Notice(`\u26D4 ${this.manifest.name}: output format error (output: ${responseRaw})`);
      return null;
    }
    if (resReliabity <= 0.2) {
      new import_obsidian4.Notice(`\u26D4 ${this.manifest.name}: response has row reliability (${resReliabity})`);
      return null;
    }
    if (commandOption.outType == 2 /* Tag */ || commandOption.outType == 3 /* Wikilink */) {
      if (commandOption.outLocation == 0 /* Cursor */) {
        this.viewManager.insertAtCursor(resOutput, commandOption.overwrite, commandOption.outType, commandOption.outPrefix, commandOption.outSuffix);
      } else if (commandOption.outLocation == 1 /* ContentTop */) {
        this.viewManager.insertAtContentTop(resOutput, commandOption.outType, commandOption.outPrefix, commandOption.outSuffix);
      }
    } else if (commandOption.outType == 0 /* FrontMatter */) {
      this.viewManager.insertAtFrontMatter(commandOption.key, resOutput, commandOption.overwrite, commandOption.outPrefix, commandOption.outSuffix);
    } else if (commandOption.outType == 1 /* Title */) {
      this.viewManager.insertAtTitle(resOutput, commandOption.overwrite, commandOption.outPrefix, commandOption.outSuffix);
    }
    new import_obsidian4.Notice(`\u2705 ${this.manifest.name}: classified to ${resOutput}`);
  }
  // create loading spin in the Notice message
  createLoadingNotice(text, number = 1e4) {
    const notice = new import_obsidian4.Notice("", number);
    const loadingContainer = document.createElement("div");
    loadingContainer.addClass("loading-container");
    const loadingIcon = document.createElement("div");
    loadingIcon.addClass("loading-icon");
    const loadingText = document.createElement("span");
    loadingText.textContent = text;
    notice.noticeEl.empty();
    loadingContainer.appendChild(loadingIcon);
    loadingContainer.appendChild(loadingText);
    notice.noticeEl.appendChild(loadingContainer);
    return notice;
  }
};
