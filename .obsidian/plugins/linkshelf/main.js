/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => LinkStowrPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/utils/api.ts
var import_obsidian = require("obsidian");
function getAPI(accessToken, customServerURL) {
  const baseURL = customServerURL != null && customServerURL !== "" ? customServerURL : "https://linkshelf.fly.dev";
  function requestFactory(method) {
    return async (url, requestParams) => {
      return await (0, import_obsidian.requestUrl)({
        url: `${baseURL}${url}`,
        method,
        headers: { "X-Api-Token": accessToken },
        ...requestParams
      });
    };
  }
  return {
    get: requestFactory("get"),
    post: requestFactory("post")
  };
}

// src/utils/file.ts
function replaceIllegalFileNameCharactersInString(text) {
  return text.replace(/[\\,#%&{}/|*<>$":@.?]/g, "").replace(/\s+/g, " ");
}
function truncate(text, length) {
  return text.substring(0, length);
}

// src/utils/template.ts
var import_obsidian2 = require("obsidian");
var DEFAULT_TEMPLATE = `---
tags: bookmark
title: "{{title}}"
url: {{url}}
---

# {{title}}

url: {{url}}

{{note}}
`;
async function getTemplateContents(app, templatePath) {
  if (templatePath == null || templatePath === "") {
    return DEFAULT_TEMPLATE;
  }
  const { metadataCache, vault } = app;
  const normalizedTemplatePath = (0, import_obsidian2.normalizePath)(templatePath);
  try {
    const templateFile = metadataCache.getFirstLinkpathDest(
      normalizedTemplatePath,
      ""
    );
    return templateFile ? vault.cachedRead(templateFile) : DEFAULT_TEMPLATE;
  } catch (err) {
    console.error(`Failed to read template path: ${templatePath}`, err);
    new import_obsidian2.Notice("Failed to read template file LinkStowr");
    return DEFAULT_TEMPLATE;
  }
}
function applyTemplateTransformations(rawTemplateContents) {
  return rawTemplateContents.replace(
    /{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi,
    (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
      const now = (0, import_obsidian2.moment)();
      const currentDate = now.clone().set({
        hour: now.hour(),
        minute: now.minute(),
        second: now.second()
      });
      if (calc) {
        currentDate.add(parseInt(timeDelta, 10), unit);
      }
      if (momentFormat) {
        return currentDate.format(momentFormat.substring(1).trim());
      }
      return currentDate.format("YYYY-MM-DD");
    }
  );
}
function replaceVariableSyntax(link, text) {
  if (!(text == null ? void 0 : text.trim())) {
    return "";
  }
  const entries = Object.entries(link);
  return entries.reduce((result, [key, val = ""]) => {
    return result.replace(new RegExp(`{{${key}}}`, "ig"), val);
  }, text).replace(/{{\w+}}/gi, "").trim();
}
function executeInlineScriptsTemplates(link, text) {
  const commandRegex = /<%(?:=)(.+)%>/g;
  const ctor = getFunctionConstructor();
  const matchedList = [...text.matchAll(commandRegex)];
  return matchedList.reduce((result, [matched, script]) => {
    try {
      const outputs = new ctor(
        [
          "const [link] = arguments",
          `const output = ${script}`,
          'if(typeof output === "string") return output',
          "return JSON.stringify(output)"
        ].join(";")
      )(link);
      return result.replace(matched, outputs);
    } catch (err) {
      console.warn(err);
    }
    return result;
  }, text);
}
function getFunctionConstructor() {
  try {
    return new Function("return (function(){}).constructor")();
  } catch (err) {
    console.warn(err);
    if (err instanceof SyntaxError) {
      throw Error("Bad template syntax");
    } else {
      throw err;
    }
  }
}
async function useTemplaterPluginInFile(app, file) {
  const templater = app.plugins.plugins["templater-obsidian"];
  if (templater && !(templater == null ? void 0 : templater.settings["trigger_on_file_creation"])) {
    await templater.templater.overwrite_file_commands(file);
  }
}

// src/main.ts
var DEFAULT_SETTINGS = {
  accessToken: "",
  linksFolderPath: "links",
  templateFilePath: "",
  syncOnLoad: false,
  customServerURL: "",
  filenameTemplate: "{{title}}"
};
var LinkStowrPlugin = class extends import_obsidian3.Plugin {
  async onload() {
    await this.loadSettings();
    this.addRibbonIcon("dice", "LinkStowr Sync", (_evt) => {
      this.sync();
    });
    this.addCommand({
      id: "sync-links",
      name: "Sync links",
      callback: async () => {
        await this.sync();
      }
    });
    this.addSettingTab(new LinkStowrSettingTab(this.app, this));
    if (this.settings.syncOnLoad) {
      await this.sync();
    }
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async sync() {
    const api = getAPI(
      this.settings.accessToken,
      this.settings.customServerURL
    );
    try {
      const response = await api.get("/api/links");
      console.log("[LinkStowr] Got response: ", response);
      const links = response.json;
      if (links) {
        const createdLinksPromises = links.map(async (link) => {
          const renderedContent = await this.getRenderedContent(link);
          const renderedFilename = await this.getRenderedFilename(link);
          try {
            const targetFile = await this.app.vault.create(
              renderedFilename,
              renderedContent
            );
            await useTemplaterPluginInFile(this.app, targetFile);
          } catch (err) {
            console.error(`Failed to create file: ${renderedFilename}`, err);
            throw new Error("Failed when creating file");
          }
        });
        await Promise.all(createdLinksPromises);
        await api.post("/api/links/clear");
        new import_obsidian3.Notice("LinkStowr Sync successful!", 3e3);
      }
    } catch (error) {
      new import_obsidian3.Notice("LinkStowr Sync failed", 3e3);
    }
  }
  async getRenderedContent(link) {
    const templateContents = await getTemplateContents(
      this.app,
      this.settings.templateFilePath
    );
    const replacedVariable = replaceVariableSyntax(
      link,
      applyTemplateTransformations(templateContents)
    );
    return executeInlineScriptsTemplates(link, replacedVariable);
  }
  async getRenderedFilename(link) {
    const templatedFilename = replaceVariableSyntax(
      link,
      this.settings.filenameTemplate
    );
    const fileName = truncate(
      replaceIllegalFileNameCharactersInString(templatedFilename),
      200
    );
    return this.getUniqueFilePath(fileName);
  }
  getUniqueFilePath(fileName) {
    let dupeCount = 0;
    const folderPath = (0, import_obsidian3.normalizePath)(this.settings.linksFolderPath);
    let path = `${folderPath}/${fileName}.md`;
    while (this.app.vault.getAbstractFileByPath(path) != null) {
      dupeCount++;
      path = `${folderPath}/${fileName}-${dupeCount}.md`;
    }
    return path;
  }
};
var LinkStowrSettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian3.Setting(containerEl).setName("Links folder path").setDesc(
      "Path to the folder to save the links to (relative to your vault). Make sure the folder exists"
    ).addText(
      (text) => text.setPlaceholder("links").setValue(this.plugin.settings.linksFolderPath).onChange(async (value) => {
        this.plugin.settings.linksFolderPath = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Access Token").setDesc("Enter your Access Token").addText(
      (text) => text.setPlaceholder("lshelf_XXXXXX_XXXXXXXXXXX").setValue(this.plugin.settings.accessToken).onChange(async (value) => {
        this.plugin.settings.accessToken = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Filename template").setDesc("Enter template for filenames generated by LinkStowr").addText(
      (text) => text.setValue(this.plugin.settings.filenameTemplate).onChange(async (value) => {
        this.plugin.settings.filenameTemplate = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Template file path").setDesc("Enter path to template file").addText(
      (text) => text.setValue(this.plugin.settings.templateFilePath).onChange(async (value) => {
        this.plugin.settings.templateFilePath = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Sync on load").setDesc("Run the Sync command when Obsidian loads").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.syncOnLoad).onChange(async (value) => {
        this.plugin.settings.syncOnLoad = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Custom server URL").setDesc(
      "Add this if you are self-hosting LinkStowr and would like to use a custom server. Make sure the URL does not end in a `/` e.g. https://www.myserver.com"
    ).addText(
      (text) => text.setPlaceholder("https://www.myserver.com").setValue(this.plugin.settings.customServerURL).onChange(async (value) => {
        this.plugin.settings.customServerURL = value;
        await this.plugin.saveSettings();
      })
    );
  }
};
