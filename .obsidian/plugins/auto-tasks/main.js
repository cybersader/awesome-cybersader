/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the GitHub repository of this plugin.
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/obsidian-daily-notes-interface/dist/main.js
var require_main = __commonJS({
  "node_modules/obsidian-daily-notes-interface/dist/main.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var obsidian = require("obsidian");
    var DEFAULT_DAILY_NOTE_FORMAT = "YYYY-MM-DD";
    var DEFAULT_WEEKLY_NOTE_FORMAT = "gggg-[W]ww";
    var DEFAULT_MONTHLY_NOTE_FORMAT = "YYYY-MM";
    var DEFAULT_QUARTERLY_NOTE_FORMAT = "YYYY-[Q]Q";
    var DEFAULT_YEARLY_NOTE_FORMAT = "YYYY";
    function shouldUsePeriodicNotesSettings(periodicity) {
      var _a, _b;
      const periodicNotes = window.app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a[periodicity]) == null ? void 0 : _b.enabled);
    }
    function getDailyNoteSettings() {
      var _a, _b, _c, _d;
      try {
        const { internalPlugins, plugins } = window.app;
        if (shouldUsePeriodicNotesSettings("daily")) {
          const { format: format2, folder: folder2, template: template2 } = ((_b = (_a = plugins.getPlugin("periodic-notes")) == null ? void 0 : _a.settings) == null ? void 0 : _b.daily) || {};
          return {
            format: format2 || DEFAULT_DAILY_NOTE_FORMAT,
            folder: (folder2 == null ? void 0 : folder2.trim()) || "",
            template: (template2 == null ? void 0 : template2.trim()) || ""
          };
        }
        const { folder, format, template } = ((_d = (_c = internalPlugins.getPluginById("daily-notes")) == null ? void 0 : _c.instance) == null ? void 0 : _d.options) || {};
        return {
          format: format || DEFAULT_DAILY_NOTE_FORMAT,
          folder: (folder == null ? void 0 : folder.trim()) || "",
          template: (template == null ? void 0 : template.trim()) || ""
        };
      } catch (err) {
        console.info("No custom daily note settings found!", err);
      }
    }
    function getWeeklyNoteSettings() {
      var _a, _b, _c, _d, _e, _f, _g;
      try {
        const pluginManager = window.app.plugins;
        const calendarSettings = (_a = pluginManager.getPlugin("calendar")) == null ? void 0 : _a.options;
        const periodicNotesSettings = (_c = (_b = pluginManager.getPlugin("periodic-notes")) == null ? void 0 : _b.settings) == null ? void 0 : _c.weekly;
        if (shouldUsePeriodicNotesSettings("weekly")) {
          return {
            format: periodicNotesSettings.format || DEFAULT_WEEKLY_NOTE_FORMAT,
            folder: ((_d = periodicNotesSettings.folder) == null ? void 0 : _d.trim()) || "",
            template: ((_e = periodicNotesSettings.template) == null ? void 0 : _e.trim()) || ""
          };
        }
        const settings = calendarSettings || {};
        return {
          format: settings.weeklyNoteFormat || DEFAULT_WEEKLY_NOTE_FORMAT,
          folder: ((_f = settings.weeklyNoteFolder) == null ? void 0 : _f.trim()) || "",
          template: ((_g = settings.weeklyNoteTemplate) == null ? void 0 : _g.trim()) || ""
        };
      } catch (err) {
        console.info("No custom weekly note settings found!", err);
      }
    }
    function getMonthlyNoteSettings() {
      var _a, _b, _c, _d;
      const pluginManager = window.app.plugins;
      try {
        const settings = shouldUsePeriodicNotesSettings("monthly") && ((_b = (_a = pluginManager.getPlugin("periodic-notes")) == null ? void 0 : _a.settings) == null ? void 0 : _b.monthly) || {};
        return {
          format: settings.format || DEFAULT_MONTHLY_NOTE_FORMAT,
          folder: ((_c = settings.folder) == null ? void 0 : _c.trim()) || "",
          template: ((_d = settings.template) == null ? void 0 : _d.trim()) || ""
        };
      } catch (err) {
        console.info("No custom monthly note settings found!", err);
      }
    }
    function getQuarterlyNoteSettings() {
      var _a, _b, _c, _d;
      const pluginManager = window.app.plugins;
      try {
        const settings = shouldUsePeriodicNotesSettings("quarterly") && ((_b = (_a = pluginManager.getPlugin("periodic-notes")) == null ? void 0 : _a.settings) == null ? void 0 : _b.quarterly) || {};
        return {
          format: settings.format || DEFAULT_QUARTERLY_NOTE_FORMAT,
          folder: ((_c = settings.folder) == null ? void 0 : _c.trim()) || "",
          template: ((_d = settings.template) == null ? void 0 : _d.trim()) || ""
        };
      } catch (err) {
        console.info("No custom quarterly note settings found!", err);
      }
    }
    function getYearlyNoteSettings() {
      var _a, _b, _c, _d;
      const pluginManager = window.app.plugins;
      try {
        const settings = shouldUsePeriodicNotesSettings("yearly") && ((_b = (_a = pluginManager.getPlugin("periodic-notes")) == null ? void 0 : _a.settings) == null ? void 0 : _b.yearly) || {};
        return {
          format: settings.format || DEFAULT_YEARLY_NOTE_FORMAT,
          folder: ((_c = settings.folder) == null ? void 0 : _c.trim()) || "",
          template: ((_d = settings.template) == null ? void 0 : _d.trim()) || ""
        };
      } catch (err) {
        console.info("No custom yearly note settings found!", err);
      }
    }
    function join(...partSegments) {
      let parts = [];
      for (let i = 0, l = partSegments.length; i < l; i++) {
        parts = parts.concat(partSegments[i].split("/"));
      }
      const newParts = [];
      for (let i = 0, l = parts.length; i < l; i++) {
        const part = parts[i];
        if (!part || part === ".")
          continue;
        else
          newParts.push(part);
      }
      if (parts[0] === "")
        newParts.unshift("");
      return newParts.join("/");
    }
    function basename(fullPath) {
      let base = fullPath.substring(fullPath.lastIndexOf("/") + 1);
      if (base.lastIndexOf(".") != -1)
        base = base.substring(0, base.lastIndexOf("."));
      return base;
    }
    async function ensureFolderExists(path) {
      const dirs = path.replace(/\\/g, "/").split("/");
      dirs.pop();
      if (dirs.length) {
        const dir = join(...dirs);
        if (!window.app.vault.getAbstractFileByPath(dir)) {
          await window.app.vault.createFolder(dir);
        }
      }
    }
    async function getNotePath(directory, filename) {
      if (!filename.endsWith(".md")) {
        filename += ".md";
      }
      const path = obsidian.normalizePath(join(directory, filename));
      await ensureFolderExists(path);
      return path;
    }
    async function getTemplateInfo(template) {
      const { metadataCache, vault } = window.app;
      const templatePath = obsidian.normalizePath(template);
      if (templatePath === "/") {
        return Promise.resolve(["", null]);
      }
      try {
        const templateFile = metadataCache.getFirstLinkpathDest(templatePath, "");
        const contents = await vault.cachedRead(templateFile);
        const IFoldInfo = window.app.foldManager.load(templateFile);
        return [contents, IFoldInfo];
      } catch (err) {
        console.error(`Failed to read the daily note template '${templatePath}'`, err);
        new obsidian.Notice("Failed to read the daily note template");
        return ["", null];
      }
    }
    function getDateUID(date, granularity = "day") {
      const ts = date.clone().startOf(granularity).format();
      return `${granularity}-${ts}`;
    }
    function removeEscapedCharacters(format) {
      return format.replace(/\[[^\]]*\]/g, "");
    }
    function isFormatAmbiguous(format, granularity) {
      if (granularity === "week") {
        const cleanFormat = removeEscapedCharacters(format);
        return /w{1,2}/i.test(cleanFormat) && (/M{1,4}/.test(cleanFormat) || /D{1,4}/.test(cleanFormat));
      }
      return false;
    }
    function getDateFromFile(file, granularity) {
      return getDateFromFilename(file.basename, granularity);
    }
    function getDateFromPath(path, granularity) {
      return getDateFromFilename(basename(path), granularity);
    }
    function getDateFromFilename(filename, granularity) {
      const getSettings = {
        day: getDailyNoteSettings,
        week: getWeeklyNoteSettings,
        month: getMonthlyNoteSettings,
        quarter: getQuarterlyNoteSettings,
        year: getYearlyNoteSettings
      };
      const format = getSettings[granularity]().format.split("/").pop();
      const noteDate = window.moment(filename, format, true);
      if (!noteDate.isValid()) {
        return null;
      }
      if (isFormatAmbiguous(format, granularity)) {
        if (granularity === "week") {
          const cleanFormat = removeEscapedCharacters(format);
          if (/w{1,2}/i.test(cleanFormat)) {
            return window.moment(
              filename,
              // If format contains week, remove day & month formatting
              format.replace(/M{1,4}/g, "").replace(/D{1,4}/g, ""),
              false
            );
          }
        }
      }
      return noteDate;
    }
    var DailyNotesFolderMissingError = class extends Error {
    };
    async function createDailyNote(date) {
      const app = window.app;
      const { vault } = app;
      const moment5 = window.moment;
      const { template, format, folder } = getDailyNoteSettings();
      const [templateContents, IFoldInfo] = await getTemplateInfo(template);
      const filename = date.format(format);
      const normalizedPath = await getNotePath(folder, filename);
      try {
        const createdFile = await vault.create(normalizedPath, templateContents.replace(/{{\s*date\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, moment5().format("HH:mm")).replace(/{{\s*title\s*}}/gi, filename).replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
          const now = moment5();
          const currentDate = date.clone().set({
            hour: now.get("hour"),
            minute: now.get("minute"),
            second: now.get("second")
          });
          if (calc) {
            currentDate.add(parseInt(timeDelta, 10), unit);
          }
          if (momentFormat) {
            return currentDate.format(momentFormat.substring(1).trim());
          }
          return currentDate.format(format);
        }).replace(/{{\s*yesterday\s*}}/gi, date.clone().subtract(1, "day").format(format)).replace(/{{\s*tomorrow\s*}}/gi, date.clone().add(1, "d").format(format)));
        app.foldManager.save(createdFile, IFoldInfo);
        return createdFile;
      } catch (err) {
        console.error(`Failed to create file: '${normalizedPath}'`, err);
        new obsidian.Notice("Unable to create new file.");
      }
    }
    function getDailyNote2(date, dailyNotes) {
      var _a;
      return (_a = dailyNotes[getDateUID(date, "day")]) != null ? _a : null;
    }
    function getAllDailyNotes2() {
      const { vault } = window.app;
      const { folder } = getDailyNoteSettings();
      const dailyNotesFolder = vault.getAbstractFileByPath(obsidian.normalizePath(folder));
      if (!dailyNotesFolder) {
        throw new DailyNotesFolderMissingError("Failed to find daily notes folder");
      }
      const dailyNotes = {};
      obsidian.Vault.recurseChildren(dailyNotesFolder, (note) => {
        if (note instanceof obsidian.TFile) {
          const date = getDateFromFile(note, "day");
          if (date) {
            const dateString = getDateUID(date, "day");
            dailyNotes[dateString] = note;
          }
        }
      });
      return dailyNotes;
    }
    var WeeklyNotesFolderMissingError = class extends Error {
    };
    function getDaysOfWeek() {
      const { moment: moment5 } = window;
      let weekStart = moment5.localeData()._week.dow;
      const daysOfWeek = [
        "sunday",
        "monday",
        "tuesday",
        "wednesday",
        "thursday",
        "friday",
        "saturday"
      ];
      while (weekStart) {
        daysOfWeek.push(daysOfWeek.shift());
        weekStart--;
      }
      return daysOfWeek;
    }
    function getDayOfWeekNumericalValue(dayOfWeekName) {
      return getDaysOfWeek().indexOf(dayOfWeekName.toLowerCase());
    }
    async function createWeeklyNote(date) {
      const { vault } = window.app;
      const { template, format, folder } = getWeeklyNoteSettings();
      const [templateContents, IFoldInfo] = await getTemplateInfo(template);
      const filename = date.format(format);
      const normalizedPath = await getNotePath(folder, filename);
      try {
        const createdFile = await vault.create(normalizedPath, templateContents.replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
          const now = window.moment();
          const currentDate = date.clone().set({
            hour: now.get("hour"),
            minute: now.get("minute"),
            second: now.get("second")
          });
          if (calc) {
            currentDate.add(parseInt(timeDelta, 10), unit);
          }
          if (momentFormat) {
            return currentDate.format(momentFormat.substring(1).trim());
          }
          return currentDate.format(format);
        }).replace(/{{\s*title\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm")).replace(/{{\s*(sunday|monday|tuesday|wednesday|thursday|friday|saturday)\s*:(.*?)}}/gi, (_, dayOfWeek, momentFormat) => {
          const day = getDayOfWeekNumericalValue(dayOfWeek);
          return date.weekday(day).format(momentFormat.trim());
        }));
        window.app.foldManager.save(createdFile, IFoldInfo);
        return createdFile;
      } catch (err) {
        console.error(`Failed to create file: '${normalizedPath}'`, err);
        new obsidian.Notice("Unable to create new file.");
      }
    }
    function getWeeklyNote2(date, weeklyNotes) {
      var _a;
      return (_a = weeklyNotes[getDateUID(date, "week")]) != null ? _a : null;
    }
    function getAllWeeklyNotes2() {
      const weeklyNotes = {};
      if (!appHasWeeklyNotesPluginLoaded()) {
        return weeklyNotes;
      }
      const { vault } = window.app;
      const { folder } = getWeeklyNoteSettings();
      const weeklyNotesFolder = vault.getAbstractFileByPath(obsidian.normalizePath(folder));
      if (!weeklyNotesFolder) {
        throw new WeeklyNotesFolderMissingError("Failed to find weekly notes folder");
      }
      obsidian.Vault.recurseChildren(weeklyNotesFolder, (note) => {
        if (note instanceof obsidian.TFile) {
          const date = getDateFromFile(note, "week");
          if (date) {
            const dateString = getDateUID(date, "week");
            weeklyNotes[dateString] = note;
          }
        }
      });
      return weeklyNotes;
    }
    var MonthlyNotesFolderMissingError = class extends Error {
    };
    async function createMonthlyNote(date) {
      const { vault } = window.app;
      const { template, format, folder } = getMonthlyNoteSettings();
      const [templateContents, IFoldInfo] = await getTemplateInfo(template);
      const filename = date.format(format);
      const normalizedPath = await getNotePath(folder, filename);
      try {
        const createdFile = await vault.create(normalizedPath, templateContents.replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
          const now = window.moment();
          const currentDate = date.clone().set({
            hour: now.get("hour"),
            minute: now.get("minute"),
            second: now.get("second")
          });
          if (calc) {
            currentDate.add(parseInt(timeDelta, 10), unit);
          }
          if (momentFormat) {
            return currentDate.format(momentFormat.substring(1).trim());
          }
          return currentDate.format(format);
        }).replace(/{{\s*date\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm")).replace(/{{\s*title\s*}}/gi, filename));
        window.app.foldManager.save(createdFile, IFoldInfo);
        return createdFile;
      } catch (err) {
        console.error(`Failed to create file: '${normalizedPath}'`, err);
        new obsidian.Notice("Unable to create new file.");
      }
    }
    function getMonthlyNote(date, monthlyNotes) {
      var _a;
      return (_a = monthlyNotes[getDateUID(date, "month")]) != null ? _a : null;
    }
    function getAllMonthlyNotes() {
      const monthlyNotes = {};
      if (!appHasMonthlyNotesPluginLoaded()) {
        return monthlyNotes;
      }
      const { vault } = window.app;
      const { folder } = getMonthlyNoteSettings();
      const monthlyNotesFolder = vault.getAbstractFileByPath(obsidian.normalizePath(folder));
      if (!monthlyNotesFolder) {
        throw new MonthlyNotesFolderMissingError("Failed to find monthly notes folder");
      }
      obsidian.Vault.recurseChildren(monthlyNotesFolder, (note) => {
        if (note instanceof obsidian.TFile) {
          const date = getDateFromFile(note, "month");
          if (date) {
            const dateString = getDateUID(date, "month");
            monthlyNotes[dateString] = note;
          }
        }
      });
      return monthlyNotes;
    }
    var QuarterlyNotesFolderMissingError = class extends Error {
    };
    async function createQuarterlyNote(date) {
      const { vault } = window.app;
      const { template, format, folder } = getQuarterlyNoteSettings();
      const [templateContents, IFoldInfo] = await getTemplateInfo(template);
      const filename = date.format(format);
      const normalizedPath = await getNotePath(folder, filename);
      try {
        const createdFile = await vault.create(normalizedPath, templateContents.replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
          const now = window.moment();
          const currentDate = date.clone().set({
            hour: now.get("hour"),
            minute: now.get("minute"),
            second: now.get("second")
          });
          if (calc) {
            currentDate.add(parseInt(timeDelta, 10), unit);
          }
          if (momentFormat) {
            return currentDate.format(momentFormat.substring(1).trim());
          }
          return currentDate.format(format);
        }).replace(/{{\s*date\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm")).replace(/{{\s*title\s*}}/gi, filename));
        window.app.foldManager.save(createdFile, IFoldInfo);
        return createdFile;
      } catch (err) {
        console.error(`Failed to create file: '${normalizedPath}'`, err);
        new obsidian.Notice("Unable to create new file.");
      }
    }
    function getQuarterlyNote(date, quarterly) {
      var _a;
      return (_a = quarterly[getDateUID(date, "quarter")]) != null ? _a : null;
    }
    function getAllQuarterlyNotes() {
      const quarterly = {};
      if (!appHasQuarterlyNotesPluginLoaded()) {
        return quarterly;
      }
      const { vault } = window.app;
      const { folder } = getQuarterlyNoteSettings();
      const quarterlyFolder = vault.getAbstractFileByPath(obsidian.normalizePath(folder));
      if (!quarterlyFolder) {
        throw new QuarterlyNotesFolderMissingError("Failed to find quarterly notes folder");
      }
      obsidian.Vault.recurseChildren(quarterlyFolder, (note) => {
        if (note instanceof obsidian.TFile) {
          const date = getDateFromFile(note, "quarter");
          if (date) {
            const dateString = getDateUID(date, "quarter");
            quarterly[dateString] = note;
          }
        }
      });
      return quarterly;
    }
    var YearlyNotesFolderMissingError = class extends Error {
    };
    async function createYearlyNote(date) {
      const { vault } = window.app;
      const { template, format, folder } = getYearlyNoteSettings();
      const [templateContents, IFoldInfo] = await getTemplateInfo(template);
      const filename = date.format(format);
      const normalizedPath = await getNotePath(folder, filename);
      try {
        const createdFile = await vault.create(normalizedPath, templateContents.replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
          const now = window.moment();
          const currentDate = date.clone().set({
            hour: now.get("hour"),
            minute: now.get("minute"),
            second: now.get("second")
          });
          if (calc) {
            currentDate.add(parseInt(timeDelta, 10), unit);
          }
          if (momentFormat) {
            return currentDate.format(momentFormat.substring(1).trim());
          }
          return currentDate.format(format);
        }).replace(/{{\s*date\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm")).replace(/{{\s*title\s*}}/gi, filename));
        window.app.foldManager.save(createdFile, IFoldInfo);
        return createdFile;
      } catch (err) {
        console.error(`Failed to create file: '${normalizedPath}'`, err);
        new obsidian.Notice("Unable to create new file.");
      }
    }
    function getYearlyNote(date, yearlyNotes) {
      var _a;
      return (_a = yearlyNotes[getDateUID(date, "year")]) != null ? _a : null;
    }
    function getAllYearlyNotes() {
      const yearlyNotes = {};
      if (!appHasYearlyNotesPluginLoaded()) {
        return yearlyNotes;
      }
      const { vault } = window.app;
      const { folder } = getYearlyNoteSettings();
      const yearlyNotesFolder = vault.getAbstractFileByPath(obsidian.normalizePath(folder));
      if (!yearlyNotesFolder) {
        throw new YearlyNotesFolderMissingError("Failed to find yearly notes folder");
      }
      obsidian.Vault.recurseChildren(yearlyNotesFolder, (note) => {
        if (note instanceof obsidian.TFile) {
          const date = getDateFromFile(note, "year");
          if (date) {
            const dateString = getDateUID(date, "year");
            yearlyNotes[dateString] = note;
          }
        }
      });
      return yearlyNotes;
    }
    function appHasDailyNotesPluginLoaded() {
      var _a, _b;
      const { app } = window;
      const dailyNotesPlugin = app.internalPlugins.plugins["daily-notes"];
      if (dailyNotesPlugin && dailyNotesPlugin.enabled) {
        return true;
      }
      const periodicNotes = app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a.daily) == null ? void 0 : _b.enabled);
    }
    function appHasWeeklyNotesPluginLoaded() {
      var _a, _b;
      const { app } = window;
      if (app.plugins.getPlugin("calendar")) {
        return true;
      }
      const periodicNotes = app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a.weekly) == null ? void 0 : _b.enabled);
    }
    function appHasMonthlyNotesPluginLoaded() {
      var _a, _b;
      const { app } = window;
      const periodicNotes = app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a.monthly) == null ? void 0 : _b.enabled);
    }
    function appHasQuarterlyNotesPluginLoaded() {
      var _a, _b;
      const { app } = window;
      const periodicNotes = app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a.quarterly) == null ? void 0 : _b.enabled);
    }
    function appHasYearlyNotesPluginLoaded() {
      var _a, _b;
      const { app } = window;
      const periodicNotes = app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a.yearly) == null ? void 0 : _b.enabled);
    }
    function getPeriodicNoteSettings(granularity) {
      const getSettings = {
        day: getDailyNoteSettings,
        week: getWeeklyNoteSettings,
        month: getMonthlyNoteSettings,
        quarter: getQuarterlyNoteSettings,
        year: getYearlyNoteSettings
      }[granularity];
      return getSettings();
    }
    function createPeriodicNote(granularity, date) {
      const createFn = {
        day: createDailyNote,
        month: createMonthlyNote,
        week: createWeeklyNote
      };
      return createFn[granularity](date);
    }
    exports.DEFAULT_DAILY_NOTE_FORMAT = DEFAULT_DAILY_NOTE_FORMAT;
    exports.DEFAULT_MONTHLY_NOTE_FORMAT = DEFAULT_MONTHLY_NOTE_FORMAT;
    exports.DEFAULT_QUARTERLY_NOTE_FORMAT = DEFAULT_QUARTERLY_NOTE_FORMAT;
    exports.DEFAULT_WEEKLY_NOTE_FORMAT = DEFAULT_WEEKLY_NOTE_FORMAT;
    exports.DEFAULT_YEARLY_NOTE_FORMAT = DEFAULT_YEARLY_NOTE_FORMAT;
    exports.appHasDailyNotesPluginLoaded = appHasDailyNotesPluginLoaded;
    exports.appHasMonthlyNotesPluginLoaded = appHasMonthlyNotesPluginLoaded;
    exports.appHasQuarterlyNotesPluginLoaded = appHasQuarterlyNotesPluginLoaded;
    exports.appHasWeeklyNotesPluginLoaded = appHasWeeklyNotesPluginLoaded;
    exports.appHasYearlyNotesPluginLoaded = appHasYearlyNotesPluginLoaded;
    exports.createDailyNote = createDailyNote;
    exports.createMonthlyNote = createMonthlyNote;
    exports.createPeriodicNote = createPeriodicNote;
    exports.createQuarterlyNote = createQuarterlyNote;
    exports.createWeeklyNote = createWeeklyNote;
    exports.createYearlyNote = createYearlyNote;
    exports.getAllDailyNotes = getAllDailyNotes2;
    exports.getAllMonthlyNotes = getAllMonthlyNotes;
    exports.getAllQuarterlyNotes = getAllQuarterlyNotes;
    exports.getAllWeeklyNotes = getAllWeeklyNotes2;
    exports.getAllYearlyNotes = getAllYearlyNotes;
    exports.getDailyNote = getDailyNote2;
    exports.getDailyNoteSettings = getDailyNoteSettings;
    exports.getDateFromFile = getDateFromFile;
    exports.getDateFromPath = getDateFromPath;
    exports.getDateUID = getDateUID;
    exports.getMonthlyNote = getMonthlyNote;
    exports.getMonthlyNoteSettings = getMonthlyNoteSettings;
    exports.getPeriodicNoteSettings = getPeriodicNoteSettings;
    exports.getQuarterlyNote = getQuarterlyNote;
    exports.getQuarterlyNoteSettings = getQuarterlyNoteSettings;
    exports.getTemplateInfo = getTemplateInfo;
    exports.getWeeklyNote = getWeeklyNote2;
    exports.getWeeklyNoteSettings = getWeeklyNoteSettings;
    exports.getYearlyNote = getYearlyNote;
    exports.getYearlyNoteSettings = getYearlyNoteSettings;
  }
});

// src/index.ts
var index_exports = {};
__export(index_exports, {
  default: () => AutoTasks
});
module.exports = __toCommonJS(index_exports);
var import_obsidian9 = require("obsidian");

// src/events.ts
var SETTINGS_UPDATED = "auto-tasks:settings-updated";

// src/tasks/task.ts
var import_obsidian = require("obsidian");
var METADATA_CHARS = "\u{1F4C5}\u{1F6EB}\u23F3\u23EB\u{1F53C}\u{1F53D}\u{1F53A}\u23EC\u{1F194}\u26D4\u{1F501}\u2795\u2705";
var TASK_COMPLETE = /^-\s\[x\]/;
var TASK_DUE_DATE = /\sðŸ“…\s(\d{4}-\d{2}-\d{2})/;
var TASK_NAME = /^(-\s\[[x\s]\]\s)(.*?)(?:\s[ðŸ“…ðŸ›«â³â«ðŸ”¼ðŸ”½ðŸ”ºâ¬ðŸ†”â›”ðŸ”âž•âœ…]|$)/;
var DUE_DATE_FORMAT = "YYYY-MM-DD";
var Task = class {
  constructor(line) {
    this.carriedOver = false;
    this.metadata = "";
    this.name = "";
    this.line = line;
    this.parse();
  }
  equals(task) {
    return this.name === task.getName();
  }
  getDueDate() {
    const meta = this.getMetadata();
    return meta.get("\u{1F4C5}");
  }
  getMetadata() {
    const map = /* @__PURE__ */ new Map();
    for (const char of METADATA_CHARS) {
      if (this.metadata.includes(char)) {
        const matched = this.metadata.match(new RegExp(String.raw`\s${char}\s(.*?)(?:\s|$)`));
        if (matched) {
          map.set(char, matched[1]);
        }
      }
    }
    return map;
  }
  getName() {
    return this.name;
  }
  isComplete() {
    return !!this.complete;
  }
  isDue() {
    if (this.dueDate === void 0) {
      const matched = this.line.match(TASK_DUE_DATE);
      if (matched) {
        this.dueDate = (0, import_obsidian.moment)(matched[1]);
      }
    }
    return !!(this.dueDate && this.dueDate.isBefore((0, import_obsidian.moment)().add(1, "day")));
  }
  markCarriedOver() {
    this.carriedOver = true;
    return this;
  }
  parse() {
    const matched = this.line.match(TASK_NAME);
    if (matched) {
      this.name = matched[2];
      this.metadata = this.line.replace(matched[1] + matched[2], "");
    }
    this.complete = !!this.line.match(TASK_COMPLETE);
    const carriedOverPrefix = AutoTasks.getSettings().carryOverPrefix;
    if (carriedOverPrefix && this.name.startsWith(carriedOverPrefix)) {
      this.carriedOver = true;
      this.name = this.name.replace(carriedOverPrefix + " ", "");
    }
  }
  toString() {
    const carriedOver = this.carriedOver ? AutoTasks.getSettings().carryOverPrefix + " " : "";
    const complete = this.complete ? "x" : " ";
    let metadata = this.metadata;
    if (this.dueDate) {
      metadata = metadata.replace(TASK_DUE_DATE, ` \u{1F4C5} ${this.dueDate.format(DUE_DATE_FORMAT)}`);
    }
    return `- [${complete}] ${carriedOver}${this.name}${metadata}`;
  }
};

// src/tasks/collection.ts
var HEADER_LINE = /^#{1,6}/;
var TASK_LINE = /^-\s\[[x\s]\]/;
var TaskCollection = class {
  constructor(contents, addBoardHeaders) {
    const lines = contents.split("\n");
    this.tasks = /* @__PURE__ */ new Map();
    let currentHeader = "";
    for (const line of lines) {
      if (line.match(HEADER_LINE)) {
        currentHeader = line;
        this.tasks.set(currentHeader, []);
      }
      if (line.match(TASK_LINE)) {
        const existingTasks = this.tasks.get(currentHeader) || [];
        existingTasks.push(new Task(line));
        this.tasks.set(currentHeader, existingTasks);
      }
    }
    if (addBoardHeaders) {
      if (!this.tasks.has(UPCOMING)) {
        this.tasks.set(UPCOMING, []);
      }
      if (!this.tasks.has(DUE)) {
        this.tasks.set(DUE, []);
      }
      if (!this.tasks.has(PROGRESS)) {
        this.tasks.set(PROGRESS, []);
      }
      if (!this.tasks.has(DONE)) {
        this.tasks.set(DONE, []);
      }
    }
  }
  add(task, header) {
    if (!header) {
      header = task.isComplete() ? DONE : task.isDue() ? DUE : UPCOMING;
    }
    const headerObj = this.tasks.get(header);
    if (headerObj !== void 0 && headerObj.findIndex((t) => t.equals(task)) > -1) {
      return;
    }
    headerObj == null ? void 0 : headerObj.push(task);
  }
  getAllTasks() {
    return Array.from(this.tasks.values()).flat();
  }
  getList(task) {
    for (let [list, tasks] of this.tasks) {
      for (const existingTask of tasks) {
        if (task.equals(existingTask)) {
          return list;
        }
      }
    }
    return "";
  }
  getTask(task) {
    for (const tasksList of this.tasks.values()) {
      for (const existingTask of tasksList) {
        if (existingTask.equals(task)) {
          return existingTask;
        }
      }
    }
  }
  getTasksFromLists(lists) {
    const returnTasks = [];
    this.tasks.forEach((value, list) => {
      if (!lists.length || lists[0] === "" || lists.indexOf(list) > -1) {
        returnTasks.push(...value);
      }
    });
    return returnTasks;
  }
  move(task, newList) {
    var _a, _b, _c;
    const oldList = this.getList(task);
    const index = (_a = this.tasks.get(oldList)) == null ? void 0 : _a.findIndex((t) => t.equals(task));
    if (index !== void 0 && index > -1) {
      (_b = this.tasks.get(oldList)) == null ? void 0 : _b.splice(index, 1);
    }
    (_c = this.tasks.get(newList)) == null ? void 0 : _c.push(task);
  }
  replace(task) {
    var _a;
    const list = this.getList(task);
    const existingTask = (_a = this.tasks.get(list)) == null ? void 0 : _a.find((t) => t.equals(task));
    if (existingTask) {
      Object.assign(existingTask, task);
    }
  }
  toString(headerSeparator) {
    headerSeparator = headerSeparator || "\n";
    let content = "";
    for (let [list, tasks] of this.tasks) {
      content = `${content}${list}

`;
      for (const task of tasks) {
        content = `${content}${task.toString()}
`;
      }
      content = `${content}${headerSeparator}`;
    }
    return content;
  }
};

// src/kanban/board.ts
var UPCOMING = "## Upcoming";
var DUE = "## Due";
var PROGRESS = "## In progress";
var DONE = "## Done";
var KANBAN_PROPERTY_NAME = "kanban-plugin";
var KANBAN_PROPERTY_VALUE = "board";
var HEADER = `
---

${KANBAN_PROPERTY_NAME}: ${KANBAN_PROPERTY_VALUE}

---
`.trim();
var FOOTER = `
%% kanban:settings
\`\`\`
{"kanban-plugin":"board","list-collapse":[false,false,false,false]}
\`\`\`
%%
`.trim();
var KanbanBoard = class {
  constructor(fileName, contents) {
    this.fileName = fileName;
    if (!contents) {
      contents = `${UPCOMING}



${DUE}



${PROGRESS}



${DONE}



`;
    }
    this.contents = contents;
  }
  getFileName() {
    return this.fileName;
  }
  getTaskCollection() {
    if (!this.tasks) {
      this.tasks = new TaskCollection(this.contents, true);
    }
    return this.tasks;
  }
  toString() {
    return `${HEADER}

${this.getTaskCollection().toString("\n\n\n\n")}


${FOOTER}`;
  }
};

// src/kanban/board-manager.ts
var KanbanBoardManager = class {
  constructor(vault, metadataCache) {
    this.vault = vault;
    this.metadataCache = metadataCache;
  }
  getAllBoards() {
    const boards = [];
    for (const file of this.vault.getFiles()) {
      if (this.isBoard(file)) {
        boards.push(file);
      }
    }
    return boards;
  }
  isBoard(file) {
    const fileCache = this.metadataCache.getFileCache(file);
    if (fileCache === null) {
      return false;
    }
    if (fileCache.frontmatter === void 0) {
      return false;
    }
    if (typeof fileCache.frontmatter[KANBAN_PROPERTY_NAME] === "undefined") {
      return false;
    }
    return fileCache.frontmatter[KANBAN_PROPERTY_NAME] === KANBAN_PROPERTY_VALUE;
  }
  async get(fileName) {
    const file = this.vault.getFileByPath(fileName);
    if (file === null) {
      throw new KanbanBoardOpenError();
    }
    return new KanbanBoard(fileName, await this.vault.read(file));
  }
};
var KanbanBoardOpenError = class extends Error {
};

// src/kanban/synchroniser.ts
var import_obsidian2 = require("obsidian");
var KanbanSynchroniser = class {
  constructor(plugin, vault) {
    this.plugin = plugin;
    this.vault = vault;
  }
  async process(board, files) {
    if (!files || !files.length) {
      files = this.vault.getFiles();
    }
    files = files.filter((file) => {
      let valid = true;
      this.plugin.getSettings().kanbanIgnoreFolders.forEach((folder) => {
        if (file.path.startsWith(folder + "/")) {
          valid = false;
        }
      });
      return valid;
    });
    for (const file of files) {
      if (file.name !== board.getFileName()) {
        await this.processSingle(board, file);
      }
    }
    const boardFile = this.vault.getFileByPath(board.getFileName());
    if (boardFile instanceof import_obsidian2.TFile) {
      await this.vault.modify(boardFile, board.toString());
    }
  }
  async processSingle(board, file) {
    const kanbanTasks = board.getTaskCollection();
    const fileTasks = new TaskCollection(await this.vault.read(file), true).getAllTasks();
    for (const task of fileTasks) {
      if (this.plugin.getSettings().kanbanIgnoreMatches.filter((ignore) => task.getName().match(ignore)).length > 0) {
        continue;
      }
      ;
      const existingTask = kanbanTasks.getTask(task);
      if (!existingTask) {
        kanbanTasks.add(task);
      } else {
        if (!task.isComplete() && kanbanTasks.getList(task) === DONE) {
          kanbanTasks.move(task, task.isDue() ? DUE : UPCOMING);
        } else if (task.isDue() && !task.isComplete()) {
          if (kanbanTasks.getList(task) !== DUE) {
            kanbanTasks.move(task, DUE);
          }
        } else if (task.isComplete() && kanbanTasks.getList(task) !== DONE) {
          kanbanTasks.move(task, DONE);
        } else {
          kanbanTasks.replace(task);
        }
      }
    }
  }
};

// src/kanban/watcher.ts
var DEFAULT_TIMEOUT = 5e3;
var Watcher = class {
  constructor(kanban, timeoutValue) {
    this.timeouts = /* @__PURE__ */ new Map();
    this.kanban = kanban;
    this.timeoutValue = timeoutValue || DEFAULT_TIMEOUT;
  }
  notifyCreate(file) {
    this.timeouts.set(file.name, window.setTimeout(this.run.bind(this, file), this.timeoutValue));
  }
  notifyModify(file) {
    if (this.timeouts.has(file.name)) {
      window.clearTimeout(this.timeouts.get(file.name));
    }
    this.timeouts.set(file.name, window.setTimeout(this.run.bind(this, file), this.timeoutValue));
  }
  notifyRename(file, oldFileName) {
    if (this.timeouts.has(oldFileName)) {
      window.clearTimeout(this.timeouts.get(oldFileName));
    }
    this.timeouts.set(file.name, window.setTimeout(this.run.bind(this, file), this.timeoutValue));
  }
  notifyDelete(file) {
    if (this.timeouts.has(file.name)) {
      window.clearTimeout(this.timeouts.get(file.name));
    }
  }
  run(file) {
    this.kanban.synchroniseTasks([file]);
  }
};

// src/kanban/provider.ts
var KanbanProvider = class {
  constructor(plugin, vault, metadataCache, boardManager, synchroniser, watcher) {
    this.plugin = plugin;
    this.boardManager = boardManager || new KanbanBoardManager(vault, metadataCache);
    this.synchroniser = synchroniser || new KanbanSynchroniser(plugin, vault);
    this.watcher = watcher || new Watcher(this);
  }
  async synchroniseTasks(files) {
    const settings = this.plugin.getSettings();
    if (!settings.kanbanSync) {
      return;
    }
    try {
      const board = await this.boardManager.get(settings.kanbanFile);
      return this.synchroniser.process(board, files);
    } catch (err) {
      return;
    }
  }
  async getBoard() {
    const settings = this.plugin.getSettings();
    if (!settings.kanbanSync) {
      return void 0;
    }
    return await this.boardManager.get(settings.kanbanFile);
  }
  getBoardManager() {
    return this.boardManager;
  }
  getWatcher() {
    return this.watcher;
  }
};

// src/plugins/kanban.ts
var PLUGIN_NAME = "obsidian-kanban";
var KanbanPluginAdapter = class {
  constructor(app) {
    this.app = app;
  }
  isEnabled() {
    return this.app.plugins.enabledPlugins.has(PLUGIN_NAME);
  }
};

// src/plugins/periodic-notes.ts
var PLUGIN_NAME2 = "periodic-notes";
var PERIODIC_NOTES_EVENT_SETTING_UPDATED = "periodic-notes:settings-updated";
var PeriodicNotesPluginAdapter = class {
  constructor(app) {
    this.app = app;
  }
  isEnabled() {
    return this.app.plugins.enabledPlugins.has(PLUGIN_NAME2);
  }
  getPlugin() {
    return this.app.plugins.getPlugin(PLUGIN_NAME2);
  }
  getSettings() {
    return this.getPlugin().settings || {
      daily: { enabled: false },
      weekly: { enabled: false }
    };
  }
  convertSettings(settings) {
    const periodicNotesSettings = this.getSettings();
    settings.daily.available = periodicNotesSettings.daily.enabled;
    settings.weekly.available = periodicNotesSettings.weekly.enabled;
    return settings;
  }
};

// src/plugins/tasks.ts
var PLUGIN_NAME3 = "obsidian-tasks-plugin";
var TasksPluginAdapter = class {
  constructor(app) {
    this.app = app;
  }
  isEnabled() {
    return this.app.plugins.enabledPlugins.has(PLUGIN_NAME3);
  }
};

// src/settings/index.ts
var DEFAULT_SETTINGS = Object.freeze({
  carryOverPrefix: "",
  kanbanSync: false,
  kanbanFile: "",
  kanbanIgnoreFolders: [],
  kanbanIgnoreMatches: [],
  tasksAvailable: false,
  daily: {
    addDue: false,
    available: false,
    carryOver: false,
    header: "## TODOs",
    searchHeaders: []
  },
  weekly: {
    addDue: false,
    available: false,
    carryOver: false,
    header: "## TODOs",
    searchHeaders: []
  }
});

// src/settings/tab.ts
var import_obsidian5 = require("obsidian");

// src/ui/suggest.ts
var import_obsidian3 = require("obsidian");
var Suggest = class extends import_obsidian3.AbstractInputSuggest {
  constructor(app, options, el) {
    super(app, el);
    this.options = /* @__PURE__ */ new Set();
    this.el = el;
    options.forEach((option) => {
      this.options.add(option.path);
    });
  }
  getSuggestions(query) {
    query = query.toLocaleLowerCase();
    return [...this.options].filter((path) => path.toLocaleLowerCase().contains(query));
  }
  renderSuggestion(value, el) {
    el.setText(value);
  }
  selectSuggestion(value, evt) {
    this.el.value = value;
    this.el.dispatchEvent(new Event("input"));
    this.close();
  }
};

// src/utils/index.ts
function capitalise(text) {
  return text.charAt(0).toUpperCase() + text.slice(1);
}

// src/settings/ignore-component.ts
var import_obsidian4 = require("obsidian");
var IgnoreComponent = class {
  constructor(app, plugin, el) {
    this.app = app;
    this.plugin = plugin;
    this.el = el;
    this.settings = this.plugin.getSettings();
  }
  display() {
    this.el.empty();
    this.existingContainerEl = this.el.createDiv({ cls: "at--setting-existing-container" });
    this.buttonContainerEl = this.el.createDiv({ cls: "at--setting-button-container" });
    this.createIgnoredEntries();
    this.createAddControls();
  }
  createIgnoredEntries() {
    for (const entry of this.getIgnoredSetting()) {
      const existingWrapperEl = this.existingContainerEl.createDiv({ cls: "at--setting-existing-wrapper" });
      const existingItemEl = existingWrapperEl.createDiv({ cls: "at--setting-existing-item" });
      const existingItemControlsEl = existingItemEl.createDiv({ cls: "at--setting-existing-controls" });
      const existingItemInputEl = existingItemControlsEl.createEl("input", { type: "text" });
      existingItemInputEl.setAttribute("readonly", "readonly");
      existingItemInputEl.setAttribute("value", entry);
      const existingItemButtonsEl = existingItemEl.createDiv({ cls: "at--setting-existing-buttons" });
      const deleteEl = existingItemButtonsEl.createEl("a");
      (0, import_obsidian4.setIcon)(deleteEl, "lucide-trash-2");
      deleteEl.setAttribute("data-setting", entry);
      deleteEl.addEventListener("click", (event) => {
        this.handleRemoveIgnoredEntry(entry);
        event.stopPropagation();
      });
    }
  }
  createAddControls() {
    const controlsWrapperEl = this.buttonContainerEl.createDiv("at--setting-controls-wrapper");
    this.addEntryInputEl = controlsWrapperEl.createEl("input", { type: "text" });
    const addEl = controlsWrapperEl.createEl("button", { cls: "button", text: "Add entry" });
    addEl.addEventListener("click", (event) => {
      this.handleAddIgnoredEntry(this.addEntryInputEl.value);
      this.addEntryInputEl.value = "";
      event.stopPropagation();
    });
  }
  async handleAddIgnoredEntry(entry) {
    this.getIgnoredSetting().push(entry);
    await this.saveAndReset();
  }
  async handleRemoveIgnoredEntry(entry) {
    this.getIgnoredSetting().remove(entry);
    await this.saveAndReset();
  }
  async saveAndReset() {
    await this.plugin.updateSettings(this.settings);
    this.display();
  }
};

// src/settings/ignore-folders.ts
var IgnoreFolders = class extends IgnoreComponent {
  constructor(app, plugin, el, folders) {
    super(app, plugin, el);
    this.folders = folders.sort((a, b) => a.name.localeCompare(b.name));
  }
  getIgnoredSetting() {
    return this.settings.kanbanIgnoreFolders;
  }
  createAddControls() {
    const controlsWrapperEl = this.buttonContainerEl.createDiv("at--setting-controls-wrapper");
    this.addEntryInputEl = controlsWrapperEl.createEl("input", { type: "text" });
    new Suggest(this.app, this.folders.filter((folder) => this.settings.kanbanIgnoreFolders.indexOf(folder.path) === -1), this.addEntryInputEl);
    const addEl = controlsWrapperEl.createEl("button", { cls: "button", text: "Add folder" });
    addEl.addEventListener("click", (event) => {
      this.handleAddIgnoredEntry(this.addEntryInputEl.value);
      this.addEntryInputEl.value = "";
      event.stopPropagation();
    });
  }
};

// src/settings/ignore-matches.ts
var IgnoreMatches = class extends IgnoreComponent {
  getIgnoredSetting() {
    return this.settings.kanbanIgnoreMatches;
  }
};

// src/settings/tab.ts
var AutoTasksSettingsTab = class extends import_obsidian5.PluginSettingTab {
  constructor(app, plugin, kanbanPlugin, kanban) {
    super(app, plugin);
    this.vault = app.vault;
    this.plugin = plugin;
    this.kanbanPlugin = kanbanPlugin;
    this.kanban = kanban;
  }
  display() {
    this.containerEl.empty();
    let settings = this.plugin.getSettings();
    const periodicities = [
      "daily",
      "weekly"
    ];
    if (!settings.daily.available && !settings.weekly.available) {
      const periodicBannerEl = this.containerEl.createDiv({ cls: "settings-banner" });
      new import_obsidian5.Setting(periodicBannerEl).setName("No periodic notes enabled").setHeading().setDesc("No periodic notes settings are enabled. You must turn on either the daily or weekly notes within the Periodic Notes plugin settings to be able to configure automatic tasks.");
    }
    if (!settings.tasksAvailable) {
      const tasksBannerEl = this.containerEl.createDiv({ cls: "settings-banner" });
      new import_obsidian5.Setting(tasksBannerEl).setName("Tasks due date support").setHeading().setDesc("Download and enable the Tasks plugin to enable due date functionality within your tasks and TODOs.");
    }
    new import_obsidian5.Setting(this.containerEl).setName("All tasks").setHeading();
    new import_obsidian5.Setting(this.containerEl).setName("Prefix for carried over tasks").setDesc('The prefix to add to any carried over tasks, e.g. "[>]".').addText((text) => {
      text.setValue(settings.carryOverPrefix).onChange(async (val) => {
        settings.carryOverPrefix = val;
        await this.plugin.updateSettings(settings);
      });
    });
    for (const periodicity of periodicities) {
      if (settings[periodicity].available) {
        new import_obsidian5.Setting(this.containerEl).setName(`${capitalise(periodicity)} notes`).setHeading();
        new import_obsidian5.Setting(this.containerEl).setName(`Carry over ${periodicity} tasks`).setDesc(`Whether any ${periodicity} tasks that are incomplete should be automatically carried over to the following note.`).addToggle((toggle) => {
          toggle.setValue(settings[periodicity].carryOver).onChange(async (val) => {
            settings[periodicity].carryOver = val;
            await this.plugin.updateSettings(settings);
          });
        });
        if (settings.tasksAvailable) {
          new import_obsidian5.Setting(this.containerEl).setName("Add due tasks").setDesc(`Whether any tasks from anywhere else in the vault should be added that are marked as due within the ${periodicity} period.`).addToggle((toggle) => {
            toggle.setValue(settings[periodicity].addDue).onChange(async (val) => {
              settings[periodicity].addDue = val;
              await this.plugin.updateSettings(settings);
            });
          });
        }
        new import_obsidian5.Setting(this.containerEl).setName(`${capitalise(periodicity)} tasks header`).setDesc("Set the header to be added to the top of the tasks section within new notes - include any markdown to set the heading style.").addText((text) => {
          text.setValue(settings[periodicity].header).onChange(async (val) => {
            settings[periodicity].header = val;
            await this.plugin.updateSettings(settings);
          });
        });
        new import_obsidian5.Setting(this.containerEl).setName("Heading(s) to search for tasks").setDesc("Comma-separated list of headings within the notes to search and include any carry over tasks from. Leave this blank to search the entire note.").addText((text) => {
          text.setValue(settings[periodicity].searchHeaders ? settings[periodicity].searchHeaders.join(",") : "").onChange(async (val) => {
            settings[periodicity].searchHeaders = val.split(",");
            await this.plugin.updateSettings(settings);
          });
        });
      }
    }
    const kanbanEl = this.containerEl.createDiv();
    new import_obsidian5.Setting(kanbanEl).setName("Kanban board").setHeading();
    if (!this.kanbanPlugin.isEnabled()) {
      const bannerEl = kanbanEl.createDiv({ cls: "settings-banner" });
      new import_obsidian5.Setting(bannerEl).setName("Kanban support").setHeading().setDesc("Download and enable the Kanban plugin to automatically sync tasks into your chosen Kanban board.");
    } else {
      const syncSetting = new import_obsidian5.Setting(kanbanEl);
      const fileSetting = new import_obsidian5.Setting(kanbanEl);
      const ignoreFoldersSetting = new import_obsidian5.Setting(kanbanEl);
      const ignoreMatchesSetting = new import_obsidian5.Setting(kanbanEl);
      syncSetting.setName("Automatically synchronise tasks to Kanban board").setDesc("Any newly discovered tasks will be added into the Kanban board you choose.").addToggle((toggle) => {
        toggle.setValue(settings.kanbanSync).onChange(async (val) => {
          fileSetting.setDisabled(!val);
          settings.kanbanSync = val;
          await this.plugin.updateSettings(settings);
        });
      });
      const boards = this.kanban.getBoardManager().getAllBoards();
      fileSetting.setName("Primary Kanban board").setDesc("This is the Kanban board that will have tasks automatically added.").addSearch((search) => {
        search.setPlaceholder("Example: board.md").setValue(settings.kanbanFile).onChange(async (val) => {
          search.inputEl.classList.remove("has-error");
          if (boards.map((board) => board.path).indexOf(val) === -1) {
            search.inputEl.classList.add("has-error");
          } else {
            settings.kanbanFile = val;
            await this.plugin.updateSettings(settings);
          }
        });
        if (settings.kanbanSync && settings.kanbanFile === "") {
          search.inputEl.classList.add("has-error");
        }
        new Suggest(this.app, boards, search.inputEl);
      });
      ignoreFoldersSetting.setName("Folder(s) to ignore").setDesc("Select folders to ignore reading tasks from when syncing to the Kanban board.");
      new IgnoreFolders(this.app, this.plugin, ignoreFoldersSetting.settingEl.createDiv({ cls: "at--setting" }), this.vault.getAllFolders()).display();
      ignoreFoldersSetting.controlEl.remove();
      ignoreFoldersSetting.settingEl.classList.add("at--setting-item");
      ignoreMatchesSetting.setName("Task name(s) to ignore").setDesc('Enter task names to ignore when syncing to the Kanban board. You can enter regular expression patterns, e.g. "^Meeting:"');
      new IgnoreMatches(this.app, this.plugin, ignoreMatchesSetting.settingEl.createDiv({ cls: "at--setting" })).display();
      ignoreMatchesSetting.controlEl.remove();
      ignoreMatchesSetting.settingEl.classList.add("at--setting-item");
    }
  }
};

// src/tasks/provider.ts
var import_obsidian8 = require("obsidian");

// src/notes/daily-note.ts
var import_obsidian6 = require("obsidian");
var import_obsidian_daily_notes_interface = __toESM(require_main());

// src/notes/index.ts
var CREATE_TIME_GAP_MS = 1e3;
var Note = class {
};
function checkCreateTime(file) {
  return file.stat.ctime > (/* @__PURE__ */ new Date()).getTime() - CREATE_TIME_GAP_MS;
}

// src/notes/daily-note.ts
var MAX_PREVIOUS = 30;
var UNIT = "day";
var DailyNote = class extends Note {
  getDate() {
    return (0, import_obsidian6.moment)().startOf(UNIT);
  }
  getCurrent() {
    return (0, import_obsidian_daily_notes_interface.getDailyNote)(this.getDate(), (0, import_obsidian_daily_notes_interface.getAllDailyNotes)());
  }
  getNextDate() {
    return this.getDate().clone().add(1, UNIT);
  }
  getPrevious() {
    let date = this.getDate().clone().subtract(1, UNIT);
    const limit = date.clone().subtract(MAX_PREVIOUS, UNIT);
    const allNotes = (0, import_obsidian_daily_notes_interface.getAllDailyNotes)();
    let note;
    do {
      note = (0, import_obsidian_daily_notes_interface.getDailyNote)(date, allNotes);
      date.subtract(1, UNIT);
    } while (!note && date.isAfter(limit));
    return note;
  }
  isValid(file) {
    const note = (0, import_obsidian_daily_notes_interface.getDailyNote)(this.getDate(), (0, import_obsidian_daily_notes_interface.getAllDailyNotes)());
    if (!note) {
      return false;
    }
    return note.name === file.name && checkCreateTime(note);
  }
};

// src/notes/weekly-note.ts
var import_obsidian7 = require("obsidian");
var import_obsidian_daily_notes_interface2 = __toESM(require_main());
var MAX_PREVIOUS2 = 8;
var UNIT2 = "week";
var WeeklyNote = class extends Note {
  getDate() {
    return (0, import_obsidian7.moment)().startOf(UNIT2);
  }
  getCurrent() {
    return (0, import_obsidian_daily_notes_interface2.getWeeklyNote)(this.getDate(), (0, import_obsidian_daily_notes_interface2.getAllWeeklyNotes)());
  }
  getNextDate() {
    return this.getDate().clone().add(1, UNIT2);
  }
  getPrevious() {
    let date = this.getDate().clone().subtract(1, UNIT2);
    const limit = date.clone().subtract(MAX_PREVIOUS2, UNIT2);
    const allNotes = (0, import_obsidian_daily_notes_interface2.getAllWeeklyNotes)();
    let note;
    do {
      note = (0, import_obsidian_daily_notes_interface2.getWeeklyNote)(date, allNotes);
      date.subtract(1, UNIT2);
    } while (!note && date.isAfter(limit));
    return note;
  }
  isValid(file) {
    const note = (0, import_obsidian_daily_notes_interface2.getWeeklyNote)(this.getDate(), (0, import_obsidian_daily_notes_interface2.getAllWeeklyNotes)());
    if (!note) {
      return false;
    }
    return note.name === file.name && checkCreateTime(note);
  }
};

// src/tasks/provider.ts
var TasksProvider = class {
  constructor(vault, kanban, dailyNote, weeklyNote) {
    this.vault = vault;
    this.kanban = kanban;
    this.dailyNote = dailyNote || new DailyNote();
    this.weeklyNote = weeklyNote || new WeeklyNote();
  }
  async checkAndCopyTasks(settings, file) {
    await this.checkAndCreateForSingleNote(settings, settings.weekly, file, this.weeklyNote);
    await this.checkAndCreateForSingleNote(settings, settings.daily, file, this.dailyNote);
  }
  async checkAndCreateForSingleNote(settings, periodicitySetting, file, cls) {
    if (periodicitySetting.available && periodicitySetting.carryOver && cls.isValid(file)) {
      const previousEntryContents = await this.vault.read(cls.getPrevious());
      const tasks = new TaskCollection(previousEntryContents).getTasksFromLists(periodicitySetting.searchHeaders);
      let tasksToAdd = tasks.filter((task) => !task.isComplete());
      if (settings.tasksAvailable && settings.kanbanSync && periodicitySetting.addDue) {
        const board = await this.kanban.getBoard();
        if (board !== void 0) {
          const boardTasks = board.getTaskCollection();
          for (const task of boardTasks.getTasksFromLists([UPCOMING, DUE, PROGRESS])) {
            const dueDate = task.getDueDate();
            if (dueDate && (0, import_obsidian8.moment)(dueDate).isBefore(cls.getNextDate()) && tasksToAdd.find((t) => t.equals(task)) === void 0) {
              tasksToAdd.push(task);
            }
          }
        }
      }
      if (settings.carryOverPrefix) {
        tasksToAdd = tasksToAdd.map((task) => task.markCarriedOver());
      }
      await this.vault.process(cls.getCurrent(), (contents) => {
        if (contents.indexOf(periodicitySetting.header + "\n") > -1) {
          return contents.replace(periodicitySetting.header + "\n", `${periodicitySetting.header}

${tasksToAdd.join("\n")}
`);
        }
        return `${contents}

${periodicitySetting.header}

${tasksToAdd.join("\n")}`;
      });
    }
  }
};

// src/index.ts
var AutoTasks = class _AutoTasks extends import_obsidian9.Plugin {
  constructor(app, manifest) {
    super(app, manifest);
    this.settings = DEFAULT_SETTINGS;
    const vault = app.vault;
    this.periodicNotesPlugin = new PeriodicNotesPluginAdapter(app);
    this.tasksPlugin = new TasksPluginAdapter(app);
    this.kanbanPlugin = new KanbanPluginAdapter(app);
    this.kanban = new KanbanProvider(this, vault, app.metadataCache);
    this.tasks = new TasksProvider(vault, this.kanban);
    _AutoTasks.instance = this;
  }
  static getSettings() {
    return _AutoTasks.instance.getSettings();
  }
  async onload() {
    this.updateSettings = this.updateSettings.bind(this);
    await this.loadSettings();
    this.app.workspace.onLayoutReady(this.onLayoutReady.bind(this));
  }
  onLayoutReady() {
    if (!this.periodicNotesPlugin.isEnabled()) {
      new import_obsidian9.Notice(
        "The Periodic Notes plugin must be installed and available for Auto Tasks to work.",
        1e4
      );
      return;
    }
    this.settings.tasksAvailable = this.tasksPlugin.isEnabled();
    const workspace = this.app.workspace;
    this.registerEvent(workspace.on(PERIODIC_NOTES_EVENT_SETTING_UPDATED, this.syncPeriodicNotesSettings.bind(this)));
    this.syncPeriodicNotesSettings();
    this.registerEvent(this.app.vault.on("create", (file) => {
      this.tasks.checkAndCopyTasks(this.settings, file);
    }));
    this.kanban.synchroniseTasks();
    this.registerEvent(this.app.vault.on("create", (file) => {
      if (file instanceof import_obsidian9.TFile && file.name !== this.settings.kanbanFile) {
        this.kanban.getWatcher().notifyCreate(file);
      }
    }));
    this.registerEvent(this.app.vault.on("modify", (file) => {
      if (file instanceof import_obsidian9.TFile && file.name !== this.settings.kanbanFile) {
        this.kanban.getWatcher().notifyModify(file);
      }
    }));
    this.registerEvent(this.app.vault.on("rename", (file, oldFileName) => {
      if (file instanceof import_obsidian9.TFile) {
        this.kanban.getWatcher().notifyRename(file, oldFileName);
      }
    }));
    this.registerEvent(this.app.vault.on("delete", (file) => {
      if (file instanceof import_obsidian9.TFile) {
        this.kanban.getWatcher().notifyDelete(file);
      }
    }));
    this.addSettingTab(new AutoTasksSettingsTab(this.app, this, this.kanbanPlugin, this.kanban));
  }
  getSettings() {
    return this.settings;
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async updateSettings(settings) {
    this.settings = settings;
    await this.saveData(settings);
    this.onSettingsUpdate();
  }
  syncPeriodicNotesSettings() {
    this.updateSettings(this.periodicNotesPlugin.convertSettings(this.settings));
  }
  onSettingsUpdate() {
    this.app.workspace.trigger(SETTINGS_UPDATED);
  }
};

/* nosourcemap */