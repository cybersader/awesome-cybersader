/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TagLink
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  tagLinkSubstitutions: new Array()
};
var DEFAULT_SUBSTITUTION = {
  tagRegex: "",
  linkSubstitution: "",
  metadata: {
    regexProblem: null,
    substitutionProblem: null,
    captureGroupCount: 0
  }
};
var TagLink = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.addCommand({
      id: "open-tag-as-link",
      name: "Open tag as a link",
      editorCallback: async (editor, _) => {
        await this.openTagAsLinkAtCursor(this, editor);
      }
    });
    this.addSettingTab(new TagLinkSettingTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async openTagAsLinkAtCursor(plugin, editor) {
    const FIND_TAG_REGEX = /#([\w\/\-_]+)/g;
    const cursorPosition = editor.getCursor();
    const currentLine = editor.getLine(cursorPosition.line);
    let searchResult;
    while ((searchResult = FIND_TAG_REGEX.exec(currentLine)) !== null) {
      if (FIND_TAG_REGEX.lastIndex < cursorPosition.ch) {
        continue;
      }
      if (searchResult.index > cursorPosition.ch) {
        break;
      }
      const selectedTag = searchResult[1];
      await plugin.openTagAsLink(selectedTag);
      break;
    }
  }
  async openTagAsLink(tag) {
    for (const tagLinkSubstitution of this.settings.tagLinkSubstitutions) {
      if (tagLinkSubstitution.tagRegex.length == 0 || tagLinkSubstitution.linkSubstitution.length == 0) {
        continue;
      }
      let tagRegex;
      try {
        tagRegex = new RegExp(tagLinkSubstitution.tagRegex);
      } catch (_) {
        continue;
      }
      let matchResult = tag.match(tagRegex);
      if (matchResult === null) {
        continue;
      }
      if (matchResult.length - 1 == 0) {
        continue;
      }
      let finalLink = tagLinkSubstitution.linkSubstitution;
      for (let index = matchResult.length - 1; index >= 1; index--) {
        finalLink = finalLink.replace("$" + index, matchResult[index]);
      }
      new import_obsidian.Notice("Opening the following link in the browser: " + finalLink);
      window.open(finalLink);
      return;
    }
    new import_obsidian.Notice("The selected tag doesn't match any configured tag link substitutions!");
  }
  async validateTagRegex(tagLinkSubstitution) {
    if (tagLinkSubstitution.tagRegex.length == 0) {
      tagLinkSubstitution.metadata.regexProblem = "The value is empty!";
      return;
    }
    try {
      const captureGroupCount = new RegExp(tagLinkSubstitution.tagRegex + "|").exec("").length - 1;
      tagLinkSubstitution.metadata.captureGroupCount = captureGroupCount;
      if (captureGroupCount == 0) {
        tagLinkSubstitution.metadata.regexProblem = "You need at least one capture group! Surround the important part of the tag with (brackets).";
        return;
      }
    } catch (_) {
      tagLinkSubstitution.metadata.regexProblem = "The regular expression is invalid!";
      return;
    }
    tagLinkSubstitution.metadata.regexProblem = null;
  }
  async validateLinkSubstitution(tagLinkSubstitution) {
    const FIND_SUBSTITUTION_REGEX = /\$(\d+)/g;
    let maximumSubstitutionValue = null;
    for (const substitutionMatch of tagLinkSubstitution.linkSubstitution.matchAll(FIND_SUBSTITUTION_REGEX)) {
      let substitutionValue = parseInt(substitutionMatch[1], 10);
      if (isNaN(substitutionValue)) {
        tagLinkSubstitution.metadata.substitutionProblem = "One of the substitution values is not a valid number!";
        return;
      }
      if (maximumSubstitutionValue === null || maximumSubstitutionValue < substitutionValue) {
        maximumSubstitutionValue = substitutionValue;
      }
    }
    if (maximumSubstitutionValue > tagLinkSubstitution.metadata.captureGroupCount) {
      tagLinkSubstitution.metadata.substitutionProblem = "One of the substitution values is greater than the number of capture groups!";
      return;
    }
    tagLinkSubstitution.metadata.substitutionProblem = null;
  }
};
var TagLinkSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Add new").addButton((button) => button.setIcon("plus").setTooltip("Add").onClick(async () => {
      this.plugin.settings.tagLinkSubstitutions.push(structuredClone(DEFAULT_SUBSTITUTION));
      await this.plugin.saveSettings();
      this.display();
    }));
    for (let index = 0; index < this.plugin.settings.tagLinkSubstitutions.length; index++) {
      const tagLinkSubstitution = this.plugin.settings.tagLinkSubstitutions[index];
      const row = new import_obsidian.Setting(containerEl);
      row.addText((text) => text.setPlaceholder("Tag regex").setValue(tagLinkSubstitution.tagRegex).onChange(async (newValue) => {
        const tagLinkSubstitution2 = this.plugin.settings.tagLinkSubstitutions[index];
        tagLinkSubstitution2.tagRegex = newValue;
        await this.plugin.validateTagRegex(tagLinkSubstitution2);
        if (tagLinkSubstitution2.metadata.regexProblem === null) {
          const originalSubstitutionProblem = tagLinkSubstitution2.metadata.substitutionProblem;
          await this.plugin.validateLinkSubstitution(tagLinkSubstitution2);
          if (tagLinkSubstitution2.metadata.substitutionProblem !== originalSubstitutionProblem) {
            this.display();
          }
        }
        this.displayElementProblem(
          text.inputEl,
          tagLinkSubstitution2.metadata.regexProblem
        );
        await this.plugin.saveSettings();
      }).then((text2) => (
        // Display any cached issues with the regular expression
        this.displayElementProblem(
          text2.inputEl,
          this.plugin.settings.tagLinkSubstitutions[index].metadata.regexProblem
        )
      )));
      row.addText((text) => text.setPlaceholder("Link substitution").setValue(tagLinkSubstitution.linkSubstitution).onChange(async (newValue) => {
        const tagLinkSubstitution2 = this.plugin.settings.tagLinkSubstitutions[index];
        tagLinkSubstitution2.linkSubstitution = newValue;
        await this.plugin.validateLinkSubstitution(tagLinkSubstitution2);
        this.displayElementProblem(
          text.inputEl,
          tagLinkSubstitution2.metadata.substitutionProblem
        );
        await this.plugin.saveSettings();
      }).then((text2) => (
        // Display any cached issues with the substitution
        this.displayElementProblem(
          text2.inputEl,
          this.plugin.settings.tagLinkSubstitutions[index].metadata.substitutionProblem
        )
      )));
      row.addButton((button) => button.setIcon("x").setTooltip("Delete").onClick(async () => {
        this.plugin.settings.tagLinkSubstitutions.splice(index, 1);
        await this.plugin.saveSettings();
        this.display();
      }));
    }
  }
  displayElementProblem(element, problem) {
    if (problem !== null) {
      element.className = "invalid";
      element.title = problem;
    } else {
      element.className = "";
      element.title = "";
    }
  }
};


/* nosourcemap */